{"meta":{"title":"天赐","subtitle":null,"description":null,"author":"天赐","url":"","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-06-05T04:54:30.711Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[トトロ 天赐] 与&nbsp; 天赐&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-05-31T23:21:46.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-05-31T23:21:46.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-05-31T23:21:46.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-05-31T23:21:46.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-06-04T16:31:44.716Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"一千行MySQL学习笔记","slug":"一千行MySQL学习笔记","date":"2019-06-05T09:41:17.000Z","updated":"2019-06-05T09:59:38.905Z","comments":true,"path":"2019/06/05/一千行MySQL学习笔记/","link":"","permalink":"/2019/06/05/一千行MySQL学习笔记/","excerpt":"","text":"作者：Jioby 链接： https://shockerli.net/post/1000-line-mysql-note/ /* Windows服务 */ -- 启动MySQL net start mysql -- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格) /* 连接与断开服务器 */ mysql -h 地址 -P 端口 -u 用户名 -p 密码 SHOW PROCESSLIST -- 显示哪些线程正在运行 SHOW VARIABLES -- 显示系统变量信息 /* 数据库操作 */ ------------------ -- 查看当前数据库 SELECT DATABASE(); -- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version(); -- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name -- 查看已有库 SHOW DATABASES[ LIKE &#39;PATTERN&#39;] -- 查看当前库信息 SHOW CREATE DATABASE 数据库名 -- 修改库的选项信息 ALTER DATABASE 库名 选项信息 -- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容 /* 表的操作 */ ------------------ -- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;] -- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = &#39;目录&#39; -- 索引文件目录 INDEX DIRECTORY = &#39;目录&#39; -- 表注释 COMMENT = &#39;string&#39; -- 分区选项 PARTITION BY ... (详细见手册) -- 查看所有表 SHOW TABLES[ LIKE &#39;pattern&#39;] SHOW TABLES FROM 表名 -- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;] SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;] -- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键 -- 删除表 DROP TABLE[ IF EXISTS] 表名 ... -- 清空表数据 TRUNCATE [TABLE] 表名 -- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名 -- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名 -- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... -- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... -- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM] -- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... /* 数据操作 */ ------------------ -- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...] -- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段 -- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部 -- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] /* 字符集编码 */ ------------------ -- MySQL、数据库、表、字段均可设置编码 -- 数据编码与客户端编码不需一致 SHOW VARIABLES LIKE &#39;character_set_%&#39; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码 SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk; SET NAMES GBK; -- 相当于完成以上三个设置 -- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;] 查看所有字符集 SHOW COLLATION [LIKE &#39;pattern&#39;] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码 /* 数据类型（列类型） */ ------------------ 1. 数值类型 -- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&#39;123&#39;，补填后为&#39;00123&#39; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 -- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。 -- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。 2. 字符串类型 -- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3 -- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 -- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. 3. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 datetime YYYY-MM-DD hh:mm:ss timestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmss date YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDD time hh:mm:ss hhmmss hhmmss year YYYY YY YYYY YY 4. 枚举和集合 -- 枚举(enum) ---------- enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。 -- 集合（set） ---------- set(val1, val2, val3...) create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) ); insert into tab values (&#39;男, 女&#39;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 /* 选择类型 */ -- PHP角度 1. 功能满足 2. 存储空间尽量小，处理效率更高 3. 考虑兼容问题 -- IP存储 ---------- 1. 只需存储，可用字符串 2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned 1) PHP函数转换 ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。 利用sprintf函数格式化字符串 sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;)); 然后用long2ip将整型转回IP字符串 2) MySQL函数转换(无符号整型，UNSIGNED) INET_ATON(&#39;127.0.0.1&#39;) 将IP转为整型 INET_NTOA(2130706433) 将整型转为IP /* 列属性（列约束） */ ------------------ 1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); 2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。 3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &#39;val&#39;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null 4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, &#39;val&#39;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time 5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x; 6. COMMENT 注释 例：create table tab ( id int ) comment &#39;注释内容&#39;; 7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 /* 建表规范 */ ------------------ -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 /* SELECT */ ------------------ SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT a. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb; b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3; c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较 d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。 e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。 f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。 g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数 h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录 /* UNION */ ------------------ 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 /* 子查询 */ ------------------ - 子查询需用括号包裹。 -- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1; -- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 /* 连接查询(join) */ ------------------ 将多个表的字段进行连接，可以指定连接条件。 -- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2; -- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充 -- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; /* 导入导出 */ ------------------ select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据 load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理 -- 控制格式 fields 控制字段格式 默认：fields terminated by &#39;\\t&#39; enclosed by &#39;&#39; escaped by &#39;\\\\&#39; terminated by &#39;string&#39; -- 终止 enclosed by &#39;char&#39; -- 包裹 escaped by &#39;char&#39; -- 转义 -- 示例： SELECT a,b,a+b INTO OUTFILE &#39;/tmp/result.text&#39; FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39; LINES TERMINATED BY &#39;\\n&#39; FROM test_table; lines 控制行格式 默认：lines terminated by &#39;\\n&#39; terminated by &#39;string&#39; -- 终止 /* INSERT */ ------------------ select语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 INSERT INTO tbl_name SET field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), (); 可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now()); 可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT); 可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...; 可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …; /* DELETE */ ------------------ DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] 按照条件删除。where 指定删除的最多记录数。limit 可以通过排序条件删除。order by + limit 支持多表删除，使用类似连接语法。 delete from 需要删除数据多表1，表2 using 表连接操作 条件。 /* TRUNCATE */ ------------------ TRUNCATE [TABLE] tbl_name 清空数据 删除重建表 区别： 1，truncate 是删除表再创建，delete 是逐条删除 2，truncate 重置auto_increment的值。而delete不会 3，truncate 不知道删除了几条，而delete知道。 4，当被用于带分区的表时，truncate 会保留分区 /* 备份与还原 */ ------------------ 备份，将数据的结构与表内数据保存起来。 利用 mysqldump 指令完成。 -- 导出 mysqldump [options] db_name [tables] mysqldump [options] ---database DB1 [DB2 DB3...] mysqldump [options] --all--database 1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql) 可以-w携带WHERE条件 -- 导入 1. 在登录mysql的情况下： source 备份文件 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 /* 视图 */ ------------------ 什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 -- 创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数 -- 查看结构 SHOW CREATE VIEW view_name -- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ... -- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement -- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构 -- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 /* 事务(transaction) */ ------------------ 事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。 -- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。 -- 事务提交 COMMIT; -- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。 -- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。 -- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。 -- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。 -- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套 -- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 -- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) /* 锁表 */ 表锁定只用于防止其它客户端进行不正当地读取和写入 MyISAM 支持表锁，InnoDB 支持行锁 -- 锁定 LOCK TABLES tbl_name [AS alias] -- 解锁 UNLOCK TABLES /* 触发器 */ ------------------ 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。 -- 创建触发器 CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构 -- 删除 DROP TRIGGER [schema_name.]trigger_name 可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new. -- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。 -- 字符连接函数 concat(str1,str2,...]) concat_ws(separator,str1,str2,...) -- 分支语句 if 条件 then 执行语句 elseif 条件 then 执行语句 else 执行语句 end if; -- 修改最外层语句结束符 delimiter 自定义结束符号 SQL语句 自定义结束符号 delimiter ; -- 修改回原来的分号 -- 语句块包裹 begin 语句块 end -- 特殊的执行 1. 只要添加记录，就会触发程序。 2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update 3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert /* SQL编程 */ ------------------ --// 局部变量 ---------- -- 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 -- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量） --// 全局变量 ---------- -- 定义、赋值 set 语句可以定义并为变量赋值。 set @var = value; 也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。 还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。 select @var:=20; select @v1:=id, @v2=name from t1 limit 1; select * from tbl_name where @var:=30; select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb; -- 自定义变量名 为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。 @var=10; - 变量被定义后，在整个会话周期都有效（登录到退出） --// 控制结构 ---------- -- if语句 if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; -- case语句 CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END -- while循环 [begin_label:] while search_condition do statement_list end while [end_label]; - 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环 --// 内置函数 ---------- -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date(&#39;yyyy-mm-dd hh:ii:ss&#39;); -- 获取日期部分 time(&#39;yyyy-mm-dd hh:ii:ss&#39;); -- 获取时间部分 date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 流程函数 case when [condition] then result [when [condition] then result ...] [else result] end 多分支 if(expr1,expr2,expr3) 双分支。 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); --// 存储函数，自定义函数 ---------- -- 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。 -- 删除 DROP FUNCTION [IF EXISTS] function_name; -- 查看 SHOW FUNCTION STATUS LIKE &#39;partten&#39; SHOW CREATE FUNCTION function_name; -- 修改 ALTER FUNCTION function_name 函数选项 --// 存储过程，自定义功能 ---------- -- 定义 存储存储过程 是一段代码（过程），存储在数据库中的sql组成。 一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。 而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。 -- 创建 CREATE PROCEDURE sp_name (参数列表) 过程体 参数列表：不同于函数的参数列表，需要指明参数类型 IN，表示输入型 OUT，表示输出型 INOUT，表示混合型 注意，没有返回值。 /* 存储过程 */ ------------------ 存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。 调用：CALL 过程名 -- 注意 - 没有返回值。 - 只能单独调用，不可夹杂在其他语句中 -- 参数 IN|OUT|INOUT 参数名 数据类型 IN 输入：在调用过程中，将数据输入到过程体内部的参数 OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端 INOUT 输入输出：既可输入，也可输出 -- 语法 CREATE PROCEDURE 过程名 (参数列表) BEGIN 过程体 END /* 用户和权限管理 */ ------------------ -- root密码重置 1. 停止MySQL服务 2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables 3. use mysql; 4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;; 5. FLUSH PRIVILEGES; 用户信息表：mysql.user -- 刷新权限 FLUSH PRIVILEGES; -- 增加用户 CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER old_user TO new_user -- 设置密码 SET PASSWORD = PASSWORD(&#39;密码&#39;) -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD(&#39;密码&#39;) -- 为指定用户设置密码 -- 删除用户 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO &#39;pms&#39;@&#39;%&#39; IDENTIFIED BY &#39;pms0817&#39;; -- 查看权限 SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 -- 权限层级 -- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。 全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。 数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。 表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。 列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。 -- 权限列表 ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限 ALTER -- 允许使用ALTER TABLE ALTER ROUTINE -- 更改或取消已存储的子程序 CREATE -- 允许使用CREATE TABLE CREATE ROUTINE -- 创建已存储的子程序 CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLE CREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。 CREATE VIEW -- 允许使用CREATE VIEW DELETE -- 允许使用DELETE DROP -- 允许使用DROP TABLE EXECUTE -- 允许用户运行已存储的子程序 FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE INDEX -- 允许使用CREATE INDEX和DROP INDEX INSERT -- 允许使用INSERT LOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLES PROCESS -- 允许使用SHOW FULL PROCESSLIST REFERENCES -- 未被实施 RELOAD -- 允许使用FLUSH REPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址 REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） SELECT -- 允许使用SELECT SHOW DATABASES -- 显示所有数据库 SHOW VIEW -- 允许使用SHOW CREATE VIEW SHUTDOWN -- 允许使用mysqladmin shutdown SUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 UPDATE -- 允许使用UPDATE USAGE -- “无权限”的同义词 GRANT OPTION -- 允许授予权限 /* 表维护 */ -- 分析和存储表的关键字分布 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... -- 检查一个或多个表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} -- 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... /* 杂项 */ ------------------ 1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\&#39; 5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. SQL对大小写不敏感 7. 清除已有语句：\\c","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"},{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"},{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"}],"author":"天赐"},{"title":"重新搭建博客","slug":"重新搭建博客","date":"2019-05-20T12:49:00.000Z","updated":"2019-06-05T09:59:51.476Z","comments":true,"path":"2019/05/20/重新搭建博客/","link":"","permalink":"/2019/05/20/重新搭建博客/","excerpt":"","text":"前言3月份初，许久没写博客（主要就是懒）的博主在莫一天心血来潮写好一篇文章后，使用hexo d部署博客文章时，发现hexo抛出各种错误。但由于当时准备面试的面试题（主要就是懒），然后就放着没管它。紧接着面试实习岗位，工作后也一直没有闲下来。最近终于抽出时间来重构博客，写下这篇文章，记录一下重构博客的过程~ 博客目录介绍. ├── .deploy ├── public ├── scaffolds ├── scripts ├── source | ├── _drafts | └── _posts ├── themes ├── _config.yml └── package.json .deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章 _posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的 关于 按钮 接下来是重头戏 _config.yml ，做个简单说明： # Hexo Configuration ## Docs: http://zespia.tw/hexo/docs/configure.html ## Source: https://github.com/tommy351/hexo/ # Site #整站的基本信息 title: 不如 #网站标题 subtitle: 码农，程序猿，未来的昏析师 #网站副标题 description: bruce sha&#39;s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到 author: bruce #网站作者，在下方显示 email: bu.ru@qq.com #联系邮箱 language: zh-CN #语言 # URL #域名和文件结构 ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: http://ibruce.info #你的域名 root: / permalink: :year/:month/:day/:title/ tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code # Writing #写文章选项 new_post_name: :title.md # File name of new posts default_layout: post #默认layout方式 auto_spacing: false # Add spaces between asian characters and western characters titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab max_open_file: 100 multi_thread: true filename_case: 0 render_drafts: false highlight: #代码高亮 enable: true #是否启用 line_number: false #是否显示行号 tab_replace: # Category &amp; Tag #分类与标签 default_category: uncategorized # default category_map: tag_map: # Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突 ## 2: Enable pagination ## 1: Disable pagination ## 0: Fully Disable archive: 1 category: 1 tag: 1 # Server #本地服务参数 ## Hexo uses Connect as a server ## You can customize the logger format as defined in ## http://www.senchalabs.org/connect/logger.html port: 4000 logger: true logger_format: # Date / Time format #日期显示格式 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: MMM D YYYY time_format: H:mm:ss # Pagination #分页设置 ## Set per_page to 0 to disable pagination per_page: 10 #每页10篇文章 pagination_dir: page # Disqus #社会化评论disqus，我使用多说，在主题中配置 disqus_shortname: # Extensions #插件，暂时未安装插件 ## Plugins: https://github.com/tommy351/hexo/wiki/Plugins ## Themes: https://github.com/tommy351/hexo/wiki/Themes ## 主题 theme: modernist # raytaylorism # pacman # modernist # light exclude_generator: # Deployment #部署 ## Docs: http://zespia.tw/hexo/docs/deploy.html deploy: type: github repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库 主题目录介绍. ├── languages #多语言 | ├── default.yml #默认语言 | └── zh-CN.yml #中文语言 ├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制 | ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制 | └── _widget #小挂件的布局，页面下方小挂件的控制 ├── source #源码 | ├── css #css源码 | | ├── _base #*.styl基础css | | ├── _partial #*.styl局部css | | ├── fonts #字体 | | ├── images #图片 | | └── style.styl #*.styl引入需要的css源码 | ├── fancybox #fancybox效果源码 | └── js #javascript源代码 ├── _config.yml #主题配置文件 └── README.md #用GitHub的都知道 如果你需要修改头部，直接修改 hexo\\themes\\modernist\\layout\\_partial\\header.ejs ，比如头上加个搜索框： &lt;div&gt; &lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\\/\\//, &#39;&#39;) %&gt;&quot;&gt; &lt;/form&gt; &lt;/div&gt; 将如上代码加入即可，您需要修改css以便这个搜索框比较美观。再如，你要修改页脚版权信息，直接编辑 hexo\\themes\\modernist\\layout\\_partial\\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。 主题安装 https://www.haomwei.com/technology/maupassant-hexo.html $ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant $ npm install hexo-renderer-pug --save $ npm install hexo-renderer-sass --save npm install hexo-renderer-pug --save安装时可能会报错，以下是解决方案：改用cnpm来安装软件 $ npm install -g cnpm –registry=https://registry.npm.taobao.org目的是直接改npm为淘宝的npm，也为防止某些依赖直接用npm来安装，导致无法顺利安装完成$ npm config set registry https://registry.npm.taobao.org 编辑Hexo目录下的 _config.yml，将theme的值改为maupassant theme: matery 功能配置# 是否启用Fancybox图片灯箱效果 # Disqus评论 shortnam disqus: # 友言评论 id uyan: # 来必力评论 data-uid livere: # 畅言评论 appid changyan: changyan_conf: ## Your changyan conf, e.g. prod_d8a508c2825ab57eeb43e7c69bba0e8b # Gitment评论相关参数 gitment: enable: false owner: repo: client_id: client_secret: # Gitalk评论相关参数 gitalk: enable: false owner: repo: client_id: client_secret: admin: # Valine评论相关参数 valine: enable: false appid: appkey: notify: false # 评论系统中的邮件提醒设置 verify: false ## Validation code. placeholder: Just so so avatar: &#39;mm&#39; pageSize: 10 guest_info: nick,mail,link # 默认使用Google搜索引擎 google_search: true # 若想使用百度搜索，将其设定为 true baidu_search: false # Swiftype 站内搜索key swiftype: # 微搜索 key tinysou: # 基于jQuery的本地搜索引擎，需要安装hexo-generator-search插件使用 self_search: false # Google Analytics 跟踪ID google_analytics: # 百度统计 跟踪ID baidu_analytics: # fancybox: true ## If you want to use fancybox please set the value to true. # 是否显示侧边栏分类数目 show_category_count: false # 是否显示文章中目录列表自动编号 toc_number: true # 是否使用分享按鈕，需要安装hexo-helper-qrcode插件使用 shareto: false # 是否使用不蒜子页面访问计数 busuanzi: false # wordcount: false ## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed. # 是否在移动设备屏幕底部显示侧边栏 widgets_on_small_screens: false ## Set to true to enable widgets on small screens. # 是否使用canvas动态背景 canvas_nest: enable: false color: ## RGB value of the color, e.g. &quot;100,99,98&quot; opacity: ## Transparency of lines, e.g. &quot;0.7&quot; zIndex: ## The z-index property of the background, e.g. &quot;-1&quot; count: ## Quantity of lines, e.g. &quot;150&quot; # 是否启用捐赠按钮 donate: enable: false github: ## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page alipay_qr: ## Path of Alipay QRcode image, e.g. /img/AliPayQR.png wechat_qr: ## Path of Wechat QRcode image, e.g. /img/WeChatQR.png btc_qr: ## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png btc_key: ## Bitcoin key, e.g. 1KuK5eK2BLsqpsFVXXSBG5wbSAwZVadt6L paypal_url: ## Paypal URL, e.g. https://www.paypal.me/tufu9441 post_copyright: enable: false ## If you want to display the copyright info after each post, please set the value to true and fill the following items on your need. author: ## Your author name, e.g. tufu9441 copyright_text: ## Your copyright text, e.g. The author owns the copyright, please indicate the source reproduced. # 自定义页面及菜单，依照已有格式填写。 # 填写后请在source目录下建立相应名称的文件夹，并包含index.md文件，以正确显示页面。 # 导航菜单中集成了FontAwesome图标字体，可以在这里选择新的图标，并按照相关说明使用。 menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: about directory: about/ icon: fa-user - page: rss directory: atom.xml icon: fa-rss # 选择和排列希望使用的侧边栏小工具 widgets: ## Six widgets in sidebar provided: search, category, tag, recent_posts, rencent_comments and links. - search - category - tag - recent_posts - recent_comments - links # 友情链接，请依照格式填写 links: - title: site-name1 url: http://www.example1.com/ - title: site-name2 url: http://www.example2.com/ - title: site-name3 url: http://www.example3.com/ # 网站历史时间线，在页面front-matter中设置layout: timeline可显示 timeline: - num: 1 word: 2014/06/12-Start - num: 2 word: 2014/11/29-XXX - num: 3 word: 2015/02/18-DDD - num: 4 word: More # Static files # 静态文件存储路径，方便设置CDN缓存 js: js css: css # Theme version # 主题版本，便于静态文件更新后刷新CDN缓存 version: 0.0.0 评论Disqus配置使用注册 https://disqus.com/ 主题特性主题目录结构-maupassant |-languages 网站图标网站Favicon：/blog/source/favicon.ico，建议的大小：32px*32px。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"/tags/Hexo/"}]},{"title":"MySQL面试题","slug":"MySQL面试题","date":"2019-01-02T12:05:58.000Z","updated":"2019-06-05T10:00:01.146Z","comments":true,"path":"2019/01/02/MySQL面试题/","link":"","permalink":"/2019/01/02/MySQL面试题/","excerpt":"","text":"1. 主键 超键 候选键 外键主 键： 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。 一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null） 超 键： 在关系中能唯一标识元组的属性集称为关系模式的超键 一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键 超键包含候选键和主键。 候选键： 是最小超键，即没有冗余元素的超键。 外 键： 在一个表中存在的另一个表的主键称此表的外键 2.数据库事务的四个特性及含义 数据库事务( transanction )正确执行的四个基本要素( ACID )：原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 原子性： 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性： 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性： 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 持久性： 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 3.drop,delete与truncate的区别 drop直接删掉表delete删除表中数据，可以加where字句truncate删除表中数据，再插入时自增长id又从1开始 1、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除的数据是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。 2、表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。 3、一般而言，drop &gt; truncate &gt; delete 4、应用范围。truncate 只能对 table；delete 可以是table和view 5、truncate 和 DELETE 只删除数据，而DROP则删除整个表（结构和数据）。 6、truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。 7、delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。 8、truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚 9、在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。 10、Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 11、TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 12、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 4.索引的工作原理及其种类 数据库索引：是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。 图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O($log_2n$)的复杂度内获取到相应数据。 创建索引可以大大提高系统的性能。 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点： 第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。 唯一索引 唯一索引是不允许其中任何两行具有相同索引值的索引。 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。 如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"}]},{"title":"ES6语法指南","slug":"ES6语法指南","date":"2018-12-18T08:10:28.000Z","updated":"2019-06-05T10:00:19.897Z","comments":true,"path":"2018/12/18/ES6语法指南/","link":"","permalink":"/2018/12/18/ES6语法指南/","excerpt":"","text":"ES6 语法指南后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： for(var i = 0; i &lt; 5; i++){ console.log(i); } console.log(&quot;循环外：&quot; + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： for(let i = 0; i &lt; 5; i++){ console.log(i); } console.log(&quot;循环外：&quot; + i) 结果： const const声明的变量是常量，不能被修改 3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 3.3.解构表达式 数组解构 比如有一个数组： let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值 // 然后打印 console.log(x,y,z); 结果： 对象解构 例如有个person对象： const person = { name:&quot;jack&quot;, age:21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } 我们可以这么做： // 解构表达式获取值 const {name,age,language} = person; // 打印 console.log(name); console.log(age); console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： function add(a , b) { // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b; } // 传一个参数 console.log(add(10)); 现在可以这么写： function add(a , b = 1) { return a + b; } // 传一个参数 console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： var print = function (obj) { console.log(obj); } // 简写为： var print2 = obj =&gt; console.log(obj); 多个参数： // 两个参数的情况： var sum = function (a , b) { return a + b; } // 简写为： var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 var sum3 = (a,b) =&gt; { return a + b; } 对象的函数属性简写 比如一个Person对象，里面有eat方法： let person = { name: &quot;jack&quot;, // 以前： eat: function (food) { console.log(this.name + &quot;在吃&quot; + food); }, // 箭头函数版： eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food),// 这里拿不到this // 简写版： eat3(food){ console.log(this.name + &quot;在吃&quot; + food); } } 箭头函数结合解构表达式 比如有一个函数： const person = { name:&quot;jack&quot;, age:21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } function hello(person) { console.log(&quot;hello,&quot; + person.name) } 如果用箭头函数和解构表达式 var hi = ({name}) =&gt; console.log(&quot;hello,&quot; + name); 3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 let arr = [&#39;1&#39;,&#39;20&#39;,&#39;-5&#39;,&#39;3&#39;]; console.log(arr) arr = arr.map(s =&gt; parseInt(s)); console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： const arr = [1,20,-5,3] 没有初始值： 指定初始值： 3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： const promise = new Promise(function(resolve, reject) { // ... 执行异步操作 if (/* 异步操作成功 */){ resolve(value);// 调用resolve，代表Promise将返回成功的结果 } else { reject(error);// 调用reject，代表Promise会返回失败结果 } }); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： promise.then(function(value){ // 异步执行成功后的回调 }); 如果想要处理promise异步执行失败的事件，还可以跟上catch： promise.then(function(value){ // 异步执行成功后的回调 }).catch(function(error){ // 异步执行失败后的回调 }) 示例： const p = new Promise(function (resolve, reject) { // 这里我们用定时任务模拟异步 setTimeout(() =&gt; { const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) { resolve(&quot;成功！num:&quot; + num) } else { reject(&quot;出错了！num:&quot; + num) } }, 300) }) // 调用promise p.then(function (msg) { console.log(msg); }).catch(function (msg) { console.log(msg); }) 结果： 3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： // Set构造函数可以接收一个数组或空 let set = new Set(); set.add(1);// [1] // 接收数组 let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： set.add(1);// 添加 set.clear();// 清空 set.delete(2);// 删除指定元素 set.has(2); // 判断是否存在 set.keys();// 返回所有key set.values();// 返回所有值 set.entries();// 返回键值对集合 // 因为set没有键值对，所有其keys、values、entries方法返回值一样的。 set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： // map接收一个数组，数组中的元素是键值对数组 const map = new Map([ [&#39;key1&#39;,&#39;value1&#39;], [&#39;key2&#39;,&#39;value2&#39;], ]) // 或者接收一个set const set = new Set([ [&#39;key1&#39;,&#39;value1&#39;], [&#39;key2&#39;,&#39;value2&#39;], ]) const map2 = new Map(set) // 或者其它map const map3 = new Map(map); 方法： 3.8.模块化3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： const util = { sum(a,b){ return a + b; } } 我可以使用export将这个对象导出： const util = { sum(a,b){ return a + b; } } export util; 当然，也可以简写为： export const util = { sum(a,b){ return a + b; } } export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： var name = &quot;jack&quot; var age = 21 export {name,age} 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： // 无需声明对象的名字 export default { sum(a,b){ return a + b; } } 这样，当使用者导入时，可以任意起名字 3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： // 导入util import util from &#39;hello.js&#39; // 调用util中的属性 util.sum(1,2) 要批量导入前面导出的name和age： import {name, age} from &#39;user.js&#39; console.log(name + &quot; , 今年&quot;+ age +&quot;岁了&quot;) 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"},{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"}]},{"title":"自定义百度云分享密码","slug":"自定义百度云分享密码","date":"2018-12-14T01:13:35.000Z","updated":"2019-06-05T10:00:31.079Z","comments":true,"path":"2018/12/14/自定义百度云分享密码/","link":"","permalink":"/2018/12/14/自定义百度云分享密码/","excerpt":"","text":"第一步打开百度云盘网页版 第二步找到需要分享的资源，点击分享之后看见下面内容： 别动，重点的在后面 第三步按下F12，进入开发者模式，点击 consle 进入控制台，如下图： 第四步在控制台中输入下面代码，按下回车 avascript:require([“function-widget-1:share/util/shareFriend/createLinkShare.js”]).prototype.makePrivatePassword=function(){return prompt(“请输入自定义的密码”,”1234”)} 第五步关闭开发者模式，点击“创建链接”，输入你想要自定义的密码，回车确定即可","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"百度网盘","slug":"百度网盘","permalink":"/tags/百度网盘/"}]},{"title":"微信小程序笔记","slug":"微信小程序笔记","date":"2018-12-11T13:15:58.000Z","updated":"2019-06-05T10:00:48.472Z","comments":true,"path":"2018/12/11/微信小程序笔记/","link":"","permalink":"/2018/12/11/微信小程序笔记/","excerpt":"","text":"微信小程序账号与工具在线文档：https://mp.weixin.qq.com/debug/wxadoc/dev/ 小程序开发者账号注册微信公众平台：https://mp.weixin.qq.com/ 小程序开发者账号注册：https://mp.weixin.qq.com/wxopen/waregister?action=step1 微信开发者工具微信开发者工具：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html 小程序在线Demo二维码体验小程序官方源码：https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip 微信小程序文件结构主体文件结构主体部分由三个文件组成，必须放在项目的根目录，如下： 文件 必填 作用 app.js 是 小程序逻辑 app.json 是 小程序公共设置 app.wxss 否 小程序公共样式表 页面文件结构页面由四个文件组成，分别是： 文件类型 必填 作用 js 是 页面逻辑 ( 微信小程序没有window和document对象 ) wxml 是 页面结构 ( XML语法，不是HTML语法 ) wxss 否 页面样式表 ( 拓展了rpx尺寸单位，微信专属响应式像素 ) json 否 页面配置 ( 不能写注释，否则编译报错 ) WXML 结构_基础 (标签、组件)组件文档：https://mp.weixin.qq.com/debug/wxadoc/dev/component/ 常用布局标签(组件)&lt;view&gt;&lt;/view&gt; 相当于 &lt;div&gt;&lt;/div&gt; &lt;text&gt;&lt;/text&gt; 相当于 &lt;span&gt;&lt;/span&gt; &lt;image&gt;&lt;/image&gt; 相当于 &lt;img /&gt; &lt;navigator&gt;&lt;/navigator&gt; 相当于 &lt;a&gt;&lt;/a&gt; &lt;block&gt;&lt;/block&gt; 区块标签，不会渲染到页面 注意：image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高 常用表单标签(组件)&lt;button&gt;&lt;/button&gt; &lt;input type=&quot;text&quot; /&gt; &lt;checkbox /&gt; &lt;radio/&gt; 轮播图组件&lt;swiper indicator-dots=&quot;是否显示面板指示点&quot; autoplay=&quot;是否自动切换&quot; interval=&quot;自动切换时间间隔&quot; duration=&quot;滑动动画时长&quot;&gt; &lt;swiper-item&gt; &lt;image src=&quot;图片路径1&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&quot;图片路径2&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; 探索：实现无缝轮播怎么办？ WXSS 样式WXSS (WeiXin Style Sheets) 是一套样式语言。 WXSS文档： https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html WXSS 新增特性与 CSS 相比，WXSS 扩展以下2个特性： 尺寸单位 rpx ( responsive pixel 响应式像素) 样式导入 @import “样式表路径”; 尺寸单位 rpx ( responsive pixel 响应式像素) : 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 JSON 配置配置文档：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html app.json 配置项列表 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口表现 tabBar Object 否 设置底部 tab 的表现 networkTimeout Object 否 设置网络超时时间 debug Boolean 否 设置是否开启 debug 模式 如：app.json { &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;: { &quot;navigationBarTitleText&quot;: &quot;小程序标题&quot; }, &quot;tabBar&quot;: { &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; }, { &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;Tab栏&quot; }] }, &quot;networkTimeout&quot;: { &quot;request&quot;: 10000, &quot;downloadFile&quot;: 10000 }, &quot;debug&quot;: true } window 配置 用于设置小程序的状态栏、导航条、标题、窗口背景色。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉背景字体、loading 图的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数。 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px window 配置图示 window 配置注意事项 !! 注意：页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个关键词。 如：/pages/message/message.json { &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;内页标题修改&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot; } tabBar 配置如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 属性说明： 属性 类型 必填 默认值 描述 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black/white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top，设置成top是无图标 其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 tabBar 配置图示 tabBar 配置注意事项 当设置 position 为 top 时，将不会显示 icon。 tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 icon 大小限制为40kb，建议尺寸为 81px * 81px。 JS 行为(逻辑)微信小程序生命周期函数Page({ /** 页面的初始数据 */ data: { }, /** 生命周期函数--监听页面加载 */ onLoad: function (options) { console.log(options); }, /** 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** 生命周期函数--监听页面显示 */ onShow: function () { }, /** 生命周期函数--监听页面隐藏 */ onHide: function () { }, /** 生命周期函数--监听页面卸载 */ onUnload: function () { } }) 页面相关事件处理函数 /** 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { }, /** 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /** 用户点击右上角分享 */ onShareAppMessage: function () { } 注意事项 微信小程序没有BOM和DOM概念，所以不能使用window对象和document对象。 WXML 高级(指令、事件)数据绑定 &#123;&#123; &#125;&#125;&lt;!--wxml--&gt; &lt;view&gt; {{message}} &lt;/view&gt; // page.js Page({ data: { message: &#39;Hello MINA!&#39; } }) 特别注意 花括号和引号之间不能有空格。 不要直接写 checked=”false”，其计算结果是一个字符串，转成 boolean 类型后代表真值。 &lt;checkbox checked=&quot;false&quot;&gt; &lt;/checkbox&gt; 其计算结果是一个字符串，转成 boolean 类型后变成了 true &lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt; 正确写法 列表渲染 wx:for&lt;!--wxml--&gt; &lt;view wx:for=&quot;{{array}}&quot;&gt; {{item}} &lt;/view&gt; // page.js Page({ data: { array: [1, 2, 3, 4, 5] } }) wx:key主要功能：提高列表渲染时排序的效率。 wx:key 的值以两种形式提供： 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 条件渲染 wx:if wx:else wx:elif&lt;!--wxml--&gt; &lt;view wx:if=&quot;{{length >= 80}}&quot;&gt; 优秀 &lt;/view&gt; &lt;view wx:elif=&quot;{{length >= 60}}&quot;&gt; 良好 &lt;/view&gt; &lt;view wx:else&gt; 加油 &lt;/view&gt; // page.js Page({ data: { length: &#39;95&#39; } }) wx:if 与 hidden 区别 wx:if 是否渲染， hidden 是否隐藏。 一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。 因此，如果需要频繁切换的情景下，用 hidden 更好。 事件 事件对象可以获取额外信息，如 id, dataset(自定义属性集合), touches(触摸点坐标)。 事件绑定和冒泡 冒泡事件 bind事件类型 如 bindtap bindlongpress 非冒泡事件 catch事件类型 如 catchtap catchlongpress 常用事件类型 类型 触发条件 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 &lt;!--wxml--&gt; &lt;view data-index=&quot;自定义属性&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt; // page.js Page({ tapHandle: function(event) { console.log(event) } }) 事件传参注意小程序绑定事件只能写函数名称，不能通过括号方式传参。 &lt;!--wxml--&gt; &lt;view bindtap=&quot;tapHandle(520)&quot;&gt; 点我触发事件 &lt;/view&gt; 错误，事件不能触发 &lt;view data-index=&quot;520&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt; // page.js Page({ tapHandle: function(event) { console.log( event.target.dataset.index ); // 输出标签自定义属性上的index值 } }) WXS 脚本WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，功能类似&lt;script&gt;标签，主要用于在视图层定义函数(比较少用)。 注意 wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。 wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。 wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。 wxs 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 &lt;!--wxml--&gt; &lt;wxs module=&quot;foo&quot;&gt; var sum = function(a,b){ return a+b; }; // 这里可以导出一个对象，这个对象可以直接在界面上使用 module.exports.sum = sum; &lt;/wxs&gt; &lt;view&gt; {{foo.sum(1,2)}} &lt;/view&gt; 微信开发者工具常用快捷键 快捷键 说明 Shift + Alt + F 格式化代码 Ctrl + P 跳到文件 Ctrl + E 跳到最近文件 Ctrl + Shift + P 上传扫码预览 Ctrl + Shift + I 显示/隐藏调试器","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"/tags/微信小程序/"}]},{"title":"Hystrix状态","slug":"Hystrix状态","date":"2018-12-07T00:12:05.000Z","updated":"2019-06-05T10:01:02.710Z","comments":true,"path":"2018/12/07/Hystrix状态/","link":"","permalink":"/2018/12/07/Hystrix状态/","excerpt":"","text":"@SpringCloudApplication 相当于：@EnableCircuitBreaker、@EnableDiscoveryClilent、@SpringBootApplication 熔断器状态的相关配置@HystrixProperty相关配置在抽象类：package com.netflix.hystrix.HystrixCommandProperties 中 熔断器开启或者关闭的条件： 1、 当满足一定的阀值的时候（默认10秒内超过20个请求次数） 2、 当失败率达到一定的时候（默认10秒内超过50%的请求失败） 3、 到达以上阀值，断路器将会开启 4、 当开启的时候，所有请求都不会进行转发 5、 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。 // 开启服务降级 @HystrixCommand( // 熔断器状态相关配置 commandProperties = { // 当请求次数达到10次时才能开启熔断 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), // 状态变换的时间，由开启 --&gt; 半开 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;20000&quot;), // 失败请求/所有请求=60% --&gt; 开启熔断器 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;) } )","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"/tags/SpringCloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"/tags/Hystrix/"}]},{"title":"HashSet如何去重?","slug":"HashSet如何去重","date":"2018-12-06T02:37:51.000Z","updated":"2019-06-05T10:01:13.208Z","comments":true,"path":"2018/12/06/HashSet如何去重/","link":"","permalink":"/2018/12/06/HashSet如何去重/","excerpt":"","text":"&lt; !– more –&gt;HashSet存储元素的原理：往hashSet添加元素的时候，首先会调用元素的 hashCode 方法得到元素的哈希码值，然后把哈希码值经过运算算出该元素存在哈希表中的位置。有两种情况： 情况1：如果算出的位置目前还没有存在任何的元素，那么该元素可以直接添加到哈希表中。 情况2： 如果算出的位置目前已经存在其他的元素，那么还会调用元素的 equals 方法再与这个位置上的元素比较一次。如果 equals 方法返回的是true，那么该元素被视为重复元素，不允许添加。如果equals方法返回的是false，那么该元素也可以被添加。 先看个最简单的构造方法* Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() { map = new HashMap&lt;&gt;(); } 很明显，HashSet底层是Hashmap存储的。借大神的话 HashSet 就是HashMap的马甲 —–someone 再看看add方法// Dummy value to associate with an Object in the backing Map private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); /** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) { return map.put(e, PRESENT)==null; } add方法的参数： map：map是一个HashMap的实例 e：我们要存储的值，是HashMap的key PRESENT：固定值( Object PRESENT = new Object(); )，空的obj对象 Set偷偷的用了HashMap的 put 方法，然而HashMap并没有去重的功能呀，那么Set是如何做到去重的呢？ 从add方法中可以看到，E是我们要存储的值，而到了HashMap里面却变成了Key，PRESENT就是个空对象。 在HashMap中Key的HashCode是决定底层数组的下标，进一步使用 equals 进行遍历对象链表中的Key进而覆盖原来的Value。 那么对于HashSet，如果 e 已经存在（先HashCode相同定位到链表，然后equals比较定位到具体的Node），那么覆盖oldValue（value其实就是个傀儡，没啥用），Key不变；如果不存在，就添加一个新的节点（即加了一个新的Key）。 HashMap的返回值是oldValue，oldValue==null说明节点之前不存在；反之说明节点存在，虽然返回false但实际上还是对底层数据进行了改变（即旧的空对象变成了新的空对象）。 总而言之，HashSet确定相同的方式其实就是HashCode相同（才能找到同一链表），然后equals的返回值（才能比较具体节点进行覆盖）。 重点看key（敲黑板）HashMap中的put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 这里边有两个看点： HashMap中key存储是hash后的值，对于String类型的相同值的hash值是一致的（其他接触类型类似，自定义对象类型需要重写hashcode方法与equel方法）。换句话说相同的值在hashMap中的存储位置是一样的。 基于上一点来看看怎么存储重复值的。如下代码对于hashMap中已经存在的key，key不变，新value覆盖就value。对于HashSet而言新旧value都是PRESENT对象，所以set在存储的时候就不会重复。 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } 所以hashset中存储的值输出的顺序和存储的先后顺序不一致，这是因为hashset是按照值的hash顺序进行输出。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HashSet","slug":"HashSet","permalink":"/tags/HashSet/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"IDEA常用快捷键","slug":"IDEA常用快捷键","date":"2018-12-04T07:45:52.000Z","updated":"2019-06-05T10:01:38.116Z","comments":true,"path":"2018/12/04/IDEA常用快捷键/","link":"","permalink":"/2018/12/04/IDEA常用快捷键/","excerpt":"","text":"Ctrl+Alt+D –&gt; 查看当前类的实现类 ctrl+l –&gt; 重写方法","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"}]},{"title":"IDEA创建SpringBoot开启找回RunDashboard","slug":"IDEA创建SpringBoot开启找回RunDashboard","date":"2018-12-04T06:32:05.000Z","updated":"2019-06-05T10:01:23.633Z","comments":true,"path":"2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/","link":"","permalink":"/2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/","excerpt":"","text":"Run Dashboard 面板Run Dashboard：微服务项目的开发过程中，工程会非常多，经常要启动很多个服务，才能完成一项测试。启动的多了，容易给开发者带来错乱的感觉，很不方便管理。IDEA开发工具推荐了一个很好用的功能–Run Dashboard。他是 Run 的升级版 我们可以对比一下这个是Run Dashboard的窗口 普通的Run窗口： 显然如果启动多个端口Run Dashboard窗口显得更好管理。一般有时候创建springboot项目的时候右下角可以提示你打开Run Dashboard，但是如果不提醒就需要自己配置了。 配置方法方式一新建项目或者通过 open 打开项目时，可能会弹出提示 “Multiple Spring Boot run configurations were detected. Run Dashboard allows to manage multiple run configurations at once.” 见下图： 点击 Show run configurations in Run Dashboard ，Run Dashboard 面板重新在底部区域展示了出来。 如没有此提示，请选择方式二或方式三 方式二打开Run Dashboard：View –&gt; Tool Windows –&gt; Run Dashboard 方式三如果上述的方式都没有打开 Run Dashboard 面板，可以在工程目录下找 .idea 文件夹下的 workspace.xml文件，通过修改此文件可达到打开 Run Dashboard 面板的目的 找到当前项目中 .idea 文件下的 workspace.xml 文件，双击打开 接下来找到 &lt;component name=&quot;RunDashboard&quot;&gt; 加入如下配置： &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; 这样 Run Dashboard 自动就弹出来了 最终配置如下： &lt;component name=&quot;RunDashboard&quot;&gt; &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name=&quot;ruleStates&quot;&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt; &lt;/component&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"}]},{"title":"Vue基础-基本语法","slug":"Vue基础-基本语法","date":"2018-11-30T09:37:11.000Z","updated":"2019-06-05T10:01:51.492Z","comments":true,"path":"2018/11/30/Vue基础-基本语法/","link":"","permalink":"/2018/11/30/Vue基础-基本语法/","excerpt":"","text":"1. 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 2. 安装 Vue2.1 下载安装下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件 2.2 使用CDN或者也可以直接使用公共的CDN服务： &lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 或者： &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 3. 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template 4. Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别（了解内容） MVC 主要是后端的分层开发思想；把 一个完整的后端项目，分成了三个部分： Model：（数据层）主要负责 数据库的操作； View：（视图层）所有前端页面，统称为 View 层 Controller：（业务逻辑层）主要处理对应的业务逻辑；（对于后台来说，这是开发的重点） MVVM是前端页面的分层开发思想，主要关注于 视图层 分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View, ViewModel Model 是 页面中，需要用到的数据 View 是页面中的HTML结构； ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念； 为什么有了MVC还要有MVVM 因为 MVC是后端的开发思想，并没有明确定义前端的页面该如何开发； MVVM 是前端的页面的开发思想，把每个页面，分成了三个部分，同时 VM 作为 MVVM 的核心，提供了双向数据绑定的概念，前端程序员，不需要手动渲染页面了，而且，页面数据发送变化，也不需要程序员手动把 数据的变化同步到Model中；这所有的操作，都是 VM 自动完成的！ 有了 MVVM 的思想以后，前端只关心 页面交互逻辑，不关心页面如何渲染； 4.2 Vue.js 基本代码 和 MVVM 之间的对应关系 注意：Vue中，不推荐程序员手动操作DOM元素；所以，在Vue项目中，没有极其变态的需求，一般不要引入 Jquery； Vue代码解析执行的步骤： 当 VM 实例对象，被 创建完成之后，会立即解析 el 指定区域中的所有代码； 当 VM 在解析 el 区域中所有代码的时候，会把 data 中的数据，按需，填充到 页面指定的区域； 注意：每当 vm 实例对象，监听到 data 中数据发生了变化，就会立即 重新解析 执行 el 区域内，所有的代码； mvvm是前端思想，mvc是后台思想 5. Vue调试工具vue-devtools的安装和使用Vue.js devtools - 翻墙安装方式 - 推荐 6. 快速入门7. Vue实例7.1 创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： var vm = new Vue({ // 选项 }) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods 等等 接下来我们一 一介绍。 7.2 模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div var vm = new Vue({ el:&quot;#app&quot; }) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 7.3 数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt; &lt;/div&gt; js: var vm = new Vue({ el:&quot;#app&quot;, data:{ name:&quot;刘德华&quot; } }) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 7.4 方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue的作用范围内使用。 html: &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; js写法一： &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ num:0 }, methods:{ add:function(){ this.num++; } } }); &lt;/script&gt; js写法二： &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ num:0 }, methods:{ add(){ this.num++; } } }); &lt;/script&gt; 7.5 生命周期7.5.1 生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 7.5.2 钩子函数钩子函数：生命周期函数的别名； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板【当 vm 实例的 data 和 methods 初始化完毕后，vm 实例会自动执行 created 函数】 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示【如果要通过某些插件操作页面上的DOM元素节点，最早要在 mounted 中进行】 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 例1：created代表在vue实例创建后； 我们可以在Vue中定义一个created函数，代表这个时期的构造函数： html: &lt;div id=&quot;app&quot;&gt; {{hello}} &lt;/div&gt; js: &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ hello:&#39;&#39; }, created(){ this.hello = &#39;czdx,一统江湖，千秋万代&#39; } }); &lt;/script&gt; 结果： 例2： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;vuejs生命周期&lt;/title&gt; &lt;script src=&quot;vuejs-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{message}} &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { message: &#39;hello world&#39; }, beforeCreate: function() { showData(&#39;创建vue实例前&#39;, this); }, created: function() { showData(&#39;创建vue实例后&#39;, this); }, beforeMount: function() { showData(&#39;挂载到dom前&#39;, this); }, mounted: function() { showData(&#39;挂载到dom后&#39;, this); }, beforeUpdate: function() { showData(&#39;数据变化更新前&#39;, this); }, updated: function() { showData(&#39;数据变化更新后&#39;, this); }, beforeDestroy: function() { showData(&#39;vue实例销毁前&#39;, this); }, destroyed: function() { showData(&#39;vue实例销毁后&#39;, this); } }); function realDom() { console.log(&#39;真实dom结构：&#39; + document.getElementById(&#39;app&#39;).innerHTML); } function showData(process, obj) { console.log(process); console.log(&#39;data 数据：&#39; + obj.message) console.log(&#39;挂载的对象：&#39;) console.log(obj.$el) realDom(); console.log(&#39;------------------&#39;) console.log(&#39;------------------&#39;) } vm.message = &quot;good...&quot;; vm.$destroy(); &lt;/script&gt; &lt;/html&gt; 7.5.3 this我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this var vm = new Vue({ el:&quot;#app&quot;, data:{ hello: &#39;&#39; // hello初始化为空 }, created(){ this.hello = &quot;czdx,一统江湖，千秋万代&quot;; console.log(this); } }) 控制台的输出： 8. 指令指令 (Directives)： 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 8.1 插值表达式8.1.1 大括号 u007B;u007B; 格式： u007B;u007B;表达式 说明：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"Java线程状态","slug":"Java线程状态","date":"2018-11-30T09:23:50.000Z","updated":"2019-06-05T10:02:17.144Z","comments":true,"path":"2018/11/30/Java线程状态/","link":"","permalink":"/2018/11/30/Java线程状态/","excerpt":"","text":"Java线程状态网上流传了很久的线程具备5种状态，这样是不贴切JDK中描述的，JDK中描述线程状态只有6种，而网络流传的5种状态就是进程的五态模型。那张广为流传的来自网络的图如下： 很明显这是操作系统中进程的5种状态，在很多操作系统书中也由介绍分别为new，ready，running，waiting，terminated。不幸的是，有很多的书上常常把这些进程状态，线程状态与Java线程状态混在一起谈。 进程与线程的区分总图： 很多人觉得在JVM线程中应该有，Running运行状态。对JAVA而言，Runnable包含了就绪与运行，那为什么JAVA不区分开呢？这跟CPU分配的时间片有关，而且JAVA进行的是抢占式轮转调度，由于我们的JVM线程是服务于监控，线程又是切换的如此之快，那么区分ready与running又没有多大意义了。再者，我们都知道现在使用的很多JVM底层都将线程映射到操作系统上了，JVM本身没有做什么调度，因为虚拟机看到的都是底层的映射与封装，故而将ready与running映射来也没有太大意义，不如统一为Runnable 总之还是有些乱的，我们不妨就拿Windows系统为例，用的就是“进程”和“线程”这两种较为标准的叫法，这时一个进程下至少有一个线程，线程是CPU调度的基本单位，进程不参与CPU调度，CPU根本不知道进程的存在。 为了避免混乱，下面说的线程状态，只是站在JVM层面上 我们先来看下，这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 初始(NEW)：新创建了一个线程对象，但还没有调用 start() 方法。 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running） 阻塞(BLOCKED)：表示线程阻塞于锁 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断） 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回 终止(TERMINATED)：表示该线程已经执行完毕 1. NEW(新建)状态 概念：线程对象创建了，但是还没有启动之前，就是新建状态 实现 Runnable接口 或继承 Thread 可以得到一个线程类，new一个实例出来，线程就进入了初始状态。 这里强调两点： 线程对象创建之后，还未开启( 调用start()方法 )时候，就处于NEW的状态 开启线程，指的是调用start方法，并不是run方法，run方法仅仅作为一个普通方法存在 线程对象调用 run() 方法不开启线程，仅是对象调用方法。线程对象调用 start() 方法开启线程，并让jvm调用 run() 方法在开启的线程中执行 当我们执行 new Thread(target) 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 Runnable (可运行)状态。 在我们研究线程状态时，采用Thread中的getState()方法进行研究 通过代码演示： public class MyThread extends Thread{ @Override public void run() { // 线程执行的代码 } } /** * 研究新建线程状态 * 新建状态：至今还未启动的线程处于这一状态 */ public class ThreadStateTest1 { public static void main(String[] args) { // 创建线程对象 MyThread myThread = new MyThread(); // 线程默认名：Thread-0 Thread-1... System.out.println(myThread.getName()); System.out.println(&quot;线程创建之后处于：&quot; + myThread.getState()); myThread.run(); System.out.println(&quot;线程run之后处于：&quot; + myThread.getState()); myThread.start(); System.out.println(&quot;线程start之后处于：&quot; + myThread.getState()); } } // 输出： // 线程创建之后处于：NEW // 线程run之后处于：NEW // 线程start之后处于：RUNNABLE 当我们执行 new Thread(target) 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 Runnable (可运行)状态。所以说 当业务需要频繁创建线城市，最好使用线程池，提高效率减轻JVM的压力。当然如果大量线程进行频繁上下文切换，此时多线程的效率会大打折扣。 2. RUNNABLE(可运行)状态 可运行状态：一个在JVM中执行的线程处于这个状态中，等待JVM调度，德能在执行，也可能在等待 注：这里的等待指的是等待调度，等待的是系统资源，如IO、CPU时间片，与 sleep、lock 的等待有着本质差别。 接下来使用代码演示一个最简单的可运行状态： public class MyThread extends Thread { @Override public void run() { System.out.println(&quot;线程开始执行&quot;); System.out.println(&quot;线程开始执行具体的任务&quot;); // 假设这个任务使用5秒钟 long beiginTime = System.currentTimeMillis(); while (System.currentTimeMillis()-beiginTime &lt; 5000){ // 假设做了5秒钟的任务 } System.out.println(&quot;线程执行完毕&quot;); } } /** * 可运行状态 * 当线程有资格运行，调用了start方法，线程首先进入可运行状态 * 这种可运行状态不一定被线程调度运行 * 简单来说，调用start方法之后，该线程处于可运行状态，但未运行 * 此时存放在&quot;可运行池&quot;中 * 线程在运行的过程中，自然该线程也是处于可运行状态 * * JDK中处于可运行状态的线程，有两种，一种是正在JVM中运行， * 另一种是可能正在等待操作系统其它资源，比如处理器 */ public class Demo { public static void main(String[] args) { // 创建线程对象 MyThread myThread = new MyThread(); System.out.println(&quot;创建完成之后：&quot; + myThread.getState()); // 开启线程 myThread.start(); System.out.println(&quot;开启线程之后：&quot; + myThread.getState()); } } 3. BLOCHED(阻塞)状态我们还是使用代码来解析一下锁阻塞状态： public class ThreadA extends Thread { private Object obj; public ThreadA(String name,Object obj){ super(name); this.obj = obj; } @Override public void run() { // 同步代码块 synchronized (obj){ System.out.println(&quot;线程A开始执行&quot;); System.out.println(&quot;线程A真正开始执行代码了&quot;); long beginTime = System.currentTimeMillis(); // 模拟5秒钟的任务 while(System.currentTimeMillis()-beginTime &lt; 5000){ } System.out.println(&quot;线程A执行完毕&quot;); } } } public class ThreadB extends Thread{ private Object obj; public ThreadB(String name,Object obj){ super(name); this.obj = obj; } @Override public void run() { // 同步代码块 synchronized (obj){ System.out.println(&quot;线程B开始执行&quot;); System.out.println(&quot;线程B真正开始执行代码了&quot;); long beginTime = System.currentTimeMillis(); // 模拟5秒钟的任务 while(System.currentTimeMillis()-beginTime &lt; 5000){ } System.out.println(&quot;线程B执行完毕&quot;); } } } /** * 线程状态之阻塞状态BLOCKED * JDK：锁阻塞并且正在等待监视器锁的某一线程状态 * 处于受阻状态的某一线程正在等待监视器锁，以便进入一个同步代码块/同步方 * 还有就是 调用Object.wart方法之后，再次进入同步中时 * */ public class BlockedDemo { public static void main(String[] args) throws InterruptedException { // 创建一个锁对象 Object obj = new Object(); // 创建线程A、B ThreadA a = new ThreadA(&quot;线程A&quot;, obj); ThreadB b = new ThreadB(&quot;线程B&quot;, obj); // 开启线程 a.start(); b.start(); // Thread.sleep(3000); System.out.println(&quot;线程A的状态是：&quot; + a.getState()); System.out.println(&quot;线程B的状态是：&quot; + b.getState()); // Thread.sleep(3000); System.out.println(&quot;线程A的状态是：&quot; + a.getState()); System.out.println(&quot;线程B的状态是：&quot; + b.getState()); } } 在这里我们只是对之前分析的情况一进行了阐释 4. Timed Waiting(计时等待)状态 带指定的等待时间的等待线程所处的状态。一个线程处于这一状态是因为用一个指定的正的等待时间（为参数）调用了一下方法中的其一： Thread.sleep 带时限（timeout）的 Object.wait 带时限（timeout）的 Thread.join LockSupport.parkNanos LockSupport.parkUntil Timed Waiting 在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 注：sleep的使用时区别去其他方法的。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting（计时等待），那么我们通过一个案例加深对该状态的一个理解： 实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串 代码： /** * 限时等待 */ public class MyThread extends Thread { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;mt的线程状态： &quot; + myThread.getState()); } } // 实现一个计算器，0-99计数，在每个数字之间暂停1秒，每个10个数字输出一个字符串 @Override public void run() { for (int i = 0; i &lt; 99; i++) { if (i%10 == 0){ System.out.println(&quot;oewewowllskd &quot; + i); } System.out.println(i); try { Thread.sleep(1000); System.out.println(&quot; 休息了1秒&quot;); } catch (Exception e) { e.printStackTrace(); } } } } 通过案例可以发西咸，sleep方法的使用还是很简单的。我们需要记住下面几点： 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 为了让其他线程有机会执行，可以将Thread.sleep() 的调用放线程run()之内，这样才能保证该线程执行过程中会睡眠 sleep 与锁无关，线程睡眠到期自动苏醒，并返回到 Runnable（可运行）状态 小提示：sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep() 方法不能保证该线程睡眠到期后就开始立刻执行 5. WAITING(无限等待)状态Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 一个线程进入 WAITING 状态是因为调用了以下方法： 不带时限的 Object.wait 方法 不带时限的 Thread.join 方法 LockSupport.park 然后会等其他线程执行一个特别的动作，比如： 一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 或 Object.notifyAll() 一个调用了 Thread.join 方法的线程会等待指定的线程结束 代码演示： /** * 无限等待 * Object中的wait方法完成 * 使用当前线程 进入无限等待状态，直到其他线程有唤醒 notify 或 notifyAll 才能被唤醒 * * 线程间通信 两个线程执行不同的操作 关联的 * 两个线程 使用同样的锁 只能使用锁对象调用wait方法或者notify方法 */ public class WaitingTest { private static Object obj = new Object(); public static void main(String[] args) throws InterruptedException { // 使用匿名函数创建线程 Thread t1 = new Thread() { @Override public void run() { synchronized (obj){ System.out.println(&quot;获取到锁，调用wait方法，当前线程进入无线等待状态。。。等待着别的线程来唤醒&quot;); try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;唤醒了这个线程，就不再是线程等待了，线程执行完毕&quot;); } } }; // 开启线程t1 t1.start(); // 使用匿名内部内方式创建一个新的线程，用来唤醒t1线程 new Thread(){ @Override public void run() { // 获取到锁 synchronized (obj){ try { // 3秒钟后执行唤醒操作 Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;获取到锁 执行 唤醒操作&quot;); // 唤醒操作 obj.notify(); } } }.start(); // 4秒后查看线程t1状态 Thread.sleep(4000); System.out.println(&quot;查看t1的线程状态&quot; + t1.getState()); } } 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 方法或 Object.notifyAll() 方法 其实 waiting 状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司了你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作一完成某些任务。 6. TEMINATED(终止)状态线程因如下两个原因之一将被终止： run() 方法正常退出而自然死亡 一个没有捕获的异常终止了 run() 方法而意外死亡 线程的方法1. wait(), notify(), notifyAll()等方法介绍在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait() 的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify() 是唤醒单个线程，而 notifyAll() 是唤醒所有的线程。 Object类中关于等待/唤醒的API详细信息如下：notify() – 唤醒在此对象监视器上等待的单个线程。notifyAll() – 唤醒在此对象监视器上等待的所有线程。wait() – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout, int nanos) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java线程","slug":"Java线程","permalink":"/tags/Java线程/"}]},{"title":"Flex布局","slug":"Flex布局","date":"2018-11-30T09:12:44.000Z","updated":"2019-06-05T10:02:30.063Z","comments":true,"path":"2018/11/30/Flex布局/","link":"","permalink":"/2018/11/30/Flex布局/","excerpt":"","text":"Flex 布局教程：语法篇作者： 阮一峰 日期： 2015年7月10日 网页布局（layout）是 CSS 的一个重点应用 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的 Flex 写法。网友JailBreak 为本文的所有示例制作了 Demo，也可以参考。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 .box{ display: flex; } 行内元素也可以使用 Flex 布局。 .box{ display: inline-flex; } Webkit 内核的浏览器，必须加上-webkit前缀。 .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性 (紫色大盒子) *以下6个属性设置在容器上。 flex-direction √ flex-wrap √ flex-flow justify-content √ align-items √ align-content 3.1 flex-direction属性 **flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性 **默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } 3.4 justify-content属性 **justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性 **align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性 (橙色小盒子) *以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性 **flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Flex","slug":"Flex","permalink":"/tags/Flex/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2018-11-30T08:19:55.000Z","updated":"2019-06-05T10:02:05.537Z","comments":true,"path":"2018/11/30/Linux常用命令/","link":"","permalink":"/2018/11/30/Linux常用命令/","excerpt":"","text":"1. Linux介绍（了解）1.1、Linux和Windows的区别Linux是一款操作系统。正规开发服务器项目部署都是放在Linux操作系统上。 Windows一款操作系统，民用操作系统。娱乐、影音、上网。 1.2、Linux历史及使用场景Linux诞生90年代，仿制Unix操作系统。 Linux是免费的，开源的 Unix是收费的，封闭的。 Linux使用场景：服务器操作系统，移动设备（安卓手机，平板电脑），路由器（WIFI），交换机，智能家居，Java程序开发 1.3、Linux的版本Linux的版本分为两种：内核版本(https://www.kernel.org/)和发行版本 Linux内核版本：Linux内核运维开发小组。 源码在一定程度上不是开源的。 Linux发行版本：由各大互联网/软件公司定制。 外围的样式功能的源码完全开源 一个内核版本是有多种多样的发行版本 Ubuntu：以强大的桌面应用为主，吸收不少Windows用户。 因为桌面应用会在一定程度上大量占用系统资源，开发。 服务器部署上，不会优先选择Ubuntu CentOS：对服务器性能进行了一定程度的优化，性能比较高，比较稳定。 服务器操作系统的优选CentOS 2、Linux安装【重点】2.1、虚拟机、Linux安装2.2、CentOS安装jdk、tomcat、mysql2.3、Linux目录介绍 /：Linux系统根目录 /etc：(etcetera) 系统配置文件存放的目录，不建议在此目录下存放可执行文件。 重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。 注：/etc/X11存放与 x windows 有关的设置（防火墙文件，网络设置文件，JDK环境配置文件，mysql） home:存放所有普通用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /root： 系统管理员root(超级用户)的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下 每一个用户都有家目录，超级管理员root家目录 /root Linux命令行模式中相当于Windows的桌面 /usr：(unix shared resources)：应用程序存放目录，比较重要的目录/usr/local本地系统管理员软件安装目录（安装系统级的应用） /usr/bin 存放应用程序 /usr/share 存放共享数据 /usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local:存放软件升级包 /usr/share/doc: 系统说明文件存放目录 /usr/share/man: 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间。​ Jdk,tomcat,mysql,redis,nginx /opt：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里 以上建议并不是强制性约束 2.4 网络三种连接方式2.4.1 桥接模式桥接模式(Bridged)：虚拟机是一台独立的电脑，直接连接到实际的网络上，与宿主机没有任何联系。 2.4.2 仅主机模式 这种方式下，虚拟机的网卡连接到宿主的 VMnet1 上，但系统并不为虚拟机提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。 仅主机模式(host-only)：虚拟机可以访问宿主机，宿主机无法访问虚拟机，虚拟机无法上网 2.4.3 NAT 模式 这种方式下，虚拟机的网卡连接到宿主的 VMnet8 上。此时系统的 VMWare NAT Service 服务就充当了路由器的作用，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。VMWare DHCP Service 负责为虚拟机提供 DHCP 服务。 NAT模式： 虚拟机可以访问宿主机，宿主机可以访问虚拟机 此时宿主机相当于路由器，虚拟机可以通过宿主机上网 宿主机可以配置254个虚拟机 3、常用命令【重点】Linux命令中参数，一般都是无序的。特殊情况下除外 注意：Linux中的命令严格区分大小写的！ 3.1、磁盘管理命令ls 列出目录内容 ls（list）功能：列出目录内容 格式： ls [参数] [文件或目录] # 参数 -a或--all 查询所有文件和文件夹，包含隐藏。注意隐藏文件、特殊目录、. 和 .. -l 查询详细列表 ls -l--&gt;简写：ll -h 友好展示信息 ll -h (d目录，-普通文件, l链接) -t 用文件和目录的更改时间排序。 -r 反向排序 --help 在线帮助 常用： ls -l --&gt; 此命令非常常用，提供简化版命令 ll ls -al ll /home/ --&gt; 显示指定目录下的内容 eg: 需求：展示某个目录下的内容 ls 目录名 所在位置：/root 想要查看:/etc目录下的内容 命令：ll -h /etc cd 切换目录 cd(change directory) 功能：切换目录 语法： # 格式 cd [目录] # 常用 cd /目录名 ，任意目录切换到指定目录中 /目录名--&gt;Linux的绝对路径 windows绝对路径--&gt;c:/xxxx/xxx.jpg?raw=true cd ../ ，向上一层目录 cd ~ ，切换到当前用户 家目录。root用户家目录 /root cd / ，切换到Linux的 根目录 cd - ，切换到上一次访问的目录。 只能两个目录相互切换 cd .. ，上一级目录 cd ，缺省当前用户目录 Linux绝对： eg：cd /etc/x1 先切换到 /目录，然后在 /目录 中找到子目录 etc，在 etc 中找 子目录x1 特点：在任意目录都可以随意切换 Linux相对： eg：cd x1/x2 在当前目录中寻找子目录x1, 在x1中寻找子目录x2 特点：必须确定 当前目录 下有子目录x1 pwd 显示当前的所在目录 pwd(print working directory) 功能：显示工作目录(当前的所在目录)。返回绝对路径 mkdir 创建目录 mkdir（make directoriy）功能： 创建目录 语法： # 格式 mkdir -p 文件夹名称 # 参数 -p 父目录不存在情况下先生成父目录 （parents） -v 显示命令执行过程中的详细信息 注意： 使用mkdir创建带后缀的文件时，创建的是目录，不是文件（创建文件使用touch命令） eg: # 1 需要在/root/t1目录下创建一个t2目录 位置：/root 命令：相对路径：mkdir t1/t2 绝对：mkdir /root/t1/t2 # 2 需要在/root/t3目录下创建一个t4目录 位置：/root 条件：t3和t4都不存在 命令：mkdir -p t3/t4 rmdir 删除空目录 rmdir(remove directory) 功能：删除空目录 指令快捷键 历史输入使用上、下箭头可以找出上一条指令和下一条指令 Tab代码补全使用tab键可以快速输入指令比如：我要输入shutdown指令，这时，我们可以只输入shut然后按下tab键，即可自动把shutdown补全 注意：使用两下Tab补全时，如果匹配的结果有多个，这时候将会把所有匹配的结果展示出来。当结果很多时将会出现以下结果： 按y之后会列出所有匹配的结果，但因为129个比较多，而在电脑中无法一次全显示出来，所以先显示一部分：（More代表还有更多，这时按回车就可以向下滚动，按下Ctrl+C将会退出） 3.2、文件浏览(管理)命令日志文件,XML,properties文件 cat 快捷查看当前文件的内容 cat（catenate）功能：快捷查看当前文件的内容 cat适合查看少量信息的文件 语法： # 格式 cat 文件名 more 分页显示文件内容 more功能：分页显示文件内容，还支持直接跳转行等功能 语法： more 文件名 操作： Enter 向下n行，需要定义。默认为1行 空格键 向下滚动一屏 或 Ctrl+F B 返回上一屏 或 Ctrl+B q 退出more less 分页显示文件内容 less功能：分页显示文件内容，操作更详细 语法： # 格式 less -mN 文件名 # 参数 -m 显示类似more命令的百分比 -N 显示每行的行号 操作： Enter 向下n行，需要定义。默认为1行 空格键 向下滚动一屏 或 Ctrl+F B 返回上一屏 或 Ctrl+B q 退出more d 前进半页 u 后退半页 回车键 前进一行 或 方向键向下 y 后退一行 或 方向键向上 v 进入vim编辑器 /字符串 向下搜索 ?字符串 向上搜索 左右方向键 相当于水平滚动条 特点： 适用于大量数据的查看 tail 指定文件末尾内容 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件 语法： # 格式 tail[必要参数][选择参数][文件] # 参数 -n&lt;行数&gt; 显示行数 -f 循环读取 eg： &amp; 表示后台运行，否则占用终端 ctrl + c 退出 3.3、文件操作命令文件 隐藏文件 Linux中以 点. 开头的是隐藏文件，使用ls命令是查看不到的，需使用ls -a 目录与文件的区别 当我们使用ls命令列出目录中的所有子目录和文件时，如何区分哪些是文件哪些是目录？可以通过详细信息中第一列的信息来区分：以 d 开头的是目录，以 - 开头的是文件 touch创建文件 功能：创建文件 语法： touch 绝对路径/相对路径 cp 复制 cp（copy）：复制文件或者复制目录 复制文件： 语法： cp 需要复制的文件 复制的位置 注意：cp可以进行重命名操作： cp demo1.java t1/ddd.java 当将一个 文件位置 以不同名字复制到当前文件时，意思是复制并重命名；即 将demo1.java复制到t1目录中，并重命名成ddd.java eg： 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中 位置：/root 命令：cp Demo1.java t1 cp /root/Demo1.java /root/t1 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中，改名为ddd.java 位置：/root 命令：cp Demo1.java t1/ddd.java 复制目录： 语法： # 格式 cp -r 需要复制的目录 复制的位置 # 参数 -r或--recursive 递归处理，将指定目录下的文件与子目录一并处理 复制目录必须使用-r eg： 需求：把/root/t5目录 复制到 /root/t1目录中 位置：/root 命令：cp -r t5 t1 cp -r /root/t5 /root/t1 cp ./abc ./xxx #无法复制目录 cp -r ./abc ./xxx #复制目录必须使用 -r参数 mv 移动、更名 mv(move) 功能： 移动 或 更名 现有的文件或目录 移动文件： 语法： # 格式 mv -f 需要移动的文件 移动的位置 # 参数 -f或--force 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录，不进行询问 eg： 需求：把/root/t5 目录 移动到 /root/t3目录中 位置：/root 命令：mv t5 t3 需求：把/root/t5 目录 移动到 /root/t3目录中 不询问，直接覆盖 位置：/root 已知：/root/t3目录中 已经有一个t5目录了 命令：mv -f t5 t3 文件更名： 格式： mv 需要移动的文件 新名字 ## 必须是在同一目录中进行此操作 eg： 文件/目录更名操作： 需求：把/root/Demo1.java 改名为 hehe.java 位置：/root 命令：mv Demo1.java hehe.java rm 删除 rm(remove) 功能：删除文件或目录 删除文件： 语法： rm 文件名 删除目录： 语法： # 格式 rm -rf 目录名 # 参数 -f或--force 强制删除文件或目录，不进行询问 -r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。删除目录必须使用-r 注意： rm -rf * 删除 当前目录 下所有内容 rm –rf /* 删除Linux系统 根目录 下所有内容 eg： 需求：删除/root/t5 目录， 位置：/root 已知：t5目录下有子目录或者文件 命令：rm -rf t5 find 查找 find功能：查找文件或目录 语法： find 目录名 -name &#39;需要查找的字符串&#39; -name 指定字符串作为寻找文件或目录的范本样式 * 表示0~多个任意字符 eg：find t1 -name &#39;*.txt&#39; eg: 需求：查找/root目录下 所有以ins开头的文件或者目录 位置：/root 命令：find /root -name &#39;ins*&#39; 3.4、文档编辑命令Windows是有记事本Linux也有类似的记事本功能 VIM编辑器 VI 编辑 操作： 输入 vi 文件名 进入 “命令(一般)模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 vim 命令 操作： 输入 vim 文件名 或 vi 文件名 进入 “一般模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 一般(命令)模式: 可以浏览文件内容，可以进行文本快捷操作（单行复制，多行复制，单行删除，多行删除…） 按 i/a/o 可以切换到 插入模式按 : 可以切换到 底行模式 插入模式： 可以编辑文件内容。 按 ESC 可以切回 一般模式 底行模式： 可以进行强制退出不保存操作 q! 可以进行保存并退出操作 wq 3.5、grep 、 管道|、重定向输出&gt;&gt;grep 正则表达式 grep：正则表达式，进行字符串搜索工作 用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活 语法： # 格式 grep -i 需要搜索的字符串 搜索的文件 # 参数 -i 忽略大小写查找数据 符合规则，就会返回符合规则的行 管道 管道命令： 可以连接多个Linux命令，其作用是将一个命令的输出用在另一个命令的输入 格式： 命令1 | 命令2 | 命令3…… eg： 需求：查询当前目录中，所有带ins关键字的行数据 位置：/root 思考：查询当前目录内容 ll 查询字符串，返回字符串所在行 grep 命令：ll | grep ins 需求：分页显示ls的help信息 命令：ls --help | more 重定向输出&gt; &gt;&gt; 重定向输出 &gt; 定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空 &gt;&gt; 将输出内容追加到目标文件中。如果文件不存在，就创建文件；如果文件存在，则将新的内容追加到那个文件的末尾，该文件中的原有内容不受影响 格式： 注意： 使用： 将一个文件夹的内容保存到文本文件中去，也就是将ls命令打印出来的内容都写到文本中去可以这样： # a.txt文件中就是ls命令打印出来的内容了 ls -al &gt;&gt; a.txt 3.6、压缩、解压命令【重要】 Linux常见压缩包： .tar 打包，大小不会进行压缩​ .tar.gz 打包并压缩文件大小 压缩：(参数顺序不变) # 格式 tar -zcvf 压缩包名字.tar.gz 需要压缩的内容 # 参数 -z 是否需要用 gzip 压缩 -c 建立一个压缩文件的参数指令（create）--压缩 -v 压缩的过程中显示文件（verbose） -f 使用档案名称，在 f 之后要立即接档名（file） eg： 例如：tar -zcvf hehe.tar.gz * 将当前目录下所有内容进行打包压缩，文件名hehe.tar.gz 解压：(参数顺序不变) # 解压到当前目录 tar -zxvf 需要解压的压缩包名称 解压到当前目录 # 解压到指定目录 tar -zxvf 需要解压的压缩包名称 -C 指定压缩路径 解压到指定目录中 # 参数 -z 是否需要用 gzip 压缩 -x 解开一个压缩文件的参数指令（extract）--解压 -v 压缩的过程中显示文件（verbose） -f 使用档名，在 f 之后要立即接档名（file） eg： 需求：需要把/root/t5/hehe.tar.gz 压缩包 解压到 指定目录中。指定目录/root/t5/t5 位置：/root/t5 命令：tar -zxvf hehe.tar.gz -C /root/t5/t5 tar -zxvf hehe.tar.gz -C t5 3.7、系统命令系统服务服务，是指常期运行，常驻内存中的进程，比如，apache、mysql、ssh等 服务与端口每个服务软件一般在运行时都会对应一个端口。查看监听的端口： ss –lntp 防火墙及防火墙设置CentOS 7.0默认使用的是firewall作为防火墙，使用iptables必须重新设置一下 查看防火墙状态： firewall-cmd --state # running 防火墙处于开启状态 # not running 防火墙处于关闭状态 直接关闭防火墙停止firewall： systemctl stop firewalld.service 禁止firewall开机启动： systemctl disable firewalld.service 查看系统进程：ps -ef需求：查看进程中 和 vim相关的进程 命令：ps -ef|grep -i vim -e 此参数的效果和指定&quot;A&quot;参数相同，显示所有程序 -f 显示UID,PPIP,C与STIME栏位 强制杀死某个进程：kill -9 pid号需求：查看进程 和 vim相关的进程有哪些，并将vim进程杀死 命令：ps -ef|grep -i vim Kill -9 pid号 -l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称 kill 9 表示强制终止 查看网络配置：ifconfig 显示网络设备 测试和目标的连通性：ping 主机名或ip地址 测试与目标主机的连通性 会持续不断一直测试，直到ctrl+c Linux centos重启命令：reboot Linux centos关机命令：halt 3.8、其他命令（了解）chmod 文件权限 hmod(change mode) 功能：变更文件或目录的权限 语法： # 格式 chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;] # 参数 -R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理 权限范围的表示法如下： u：User，即文件或目录的拥有者 g：Group，即文件或目录的所属群组 o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围 a：All，即全部的用户，包含拥有者，所属群组以及其他用户 符号： ‘+’添加权限 ‘-‘取消权限 有关权限代号的部分，列表于下： r：读取权限，数字代号为”4” w：写入权限，数字代号为”2” x：执行或切换权限，数字代号为”1” -：不具任何权限，数字代号为”0” eg: mkdir xxx ll | grep xxx chmod u-rwx xxx #取消xxx目录，用户“读写执行”权限 chmod g-rwx xxx #取消xxx目录，组“读写执行”权限 chmod 777 xxx #给xxx目录添加所有权限 linux 权限格式：&lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt; 网络配置 VIM命令配置 网卡配置 cat /etc/sysconfig/network-scripts/ifcfg-eth0 概要信息如下: DEVICE=eth0 #网卡名称 TYPE=Ethernet #网卡类型 ONBOOT=yes #是否开机启动网卡 BOOTPROTO=static #静态获取IP，其他取值：dhcp （如果设置dhcp下面红色不需要） IPADDR=192.168.44.100 #ip地址 GATEWAY=192.168.44.2 #网关 NETMASK=255.255.255.0 #子网掩码 setup设置 选择“网络配置” 选择“设备配置” 选择“第一块网卡” 设置IP地址等详细信息 命令总结 和 帮助 内部命令：属于Shell解析器的一部分 （系统启动直接加载到内存的） cd 切换目录（change directory） pwd 显示当前工作目录（print working directory） help 帮助 外部命令：独立于Shell解析器之外的文件程序（独立的可执行文件） ls 显示文件和目录列表（list） mkdir 创建目录（make directoriy） cp 复制文件或目录（copy） 查看帮助文档 内部命令：help + 命令（eg：help cd） 外部命令：man + 命令（eg：man ls） 不用特意记忆命令分类，开发中，如果需要查看命令参数，先使用man，如果没有结果，再使用help","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"豆瓣Top250资源合集","slug":"豆瓣Top250资源合集","date":"2018-11-28T17:45:30.000Z","updated":"2019-06-05T10:02:45.475Z","comments":true,"path":"2018/11/29/豆瓣Top250资源合集/","link":"","permalink":"/2018/11/29/豆瓣Top250资源合集/","excerpt":"","text":"点击影片”名称”即可获取资源链接 # 更新至Top1-Top100，敬请期待… 排名名称年份评分Top1肖申克的救赎19949.6Top2霸王别姬19939.6Top3这个杀手不太冷19949.4Top4阿甘正传19949.4Top5美丽人生19979.5Top6泰坦尼克号19979.3Top7千与千寻20019.3Top8辛德勒的名单19939.5Top9盗梦空间20109.3Top10机器人总动员20089.3Top11忠犬八公的故事20099.3Top12三傻大闹宝莱坞20099.2Top13海上钢琴师19989.2Top14放牛班的春天20049.2Top15大话西游之大圣娶亲19959.2Top16楚门的世界19989.2Top17教父19729.2Top18星际穿越20149.2Top19龙猫19889.1Top20熔炉20119.3Top21无间道20029.1Top22当幸福来敲门20069.0Top23触不可及20119.2Top24怦然心动20109.0Top25乱世佳人19399.2Top26疯狂动物城20169.2Top27蝙蝠侠：黑暗骑士20089.1Top28天堂电影院19889.1Top29活着19949.1Top30少年派的奇幻漂流20129.0Top31十二怒汉19579.4Top32鬼子来了20009.2Top33指环王3：王者无敌20039.1Top34控方证人19579.6Top35搏击俱乐部19999.0Top36天空之城19869.0Top37飞屋环游记20098.9Top38大话西游之月光宝盒19958.9Top39罗马假日19539.0Top40摔跤吧！爸爸20169.1Top41窃听风暴20069.1Top42辩护人20139.2Top43两杆大烟枪19989.1Top44闻香识女人19929.0Top45哈尔的移动城堡20048.9Top46飞越疯人院19759.0Top47死亡诗社19899.0Top48V字仇杀队20058.8Top49海豚湾20099.3Top50教父219749.1Top51指环王2：双塔奇兵20029.0Top52指环王1：魔戒再现20018.9Top53美丽心灵20018.9Top54饮食男女19949.1Top55情书19958.8Top56素媛20139.1Top57狮子王19948.9Top58钢琴家20029.1Top59美国往事19849.1Top60小鞋子19979.2Top61七宗罪19958.8Top62被嫌弃的松子的一生20068.9Top63致命魔术20068.8Top64本杰明·巴顿奇事20088.8Top65末代皇帝19879.0Top66西西里的美丽传说20008.8Top67天使爱美丽20018.7Top68黑客帝国19998.9Top69让子弹飞20108.7Top70拯救大兵瑞恩19988.9Top71看不见的客人20168.7Top72音乐之声19658.9Top73低俗小说19948.8Top74勇敢的心19958.8Top75剪刀手爱德华19908.7Top76大闹天宫19611964197820049.3Top77沉默的羔羊19918.8Top78蝴蝶效应20048.7Top79哈利·波特与魔法石20018.8Top80春光乍泄19978.8Top81入殓师20088.8Top82心灵捕手19978.8Top83猫鼠游戏20028.8Top84布达佩斯大饭店20148.8Top85禁闭岛20108.7Top86玛丽和马克思20098.9Top87阳光灿烂的日子19948.8Top88第六感19998.8Top89幽灵公主19978.8Top90重庆森林19948.7Top91狩猎20129.1Top92致命ID20038.7Top93穿条纹睡衣的男孩20088.9Top94断背山20058.7Top95加勒比海盗20038.6Top96大鱼20038.7Top97阿凡达20098.6Top98摩登时代19369.2Top99告白20108.7Top100一一20009.0Top101射雕英雄传之东成西就19938.7Top102甜蜜蜜19968.8Top103阳光姐妹淘20118.8Top104消失的爱人20148.7Top105爱在黎明破晓前19958.7Top106上帝之城20028.9Top107小森林 夏秋篇20148.9Top108侧耳倾听19958.8Top109喜剧之王19998.6Top110倩女幽魂19878.6Top111恐怖直播20138.7Top112风之谷19848.8Top113爱在日落黄昏时20048.8Top114超脱20118.8Top115红辣椒20068.9Top116菊次郎的夏天19998.8Top117驯龙高手20108.7Top118幸福终点站20048.7Top119神偷奶爸20108.5Top120借东西的小人阿莉埃蒂20108.7Top121杀人回忆20038.7Top122七武士19549.2Top123岁月神偷20108.6Top124请以你的名字呼唤我20178.8Top125萤火虫之墓19888.7Top126怪兽电力公司20018.6Top127小森林 冬春篇20159.0Top128哈利·波特与死亡圣器(下)20118.7Top129谍影重重320078.7Top130喜宴19938.8Top131东邪西毒19948.6Top132电锯惊魂20048.7Top133贫民窟的百万富翁20088.5Top134疯狂原始人20138.7Top135记忆碎片20008.6Top1367号房的礼物20138.7Top137黑天鹅20108.5Top138萤火之森20118.8Top139真爱至上20038.5Top140英雄本色19868.6Top141超能陆战队20148.6Top142雨人19888.6Top143心迷宫20148.7Top144蝙蝠侠：黑暗骑士崛起20128.6Top145卢旺达饭店20048.9Top146唐伯虎点秋香19938.5Top147海洋20099.0Top148傲慢与偏见20058.5Top149荒蛮故事20148.8Top150纵横四海19918.7Top151海边的曼彻斯特20168.6Top152教父319908.8Top153虎口脱险19668.9Top154无人知晓20049.1Top155时空恋旅人20138.7Top156完美的世界19939.0Top157寻梦环游记20179.0Top158玩具总动员320108.8Top159燃情岁月19948.7Top160花样年华20008.5Top161恋恋笔记本20048.5Top162达拉斯买家俱乐部20138.7Top163血战钢锯岭20168.7Top164二十二20158.7Top165雨中曲19529.0Top166魂断蓝桥19408.8Top167穿越时空的少女20068.6Top168猜火车19968.5Top169我是山姆20018.8Top170冰川时代20028.5Top171人工智能20018.6Top172爆裂鼓手20148.6Top173头脑特工队20158.7Top174被解救的姜戈20128.6Top175未麻的部屋19978.8Top176罗生门19508.7Top177浪潮20088.7Top178香水20068.4Top179朗读者20088.5Top180阿飞正传19908.5Top181你的名字。20168.4Top182房间20158.8Top183可可西里20048.7Top184恐怖游轮20098.4Top185模仿游戏20148.6Top186一个叫欧维的男人决定去死20158.8Top187一次别离20118.7Top188忠犬八公物语19879.1Top189战争之王20058.6Top190追随19988.9Top191魔女宅急便19898.5Top192撞车20048.6Top193谍影重重20028.5Top194完美陌生人20168.6Top195地球上的星星20078.9Top196牯岭街少年杀人事件19918.8Top197谍影重重220048.6Top198哪吒闹海19798.9Top199惊魂记19608.9Top200青蛇19938.5Top201梦之安魂曲20008.7Top202无敌破坏王20128.7Top203黑客帝国3：矩阵革命20038.6Top204小萝莉的猴神大叔20158.5Top205再次出发之纽约遇见你20138.5Top206海街日记20158.7Top207新龙门客栈19928.5Top208东京物语19539.2Top209步履不停20088.8Top210终结者2：审判日19918.6Top211源代码20118.4Top212初恋这件小事20108.3Top213绿里奇迹19998.7Top214城市之光19319.2Top215末路狂花19918.7Top216爱在午夜降临前20138.8Top217疯狂的石头20068.3Top218秒速5厘米20078.3Top219无耻混蛋20098.5Top220这个男人来自地球20078.5Top221勇闯夺命岛19968.6Top222E.T. 外星人19828.5Top223碧海蓝天19888.7Top224变脸19978.4Top225卡萨布兰卡19428.6Top226黄金三镖客19669.1Top227发条橙19718.5Top228彗星来的那一夜20138.4Top229聚焦20158.8Top230海盗电台20098.6Top231美国丽人19998.5Top232血钻20068.5Top233非常嫌疑犯19958.6Top234国王的演讲20108.3Top235荒野生存20078.6Top236英国病人19968.5Top237黑鹰坠落20018.6Top238我爱你20119.0Top239迁徙的鸟20019.1Top240遗愿清单20078.5Top241勇士20118.9Top242荒岛余生20008.5Top2432001太空漫游19688.7Top244枪火19998.7Top245燕尾蝶19968.6Top246叫我第一名20088.6Top247穆赫兰道20018.3Top248千钧一发19978.7Top249大卫·戈尔的一生20038.6Top250上帝也疯狂19808.7","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"公众号文章","slug":"公众号文章","permalink":"/tags/公众号文章/"},{"name":"Top电影","slug":"Top电影","permalink":"/tags/Top电影/"}]},{"title":"使用 Hexo+GitHub 搭建个人博客","slug":"使用Hexo+GitHub搭建个人博客","date":"2018-11-28T07:36:06.000Z","updated":"2019-06-05T10:02:59.953Z","comments":true,"path":"2018/11/28/使用Hexo+GitHub搭建个人博客/","link":"","permalink":"/2018/11/28/使用Hexo+GitHub搭建个人博客/","excerpt":"","text":"昨天偶然看见一篇有关使用Hexo搭建个人博客的文章，瞬间吸引我的注意。今天使用的一天的时间在GitHub上搭建了一个个人博客，感觉还不错，分享给大家，并记录下我搭建过程中趟过的坑 环境：Win10 + Hexo + GitHub 效果展示：脚印的博客 一、准备工作1. 了解Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官方文档：https://hexo.io/zh-cn/docs/ 2. 搭建Node.js环境Hexo基于Node.js环境，那么我们搭建博客网站首先需要安装Node.js环境 下载地址：http://nodejs.cn/download 详细安装文档：http://www.runoob.com/nodejs/nodejs-install-setup.html 测试安装：命令行使用 node -v 、npm -v，查看显示版本号即成功。如下图： 3. 注册Github账号这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件 注册地址：https://github.com注册流程：https://blog.csdn.net/p10010/article/details/51336332 注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦 4. 安装Git版本工具 使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步 下载地址：https://git-scm.com/downloads Windows系统需下载，Mac系统因为自带Git无需操作 详细安装文档：https://blog.csdn.net/u013295518/article/details/78746007 测试安装：git --version，查看显示版本号即成功。如下图： 配置SSH：https://blog.csdn.net/qq_35246620/article/details/69061355 SSH key添加之后，就可以在本机git bash中进行测试，输入ssh -T git@github.com进行测试 显示 Hi username ！You&#39;ve successfully... 说明ssh配置成功了 5. 在本地安装 Hexo Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件 npm install -g hexo-cli 注意：在回车之后，可能会出现一行WARN的警告语句，不用管它，这个不妨碍安装 过一段时间如果出现hexo版本号之类的语句就代表差不多了 然后输入 npm install hexo --save 这个时候你会看到命令行出现了一堆白字，紧接着输入hexo v查看是否安装成功： 此时，Hexo已经安装完成 二、搭建博客1. 开启GitHub Pages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是： 仓库名固定：你的github的username.github.io 这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。 点击Create Repository后，选着仓库的Setting进入设置 往下滑找到 Github Pages 如下： 这里我们需要点击 Choose a theme 任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 点击 Select theme 选着主题后，此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 输入你的 GitHub 的用户名和密码，成功后复制https://username.github.io/到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！ 2. 创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下： hexo init myHexoBlog //myHexoBlog是项目名 等一会，如果出现橙色的 WARN 没关系，只要不出现红色的 ERROR 就行。好了后，输入命令： hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 然后点开 http://localhost:4000/ ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！ 3. 同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地博客目录的配置：修改本地博客根目录下的_config.yml文件，修改deploy下的配置，如下： deploy: type: git repository: git@github.com:xiongtianci-tc/xiongtianci-tc.github.io.git #复制的仓库地址 branch: master 注意： repository后面的内容是 git@gitbub.com:username/库地址 的形式 type、repository、branch冒号的后面都有一个空格（切记~~） 最后执行控制台命令： npm install hexo-deployer-git --save //安装部署插件 hexo d //部署到github 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三、发布你的第一篇博客终于可以发布自己的第一篇博客了，是不是很激动？（博主当时可是超级激动的~）首先，在本地博客文件夹根目录输入： hexo new &quot;我个人博客的第一篇博客，激动~&quot; hexo g //生成网页 hexo d //部署到远端(github) 现在打开我们的博客网站：http://UserName.github.io,会看到网页如下(可能需要刷新几次页面)： 需要编写博客内容时，只需编写本地博客的 _posts 的博客原文，然后通过 hexo g &amp;&amp; hexo d 重新部署到github即可 四、更换主题此时，我们的个人博客已经搭建完成。但是我们需要网站更加高大上，更加美观些，我们可以通过更换主题来实现个性化博客 这里以使用github上的next主题为例： 1. 下载主题next主题：https://github.com/iissnan/hexo-theme-next 在控制台中切换到本地博客根目录输入： $ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next 下载成之后我们会看到next的主题已经存在 thems 里了如下： 2. 更换主题修改博客根目录(不是next主题)下的 _config.yml 文件，搜索 theme 字段，并将其值修改为 next 然后在控制台下输入如下命令： hexo clean //清理缓存 hexo g //重新生成博客代码 hexo d //部署到本地 // 或者直接输入：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 再次打开我们的博客网站：https://UserName.github.io，将会发现我们的博客主题已经发生了改变 五、个性化通过此步骤我们可以设置博客的作者、格言、语言… 在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项 1. 站点配置在本地的博客根目录下找到_config.yml，用编辑器打开进行内容的设置，如下： 这里可以修改博客网站的标题、描述，语言等属性 2. 主题设置网上有个超级详细的教程，我就不赘述了： 文档地址：http://theme-next.iissnan.com/getting-started.html 终于结束了， 最后，","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"/tags/Hexo/"}]}]}