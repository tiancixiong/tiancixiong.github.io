{"meta":{"title":"天赐","subtitle":"Viva La Vida","description":"Viva La Vida","author":"天赐","url":"https://www.xiongtianci.com","root":"/"},"pages":[{"title":"","date":"2019-06-14T02:46:40.863Z","updated":"2019-06-14T02:46:40.863Z","comments":true,"path":"baidu_verify_S4IxG3JiC9.html","permalink":"https://www.xiongtianci.com/baidu_verify_S4IxG3JiC9.html","excerpt":"","text":"S4IxG3JiC9"},{"title":"","date":"2019-06-13T15:42:05.147Z","updated":"2019-06-11T09:47:49.936Z","comments":true,"path":"googleb2e7c27c164ee2f9.html","permalink":"https://www.xiongtianci.com/googleb2e7c27c164ee2f9.html","excerpt":"","text":"google-site-verification: googleb2e7c27c164ee2f9.html"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-06-20T02:07:05.026Z","comments":false,"path":"about/index.html","permalink":"https://www.xiongtianci.com/about/index.html","excerpt":"","text":"[トトロ 天赐] 与&nbsp; 天赐&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, 朋友, 欢迎来访~👋\" }).then(function() { botui.message.add({ delay: 1100, content: \"这里是~天赐~\" }).then(function() { botui.message.add({ delay: 1100, content: \"a boy~\" }).then(function() { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function(a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function() { botui.message.add({ delay: 600, content: \"😘\" }).then(function() { secondpart() }) }, end = function() { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function() { botui.message.add({ delay: 1500, content: \"目前任职于某司实习生\" }).then(function() { botui.message.add({ delay: 1500, content: \"大学入坑编程, 后来一去不返…\" }).then(function() { botui.message.add({ delay: 1200, content: \"现在的工作是java码畜\" }).then(function() { botui.message.add({ delay: 1500, content: \"略懂 大数据, 偶尔也折腾 Linux/HTML/CSS/JavaScript/Node.js等\" }).then(function() { botui.message.add({ delay: 1800, content: \"喜欢旅行和电影, 正计划一场毕业旅行\" }).then(function() { botui.action.button({ delay: 1100, action: [{ text: \"博客的内容是什么呢？ 🤔\", value: \"blog-daily\" }] }).then(function(a) { thirdpart() }) }) }) }) }) }) }, thirdpart = function() { botui.message.add({ delay: 1E3, content: \"都是一些日常（灌水）内容，会不定时记录自己遇到的技术问题和生活片段，也会转载一下有意思的博文~\" }).then(function() { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧~ ^_^\" }) }) } } bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-06-04T16:31:44.716Z","comments":false,"path":"bangumi/index.html","permalink":"https://www.xiongtianci.com/bangumi/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-06-18T03:36:08.562Z","comments":false,"path":"client/index.html","permalink":"https://www.xiongtianci.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-06-18T03:35:09.325Z","comments":false,"path":"donate/index.html","permalink":"https://www.xiongtianci.com/donate/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-06-18T03:35:20.910Z","comments":true,"path":"comment/index.html","permalink":"https://www.xiongtianci.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-06-18T03:34:38.073Z","comments":false,"path":"lab/index.html","permalink":"https://www.xiongtianci.com/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-06-26T02:07:56.992Z","comments":true,"path":"links/index.html","permalink":"https://www.xiongtianci.com/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-06-18T03:44:25.191Z","comments":false,"path":"music/index.html","permalink":"https://www.xiongtianci.com/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-06-18T03:38:10.531Z","comments":true,"path":"rss/index.html","permalink":"https://www.xiongtianci.com/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://www.xiongtianci.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-06-18T03:50:51.657Z","comments":true,"path":"tags/index.html","permalink":"https://www.xiongtianci.com/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"video/index.html","permalink":"https://www.xiongtianci.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"Notepad++正则的使用","slug":"Notepad++正则的使用","date":"2019-06-26T01:13:07.000Z","updated":"2019-06-26T03:11:29.585Z","comments":true,"path":"2019/06/26/Notepad++正则的使用/","link":"","permalink":"https://www.xiongtianci.com/2019/06/26/Notepad++正则的使用/","excerpt":"","text":"操作Notepad++正则Notepad++使用正则替换的操作：Ctrl+H -&gt; 勾选正则表达式 -&gt; 输入查找目标和替换为 -&gt; 全部替换 比如现在需求是要删除文本中的空行，可能一行也可能是多行： 使用正则\\n[\\s| ]*\\r替换为空即可： 结果： 正则汇总 正则 描述 \\n[\\s&#124; ]*\\r 匹配空白行(n行) ^ 匹配每行开头 $ 匹配每行结尾","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"正则","slug":"正则","permalink":"https://www.xiongtianci.com/tags/正则/"},{"name":"Notepad++","slug":"Notepad","permalink":"https://www.xiongtianci.com/tags/Notepad/"}],"author":"天赐"},{"title":"CSS :hover选择器的使用","slug":"CSS-hover选择器的使用","date":"2019-06-24T08:49:29.000Z","updated":"2019-06-24T09:11:14.718Z","comments":true,"path":"2019/06/24/CSS-hover选择器的使用/","link":"","permalink":"https://www.xiongtianci.com/2019/06/24/CSS-hover选择器的使用/","excerpt":"","text":"定义:hover 选择器，用于选择鼠标指针浮动在上面的元素 :hover选择器适用于所有元素 用法用法一a:hover { background-color: yellow; } 效果：当鼠标悬浮在a元素上时，a的背景颜色设置为黄色 用法二使用 a 控制其他块的样式 子元素使用 a 控制 a 的子元素 b ： a:hover b { background-color:blue; } 兄弟元素使用 a 控制 a 的兄弟元素 c(同级元素) a:hover + c { background-color:blue; } 就近元素使用 a 控制 a 的就近元素 d a:hover ~ d { background-color:blue; } 总结:hover用于选择鼠标悬停其上时的元素 空格：控制子元素 +：控制同级(兄弟)元素 ~：控制就近元素","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/tags/笔记/"},{"name":"CSS","slug":"CSS","permalink":"https://www.xiongtianci.com/tags/CSS/"},{"name":"选择器","slug":"选择器","permalink":"https://www.xiongtianci.com/tags/选择器/"}],"author":"天赐"},{"title":"LeanCloud域名更换-恢复Sakura主题Valine评论","slug":"LeanCloud域名更换-恢复Sakura主题Valine评论","date":"2019-06-21T09:32:56.000Z","updated":"2019-06-22T02:06:26.475Z","comments":true,"path":"2019/06/21/LeanCloud域名更换-恢复Sakura主题Valine评论/","link":"","permalink":"https://www.xiongtianci.com/2019/06/21/LeanCloud域名更换-恢复Sakura主题Valine评论/","excerpt":"","text":"LeanCloud域名更换使用Valine评论插件注册过LeanCloud的小伙伴们从昨天起应该都收到过一封邮件和一条短信，告知了LeanCloud对域名进行更换： 从而导致好多小伙伴们的Valine评论插件报错Code -1: Request has been terminated： Code -1: Request has been terminated Possible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc. Valine插件作者在今天下午解决了这个问题： 恢复Valine评论博主的Hexo主题是Sakura下面是博主恢复Valine评论的记录： 1、打开文件/themes/sakura/layout/_partial/footer.ejs 2、搜索`unpkg.com/valine@1.3.4/dist/Valine.min.js，将此路径替换为unpkg.com/valine@1.3.7/dist/Valine.min.js` 3、将&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;删除或注释掉即可","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.xiongtianci.com/tags/Hexo/"},{"name":"Valine","slug":"Valine","permalink":"https://www.xiongtianci.com/tags/Valine/"}],"author":"天赐"},{"title":"Octotree访问私有仓库：Error: Private repository","slug":"Octotree访问私有仓库：Error-Private-repository","date":"2019-06-18T07:52:34.000Z","updated":"2019-06-19T07:39:14.222Z","comments":true,"path":"2019/06/18/Octotree访问私有仓库：Error-Private-repository/","link":"","permalink":"https://www.xiongtianci.com/2019/06/18/Octotree访问私有仓库：Error-Private-repository/","excerpt":"","text":"问题在GitHub私有仓库中使用Octotree时出现下面情况： 这个是因为我们需要在GitHub中给Octotree设置一个访问令牌 解决在GitHub中：Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token 创建令牌 设置名称Octotree browser extension（任意）： 勾选权限范围： 点击Generate token创建令牌： 点击复制按钮复制令牌token（注意：这个token值只会显示一次） 在Octotree中点击设置按钮： 将你刚刚复制的token粘贴到GitHub access token文本框中，点击Apply settings，刷新页面即可： 注意事项 Octotree将令牌token存储在浏览器缓存中，如果将浏览器存储令牌token的缓存清除后，Octotree将会失去私有仓库的访问权限，需重新设置令牌token。https://github.com/ovity/octotree/issues/717","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"google扩展","slug":"google扩展","permalink":"https://www.xiongtianci.com/tags/google扩展/"},{"name":"Octotree","slug":"Octotree","permalink":"https://www.xiongtianci.com/tags/Octotree/"}],"author":"天赐"},{"title":"电影资源网址-珍藏","slug":"电影资源网址-珍藏","date":"2019-06-15T13:55:43.000Z","updated":"2019-06-23T05:47:03.173Z","comments":true,"path":"2019/06/15/电影资源网址-珍藏/","link":"","permalink":"https://www.xiongtianci.com/2019/06/15/电影资源网址-珍藏/","excerpt":"","text":"影视讯息 豆瓣电影 IMDb 烂番茄 实时票房 1905 时光网 MTC 天涯小筑 电影DVD光盘资源分享网 台湾电影资料站 雅虎电影 电影海报 新电影生肉 海盗湾 Zooqle TorrentGalaxy RARBG kat片源 eztv美剧 lime Monova 俄站 熟肉 BD影视 电影天堂 人人影视 电影FM 第一时间电影 盘盘搜 泡饭影视 悟空视频 高清电台 19影视 BTtwo 飘花资源网 6V电影网 ED2000 高清MP4 悠悠MP4 爱下电影 蓝鲸电影 沙发电影网 音范丝 电影港 嘎嘎影视 无极论坛 帝国出品 片源网 影视看看 电影蜜蜂 美剧 Orange字幕组 美剧天堂 爱美剧 电影首发站美剧 美剧鸟 美剧汇 字幕组 磁力站 天天美剧 美剧-一站搜 看美剧 鱼子酱 电波字幕组 冰冰字幕组 玄字幕组 Fantopia字幕组 大家字幕组 动漫 密柑计划 9ANIME *生肉 萌番组 D站 简单动漫 漫猫动漫 喵搜 科学上网 动漫花园 韩剧 嘟嘟韩剧网 韩剧网 韩迷字幕组 韩国综艺 住在韩国 日剧 neets搜索站-日剧 诸神字幕组-日剧 字幕组-日剧 NO视频 隐社导航 心动日剧 日剧网 花译工坊 追新番 日菁字幕组 第六感 东京不够热 综艺 综艺巴士 纪录片 老纪录 纪录片天地 wiki 科学上网 纪录片之家 纪录片-诸神字幕组 搜索常用 neets搜索站 网盘搜索 盘多多 一网打尽 番茄搜搜 史莱姆导航 探索云盘搜索 胖次 盘搜搜 盘窝窝 百度网盘搜索 网盘搜搜 去转盘网 凌风云搜索 盘优搜 搜搜云盘 搜云盘 58搜索 百度网盘搜索 坑搜网 搜盘侠 BT搜索 磁力聚合搜索神器 BT部落天堂 磁力猫 磁力鼠 万磁搜 BT之家 流弊网) 蓝光电影网 磁力站 查片源 torrentdownload Diggbt kikiBT 种子磁力 一站搜 小不点搜索 科学上网 Torrent Kitty 外挂字幕库 字幕库 opensubtitles 伪射手 R3字幕 台湾精研社R3官字幕 字幕天堂 科学上网 SUBHD 其他 V电影，国内优质短片分享平台，实时分享国内外各类短片，V电影专注于短片领域，收录的国内外优质短片作品近万部，被媒体称为中国版的VIMEO 放映TV，网页简洁美观，动态酷炫，主页以大搜索框属人耳目，放映TV分类详细，每部影片的导演、主演、类型和上映时间具有详细数据，并采用的豆瓣和IMDB的双重评分记录，每部影片至多有8家以内的主流视频网站云点播功能。 某柠檬 参考 常用各类电影资源网址","categories":[{"name":"资源","slug":"资源","permalink":"https://www.xiongtianci.com/categories/资源/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://www.xiongtianci.com/tags/电影/"}],"author":"天赐"},{"title":"Typora锚点-页内跳转","slug":"Typora锚点-页内跳转","date":"2019-06-13T06:54:02.000Z","updated":"2019-06-18T08:51:41.315Z","comments":true,"path":"2019/06/13/Typora锚点-页内跳转/","link":"","permalink":"https://www.xiongtianci.com/2019/06/13/Typora锚点-页内跳转/","excerpt":"","text":"锚点锚点：通俗简单地说，比如一篇很长的文章，你想按分段精确来看，那就可以用到锚点了。 锚点的用法有两种，但性质同样，都是通过链接标签&lt;a&gt;&lt;/a&gt;以及其href属性实现的：一种是：页内跳转一种是：跳到其他页面的某个指定区域 要想使用锚点必须在路径href值中使用# # 的作用#代表网页中的一个位置 其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。href中#后面的值要跟name或id一致，","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Typora","slug":"Typora","permalink":"https://www.xiongtianci.com/tags/Typora/"}],"author":"天赐"},{"title":"打造个性超赞博客Hexo+Next+GitHub Pages的超深度优化","slug":"打造个性超赞博客Hexo-NexT-GitHub-Pages的超深度优化","date":"2019-06-13T02:11:45.000Z","updated":"2019-06-20T10:16:08.060Z","comments":true,"path":"2019/06/13/打造个性超赞博客Hexo-NexT-GitHub-Pages的超深度优化/","link":"","permalink":"https://www.xiongtianci.com/2019/06/13/打造个性超赞博客Hexo-NexT-GitHub-Pages的超深度优化/","excerpt":"","text":"作者：reuixiy 原文：https://io-oi.me/tech/hexo-next-optimization.html#main theme-next：https://github.com/xiongtianci-tc/hexo-theme-next PS：此博文是博主在使用hexo建站时看过的最详细的一篇，由于原作者reuixiy在半个月前将博客主题进行了重构，故将此博文转载并附上我原先fork的主题地址，以便日后食用~ 侵权立删 必读 写在前面本文主要内容是 NexT 主题的个性化定制和一些细节的优化。搭建的过程，已有的优化，Markdown 的使用，都直接贴出大佬的文章链接。 首先肯定是感谢各位大佬的文章，我一个小白，没学 HTML，没学 CSS，没学 JavaScript，连 C 也还没学会……如果你是一个和我一样的小白，且对本博客感觉还蛮满意，恭喜你！看完这篇文章，你自己也可以拥有一个这样的博客啦！ 给小白（像我一样，也许还有完美主义和强迫症😂）却想搭建个性化博客提供参考，是我写这篇文章的主要目的，所以如果本文有幸被大佬读到，文中的不足还请大佬见谅。 本文参考的文章都会直接给出原文链接或者以注脚的形式标记出处，但 Google 参考了实在太多太多了，有些我当时没做记录，如有遗漏，欢迎指出。另外，有一些优化的很好的博客，有很多很酷的功能，我当时没收藏，后来非常后悔，提醒大家如果看到很赞的博客，一定要马上收藏。 重要的定义了解定义，防止懵逼和大脑混乱。这两个文件名字都叫_config.yml，容易乱。 1）站点配置文件，位于站点文件夹根目录内~/blog/_config.yml 2）主题配置文件，位于主题文件夹根目录内~/blog/themes/next/_config.yml 我操作的环境留这个，是因为有时我 Google 教程，发现按流程走，却达不到应有的效果。故当按照这篇的某流程却达不到预期效果，可以考虑考虑这个，然后自己灵活点去 Google 解决方案。 # [2017.12.13 更新] /* 调试浏览器 */ Google Chrome Version 62.0.3202.94 (Official Build) (64-bit) /* 版本信息 */ root@kali:~/blog# hexo version (node:6675) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated. hexo: 3.4.1 hexo-cli: 1.0.4 os: Linux 4.13.0-kali1-amd64 linux x64 http_parser: 2.7.0 node: 8.3.0 v8: 6.0.286.52 uv: 1.13.1 zlib: 1.2.11 ares: 1.10.1-DEV modules: 57 openssl: 1.0.2l icu: 59.1 unicode: 9.0 cldr: 31.0.1 tz: 2017b /* 依赖包 */ root@kali:~/blog# cat package.json { &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.4.1&quot; }, &quot;dependencies&quot;: { &quot;gulp&quot;: &quot;^3.9.1&quot;, /* 压缩代码 */ &quot;gulp-htmlclean&quot;: &quot;^2.7.15&quot;, /* 压缩代码 */ &quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;, /* 压缩代码 */ &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;, /* 压缩代码 */ &quot;hexo&quot;: &quot;^3.4.1&quot;, /* 默认安装 */ &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, /* Git 部署工具 */ &quot;hexo-filter-github-emojis&quot;: &quot;^1.4.3&quot;, /* emoji 支持 */ &quot;hexo-footnotes&quot;: &quot;^1.0.1&quot;, /* 注脚 */ &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, /* 默认安装 */ &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, /* 默认安装 */ &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;, /* RSS */ &quot;hexo-generator-index-pin-top&quot;: &quot;^0.2.2&quot;, /* 替代默认安装的，支持文章置顶 */ &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;, /* 本地搜索 */ &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;, /* 生成 sitemap.xml，利于 SEO */ &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, /* 默认安装 */ &quot;hexo-renderer-ejs&quot;: &quot;^0.3.0&quot;, /* 默认安装 */ &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;, /* 默认安装 */ &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, /* 默认安装 */ &quot;hexo-server&quot;: &quot;^0.2.0&quot;, /* 默认安装 */ &quot;hexo-tag-aplayer&quot;: &quot;^2.0.5&quot;, /* 音乐播放插件，支持歌词 */ &quot;hexo-tag-dplayer&quot;: &quot;^0.2.1&quot;, /* 视频播放插件，支持弹幕 */ &quot;hexo-wordcount&quot;: &quot;^3.0.2&quot; /* 字数统计 */ } } /* 主题NexT版本 */ version: 5.1.3 /* 优化主题NexT的设计版式 */ scheme: Muse 开始 搭建博客终于进入正文了！但是这个我却不打算写，因为看到了一些很好的文章，这里直接给出这些文章的链接🌚～ 在本地安装 Hexo直接参考 Hexo 官方文档，毕竟是官方文档。安装好 Hexo 后，先任意目录新建个文件夹，名字可以为 blog，然后进入这个文件夹，输入命令： # 所在目录：~/blog/ hexo init 等一会，如果出现橙色的 WARN 没关系，只要不出现红色的 ERROR 就行。好了后，输入命令： # 所在目录：~/blog/ hexo g &amp;&amp; hexo s 然后点开 http://localhost:4000/ ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！距离成功只差下一步——部署博客到 GitHub Pages 了～ 部署博客到 GitHub PagesGitHub Pages 是开源协作社区 GitHub 的一个服务，将博客部署到它上面再合适不过了。 问题 解答 为什么要部署到 GitHub Pages 上？ 首先免费，其次省心，最后可以学习使用 GitHub。 GitHub Pages 有容量限制吗？ 有，由 What is GitHub Pages? 可知：大小限制为 1GB，一个月 100GB 流量。 超出限制的容量怎么办？ 讲真，如果图片音乐视频等大文件都放在七牛云 KODO、阿里云 OSS 或其它云存储上，那么压根不用担心，因为我的博客现在[2017.11.17]也才用了 6.73MB 😅，所以无需担心。 国内访问速度行不行，有必要同时部署在 Coding 上吗？ 个人感觉完全没必要，自己不用梯子时，感觉访问速度可以，毕竟站点的大文件都是放在了云存储上。 我可以用自己的域名吗？ 可以，并且原生支持 https，教程见这篇文章。 注册 GitHub 帐号和创建 Repository 请查看这篇文章，之后在站点文件夹根目录，安装 Git 部署插件（以后安装插件都先到这个目录），输入下面命令回车： # 所在目录：~/blog/ npm install hexo-deployer-git --save 然后，打开站点文件夹根目录下的站点配置文件，编辑： # 文件位置：~/blog/_config.yml # URL url: https://reuixiy.github.io/ . . .省略…… . . # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: - type: + type: git + repository: https://github.com/reuixiy/reuixiy.github.io.git + branch: master 将其中的reuixiy改成你的 GitHub 注册的帐号名就行，然后执行下面的命令： # 所在目录：~/blog/ hexo clean &amp;&amp; hexo g &amp;&amp; hexo 输入你的 GitHub 的用户名和密码，成功后复制https://帐号名.github.io/到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！ 当然，如果你不想每次都输入用户名和密码，不想每次更新时，在 GitHub 上显示invalid-email-address，可以按上面所提的那篇文章操作。 更新提示（可以最后看）更新会有不确定因素，即讨厌又麻烦，但是不更新又怎么能享受新功能呢😑… 其它更新1）npm 更新全局安装的包： npm update -g 2）npm 更新站点文件夹根目录下安装的依赖包： # 所在目录：~/blog/ npm update 3）更新 npm 它自己： npm install npm -g 4）更新 Node.js 到最新版： npm install n -g n latest 更新主题进入主题文件夹根目录，然后git pull，发现报错，怎么解决呢？可以先浏览这篇文章，然后参考我的操作。 先到主题文件夹根目录： # 所在目录：~/blog/themes/next/ git pull 会发现报错，由于我们更改了相关文件，更新不成功，所以要将本地的所有修改先暂时存储起来： # 所在目录：~/blog/themes/next/ git stash 然后再试一下： # 所在目录：~/blog/themes/next/ git pull 可以了吧，接下来还原暂时存储的内容（即保存我们的所有修改）： # 所在目录：~/blog/themes/next/ git stash pop 如果报CONFLICT，是因为 Git 无法确定一些改动，所以要我们手动解决文件中冲突的部分，这个比较麻烦，可以参考我下面的流程。 首先打开报CONFLICT的文件，Ctrl + F 搜索&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes，查看从此处到=======之间保存的代码，回忆一下自己当时更改了什么，是为了达到什么功能。 然后查看=======到&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream之间更新的代码，与下面保存的代码进行对比（也请浏览下所标出代码前后的代码）： 如果改动较大，可能是主题增加了新功能，建议保留更新的代码，然后更改一下，达到自己想要在保存的代码中实现的功能，最后删除保存的代码。 如果改动较小，建议还是保留更新的代码，然后更改一下，最后删除保存的代码。 注意：要是自己不确定，一定记得将&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream到&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes之间的代码另存备份，然后进行调试，直到最后确定没有问题。 最后： # 所在目录：~/blog/themes/next/ root@kali:~/blog/themes/next# git pull error: Pulling is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use &#39;git add/rm &lt;file&gt;&#39; hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. 哇，又报错了😂😂😂，咋办？ 先查看： # 所在目录：~/blog/themes/next/ root@kali:~/blog/themes/next# git status On branch master Your branch is up to date with &#39;origin/master&#39;. Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: layout/_custom/header.swig modified: layout/_custom/sidebar.swig modified: layout/_layout.swig modified: layout/category.swig modified: layout/tag.swig modified: source/css/_common/components/post/post-meta.styl modified: source/css/_common/components/post/post-nav.styl modified: source/css/_common/scaffolding/base.styl modified: source/css/_custom/custom.styl deleted: source/images/avatar.gif modified: source/lib/Han/dist/han.min.css Unmerged paths: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: _config.yml both modified: languages/zh-Hans.yml both modified: layout/_macro/post-copyright.swig both modified: layout/_macro/post.swig both modified: layout/_macro/sidebar.swig both modified: layout/_partials/footer.swig both modified: layout/page.swig both modified: source/css/_variables/base.styl Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) layout/_macro/passage-end-tag.swig source/js/src/love.js 看下面Unmerged paths，说git reset HEAD &lt;file&gt;...来取消修改（大概），git add &lt;file&gt;...来 mark 决定（大概），我们当然要保存这些文件的更改，所以： # 所在目录：~/blog/themes/next/ root@kali:~/blog/themes/next# git add _config.yml languages/zh-Hans.yml layout/_macro/post-copyright.swig layout/_macro/post.swig layout/_macro/sidebar.swig layout/_partials/footer.swig layout/page.swig source/css/_variables/base.styl layout/_macro/passage-end-tag.swig source/js/src/love.js 顺便把新加的passage-end-tag.swig和love.js也加进去，最后再来试一下吧： # 所在目录：~/blog/themes/next/ root@kali:~/blog/themes/next# git pull Already up to date. 哇，成功更新主题！ 注意：更新有风险，一定要谨慎处理文件中冲突的部分！另，如果更新 NexT 主题后，配置文件有些新功能不会配置，可以查看 Releases（最新版）页面，去里面找说明。 优化 基本功能配置通过上面的折腾，你应该能够在自己的 GitHub Pages 上看到自己的博客了，接下来就是配置和增加功能，如阅读统计、加上评论和安装插件啥的，还有就是添加一些博客的基本信息，这些配置建议在写文章之前先折腾好。 基本功能配置大部分就是改两个文件，都叫_config.yml，文章的开头位置已告诉大家。我觉得与其将两个文件中的每点都分开来解释，倒不如直接将这两个文件贴出来，然后通过注释的方式告诉大家配置的方法，所以下面我会贴出这两个文件，怎么配置看注释就好了😄～ 选择主题不过还有一件事要先说一说，就是选择合适自己的主题，这是搭建好博客后最重要的一件事。默认的主题功能少，而且不太好看（个人感觉），而一些主题则有很多功能，也比较美观。 我选择的是 NexT（最新版），简洁且功能不少，也是在 GitHub 上被 Star 最多[2017.11.17]的一个 Hexo 主题。第二多的是 hexo-theme-yilia，第三多的是 hexo-theme-material（还有一个很棒的 Material Design 风格主题 hexo-theme-material-indigo），还有一个我感觉比较有特色的，叫 Cactus Dark，这几个我感觉都不错，可以点开链接看看长啥样。要是我上面说的还是没有合你胃口的😅，咋办？去 Hexo Themes 慢慢找。 至于换主题，很简单，我拿 NexT 主题举个栗子。首先在这个主题的 GitHub 页面的右上方复制链接，如下图： 然后： # 所在目录：~/blog/themes/ git clone https://github.com/theme-next/hexo-theme-next.git next 再在站点配置文件中修改成如下即可： # 文件位置：~/blog/_config.yml ## Themes: https://hexo.io/themes/ theme: next 站点配置文件请先查看 Hexo 官方文档，再查看下面我贴出的，如果这样后你还是对有些地方比较懵，可以自行 Google。如果你的文件中没有相关内容，请勿直接添加，且所有的:都为英文字符，它后面都有一个空格。 # [2017.11.14 更新] 文件位置：~/blog/_config.yml # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: reuixiy subtitle: Viva La Vida description: 易 象 辞 author: reuixiy language: zh-CN timezone: # URL url: https://reuixiy.github.io/ root: / # 博客文章的 URL 结构，请务必写文章之前就想好！ # 详细参数请查看：https://hexo.io/docs/permalinks.html # 当然最好不要参考我的，我的太不利于 SEO 了，除非…… permalink: :category/:year/:month/:day/:title.html permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true # 代码高亮设置 highlight: enable: true line_number: true # 代码自动高亮 auto_detect: true tab_replace: # 关于代码高亮的更多知识，可以查看本文 6.5.2 节 # Home page setting # path: Root path for your blogs index page. (default = &#39;&#39;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator: path: &#39;&#39; per_page: 10 order_by: -date # Category &amp; Tag default_category: uncategorized # URL 中的分类和标签「翻译」成英文 # 见：https://github.com/hexojs/hexo/issues/1162 category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination # 这个我有点懵，上面不是有啊…… per_page: 10 pagination_dir: page ## 修改归档页面、某一分类页面、某一标签页面的显示篇数 ## 参考：http://theme-next.iissnan.com/faqs.html#setting-page-size archive_generator: per_page: 0 yearly: false monthly: false daily: false category_generator: per_page: 0 tag_generator: per_page: 0 # Extensions ## Plugins: https://hexo.io/plugins/ # RSS，要先进入站点文件夹根目录安装插件 # npm install hexo-generator-feed --save 即可 # 无需更多配置 # 参数说明查看 README：https://github.com/hexojs/hexo-generator-feed feed: type: atom path: atom.xml # 文章数，0 为全部 limit: 0 hub: # 是否包含文章内容 content: true # emoji 支持，教程见本文 6.3 节 githubEmojis: enable: true idName: github-emoji unicode: false styles: localEmojis: ## Themes: https://hexo.io/themes/ # 主题配置 theme: next # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: https://github.com/reuixiy/reuixiy.github.io.git branch: master 主题配置文件如果你的主题不是 NexT，那么请另 Google。建议先查看 NexT 官方文档（最新版），写得很好，多逗留会没坏处。由于文件过长，为了保证文章阅读效果，我把文件放在了 GitHub。另外，我把我没有配置的差不多都删了，有问题可以多 Google。如果里面有些设置你还想进一步自定义，比如进一步自定义页脚文字的顺序，折腾完本文第 5 节你就会了😉。 动态背景 在主题配置文件中，靠后面，改canvas_nest: true，想要更改颜色和数量？修改文件： # 文件位置 ~/blog/themes/next/source/lib/canvas-nest/canvas-nest.min.js 怎么修改？参考 README。 注脚 在 Hexo 插件搜索footnotes，发现目前有两种插件，右边的可以实现鼠标放在上面悬浮显示注释的功能，但是亲测有一个 Bug，有时对页面宽度有影响，强迫症难以忍受。我安装的是左边的，先进入站点文件夹根目录，然后： # 所在目录：~/blog/ npm install hexo-footnotes --save 安装后按 README 的介绍的语法书写，应该就可以了。注意：注脚的内容一定要放在 Markdown 文档的最后面，否则可能会有错误。 优化 网页样式布局发现页面有大量留白？颜色不合自己口味？那就 F12 开始吧，大换装开始！空白区？颜色？背景？圆角矩形？阴影？透明度？超链接样式？侧栏头像圆形并旋转？文章标题前面的竖线和颜色？只需按下 F12，改到自己想要的样式，然后 Copy 到custom.styl文件即可。感觉这是 NexT 主题非常棒的设计，因为这让我们能够很方便自定义博客的样式。怎么知道要修改这个文件呢？强烈推荐阅读这篇文章。 怎么更改？浏览器按 F12 即可，建议用 Google Chrome 浏览器（有梯子的直接去 Google 下载😂），或者火狐浏览器。如果你按下 F12 后简直特么一脸懵逼，那么别急，硬着头皮慢慢折腾吧哈哈哈嗝～ bb - for - bb不管你信不信，其实博主就是这样直接折腾过来的，我之前没学过 HTML 和 CSS，所以当时按下 F12 真是一脸懵逼。我一开始是 Google（关键字：Hexo NexT 自定义）到上面那篇文章，一点进去，卧槽！侧栏终于不是清一色的默认黑色，激动！这位大佬怎么改的啊？这篇文章一定有吧😍！？然后看下去，果然有！然后眼睛先盯着贴的custom.styl，久久看着少数的注释，Copy 一段到自己的custom.styl，保存，然后hexo clean、hexo g、hexo s（当时我还不知道可以hexo s后可以直接本地调试😭），再去浏览器刷新自己的本地调试页面，看看效果。效果是有了，但是不是我想要的效果啊……于是去百度其中一行 CSS 代码，再回去慢慢删改调试……博主由懵逼到熟悉花了不少时间，但是我写这篇文章就是为了减少像我这样的小白折腾的时间，所以下面详细说明下按下 F12 后怎么快速由懵逼到熟悉！ 快速由懵逼到熟悉首先按下 F12 后的操作流程图，就是这篇文章中的三步骤，点小箭头定位元素，调试 CSS 代码，最后 Copy 到custom.styl。然后懵逼的地方，应该有下面两点： 按下 F12 后弹出的界面是什么鬼？！ 界面中的{}前面的和里面的英文是什么鬼？！ 第一点：弹出的界面是为调试设计的，如果你知道调试的是啥，也许就自然了解弹出的界面，所以我不多说，不过还是给一份 Google 官方的资料——Chrome 开发者工具。第二点：{}前面的是 HTML 的元素名，{}里面的是这个元素的 CSS 样式。 社交要先有自己原则，一段代码要先声明变量，一个数学问题有前提，一篇论文要先定义名词，到这里我们也必须要先了解一些 HTML 和 CSS 的基本语法知识了，才能继续折腾下去。建议先浏览下这篇文章，但没必要记住里面的每一个语法知识，因为这样的记忆是不够深刻也并不高效的，只要浏览下留个印象（为了能找准元素）就行，而记忆是要在实践中记忆的。 bb - for - fun实践？对！就是打开自己的本地调试页面，然后用你挑剔的眼光看看，哪里让你不爽，就按 F12，定位元素，最后调试，直到改到自己满意。这不是与一开始说的三步骤一样吗，为啥现在又说一遍？不不不，想想如果你点开一个俄文网站，然后我给你个这页面上的一个俄文链接的中文翻译，让你找到这个俄文链接并点开，你会不会懵逼呢……一样的，如果我没有让先你浏览 HTML 和 CSS 的基本语法知识，那么对网页中出现的东东大脑压根就「翻译」不成 HTML 和 CSS 代码（反之一样）。对 HTML 和 CSS 的语法定义不明，就可能会找不准元素，而找不准元素不仅可能达不到预期效果，还可能会产生一些新的 bugs，所以要先浏览上面那篇文章。这也是我这个小白走过的坑中，最大的一个了，花费了我不少时间在无意义的搜索上，想达到一个效果，但是不知道输入什么搜索关键字……最后，要熟练还是要多折腾……喵？！多折腾，说好的快速呢！？快速是要有对比的，我填了定义不明这个大坑，你按我说的操作，与我的慢折腾经历相比，你的折腾当然是快速。诡辩？好吧说实话也算是谎言，不过是个善意的谎言，只为给你一种神奇的能量——Hope，这种谎言在生活中很常见，但我的缺少一个目的——钱。 附上我的 custom.styl由于文件过长，为了保证文章阅读效果，我把文件放在了 GitHub。请先找对元素，不然可能会制造出新 bug，建议大家修改一个，就加个注释，方便以后调试修改。注意：一定是先 F12 找到要自定义的元素，调试成自己喜欢的值，然后再复制到custom.styl，而不是直接复制我给出的，我给出的仅供参考。 修改字体优化了这么多，但还有一个最影响博客形象和阅读体验的项没有优化，瓦特？字体！文章字体大小可以编辑： # 文件位置：~/blog/themes/next/source/css/_variables/base.styl $font-size-base = 16px 如果你是一个和我一样对字体一脸懵逼的人，推荐阅读： Web 中文字体排版指南 Web 字体的选择和运用 如何优雅的选择默认字体（font-family） 中文字体网页开发指南 在 Web 内容中使用系统字体 首先对于汉字来说，因为其字体库太大，通常都是调用本地中文字体库。然而，不同设备有不同默认中文字体和中文字体库，想要尽可能在不同设备上有较好的显示效果，就要在调用不同设备的本地字体库中显示效果较好的中文字体。下面附上我的供大家参考： # 文件位置：~/blog/themes/next/source/css/_variables/base.styl // Font families. $font-family-chinese = -apple-system, BlinkMacSystemFont, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;STHeiti&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Droid Sans Fallback&quot;, &quot;Microsoft YaHei&quot; $font-family-base = $font-family-chinese, sans-serif $font-family-base = get_font_family(&#39;global&#39;), $font-family-chinese, sans-serif if get_font_family(&#39;global&#39;) $font-family-logo = $font-family-base $font-family-logo = get_font_family(&#39;logo&#39;), $font-family-base if get_font_family(&#39;logo&#39;) $font-family-headings = $font-family-base $font-family-headings = get_font_family(&#39;headings&#39;), $font-family-base if get_font_family(&#39;headings&#39;) $font-family-posts = $font-family-base $font-family-posts = get_font_family(&#39;posts&#39;), $font-family-base if get_font_family(&#39;posts&#39;) $font-family-monospace = $font-family-chinese, monospace $font-family-monospace = Menlo, Monaco, Consolas, get_font_family(&#39;codes&#39;), $font-family-chinese, monospace if get_font_family(&#39;codes&#39;) 注意：要想 NexT 主题的简体中文字体配置生效，站点配置文件中的 language 必须为 zh-CN。然后对于英文字体，因为其字体库很小，所以想要个性化就简单多了。首先去 Google Fonts 找自己喜欢的英文字体，然后编辑主题配置文件，可以查看一下 NexT 官方文档（最新版）。下面附上我的供大家参考： # 文件位置：~/blog/themes/next/_config.yml font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) # 亲测这个可用，如果不可用，自己搜索 [Google 字体 国内镜像]，找个能用的就行 host: https://fonts.loli.net # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: Roboto Slab # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: Roboto Mono size: 注意：本博客的字体最新设置方法请看我的这篇文章。 进阶 高级功能配置这些功能的配置，大部分都要修改 NexT 主题的一些文件，所以git pull升级主题的时候，会比较麻烦，解决方法见本文 2.3.2 节。 大佬的文章更多如外挂一样的功能配置，就直接贴大佬的文章了，哪些功能自己喜欢，按照大佬的教程来配置就行。不过也有坑，比如有些功能（超链接样式、侧栏头像圆形并旋转）可以直接通过在custom.styl添加 CSS 代码实现，无需更改其它文件。 Hexo 高阶教程 NexT 主题优化 Hexo 的 NexT 主题个性化教程：打造炫酷网站 Hexo 搭建博客的个性化设置 第一篇文章内有 NexT 主题的文件目录说明，这对自己自定义博客有很大帮助。此外，大佬的博客可不仅仅有一篇文章，多在上面逗留会，也许会有甜品。 更改上一篇，下一篇的顺序进入一篇文章，在文章底部，有上下篇的链接（&lt; &gt;），但是点 &gt; 发现进入的是页面中的的上面那篇文章，与操作习惯不符，别扭。 我猜这是从时间角度设计的，&gt; 英语叫 next，而 next 是更新的。不过别扭就改成习惯的好了，从空间位置角度设计。[^1] 方法就是修改文件： # 文件位置：~/blog/themes/next/layout/_macro/post.swig {% if not is_index and (post.prev or post.next) %} - {% if post.next %} + {% if post.prev %} - + - {{ post.next.title }} + {{ post.prev.title }} {% endif %} &lt;/div&gt; &lt;span class=&quot;post-nav-divider&quot;&gt;&lt;/span&gt; &lt;div class=&quot;post-nav-prev post-nav-item&quot;&gt; - {% if post.prev %} + {% if post.next %} - + - {{ post.prev.title }} + {{ post.next.title }} {% endif %} &lt;/div&gt; &lt;/div&gt; {% endif %} 自己改单词请注意：是 prev 不是 perv，之前自己搞错了，然后盯着电脑屏幕尴尬半天，不停想特么老子哪里错了，怎么特么就是达不到效果！？？？ 移动端显示 back-to-top 按钮和侧栏今天更新一下 NexT 主题，发现已经添加这功能，前提是主题的设计模版是 Muse 或 Mist，然后可以直接在主题配置文件中配置： # 文件位置：~/blog/themes/next/_config.yml # Enable sidebar on narrow view onmobile: true 如果你发现你的主题配置文件_config.yml中没有这段内容，可以尝试按本文 2.3.1 节的方法更新主题。 博客推广及谷歌搜索优化（必读）想自己写的文章被别人看到？希望得到别人的评论肯定？渴望用自己写的文章照亮他人，给整个文明光能？那么这个就不可或缺了。你能看到这篇文章，很大程度上也是因为这个😏。 博客推广博客推广第一步，手动推广。你可以多浏览别人的博客并留下你的爪印（博客地址），比如评论；你可以去 README.md 中提到的这个 issue 留下你的爪印；你可以去 Issues（最新版）页面试着回答下大家的问题并留下你的爪印。 搜索引擎博客推广第二步，SEO（Search Engine Optimization）。搜索引擎是互联网上寻找资源的重要手段，而要让别人能够在搜索结果中看到自己的博客文章链接，就必须让搜索引擎收录，怎么操作呢？ 直接参考这篇文章，学会使用站长工具抓取自己的网页，然后请求搜索引擎收录。博主也是刚接触不久，不太懂，但推荐提交次数尽量多，而且每天尽量都提交一次。我没有弄百度的，只弄了 Google 的，但是前几天百度hexo next 优化（其它关键字没试），发现第一页就有自己文章，而且文章图片也在上面，很显眼，让我非常惊喜😆！ 看到链接是 SegmentFault 的，恍然大悟，原来是这个大佬推荐的，不仅帮我把此文推到了掘金，还有 SegmentFault，在此再次感谢大佬！这也给了一个启示，除了直接向搜索引擎提交自己的链接，还可以通过这种途径优化博客的 SEO。 间接影响另外，SEO 固然重要，但不要小看另一种影响，相比搜索引擎，这种可以称之为间接影响。这篇文章是一篇技术性的文章，而技术人员经常会用 Google，所以对这篇文章的浏览量，搜索引擎的功劳较大。但是，如果是其他的文章，比如一首诗，那么直接通过 Google 访问的读者几乎没有，那读者哪来？从其它文章上的读者「流」过来的。因为读者浏览着的不是一篇文章，而是一个博客。 而想让博客上的几乎不可能被 Google 的一首诗被浏览，就要这样间接拉读者了，可以称之「引流」。首先对博客上的每篇文章来说，肯定是读者花在自己博客的时间越长，被读到的可能性越大。这就意味着你要尽可能把用户留在自己的博客上，怎么留？ 博客要装饰好 文章质量要高 读者的第二印象是博客的界面，如果界面够特别，也许马上就被加入了书签。第三印象是文章内容，这其实更加重要，如果文章质量很高，那么读者肯定不会让这么好的一篇文章消失在自己的记忆中，即使界面不咋地。第一印象？加载速度，试想点开半天还是空白，那么肯定马上关了。 如果做到上面三点，那么就算好不容易「骗」到一个 Google 浏览量，但是这个读者马上被博客和文章惊呆了，看完文章后，这读者心里美滋滋，认为这么好的文章（博客）必须分享啊（如上面的大佬推荐🌚），于是可能马上来了一大批满怀期待的读者，然后这批读者又……这时文章的读者数（博客的访问量）就不是简单的加法了～ 知识平台直接或间接因为 Google 这样的搜索引擎而来的读者，绝大部分都是技术人员，而他们只希望尽快解决自己的技术问题，这也是他们的目的，这就意味着博客上的一首诗还是很难被欣赏。而要想照亮他人，他人必须要能懂自己的文章，这样也才可能有更强的交互——评论。所以为了不浪费自己的光能，能把自己的光能完完整整地贡献给文明，那就必须也让一首诗也有评论，怎么做呢？让读者的类型多样化，不限于技术人员。还好现在大部分读者也不用搜索引擎了，谁在吞食搜索引擎的用户？移动端。智能手机的迅速普及导致搜索引擎已经不是人们获取知识的主要途径，大部分人已经将手机 APP 上的知识平台作为自己获取知识的主要途径，比如：知乎、简书、微信订阅号……所以，你还可以将自己的文章发布在这些知识平台上的相应分类上，然后留个博客链接，吸引更多类型的读者😄～ 谷歌分析你怎么知道自己推广的效果？你怎么知道有没有人看了自己的博客？哪篇文章最受欢迎？此时有没有人正浏览着自己的博客？自己的文章有没有被引用？这时最常用的就是强大免费的 Google Analytics，推荐博客建好后，就立即使用。 如何使用？请务必自备梯子查看 Google 官方的教程，开始使用后一定要按照里面的设置，先添加多份 view（数据视图）。 ATTENTION：虽然有个复制 view 选项，但由 Google Analytics（分析）帮助中的具体复制内容再加上我的实践，发现（用我这个外行人的话来说）：复制 view 时只会复制它的相关配置，不会复制数据！所以请使用后立即按照官方教程中的方式添加 view！ 我们写文章，会在本地调试，这时 Google Analytics 也是会收集数据的，会影响数据分析，所以必须添加一个 filter（过滤器）。 ATTENTION：由 Google Analytics（分析）的工作原理可知，filter 是在数据处理时生效的（如上图），也就是说添加 filter 后只能过滤添加它之后的数据，而无法过滤添加它之前的数据（处理后），而 view 是利用处理后的数据生成的，所以要想去除自己在本地调试时的影响（在 view 中看不到自己在本地调试时的访问），请添加 view 之后就立即添加 filter！ 时间轴页面的年份分隔在 Archives（归档）页面，文章之间有年份分隔，而某一个 category 和 tag 的时间轴页面却没有。怎么办呢？修改两个文件，加代码即可😌～ category加到哪？要加两个位置： # 文件位置：~/blog/themes/next/layout/category.swig {% for post in page.posts %} 位置A {{ post_template.render(post) }} {% endfor %} . . .（省略好多行） . . 位置B（没错最后面） 加什么？绿色的自己看着加： # 文件位置：~/blog/themes/next/layout/category.swig # https://github.com/reuixiy/blog-files/blob/master/category.swig {% for post in page.posts %} + + {# Show year #} + {% set year %} + {% set post.year = date(post.date, 'YYYY') %} + + {% if post.year !== year %} + {% set year = post.year %} + + {{ year }} + + {% endif %} + {# endshow #} + {{ post_template.render(post) }} {% endfor %} . . .（省略好多行） . . +{% block script_extra %} + {% if theme.use_motion %} + + $('.archive-year').velocity('transition.slideLeftIn'); + + {% endif %} +{% endblock %} tag文件位置：~/blog/themes/next/layout/tag.swig，修改内容与 category 的完全一样。 说明两段代码直接 Copy 同目录下的 archive.swig 文件里面的，而且 tag.swig 和 category.swig 好像都预留了位置似的，代码小白的我折腾了半天，才改好😭😭😭，不知道写代码的大佬怎么想的w(ﾟДﾟ)w～ 文章底部加上评分小星星淘宝买东西，作为消费者的我们，看评价很重要。现在作为博主，写了一篇文章，很期待读者的反馈。而与淘宝一样，确认收货后，相比评论，更愿意五星好评。那么博客文章怎么加上呢？首先打开主题配置文件： # 文件位置：~/blog/themes/next/_config.yml # Star rating support to each article. # To get your ID visit https://widgetpack.com rating: enable: true id: color: f79533 先去注释中的网站，首页点 Rating，然后注册个帐号，填一下自己博客的信息，左上角有个 ID，填进主题配置文件中就行，color改成自己喜欢的即可。另： 1）可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device(cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。2）建议在侧栏 &gt; Site &gt; Setting 中勾选 Private 选项。3）上面两步勾选后别忘了点击页面右下方的 SAVE SETTING 绿色按钮保存。 如果感觉上下留白太多，咋整？浏览器 F12 找元素，调成自己喜欢的值，然后 Copy 到custom.styl即可，参考本文 4.2 节。经过上面的配置，默认最下面只会显示 5 颗小星星，简洁但不明了😂，怎么加上文字说明呢？编辑下面这个文件，Ctrl + F 搜索rating，找到这段，对比我给出的，在绿色这行所示的位置，加上自己想要的说明和样式即可。 # 文件位置：~/blog/themes/next/layout/_macro/post.swig {% if theme.rating.enable %} + (&gt;看完记得五星好评哦亲&lt;) {% endif %} 侧栏加入已运行的时间我们都有自己的生日，都知道自己的岁数，那为什么不给博客加上，让读者知道博客的年纪呢？操作很简单，而且不是精确到年而是精确到秒，233333～ 首先要加入下面代码：[^2] # 文件位置：~/blog/themes/next/layout/_custom/sidebar.swig &lt;div id=&quot;days&quot;&gt;&lt;/div&gt; &lt;script&gt; function show_date_time(){ window.setTimeout(&quot;show_date_time()&quot;, 1000); BirthDay=new Date(&quot;05/27/2017 15:13:14&quot;); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById(&#39;days&#39;).innerHTML=&quot;已运行 &quot;+daysold+&quot; 天 &quot;+hrsold+&quot; 小时 &quot;+minsold+&quot; 分 &quot;+seconds+&quot; 秒&quot;; } function setzero(i) { if (i&lt;10) { i=&quot;0&quot; + i }; return i; } show_date_time(); &lt;/script&gt; 上面Date的值记得改为你自己的，且按上面格式，然后修改： # 文件位置：~/blog/themes/next/layout/_macro/sidebar.swig {% if theme.links %} {{ theme.links_title }}&nbsp; {% for name, link in theme.links %} {{ name }} {% endfor %} + {% include '../_custom/sidebar.swig' %} {% endif %} - {% include '../_custom/sidebar.swig' %} 这样就可以了！当然，要是不喜欢颜色，感觉不好看，就可以在上文所提的custom.styl加入： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的侧栏时间样式 #days { display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px; } 里面的值 F12 调成自己喜欢的，然后更改即可。要是不想放在侧栏，想放在页脚，自己应该能折腾了吧😄～ 添加 TopX 页面博客已有的分类，如 categories 和 tags，都是基于博主的，那么有没有一种分类是基于读者的呢？有，一种是搜索，另一种就是这里的文章阅读量排行榜。前提是在主题配置文件中配置了 leancloud_visitors，配置方法见本文 3.3 节中我的主题配置文件中的教程链接。首先新建页面： # 所在目录：~/blog/ hexo new page &quot;top&quot; 然后在主题配置文件中加上菜单 top 和它的 icon： # 文件位置：~/blog/themes/next/_config.yml menu: top: /top/ || signal 接着在语言翻译文件中加上菜单 top： # 文件位置：~/blog/themes/next/languages/zh_Hans.yml menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 top: TopX /* 可以不为 TopX，随便取 */ 注意：如果你的站点配置文件中的 languages 写的不是 zh-CN，那么这里请更改相应语言配置文件。最后，编辑第一步新建页面生成的文件：[^3] # 文件位置：~/blog/source/top/index.md --- title: TopX /* 可以不为 TopX，随便取 */ comments: false keywords: top,文章阅读量排行榜 description: 博客文章阅读量排行榜 --- &lt;div id=&quot;top&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script&gt;AV.initialize(&quot;app_id&quot;, &quot;app_key&quot;);&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var time=0 var title=&quot;&quot; var url=&quot;&quot; var query = new AV.Query(&#39;Counter&#39;); query.notEqualTo(&#39;id&#39;,0); query.descending(&#39;time&#39;); query.limit(1000); query.find().then(function (todo) { for (var i=0;i&lt;1000;i++){ var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content=&quot;&lt;a href=&#39;&quot;+&quot;https://reuixiy.github.io&quot;+url+&quot;&#39;&gt;&quot;+title+&quot;&lt;/a&gt;&quot;+&quot;&lt;br /&gt;&quot;+&quot;&lt;font color=&#39;#555&#39;&gt;&quot;+&quot;阅读次数：&quot;+time+&quot;&lt;/font&gt;&quot;+&quot;&lt;br /&gt;&lt;br /&gt;&quot;; document.getElementById(&quot;top&quot;).innerHTML+=content } }, function (error) { console.log(&quot;error&quot;); }); &lt;/script&gt; &lt;style&gt;.post-description { display: none; }&lt;/style&gt; 必须将里面的里面的app_id和app_key替换为你的主题配置文件中的值，必须替换里面博客的链接，1000是显示文章的数量，其它可以自己看情况更改。最后，修改样式可以在custom.styl中加入自定义代码，参考本文 4.2 节。Okay！完成了！不过还有几点需要注意： 1）如果在设置 &gt; 安全中心中，没有将http://localhost:4000加入 Web 安全域名，那么本地调试将看不到，可以先将之加入，调试完后删除。2）如果你发现文章标题显示不对，这是由于更改过文章标题导致的，在存储 &gt; Counter 双击title修改即可。 另外，应该也可以按类似的方式，利用 JS 代码，将评分（rating）高╱多的文章，评论多的文章，也加入这个页面，不过现在博客的阅读量还不多，我暂时没折腾（其实也不太会）。如果你实现了，麻烦告诉我哦😘～ 注意：如果你的博客使用了 Valine 评论系统，那么可能会有代码冲突问题，解决方法见这篇文章。 利用 gulp 压缩代码右键查看网页源代码发现有大量留白，咋整？利用 gulp。首先任意目录全局安装：[^4] npm install gulp@3.9.1 -g 然后到站点文件夹根目录： # 所在目录：~/blog/ npm install gulp@3.9.1 gulp-minify-css gulp-htmlmin gulp-htmlclean --save 接着在站点文件夹根目录新建 gulpfile.js： # 文件位置：~/blog/gulpfile.js var gulp = require(&#39;gulp&#39;); var minifycss = require(&#39;gulp-minify-css&#39;); var htmlmin = require(&#39;gulp-htmlmin&#39;); var htmlclean = require(&#39;gulp-htmlclean&#39;); gulp.task(&#39;minify-css&#39;, function() { return gulp.src(&#39;./public/**/*.css&#39;) .pipe(minifycss()) .pipe(gulp.dest(&#39;./public&#39;)) }); gulp.task(&#39;minify-html&#39;, function() { return gulp.src(&#39;./public/**/*.html&#39;) .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true })) .pipe(gulp.dest(&#39;./public&#39;)) }); gulp.task(&#39;default&#39;, [&#39;minify-html&#39;, &#39;minify-css&#39;]); 最后部署到 GitHub Pages 上查看效果： # 所在目录：~/blog/ hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 我没有压缩 JavaScript，因为我发现会报错，实际也并不需要，因为大部分 JavaScript 都已压缩过。这里的这段代码执行 gulp 后也不支持hexo s本地调试，记得在哪看过解决方法，需要的自己 Google。另外，可能会产生一些奇怪的 bugs，没看到最好，要是看到了的话就自己解决吧～（逃…… 让页脚的心跳动起来世界上有一种伟大的力量，它的名字无人不晓，就是——❤～ 首先编辑主题配置文件： # 文件位置：~/blog/themes/next/_config.yml footer: - icon: user + icon: heart 然后编辑： # 文件位置：~/blog/themes/next/layout/_partials/footer.swig - &lt;span class=&quot;with-love&quot;&gt; + &lt;span class=&quot;with-love&quot; id=&quot;heart&quot;&gt; 接着编辑custom.styl，加入： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义页脚跳动的心样式 @keyframes heartAnimate { 0%,100%{transform:scale(1);} 10%,30%{transform:scale(0.9);} 20%,40%,60%,80%{transform:scale(1.1);} 50%,70%{transform:scale(1.1);} } #heart { animation: heartAnimate 1.33s ease-in-out infinite; } .with-love { color: rgb(255, 113, 168); } color的值可以改成你自己喜欢的，灵感来自 DIYgod 大佬的博客，CSS 代码参考这篇文章。 注意：最新版本的主题已支持，无需添加代码，直接设置animated即可。 页脚加上微信二维码主题默认的微信订阅个人感觉不美观，看到很多网站都是在页脚有个微信的 LOGO，然后鼠标移动到上面便会显示二维码，这样感觉很棒。 首先编辑文件，在文件最后加上下面代码： # 文件位置：~/blog/themes/next/layout/_partials/footer.swig &lt;div class=&quot;weixin-box&quot;&gt; &lt;div class=&quot;weixin-menu&quot;&gt; &lt;div class=&quot;weixin-hover&quot;&gt; &lt;div class=&quot;weixin-description&quot;&gt;微信扫一扫，订阅本博客&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 然后编辑custom.styl，加入： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的页脚微信订阅号样式 .weixin-box { position: absolute; bottom: 43px; left: 10px; border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35); } .weixin-menu { position: relative; height: 24px; width: 24px; cursor: pointer; background: url(https://微信的logo.svg); background-size: 24px 24px; } .weixin-hover { position: absolute; bottom: 0px; left: 0px; height: 0px; width: 0px; border-radius: 3px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background: url(https://二维码.svg); background-color: #fff; background-repeat: no-repeat; background-size: 150px 150px; transition: all 0.35s ease-in-out; z-index: 1024; opacity: 0; } .weixin-menu:hover .weixin-hover { bottom: 24px; left: 24px; height: 170px; width: 150px; opacity: 1; } .weixin-description { opacity: 0; position: absolute; bottom: 3%; left: 5%; right: 5%; font-size: 12px; transition: all 0.35s cubic-bezier(1, 0, 0, 1); } .weixin-menu:hover .weixin-description { opacity: 1; } 图片务必用矢量图 SVG 格式，否则手机上显示效果很差，其它的自己看情况更改。微信 LOGO 的图片我准备好了，点击下载 wechat.svg (1.6KB)。微信订阅号的二维码怎么弄成 SVG 格式呢，安利个网站，下载 SVG 格式的就行。最后，我参考了这个代码。 更改标签云（tagcloud）的颜色如果你和我一样个性化了博客的整体布局颜色，那么默认的标签云页面可能看起来很丑，怎么更改？修改下文件： # 文件位置：~/blog/themes/next/layout/page.swig {{ tagcloud({min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'}) }} 修改对应参数值即可，参数说明见 Hexo 官方文档，颜色可以参考这个网站，自己去纠结…… 点击侧栏头像回到博客首页不知道为什么，我看到侧栏头像的第一反应是点击，然后心理预期会跳到博客首页，可惜也仅是预期，那么开始动手吧～首先要在主题配置文件中配置好，比如我把头像avatar.gif放在~/blog/source/uploads/下，则： # 文件位置：~/blog/themes/next/_config.yml # Sidebar Avatar # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif -#avatar: /images/avatar.gif +avatar: /uploads/avatar.gif 然后编辑文件： # 文件位置：~/blog/themes/next/layout/_macro/sidebar.swig + &lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;{{ url_for( theme.avatar | default(theme.images + '/avatar.gif') ) }}&quot; alt=&quot;{{ theme.author }}&quot; /&gt; + &lt;/a&gt; 文章摘要图片俗话说：「图文并茂」，现实中用笔书写文章实现起来比较困难，但在博客上可以很轻松实现😎。首先，文章摘要（excerpt）是指每篇文章（post）在页面（page）上显示的那部分内容，也就是 [Read More] 之前的文章内容。由于它会展示在页面，因此在每篇文章的文章摘要中加一张图片，页面看起来就很美观。但是有时候可能会出现一个问题：你想从文章中选一张图片作为文章摘要图片，而这张图片由于写作要求，必须添加在文章的末尾，这样点 [Read More] 查看文章时，这张图片就会重复出现了。咋办？ 前提是在主题配置文件中： # 文件位置：~/blog/themes/next/_config.yml excerpt_description: false auto_excerpt: enable: false 首先加代码： # 文件位置：~/blog/themes/next/layout/_macro/post.swig {% if is_index %} {% if post.description and theme.excerpt_description %} {{ post.description }} {{ __('post.read_more') }} &raquo; {% elif post.excerpt %} {{ post.excerpt }} + + {% if post.image %} + + + + {% endif %} + &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;{{ url_for(post.path) }}{% if theme.scroll_to_more %}#{{ __('post.more') }}{% endif %}&quot; rel=&quot;contents&quot;&gt; {{ __('post.read_more') }} &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; 为了防止有的图片宽度不够导致风格不够统一，页面不美观，需要在custom.styl中加入： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的文章摘要图片样式 img.img-topic { width: 100%; } 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： image: url url即图片的链接地址～ 参考： issue：https://github.com/iissnan/hexo-theme-next/issues/1190 文章：http://wellliu.com/2016/12/30/【转】Blog摘要配图/ 文章置顶由于博客的首页可能是被浏览最多的页面，所以首页的前几篇文章被阅读的可能性比较大。可以利用这个特点，通过将自己认为重要的文章放在首页，从而让重要的文章被阅读的可能性增大😄。但是，默认的排序只有一个维度——时间，两种选择——正序和倒序，这就造成自己的得意之作被埋没了，怎么办呢，如何实现文章的置顶？ NexT 主题以前有过这个功能，然而由于一些 bugs（issue）被去掉了。不过在这个丰富的 issue 中，我自己摸索出了一种解决方法，参考了 issue 中的那篇文章。 首先移除默认安装的插件： # 所在目录：~/blog/ npm uninstall hexo-generator-index --save 然后安装新插件： # 所在目录：~/blog/ npm install hexo-generator-index-pin-top --save 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： top: true 然后就行了。如果你置顶了多篇，怎么控制顺序呢？设置top的值（大的在前面），比如： # Post a.md title: a top: 1 # Post b.md title: b top: 10 那么文章 b 便会显示在文章 a 的前面。可是，没有任何标记啊，读者怎么知道文章置顶了😂～还好 NexT 原有的置顶功能有考虑到这个，且置顶的样式没有被移除，所以可以直接利用，编辑文件： # 文件位置：~/blog/node_modules/hexo-generator-index-pin-top/lib/generator.js &#39;use strict&#39;; var pagination = require(&#39;hexo-pagination&#39;); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.sticky &amp;&amp; b.sticky) { // 两篇文章sticky都有定义 if(a.sticky == b.sticky) return b.date - a.date; // 若sticky值一样则按照文章日期降序排 else return b.sticky - a.sticky; // 否则按照sticky值降序排 } else if(a.sticky &amp;&amp; !b.sticky) { // 以下是只有一篇文章sticky有定义，那么将有sticky的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.sticky &amp;&amp; b.sticky) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || &#39;page&#39;; return pagination(&#39;&#39;, posts, { perPage: config.index_generator.per_page, layout: [&#39;index&#39;, &#39;archive&#39;], format: paginationDir + &#39;/%d/&#39;, data: { __index: true } }); }; 也就是将插件的top全部替换为 NexT 原有的sticky，然后将Front-matter中的top替换为sticky，就能调用 NexT 主题原有的置顶样式了。 最后可以自定义一下样式： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的文章置顶样式 .post-sticky-flag { font-size: inherit; float: left; color: rgb(0, 0, 0); cursor: help; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .post-sticky-flag:hover { color: #07b39b; } 已发现的 bug：新安装的插件无法实现站点配置文件中order_by: date，即文章按时间从旧到新排列的配置，也就意味着文章只能按默认的时间从新到旧排列。 背景图片1）CSS # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 背景图片 body::before { background-image: url(https://背景图.jpg); background-repeat: no-repeat; background-size: cover; background-position: 50% 50%; content: &quot; &quot;; position: fixed; width: 100%; height: 100%; top: 0; left: 0; z-index: -2; } 2）jquery-backstretch # 文件位置：~/blog/themes/next/layout/_layout.swig + &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js&quot;&gt;&lt;/script&gt; + &lt;script&gt; + $(&quot;body&quot;).backstretch(&quot;https://背景图.jpg&quot;); + &lt;/script&gt; &lt;/body&gt; 加入到文件最后面&lt;/body&gt;前面即可。你可以浏览器按 F12 查看我的页面，就可以在&lt;/body&gt;前发现。幻灯片等更多用法请自行查看 GitHub 上的 README。 动态效果可以在主题配置文件_config.yml里的motion中配置，但是如果你和我一样更改了博客的背景色，可能不能达到很好的效果，怎么办呢？参考这里，修改下面两个文件的相应内容。 ~/blog/themes/next/source/css/_common/components/post/post.styl ~/blog/themes/next/source/js/src/motion.js 相关╱热门╱推荐文章https://io-oi.me/tech/related-popular-recommended-posts.html MathJax 的静态显示（svg）https://io-oi.me/tech/hexo-mathjax-svg.html 加速 Hexo 博客https://io-oi.me/tech/speed-up-hexo.html 往归档页面加入 12 生肖https://io-oi.me/tech/add-chinese-zodiac-to-next.html 进阶 写出优雅文章博客搭好了，只能说有个漂亮的外壳，内容丰富且颜值高的文章才是真正的精华。文章内容只能靠自己，不过这里教你几招提高文章颜值的方法。写文章前请先查看 Hexo 官方文档之写作，写得很棒！ 文章的模版文件如果你是在站点文件夹根目录用hexo new post &lt;title&gt;新建的文章，那么其实它就是将文章的模版文件post.md「复制」了一份到~/blog/source/_posts/下，所以这也意味着： 你可以直接通过在~/blog/source/_posts/下新建.md结尾的文件来写新的文章。 你可以通过自定义文章的模版文件，从而每次命令行新建的文章都会有你自定义的内容。 注意：如果自己直接新建文件，一定要记得加上文件最上方的参数，即下面的相关内容，还有编码请用 UTF-8。 关于文件最上方的参数，参见 Hexo 官方文档的 Front-matter 和页面变量，下面是我的总结： /* ！！！！！！！！！！ ** 每一项的 : 后面均有一个空格 ** 且 : 为英文符号 ** ！！！！！！！！！！ */ title: /* 文章标题，可以为中文 */ date: /* 建立日期，如果自己手动添加，请按固定格式 ** 就算不写，页面每篇文章顶部的发表于……也能显示 ** 只要在主题配置文件中，配置了 created_at 就行 ** 那为什么还要自己加上？ ** 自定义文章发布的时间 */ updated: /* 更新日期，其它与上面的建立日期类似 ** 不过在页面每篇文章顶部，是更新于…… ** 在主题配置文件中，是 updated_at */ permalink: /* 若站点配置文件下的 permalink 配置了 title ** 则可以替换文章 URL 里面的 title（文章标题） */ categories: /* 分类，支持多级，比如： - technology - computer - computer-aided-art 则为 technology/computer/computer-aided-art （不适用于 layout: page） */ tags: /* 标签 ** 多个可以这样写 [标签1,标签2,标签3] ** （不适用于 layout: page） */ description: /* 文章的描述，在每篇文章标题下方显示 ** 并且作为网页的 description 元数据 ** 如果不写，则自动取 &lt;!-- more --&gt; ** 之前的文字作为网页的 description 元数据 */ keywords: /* 关键字，并且作为网页的 keywords 元数据 ** 如果不写，则自动取 tags 里的项 ** 作为网页的 keywords 元数据 */ comments: /* 是否开启评论 ** 默认值是 true ** 要关闭写 false */ layout: /* 页面布局，默认值是 post，默认值可以在 ** 站点配置文件中修改 default_layout ** 另：404 页面可能用到，将其值改为 false */ type: /* categories，目录页面 ** tags，标签页面 ** picture，用来生成 group-pictures ** quote？ ** https://io-oi.me/tech/test.html */ photos: /* Gallery support，用来支持画廊╱相册，用法如下： - photo_url_1 - photo_url_2 - photo_url_3 https://io-oi.me/tech/test.html */ link: /* 文章的外部链接 ** https://io-oi.me/tech/test.html */ image: /* 自定义的文章摘要图片，只在页面展示，文章内消失 ** 此项只有参考本文 5.14 节配置好，否则请勿添加！ */ sticky: /* 文章置顶 ** 此项只有参考本文 5.15 节配置好，否则请勿添加！ */ password: /* 文章密码，此项只有参考教程： ** http://shenzekun.cn/hexo的next主题个性化配置教程.html ** 第 24 节，配置好，否则请勿添加！ ** 发现还是有 bug 的，就是右键在新标签中打开 ** 然后无论是否输入密码，都能看到内容 */ 灵活利用 permalink，如果你是一个和我一样希望文章 URL 中不会出现中文的人。 使用 Markdown（必读）用 Hexo 写文章是直接用 Markdown 写的，而不是像 WordPress 有一个类似 Word 一样的文字编辑器，所以第一次用会感觉有点难，但你熟练之后，就会觉得文字编辑器都是辣鸡🌚… Markdown 简介Markdown 的目标是实现「易读易写」。 不过最需要强调的便是它的可读性。一份使用 Markdown 格式撰写的文件应该可以直接以纯文字发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大灵感来源其实是纯文字的电子邮件格式。 因此 Markdown 的语法全由标点符号所组成，并经过严谨慎选，是为了让它们看起来就像所要表达的意思。像是在文字两旁加上星号，看起来就像强调。Markdown 的清单看起来，嗯，就是清单。假如你有使用过电子邮件，区块引言看起来就真的像是引用一段文字。[^5] Markdown 教程这是写文章必须掌握的技能哦，一开始可能比较懵，因为大脑没有相关概念，无法将 Markdown 语法「翻译」成相应样式，不过多写几篇就好啦🙊。 Markdown 语法说明 Markdown 教程 我个人的总结1）文章内标题请从二级标题（##）开始！2）英语单词、数字左右看情况加上空格！3）Markdwon 文档写完一段回车后务必再回车一次空一行！ 如何使用 emoji在这个表情横行的时代，使用 emoji 似乎已经是日常。之前一直搜索相关插件，安装了很多，但都失败了。后来发现，直接 Copy &amp; Paste 就能用😆，可以去这个网站 Copy。但是有个缺点，就是不同系统，不同浏览器，渲染的效果不同，有些甚至不能显示。为什么呢？因为这种方法 Copy 的是 Unicode，因此显示时有上面这个缺点，但是我们也可以直接调用图片，保证显示效果一致。另：无论主题配置文件中的 fancybox 的值是 true 还是 false，对下面这种方法都没太大影响✌。 首先安装插件： # 所在目录：~/blog/ npm install hexo-filter-github-emojis --save 然后在站点配置文件的适当位置中加入： # 文件位置：~/blog/_config.yml githubEmojis: enable: true - className: github-emoji + idName: github-emoji unicode: false styles: localEmojis: 没错，加入的是idName这行而非className这行，为什么我要这样写？因为要编辑文件： Ctrl + F 搜索class，全部替换为id。 Ctrl + F 搜索title，更改相关代码，如下： # 文件位置：~/blog/node_modules/hexo-filter-github-emojis/index.js var codepoints = emojis[emojiName].codepoints if (options.unicode &amp;&amp; codepoints) { codepoints = codepoints.map(function (code) { return &#39;&amp;#x&#39; + code + &#39;;&#39; }).join(&#39;&#39;) return &#39;&lt;span id=&quot;&#39; + options.idName + &#39;&quot; &#39; + styles + - &#39; title=&quot;&#39; + emojiName + - &#39;&quot; data-src=&quot;&#39; + emojis[emojiName].src + + &#39; data-src=&quot;&#39; + emojis[emojiName].src + &#39;&quot;&gt;&#39; + codepoints + &#39;&lt;/span&gt;&#39; } else { return &#39;&lt;img id=&quot;&#39; + options.idName + &#39;&quot; &#39; + styles + - &#39; title=&quot;&#39; + emojiName + &#39;&quot; alt=&quot;&#39; + emojiName + &#39;&quot; src=&quot;&#39; + + &#39; alt=&quot;&#39; + emojiName + &#39;&quot; src=&quot;&#39; + emojis[emojiName].src + &#39;&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;&#39; } 由于 NexT 主题的相关样式会干扰 emoji 图片的显示效果，所以要在custom.styl中加代码： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl /* 里面的 color 值请改为你博客的！ */ // 自定义emoji样式 img#github-emoji { margin: 0px; padding: 0px; display: inline !important; vertical-align: text-bottom; border: none; cursor: text; box-shadow: none; } // 文章超链接样式（为emoji特设） .post-body a { color: rgb(80, 115, 184); border-bottom: none; text-decoration: underline; } .post-body a:hover { color: rgb(161, 102, 171); border-bottom: none; text-decoration: underline; } // 标签云页面超链接样式（为emoji特设） .tag-cloud a { color: rgb(80, 115, 184); border-bottom: 1px solid rgb(80, 115, 184); text-decoration: none; } .tag-cloud a:hover { color: rgb(161, 102, 171); border-bottom: 1px solid rgb(161, 102, 171); text-decoration: none; } // 文章元数据中categories的样式（为emoji特设） a.categories { color: rgb(80, 115, 184); border-bottom: none; text-decoration: underline; } a.categories:hover { color: rgb(161, 102, 171); border-bottom: none; text-decoration: underline; } // tabs标签（为emoji特设） .post-body .tabs ul.nav-tabs li.tab a { text-decoration: none; } // 图片下方标题设置（为emoji特设） a.fancybox{ text-decoration: none !important; } // 按钮样式（为emoji特设） .btn { color: #fff !important; text-decoration: none !important; border: 2px solid #222 !important; } .btn:hover { color: #222 !important; } 然后直接去 Emoji Cheat Sheet 点一下自己想要的表情复制，再粘贴到自己的文章中即可👻～而且用途不止于 emoji，手机里的各种表情包，传到自己的云存储，然后按照插件 README 中的写法： &lt;img id=&quot;github-emoji&quot; src=&quot;https://表情包.gif&quot; height=&quot;30&quot; width=&quot;30&quot; /&gt; 改下 URL，看情况改下 height 和 width 的值即可啦，GIF 也可以哦～当然，还有萌即正义的颜文字 (ﾉ*･ω･)ﾉ～ 问题 解答 调用的是哪里的 emoji 图片？ 由这个插件的 README 可知，调用 GitHub 的 API，写法也是按照 GitHub 的😉～ 为什么要将插件源码里的class改为id？ 按下 F12 可看到，开启 fancyBox 后，NexT 会为默认的图片标签（img）加上一个fancybox的class，里面有一个样式：display: block !important;，因为我们要让 emoji 显示在文字之间（display: inline;），但是由于默认的class已经加了!important，所以必须用样式规则的应用优先权高于class的id。 为什么要删除插件源码里的title？ 因为开启 fancyBox 后，NexT 会将图片的title显示在图片下方，显然不满足 emoji 的显示要求。 为什么要修改.post-body a的样式？ 因为开启 fancyBox 后，NexT 会将图片标签包裹在一个a标签内，而a标签是有下划线的，emoji 下面竟然有根线？显然不满足要求。 加进custom.styl的其它一大堆代码是什么鬼？ 补 bugs😑… 插入音乐和视频音乐的话，网易云音乐的外链很好用，不仅有可以单曲，还能有歌单，有兴趣的自己去网易云音乐找首歌尝试。但是有一些音乐因为版权原因放不了，还有就是不完全支持 https，导致小绿锁不见了。要解决这些缺点，就需要安装插件👽。 音乐1）直接用 HTML 的标签，写法如下： &lt;audio src=&quot;https://什么什么什么.mp3&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt; 2）用插件，有显示歌词功能，也美观。首先在站点文件夹根目录安装插件： # 所在目录：~/blog/ npm install hexo-tag-aplayer --save 然后文章中的写法： {% aplayer \"歌曲名\" \"歌手名\" \"https://什么什么什么.mp3\" \"https://封面图.jpg\" \"lrc:https://歌词.lrc\" %} 另外可以支持歌单： {% aplayerlist %} { \"autoplay\": false, \"showlrc\": 3, \"mutex\": true, \"music\": [ { \"title\": \"歌曲名\", \"author\": \"歌手名\", \"url\": \"https://什么什么什么.mp3\", \"pic\": \"https://封面图.jpg\", \"lrc\": \"https://歌词.lrc\" }, { \"title\": \"歌曲名\", \"author\": \"歌手名\", \"url\": \"https://什么什么什么.mp3\", \"pic\": \"https://封面图.jpg\", \"lrc\": \"https://歌词.lrc\" } ] } {% endaplayerlist %} 里面的详细参数见 README 和这插件的「母亲」Aplayer 的官方文档。关于 LRC歌词，可以用工具下载网易云音乐的歌词，另发现暂时不支持offset参数。当然，如果那歌词很操蛋，有错误（比如字母大小写和标点符号乱加）或者时间完全对不上，然后你也和我一样是个完美主义者，那接下来就是令人窒息的操作了，一句一句自己查看修改…… 什么，你想把网易云的几百首歌手动同步到博客😨？慢慢慢，有一种非常简单的方法，此这种方法也支持单曲，将参数里的playlist更改为song即可，非常建议食用！更多功能请仔细阅读 README。 视频1）直接用 HTML 的标签，写法如下： &lt;video poster=&quot;https://封面图.jpg&quot; src=&quot;https://什么什么什么.mp4&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 2）用插件，可支持弹幕，首先在站点文件夹根目录安装插件： # 所在目录：~/blog/ npm install hexo-tag-dplayer --save 然后文章中的写法： {% dplayer \"url=https://什么什么什么.mp4\" \"https://封面图.jpg\" \"api=https://api.prprpr.me/dplayer/\" \"id=\" \"loop=false\" %} 要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字😂生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。 当然，这个插件的功能还有很多，可以去 README 和这插件的「母亲」Dplayer 的官方文档看看。 好玩的写作样式用一些特殊的样式，可以增加文章的可读性。不过也不是越多越好，没必要写一篇文章就把下面的样式全部用一遍，这样只会适得其反，从下面的样式中选几个自己觉得比较好的、经常会用的就行。而且写博客重点是文章的文字内容，而不是这些样式，样式只是为了让文章更美观，更适合阅读。这和我们用 Markdown 写文章是一样的道理，用 Markdown 而不是直接写 HTML 代码，就是为了将更多时间花在文字上🐒。 主题自带样式 代码块高亮先看效果： # Java # 代码来自这：https://highlightjs.org/static/demo/ /** * @author John Smith &lt;john.smith@example.com&gt; */ package l2f.gameserver.model; public abstract class L2Char extends L2Object { public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) { _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) { // wtf!? return; } } } 这里指的是```代码块，而不是行内代码块（`代码`），它的用法如下： ```[language] [title] [url] [link-text] 代码 ``` [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]。 首先关于代码块颜色高亮，高亮的模式可以在主题配置文件中设置： # Code Highlight theme # Available value: # normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal 要颜色正确高亮，代码语言的名称肯定要写对，各种支持语言的名称可以查看这篇文章。当然，如果你和我一样懒，可以在站点配置文件_config.yml中设置自动高亮： # 文件位置：~/blog/_config.yml highlight: enable: true line_number: true # 代码自动高亮 - auto_detect: false + auto_detect: true 咦？发现了什么没有😳，红色-和绿色+的样式哪来的？哈哈哈，原来这也是一种语言，叫diff，所以你只需在 [language] 这写diff，然后在相应代码前面加上-和+就行了。 当然，要是你不满意顶部的文字样式，也可以自己在custom.styl自定义： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 文章```代码块顶部样式 .highlight figcaption { margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9; } .highlight figcaption a { color: rgb(80, 115, 184); } 参考了 Hexo 官方文档的标签插件页面，这个页面还有更多的 Hexo 标签插件（Tag Plugins）的用法，请自行查看。 主题自带样式 各种标签https://theme-next.org/docs/tag-plugins/ 自定义样式 数字块由于是自定义的样式，故要自己将 CSS 代码加到custom.styl中。为什么可以自定义呢？如果你是一个和我一样的小白，可以点击这里了解了解 CSS 中id和class的知识。 需加入custom.styl的代码： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的数字块 span#inline-toc { display: inline-block; border-radius: 80% 100% 90% 20%; background-color: rgb(227, 242, 253); color: #555; padding: 0.05em 0.4em; margin: 2px 5px 2px 0px; line-height: 1.5; } 使用： &lt;span id=&quot;inline-toc&quot;&gt;1.&lt;/span&gt; 参考：https://qianling.pw/style/#TOC数字块 结尾其实写这篇文章时，犯了一个很大的错误，把定制（customization）写成了优化（optimization），本文的内容都是个性化的定制，而非优化🌚… 然后毕竟只是小白，本文如有错误，欢迎评论指出～也欢迎你把这篇文章加入收藏夹，毕竟 NexT 主题一直在更新，会有一些新的功能和配置，这篇文章自然也会一直保持更新😄～ 不知道这篇文章有木有照亮你呢？为修改这篇文章博主光通宵就来了两次，如果你觉得这篇文章很赞，欢迎分享本文给更多像我一样的小白看到！感谢😘φ(≧ω≦*)♪～ 最后如果引用本文的内容，麻烦留个本文的链接，因为如果读者或我自己发现文章有错误，我会在这里更正，留个本文的链接，防止我暂时的疏漏耽误了他人宝贵的时间。 [^1]: https://github.com/ahonn/hexo-theme-even/issues/69↑[^2]: http://lovekernel.com/2017/hexo博客构建笔记/↑[^3]: http://lovekernel.com/2017/hexo博客构建笔记/↑[^4]: https://leaferx.online/2017/06/16/use-gulp-to-minimize/↑[^5]: http://markdown.tw/↑","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"转载","slug":"转载","permalink":"https://www.xiongtianci.com/categories/转载/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.xiongtianci.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.xiongtianci.com/tags/博客/"},{"name":"Pages","slug":"Pages","permalink":"https://www.xiongtianci.com/tags/Pages/"}],"author":"天赐"},{"title":"git push报错：The current branch master has no upstream branch","slug":"git-push报错：The-current-branch-master-has-no-upstream-branch","date":"2019-06-12T06:22:18.000Z","updated":"2019-06-18T08:52:09.420Z","comments":true,"path":"2019/06/12/git-push报错：The-current-branch-master-has-no-upstream-branch/","link":"","permalink":"https://www.xiongtianci.com/2019/06/12/git-push报错：The-current-branch-master-has-no-upstream-branch/","excerpt":"","text":"问题进行git push操作时报错：fatal: The current branch master has no upstream branch. 原因：没有将本地的分支与远程仓库的分支进行关联通过git branch查看本地分支只有master 通过git branch -a查看远程分支，有master和remotes/origin/master两个 这时由于远程仓库太多，且分支较多。在默认情况下，git push时一般会上传到origin下的master分支上，然而当repository和branch过多，而又没有设置关联时，git就会产生疑问，因为它无法判断你的push目标 解决方式一使用git push --set-upstream origin master命令 方式二使用git push -u origin master命令","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"},{"name":"Git","slug":"Git","permalink":"https://www.xiongtianci.com/tags/Git/"}],"author":"天赐"},{"title":"hexo常用命名汇总","slug":"hexo常用命名汇总","date":"2019-06-12T01:32:47.000Z","updated":"2019-06-20T09:15:32.085Z","comments":true,"path":"2019/06/12/hexo常用命名汇总/","link":"","permalink":"https://www.xiongtianci.com/2019/06/12/hexo常用命名汇总/","excerpt":"","text":"# 新建文章 hexo n # 清除缓存 hexo clean # 生成静态页面+部署 hexo d -g # 等同：hexo g &amp;&amp; hexo d # 生成静态网页 hexo g # 部署 hexo d # 启动服务器预览 hexo s 建站# 安装hexo npm install hexo -g # 升级hexo npm update hexo -g # hexo初始化 hexo init # 查看node.js版本号 node -v # 查看npm版本号 npm -v # 查看git版本号 git --version # 查看hexo版本号 hexo -v 插件安装和卸载# 安装插件 npm install hexo-xxx-xxx --save # 卸载插件 npm uninstall hexo-xxx-xxx --save 指令简写 指令 简写 描述 hexo new hexo n 新建文章 hexo generate hexo g 生成静态文件 hexo deploy hexo d 部署 hexo server hexo s 启动服务预览 hexo publish hexo p 发表草稿 注: hexo clean 没有简写, git --version 没有简写 init# 新建一个网站 $ hexo init [folder] 如果没有设置folder，Hexo默认在当前文件夹建立网站 new# 新建一篇文章,文章名称和标题为 [title],文章采用 [layout] 布局 $ hexo new [layout] &lt;title&gt; 会在目录source/_posts下生成 [title].md 文件，[title].md文件的顶部会使用---分割区域，也称作Front matter区如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替（一般默认是post）。如果标题包含空格的话，请使用引号括起来。 # eg $ hexo new &quot;post title with whitespace&quot; generate# 生成静态文件 $ hexo generate $ hexo g 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将/blog/source/下面的.md后缀的文件编译为.html后缀的文件,存放在/blog/public/路径下 publish# 发表草稿 $ hexo publish [layout] &lt;filename&gt; hexo publish [layout] &lt;title&gt; 通过 publish 命令将草稿移动到 source/_posts 文件夹如:$ hexo publish [layout] &lt;title&gt;，草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 server# 启动服务器（常用于调试） $ hexo server $ hexo s 默认情况下，访问网址为： http://localhost:4000/。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。 选项 描述 eg -p, --port 重设端口 hexo s -p 5000 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 -i 自定义IP hexo s -i 192.168.1.1 deploy# 部署网站,将本地数据部署到远端服务器(如github、coding) $ hexo deploy $ hexo d 参数 描述 -g, --generate 部署之前预先生成静态文件 render# 渲染文件 $ hexo render &lt;file1&gt; [file2] ... 参数 描述 -o, --output 设置输出路径 migrate$ hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean# 清除缓存,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 $ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list# 列出网站资料 $ hexo list &lt;type&gt; version# 显示 Hexo 版本 $ hexo version 选项安全模式$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式$ hexo --silent 隐藏终端信息。 自定义配置文件的路径$ hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD$ hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。 参考 hexo官方文档 hexo常用命令笔记","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.xiongtianci.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.xiongtianci.com/tags/博客/"}],"author":"天赐"},{"title":"git常用命名汇总","slug":"git常用命名汇总","date":"2019-06-12T01:24:41.000Z","updated":"2019-06-18T08:52:02.470Z","comments":true,"path":"2019/06/12/git常用命名汇总/","link":"","permalink":"https://www.xiongtianci.com/2019/06/12/git常用命名汇总/","excerpt":"","text":"常用将本地项目初始化# $ git init # 给项目添加远程仓库 $ git remote add origin git@github.xxx.git # 本地分支和远程分支建立联系(使用git branch -vv 可以查看本地分支和远程分支的关联关系) $ git branch --set-upstream-to=origin/远程分支 本地分支 查看 # 查看工作目录和暂存区的状态 $ git status # 查看工作区与暂存区的差异 $ git diff # 查看提交历史 $ git log # 查看命令历史 $ git reflog # ----分支 # 查看git本地分支 $ git branch # 查看git远程分支 $ git branch -r # 查看所有本地分支和远程分支，远程分支为红色 $ git branch -a # 查看每个本地分支的最后一次提交 $ git branch -v # 查看本地分支和远程分支联系 $ git branch -vv # 切换git分支 $ git checkout branch-name # 创建分支 $ git branch branch-name # 新建并切换git分支 $ git checkout -b branch-name # 删除git分支 $ git branch -d branch-name # 强制删除git分支 $ git branch -D branch-name # 删除git远程分支 $ git push origin -d branch-name # 本地分支和远程分支建立联系 $ git branch --set-upstream-to=origin/远程分支 本地分支 # 查看git 配置 $ git config -l # 修改远程仓库地址 $ git remote set-url origin git@github.xxx.git # 本地分支回滚到指定版本 $ git reset --hard &lt;commit ID号&gt; # 强制推送到远程分支 $ git push -f origin &lt;branch name&gt; 删除commit记录何时需要删除Git提交的历史记录 当历史记录中出现过密码等敏感信息在历史记录中, 需要删除历史记录时 当项目因历史记录过多, 导致历史记录占用了大量内存时, 比如Github仓库个人总容量时1GB不够用时 当你想要一个全新的项目的时候, 并且想保持项目代码不变 # 1. 创建全新的孤立分支 latest_branch git checkout --orphan latest_branch # 2. 暂存所有文件 git add -A # 3. 提交所有文件的修改到latest_branch git commit -am &quot;del all history&quot; # 4. 删除原来的master分支 git branch -D master # 5. 修改latest_branch分支名为master git branch -m master # 6. 强制更新远程服务器的master分支, 至此清空git所有历史 git push -f origin master 新建代码库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] git initgit init命令将当前目录转为git仓库它会在当前目录下生成一个.git子目录，在其中写入git的配置和项目的快照 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] git clonegit clone命令用于克隆远程分支 # 下载一个项目和它的整个代码历史 $ git clone [url] # 将alpha目录（必须是git代码仓库），克隆到delta目录 # bare参数表示delta目录只有仓库区，没有工作区和暂存区，即delta目录中就是.git目录的内容 $ git clone alpha delta --bare 配置# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; git configGit的设置文件为.gitconfig，它可以在用户主目录下，也可以在项目目录下 # 显示当前的Git配置 $ git config --list $ git config -l # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 # 参数 # 1.系统级别：--system # 2.用户全局：--global # 3.单独一个项目：--local $ git config --global user.name &quot;xxxx&quot; #用户名 $ git config --global user.email &quot;xxxx@xxx.com&quot; #邮箱 $ git config --global core.editor vim #编辑器 $ git config --global alias.st status #按这种方法，配置别名 增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] git addgit add命令用于将变化的文件，从工作区提交到暂存区。它的作用就是告诉 Git，下一次哪些变化需要保存到仓库区。用户可以使用git status命令查看目前的暂存区放置了哪些文件。 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 # 会把当前目录中所有有改动的文件（不包括.gitignore中要忽略的文件）都添加到git缓冲区以待提交 $ git add . # 会把当前目录中所有有改动的文件（包括.gitignore中要忽略的文件）都添加到git缓冲区以待提交 $ git add * #&lt;不推荐&gt; 参数-u参数表示只添加暂存区已有的文件（包括删除操作），但不添加新增的文件。 $ git add -u -A或者--all参数表示追踪所有操作，包括新增、修改和删除 Git 2.0 版开始，-A参数成为默认，即git add .等同于git add -A $ git add -A -f参数表示强制添加某个文件，不管.gitignore是否包含了这个文件。 $ git add -f &lt;fileName&gt; -p参数表示进入交互模式，指定哪些修改需要添加到暂存区。即使是同一个文件，也可以只提交部分变动。 # 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交 $ git add -p 注意，Git 2.0 版以前，git add默认不追踪删除操作。即在工作区删除一个文件后，git add命令不会将这个变化提交到暂存区，导致这个文件继续存在于历史中。Git 2.0 改变了这个行为。 git rmgit rm命令用于删除文件。 # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] git mv# 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend &lt;file1&gt; &lt;file2&gt; ... git commitgit commit命令用于将暂存区中的变化提交到仓库区。-m参数用于指定 commit 信息，是必需的。如果省略-m参数，git commit会自动打开文本编辑器，要求输入。 # 提交暂存区到仓库区 $ git commit -m &quot;message&quot; # 提交暂存区的指定文件到仓库区 # 将工作区中指定文件的变化，先添加到暂存区，然后再将暂存区提交到仓库区 $ git commit [file1] [file2] ... -m [message] 参数-m-m参数用于添加提交说明如果没有指定提交说明，运行 commit 会直接打开默认的文本编辑器，让用户撰写提交说明 $ git commit -m &quot;message&quot; -a-a参数用于先将所有工作区的变动文件，提交到暂存区，再运行git commit。用了-a参数，就不用执行git add .命令了。 # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -am &quot;message&quot; –allow-empty--allow-empty参数用于没有提交信息的 commit $ git commit --allow-empty –amend–amend参数用于撤销上一次 commit，然后生成一个新的 commit # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend &lt;file1&gt; &lt;file2&gt; ... –fixup--fixup参数的含义是，当前添加的 commit 是以前某一个 commit 的修正。以后执行互动式的git rebase的时候，这两个 commit 将会合并成一个。 # 提交说明将自动生成，即在目标 commit 的提交说明的最前面，添加&quot;fixup!&quot;这个词 $ git commit --fixup &lt;commit&gt; –squash--squash参数的作用与--fixup类似，表示当前添加的 commit 应该与以前某一个 commit 合并成一个，以后执行互动式的git rebase的时候，这两个 commit 将会合并成一个。 $ git commit --squash &lt;commit&gt; 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch-name] # 新建一个分支，指向指定commit $ git branch [branch-name] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch-name] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch-name] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch-name] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete &lt;branch-name&gt; $ git branch -dr &lt;remote/branch&gt; git branchgit branch是分支操作命令 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a 新建一个分支直接在git branch后面跟上分支名，就表示新建该分支 # 新建一个分支，但依然停留在当前分支 $ git branch branch-name 新建一个分支，指向当前 commit。本质是在refs/heads/目录中生成一个文件，文件名为分支名，内容为当前 commit 的哈希值 注意：创建后，还是停留在原来分支，需要用git checkout切换到新建分支 # 切换到指定分支，并更新工作区 $ git checkout branch-name 使用-b参数，可以新建的同时，切换到新分支 # 新建一个分支，并切换到该分支 $ git checkout -b NewBranch MyBranch 删除分支-d参数用来删除一个分支，前提是该分支没有未合并的变动 # 删除分支 $ git branch -d &lt;branch-name分支名&gt; 强制删除一个分支，不管有没有未合并变化 $ git branch -D &lt;branch-name分支名&gt; 删除远程分支 # 删除远程分支 $ git push origin --delete &lt;branch-name&gt; $ git branch -dr &lt;remote/branch&gt; 分支改名# 新建一个分支 $ git checkout -b twitter-experiment feature132 # 删除原来的分支，使用新的分支，从而达到重命名操作 $ git branch -d feature132 另一种写法 # 为当前分支改名 $ git branch -m twitter-experiment # 为指定分支改名 $ git branch -m feature132 twitter-experiment # 如果有重名分支，强制改名 $ git branch -m feature132 twitter-experiment 查看 merge 情况# 显示全部合并到当前分支的分支 $ git branch --merged # 显示未合并到当前分支的分支 $ git branch --no-merged git merge合并指定分支到当前分支 # 合并指定分支到当前分支 $ git merge [branch] git cherry-pickgit cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交 # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] 标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] git taggit tag命令用于为 commit 打标签Tag 分两种：普通tag和注解tag只有annotated tag(注解tag) 才会产生 object $ git tag tmp # 生成.git/refs/tags/tmp $ git tag -a release $ git tag -a [VERSION] -m &quot;released [VERSION]&quot; 上面代码表示为当前commit打上一个带注解的标签，标签名为release普通标签的写法 $ git tag 1.0.0 $ git push --tags $ git tag v0.0.1 $ git push origin master --tags 查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [&lt;file&gt;] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 远程同步git remote当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origingit remote查看远程库的信息 # 下载远程仓库的所有变动 $ git fetch [remote] # 查看远程库详细信息 # 显示可以抓取(fetch)和推送(push)的origin的地址；如果没有推送权限，就看不到push的地址 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 查看版本改动git diffgit diff命令用于查看文件之间的差异 在git提交环节，存在三大部分：working tree（工作区）, index file（暂存区：stage）, commit（分支：master） # 查看工作区与暂存区的差异 $ git diff # 查看某个文件的工作区与暂存区的差异 $ git diff file.txt # 查看暂存区与当前 commit 的差异 $ git diff --cached # 查看两个commit的差异 $ git diff &lt;commitBefore&gt; &lt;commitAfter&gt; # 查看暂存区与仓库区的差异 $ git diff --cached # 查看工作区与上一次commit之间的差异 # 即如果执行 git commit -a，将提交的文件 $ git diff HEAD # 查看工作区与某个 commit 的差异 $ git diff &lt;commit&gt; # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 查看工作区与当前分支上一次提交的差异，但是局限于test文件 $ git diff HEAD -- ./test # 查看当前分支上一次提交与上上一次提交之间的差异 $ git diff HEAD -- ./test # 生成patch $ git format-patch master --stdout &gt; mypatch.patch 比较两个分支 # 查看topic分支与master分支最新提交之间的差异 $ git diff topic master # 与上一条命令相同 $ git diff topic..master # 查看自从topic分支建立以后，master分支发生的变化 $ git diff topic...master 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到工作区 $ git checkout [commit] [file] # 恢复上一个commit的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 其他# 生成一个可供发布的压缩包 $ git archive HEAD表示当前版本，也就是最新的提交。上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写100个^ 比较容易数不过来，所以写成HEAD~100。HEAD~2相当于HEAD^^ 参考 廖雪峰官方网站、阮一峰 Git 教程","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.xiongtianci.com/tags/Git/"}],"author":"天赐"},{"title":"常用正则表达式公式","slug":"常用正则表达式公式","date":"2019-06-10T10:07:34.000Z","updated":"2019-06-18T08:52:23.026Z","comments":true,"path":"2019/06/10/常用正则表达式公式/","link":"","permalink":"https://www.xiongtianci.com/2019/06/10/常用正则表达式公式/","excerpt":"","text":"作者：艾欢欢 链接：收藏一波：常用正则表达式公式总结 校验数字的表达式一位数字： ^[0-9]\\*$ n位的数字： ^\\d{n}$ 至少n位的数字： ^\\d{n,}$ m-n位的数字： ^\\d{m,n}$ 零和非零开头的数字： ^(0|[1-9][0-9]\\*)$ 非零开头的最多带两位小数的数字： ^([1-9][0-9]\\*)+(\\.[0-9]{1,2})?$ 带1-2位小数的正数或负数： ^(\\-)?\\d+(\\.\\d{1,2})$ 正数、负数、和小数： ^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数： ^[0-9]+(\\.[0-9]{2})?$ 有1~3位小数的正实数： ^[0-9]+(\\.[0-9]{1,3})?$ 非零的正整数： ^[1-9]\\d\\*$ 或 ^([1-9][0-9]\\*){1,3}$ 或 ^\\+?[1-9][0-9]\\*$ 非零的负整数： ^\\-[1-9][]0-9&quot;\\*$ 或 ^-[1-9]\\d\\*$ 非负整数： ^\\d+$ 或 ^[1-9]\\d\\*|0$ 非正整数： ^-[1-9]\\d\\*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数： ^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*|0?\\.0+|0$ 非正浮点数： ^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*))|0?\\.0+|0$ 正浮点数： ^[1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*$ 或 ^(([0-9]+\\.[0-9]\\*[1-9][0-9]\\*)|([0-9]\\*[1-9][0-9]\\*\\.[0-9]+)|([0-9]\\*[1-9][0-9]\\*))$ 负浮点数： ^-([1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*)$ 或 ^(-(([0-9]+\\.[0-9]\\*[1-9][0-9]\\*)|([0-9]\\*[1-9][0-9]\\*\\.[0-9]+)|([0-9]\\*[1-9][0-9]\\*)))$ 浮点数： ^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*|0?\\.0+|0)$ 校验字符的表达式汉字： ^[\\u4e00-\\u9fa5]{0,}$ 英文和数字： ^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符： ^.{3,20}$ 由26个英文字母组成的字符串： ^[A-Za-z]+$ 由26个大写英文字母组成的字符串： ^[A-Z]+$ 由26个小写英文字母组成的字符串： ^[a-z]+$ 由数字和26个英文字母组成的字符串： ^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串： ^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线： ^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号： ^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 禁止输入含有~的字符： [^~\\x22]+ 特殊需求表达式Email地址： ^\\w+([-+.]\\w+)\\*@\\w+([-.]\\w+)\\*\\.\\w+([-.]\\w+)\\*$ 域名： [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL： [a-zA-z]+://[^\\s]\\* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]\\*)?$ 手机号码： ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 国内电话号码(0511-4405222、021-87888822)： \\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X： (^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： ^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)： ^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)： ^(?=.\\*\\d)(?=.\\*[a-z])(?=.\\*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)： ^(?=.\\*\\d)(?=.\\*[a-z])(?=.\\*[A-Z]).{8,10}$ 日期格式： ^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)： ^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)： ^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件： ^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式： [\\u4e00-\\u9fa5] 空白行的正则表达式： \\n\\s\\*\\r (可以用来删除空白行) HTML标记的正则表达式： &lt;(\\S\\*?)[^&gt;]\\*&gt;.\\*?|&lt;.\\*? /&gt; ( 首尾空白字符的正则表达式：^\\s\\*|\\s\\*$或(^\\s\\*)|(\\s\\*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号： [1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码： [1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址： ((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"},{"name":"转载","slug":"转载","permalink":"https://www.xiongtianci.com/categories/转载/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://www.xiongtianci.com/tags/正则/"}],"author":"天赐"},{"title":"致迷茫中的自己","slug":"致迷茫中的自己","date":"2019-06-10T04:40:33.000Z","updated":"2019-06-18T08:52:15.941Z","comments":true,"path":"2019/06/10/致迷茫中的自己/","link":"","permalink":"https://www.xiongtianci.com/2019/06/10/致迷茫中的自己/","excerpt":"","text":"如果感到迷茫，而且选择比较多的时候，就先都试着做做呗，大不了就累一点不睡觉嘛。 上面这句话来自我超喜欢的一个B站up主–无聊的Do君5月1号的视频","categories":[{"name":"生活","slug":"生活","permalink":"https://www.xiongtianci.com/categories/生活/"},{"name":"随想","slug":"随想","permalink":"https://www.xiongtianci.com/categories/随想/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.xiongtianci.com/tags/生活/"}],"author":"天赐"},{"title":"一千行MySQL学习笔记","slug":"一千行MySQL学习笔记","date":"2019-06-05T09:41:17.000Z","updated":"2019-06-18T08:52:29.462Z","comments":true,"path":"2019/06/05/一千行MySQL学习笔记/","link":"","permalink":"https://www.xiongtianci.com/2019/06/05/一千行MySQL学习笔记/","excerpt":"","text":"作者：Jioby 链接： https://shockerli.net/post/1000-line-mysql-note/ Windows服务-- 启动mysql net start mysql -- 创建windows服务(注意：等号与值之间有空格) sc create mysql binpath= mysqld_bin_path 连接与断开服务器-- 连接（地址、端口可不填，默认为localhost:3306） mysql -h 地址 -p 端口 -u 用户名 -p 密码 -- 显示哪些线程正在运行 show processlist -- 显示系统变量信息 show variables 数据库操作-- 查看当前数据库 select database(); -- 显示当前时间、用户名、数据库版本 select now(), user(), version(); -- 创建库 create database[ if not exists] 数据库名 数据库选项 -- 数据库选项： character set charset_name collate collation_name -- 查看已有库 show databases[ like &#39;pattern&#39;] -- 查看当前库信息 show create database 数据库名 -- 修改库的选项信息 alter database 库名 选项信息 -- 删除库 drop database[ if exists] 数据库名 -- 同时删除该数据库相关的目录及其目录内容 表的操作-- 创建表 create [temporary] table [if not exists] [库名.]表名 (表的结构定义) [表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 temporary 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [not null | null] [default default_value] [auto_increment] [unique [key] | [primary] key] [comment &#39;string&#39;] -- 表选项 -- 字符集 charset = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 engine = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：innodb myisam memory/heap bdb merge example csv maxdb archive 不同的引擎在保存表的结构和数据时采用不同的方式 myisam表文件含义：.frm表定义，.myd表数据，.myi表索引 innodb表文件含义：.frm表定义，表空间数据和日志文件 show engines -- 显示存储引擎的状态信息 show engine 引擎名 {logs|status} -- 显示存储引擎的日志或状态信息 -- 自增起始数 auto_increment = 行数 -- 数据文件目录 data directory = &#39;目录&#39; -- 索引文件目录 index directory = &#39;目录&#39; -- 表注释 comment = &#39;string&#39; -- 分区选项 partition by ... (详细见手册) -- 查看所有表 show tables[ like &#39;pattern&#39;] show tables from 表名 -- 查看表机构 show create table 表名 （信息更详细） desc 表名 / describe 表名 / explain 表名 / show columns from 表名 [like &#39;pattern&#39;] show table status [from db_name] [like &#39;pattern&#39;] -- 修改表 -- 修改表本身的选项 alter table 表名 表的选项 eg: alter table 表名 engine=myisam; -- 对表进行重命名 rename table 原表名 to 新表名 rename table 原表名 to 库名.表名 （可将表移动到另一个数据库） -- rename可以交换两个表名 -- 修改表的字段机构（13.1.2. alter table语法） alter table 表名 操作名 -- 操作名 add[ column] 字段定义 -- 增加字段 after 字段名 -- 表示增加在该字段名后面 first -- 表示增加在第一个 add primary key(字段名) -- 创建主键 add unique [索引名] (字段名)-- 创建唯一索引 add index [索引名] (字段名) -- 创建普通索引 drop[ column] 字段名 -- 删除字段 modify[ column] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) change[ column] 原字段名 新字段名 字段属性 -- 支持对字段名修改 drop primary key -- 删除主键(删除主键前需删除其auto_increment属性) drop index 索引名 -- 删除索引 drop foreign key 外键 -- 删除外键 -- 删除表 drop table[ if exists] 表名 ... -- 清空表数据 truncate [table] 表名 -- 复制表结构 create table 表名 like 要复制的表名 -- 复制表结构和数据 create table 表名 [as] select * from 要复制的表名 -- 检查表是否有错误 check table tbl_name [, tbl_name] ... [option] ... -- 优化表 optimize [local | no_write_to_binlog] table tbl_name [, tbl_name] ... -- 修复表 repair [local | no_write_to_binlog] table tbl_name [, tbl_name] ... [quick] [extended] [use_frm] -- 分析表 analyze [local | no_write_to_binlog] table tbl_name [, tbl_name] ... 数据操作-- 增 insert [into] 表名 [(字段列表)] values (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ replace 与 insert 完全一样，可互换。 insert [into] 表名 set 字段名=值[, 字段名=值, ...] -- 查 select 字段列表 from 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段 -- 删 delete from 表名[ 删除条件子句] 没有条件子句，则会删除全部 -- 改 update 表名 set 字段名=新值[, 字段名=新值] [更新条件] 字符集编码-- mysql、数据库、表、字段均可设置编码 -- 数据编码与客户端编码不需一致 show variables like &#39;character_set_%&#39; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码 set 变量名 = 变量值 set character_set_client = gbk; set character_set_results = gbk; set character_set_connection = gbk; set names gbk; -- 相当于完成以上三个设置 -- 校对集 校对集用以排序 show character set [like &#39;pattern&#39;]/show charset [like &#39;pattern&#39;] 查看所有字符集 show collation [like &#39;pattern&#39;] 查看所有校对集 charset 字符集编码 设置字符集编码 collate 校对集编码 设置校对集编码 数据类型（列类型）1. 数值类型 -- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(m) m表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&#39;123&#39;，补填后为&#39;00123&#39; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。mysql没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 -- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(m, d) double(m, d) m表示总位数，d表示小数位数。 m和d的大小会决定浮点数的范围。不同于整型的固定范围。 m既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。 -- c. 定点数 ---------- decimal -- 可变长度 decimal(m, d) m也表示总位数，d表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。 2. 字符串类型 -- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 m表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 create table tb(c1 int, c2 char(30), c3 varchar(n)) charset=utf8; 问n的最大值是多少？ 答：(65535-1-2-4-30*3)/3 -- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 -- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. 3. 日期时间类型 一般用整型保存时间戳，因为php可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 datetime yyyy-mm-dd hh:mm:ss timestamp yy-mm-dd hh:mm:ss yyyymmddhhmmss yymmddhhmmss yyyymmddhhmmss yymmddhhmmss date yyyy-mm-dd yy-mm-dd yyyymmdd yymmdd yyyymmdd yymmdd time hh:mm:ss hhmmss hhmmss year yyyy yy yyyy yy 4. 枚举和集合 -- 枚举(enum) ---------- enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 null值的索引是null。 空字符串错误值的索引值是0。 -- 集合（set） ---------- set(val1, val2, val3...) create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) ); insert into tab values (&#39;男, 女&#39;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，set成员值的尾部空格将自动被删除。 选择类型-- php角度 1. 功能满足 2. 存储空间尽量小，处理效率更高 3. 考虑兼容问题 -- ip存储 ---------- 1. 只需存储，可用字符串 2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned 1) php函数转换 ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。 利用sprintf函数格式化字符串 sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;)); 然后用long2ip将整型转回ip字符串 2) mysql函数转换(无符号整型，unsigned) inet_aton(&#39;127.0.0.1&#39;) 将ip转为整型 inet_ntoa(2130706433) 将整型转为ip 列属性（列约束）1. primary 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); 2. unique 唯一索引（唯一约束） 使得某字段的值也不能重复。 3. null 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &#39;val&#39;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null 4. default 默认值属性 当前字段的默认值。 insert into tab values (default, &#39;val&#39;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time 5. auto_increment 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x; 6. comment 注释 例：create table tab ( id int ) comment &#39;注释内容&#39;; 7. foreign key 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 mysql中，可以对innodb引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被innodb存储引擎所支持。其他引擎是不支持的。 建表规范-- normal format, nf - 每个表保存一个实体信息 - 每个具有一个id字段作为主键 - id主键 + 原子表 -- 1nf, 第一范式 字段不能再分，就满足第一范式。 -- 2nf, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3nf, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 selectselect [all|distinct] select_expr from -&gt; where -&gt; group by [合计函数] -&gt; having -&gt; order by -&gt; limit a. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb; b. from 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 select * from tb1 as tt, tb2 as bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 select * from tb1, tb2; -- 向优化符提示如何选择索引 use index、ignore index、force index select * from table1 use index (key1,key2) where key1=1 and key2=2 and key3=3; select * from table1 ignore index (key3) where key1=1 and key2=2 and key3=3; c. where 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较 d. group by 子句, 分组子句 group by 字段/别名 [排序方式] 分组后会进行排序。升序：asc，降序：desc 以下[合计函数]需配合 group by 使用： count 返回不同的非null值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非null值的字符串结果。组内字符串连接。 e. having 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行where代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having sql标准要求having必须引用group by子句中的列或用于合计函数中的列。 f. order by 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：asc，降序：desc 支持多个字段的排序。 g. limit 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数 h. distinct, all 选项 distinct 去除重复记录 默认为 all, 全部记录 union将多个select查询的结果组合成一个结果集合。 select ... union [all|distinct] select ... 默认 distinct 方式，即所有返回的行都是唯一的 建议，对每个select查询加上小括号包裹。 order by 排序时，需加上 limit 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 子查询 - 子查询需用括号包裹。 -- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1; -- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 row(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 连接查询(join) 将多个表的字段进行连接，可以指定连接条件。 -- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2; -- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充 -- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; /* 导入导出 */ ------------------ select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据 load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理 -- 控制格式 fields 控制字段格式 默认：fields terminated by &#39;\\t&#39; enclosed by &#39;&#39; escaped by &#39;\\\\&#39; terminated by &#39;string&#39; -- 终止 enclosed by &#39;char&#39; -- 包裹 escaped by &#39;char&#39; -- 转义 -- 示例： select a,b,a+b into outfile &#39;/tmp/result.text&#39; fields terminated by &#39;,&#39; optionally enclosed by &#39;&quot;&#39; lines terminated by &#39;\\n&#39; from test_table; lines 控制行格式 默认：lines terminated by &#39;\\n&#39; terminated by &#39;string&#39; -- 终止 insertselect语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 insert into tbl_name set field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 insert into tbl_name values (), (), (); 可以在列值指定时，使用表达式。 insert into tbl_name values (field_value, 10+10, now()); 可以使用一个特殊值 default，表示该列使用默认值。 insert into tbl_name values (field_value, default); 可以通过一个查询的结果，作为需要插入的值。 insert into tbl_name select ...; 可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 insert into tbl_name values/set/select on duplicate key update 字段=值, …; deletedelete from tbl_name [where where_definition] [order by ...] [limit row_count] 按照条件删除。where 指定删除的最多记录数。limit 可以通过排序条件删除。order by + limit 支持多表删除，使用类似连接语法。 delete from 需要删除数据多表1，表2 using 表连接操作 条件。 /* truncate */ ------------------ truncate [table] tbl_name 清空数据 删除重建表 区别： 1，truncate 是删除表再创建，delete 是逐条删除 2，truncate 重置auto_increment的值。而delete不会 3，truncate 不知道删除了几条，而delete知道。 4，当被用于带分区的表时，truncate 会保留分区 备份与还原备份，将数据的结构与表内数据保存起来。 利用 mysqldump 指令完成。 -- 导出 mysqldump [options] db_name [tables] mysqldump [options] ---database db1 [db2 db3...] mysqldump [options] --all--database 1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(d:/a.sql) 2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(d:/a.sql) 3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(d:/a.sql) 4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(d:/a.sql) 可以-w携带where条件 -- 导入 1. 在登录mysql的情况下： source 备份文件 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 视图什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 -- 创建视图 create [or replace] [algorithm = {undefined | merge | temptable}] view view_name [(column_list)] as select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过algorithm指定。 - column_list如果存在，则数目必须等于select语句检索的列数 -- 查看结构 show create view view_name -- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 drop view [if exists] view_name ... -- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 alter view view_name [(column_list)] as select_statement -- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构 -- 视图算法(algorithm) merge 合并 将视图的查询语句，与外部查询需要先合并再执行！ temptable 临时表 将视图执行完毕后，形成临时表，再做外层查询！ undefined 未定义(默认)，指的是mysql自主去选择相应的算法。 事务(transaction)事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续sql的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 innodb 或 bdb 存储引擎，对自动提交的特性支持完成。 - innodb被称为事务安全型引擎。 -- 事务开启 start transaction; 或者 begin; 开启事务后，所有被执行的sql语句均被认作当前事务内的sql语句。 -- 事务提交 commit; -- 事务回滚 rollback; 如果部分操作发生问题，映射到事务开启前。 -- 事务的特性 1. 原子性（atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。 -- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。 -- 事务的原理 利用innodb的自动提交(autocommit)特性完成。 普通的mysql执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。 -- 注意 1. 数据定义语言（ddl）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套 -- 保存点 savepoint 保存点名称 -- 设置一个事务保存点 rollback to savepoint 保存点名称 -- 回滚到保存点 release savepoint 保存点名称 -- 删除保存点 -- innodb自动提交特性设置 set autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与start transaction不同的是， set autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而start transaction记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表表锁定只用于防止其它客户端进行不正当地读取和写入 myisam 支持表锁，innodb 支持行锁 -- 锁定 lock tables tbl_name [as alias] -- 解锁 unlock tables 触发器 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。 -- 创建触发器 create trigger trigger_name trigger_time trigger_event on tbl_name for each row trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 insert：将新行插入表时激活触发程序 update：更改某一行时激活触发程序 delete：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与temporary表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用begin...end复合语句结构 -- 删除 drop trigger [schema_name.]trigger_name 可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new. -- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。 -- 字符连接函数 concat(str1,str2,...]) concat_ws(separator,str1,str2,...) -- 分支语句 if 条件 then 执行语句 elseif 条件 then 执行语句 else 执行语句 end if; -- 修改最外层语句结束符 delimiter 自定义结束符号 sql语句 自定义结束符号 delimiter ; -- 修改回原来的分号 -- 语句块包裹 begin 语句块 end -- 特殊的执行 1. 只要添加记录，就会触发程序。 2. insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update 3. replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert SQL编程--// 局部变量 ---------- -- 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 -- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量） --// 全局变量 ---------- -- 定义、赋值 set 语句可以定义并为变量赋值。 set @var = value; 也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。 还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。 select @var:=20; select @v1:=id, @v2=name from t1 limit 1; select * from tbl_name where @var:=30; select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb; -- 自定义变量名 为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。 @var=10; - 变量被定义后，在整个会话周期都有效（登录到退出） --// 控制结构 ---------- -- if语句 if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; -- case语句 case value when [compare-value] then result [when [compare-value] then result ...] [else result] end -- while循环 [begin_label:] while search_condition do statement_list end while [end_label]; - 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环 --// 内置函数 ---------- -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date(&#39;yyyy-mm-dd hh:ii:ss&#39;); -- 获取日期部分 time(&#39;yyyy-mm-dd hh:ii:ss&#39;); -- 获取时间部分 date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 流程函数 case when [condition] then result [when [condition] then result ...] [else result] end 多分支 if(expr1,expr2,expr3) 双分支。 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); --// 存储函数，自定义函数 ---------- -- 新建 create function function_name (参数列表) returns 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。 -- 删除 drop function [if exists] function_name; -- 查看 show function status like &#39;partten&#39; show create function function_name; -- 修改 alter function function_name 函数选项 --// 存储过程，自定义功能 ---------- -- 定义 存储存储过程 是一段代码（过程），存储在数据库中的sql组成。 一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。 而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。 -- 创建 create procedure sp_name (参数列表) 过程体 参数列表：不同于函数的参数列表，需要指明参数类型 in，表示输入型 out，表示输出型 inout，表示混合型 注意，没有返回值。 存储过程存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。 调用：call 过程名 -- 注意 - 没有返回值。 - 只能单独调用，不可夹杂在其他语句中 -- 参数 in|out|inout 参数名 数据类型 in 输入：在调用过程中，将数据输入到过程体内部的参数 out 输出：在调用过程中，将过程体处理完的结果返回到客户端 inout 输入输出：既可输入，也可输出 -- 语法 create procedure 过程名 (参数列表) begin 过程体 end 用户和权限管理-- root密码重置 1. 停止mysql服务 2. [linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [windows] mysqld --skip-grant-tables 3. use mysql; 4. update `user` set password=password(&quot;密码&quot;) where `user` = &quot;root&quot;; 5. flush privileges; 用户信息表：mysql.user -- 刷新权限 flush privileges; -- 增加用户 create user 用户名 identified by [password] 密码(字符串) - 必须拥有mysql数据库的全局create user权限，或拥有insert权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略password关键词。要把密码指定为由password()函数返回的混编值，需包含关键字password -- 重命名用户 rename user old_user to new_user -- 设置密码 set password = password(&#39;密码&#39;) -- 为当前用户设置密码 set password for 用户名 = password(&#39;密码&#39;) -- 为指定用户设置密码 -- 删除用户 drop user 用户名 -- 分配权限/添加用户 grant 权限列表 on 表名 to 用户名 [identified by [password] &#39;password&#39;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 grant all privileges on `pms`.* to &#39;pms&#39;@&#39;%&#39; identified by &#39;pms0817&#39;; -- 查看权限 show grants for 用户名 -- 查看当前用户权限 show grants; 或 show grants for current_user; 或 show grants for current_user(); -- 撤消权限 revoke 权限列表 on 表名 from 用户名 revoke all privileges, grant option from 用户名 -- 撤销所有权限 -- 权限层级 -- 要使用grant或revoke，您必须拥有grant option权限，并且您必须用于您正在授予或撤销的权限。 全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user grant all on *.*和 revoke all on *.*只授予和撤销全局权限。 数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host grant all on db_name.*和revoke all on db_name.*只授予和撤销数据库权限。 表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv grant all on db_name.tbl_name和revoke all on db_name.tbl_name只授予和撤销表权限。 列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用revoke时，您必须指定与被授权列相同的列。 -- 权限列表 all [privileges] -- 设置除grant option之外的所有简单权限 alter -- 允许使用alter table alter routine -- 更改或取消已存储的子程序 create -- 允许使用create table create routine -- 创建已存储的子程序 create temporary tables -- 允许使用create temporary table create user -- 允许使用create user, drop user, rename user和revoke all privileges。 create view -- 允许使用create view delete -- 允许使用delete drop -- 允许使用drop table execute -- 允许用户运行已存储的子程序 file -- 允许使用select...into outfile和load data infile index -- 允许使用create index和drop index insert -- 允许使用insert lock tables -- 允许对您拥有select权限的表使用lock tables process -- 允许使用show full processlist references -- 未被实施 reload -- 允许使用flush replication client -- 允许用户询问从属服务器或主服务器的地址 replication slave -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） select -- 允许使用select show databases -- 显示所有数据库 show view -- 允许使用show create view shutdown -- 允许使用mysqladmin shutdown super -- 允许使用change master, kill, purge master logs和set global语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 update -- 允许使用update usage -- “无权限”的同义词 grant option -- 允许授予权限 表维护-- 分析和存储表的关键字分布 analyze [local | no_write_to_binlog] table 表名 ... -- 检查一个或多个表是否有错误 check table tbl_name [, tbl_name] ... [option] ... option = {quick | fast | medium | extended | changed} -- 整理数据文件的碎片 optimize [local | no_write_to_binlog] table tbl_name [, tbl_name] ... 杂项1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准sql注释风格，要求双破折号后加一空格符（空格、tab、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\&#39; 5. cmd命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\g&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. sql对大小写不敏感 7. 清除已有语句：\\c","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"},{"name":"转载","slug":"转载","permalink":"https://www.xiongtianci.com/categories/转载/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"npm install hexo-renderer-sass时报错","slug":"npm-install-hexo-renderer-sass时报错","date":"2019-05-20T15:37:42.000Z","updated":"2019-06-18T08:52:46.664Z","comments":true,"path":"2019/05/20/npm-install-hexo-renderer-sass时报错/","link":"","permalink":"https://www.xiongtianci.com/2019/05/20/npm-install-hexo-renderer-sass时报错/","excerpt":"","text":"问题使用hexo搭建博客时，需安装hexo-renderer-sass： $ npm install hexo-renderer-sass 解决改用淘宝镜像： $ npm install -g cnpm --registry=https://registry.npm.taobao.org $ npm config set registry https://registry.npm.taobao.org 再次安装： $ cnpm install hexo-renderer-sass --save","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.xiongtianci.com/tags/Hexo/"}],"author":"天赐"},{"title":"重新搭建博客","slug":"重新搭建博客","date":"2019-05-20T12:49:00.000Z","updated":"2019-06-18T08:52:38.190Z","comments":true,"path":"2019/05/20/重新搭建博客/","link":"","permalink":"https://www.xiongtianci.com/2019/05/20/重新搭建博客/","excerpt":"","text":"前言3月份初，许久没写博客（主要就是懒）的博主在莫一天心血来潮写好一篇文章后，使用hexo d部署博客文章时，发现hexo抛出各种错误。但由于当时准备面试的面试题（主要就是懒），然后就放着没管它。紧接着面试实习岗位，工作后也一直没有闲下来。最近终于抽出时间来重构博客，写下这篇文章，记录一下重构博客的过程~ 博客目录介绍. ├── .deploy ├── public ├── scaffolds ├── scripts ├── source | ├── _drafts | └── _posts ├── themes ├── _config.yml └── package.json .deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章 _posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的 关于 按钮 接下来是重头戏 _config.yml ，做个简单说明： # Hexo Configuration ## Docs: http://zespia.tw/hexo/docs/configure.html ## Source: https://github.com/tommy351/hexo/ # Site #整站的基本信息 title: 不如 #网站标题 subtitle: 码农，程序猿，未来的昏析师 #网站副标题 description: bruce sha&#39;s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到 author: bruce #网站作者，在下方显示 email: bu.ru@qq.com #联系邮箱 language: zh-CN #语言 # URL #域名和文件结构 ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: http://ibruce.info #你的域名 root: / permalink: :year/:month/:day/:title/ tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code # Writing #写文章选项 new_post_name: :title.md # File name of new posts default_layout: post #默认layout方式 auto_spacing: false # Add spaces between asian characters and western characters titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab max_open_file: 100 multi_thread: true filename_case: 0 render_drafts: false highlight: #代码高亮 enable: true #是否启用 line_number: false #是否显示行号 tab_replace: # Category &amp; Tag #分类与标签 default_category: uncategorized # default category_map: tag_map: # Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突 ## 2: Enable pagination ## 1: Disable pagination ## 0: Fully Disable archive: 1 category: 1 tag: 1 # Server #本地服务参数 ## Hexo uses Connect as a server ## You can customize the logger format as defined in ## http://www.senchalabs.org/connect/logger.html port: 4000 logger: true logger_format: # Date / Time format #日期显示格式 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: MMM D YYYY time_format: H:mm:ss # Pagination #分页设置 ## Set per_page to 0 to disable pagination per_page: 10 #每页10篇文章 pagination_dir: page # Disqus #社会化评论disqus，我使用多说，在主题中配置 disqus_shortname: # Extensions #插件，暂时未安装插件 ## Plugins: https://github.com/tommy351/hexo/wiki/Plugins ## Themes: https://github.com/tommy351/hexo/wiki/Themes ## 主题 theme: modernist # raytaylorism # pacman # modernist # light exclude_generator: # Deployment #部署 ## Docs: http://zespia.tw/hexo/docs/deploy.html deploy: type: github repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库 主题目录介绍. ├── languages #多语言 | ├── default.yml #默认语言 | └── zh-CN.yml #中文语言 ├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制 | ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制 | └── _widget #小挂件的布局，页面下方小挂件的控制 ├── source #源码 | ├── css #css源码 | | ├── _base #*.styl基础css | | ├── _partial #*.styl局部css | | ├── fonts #字体 | | ├── images #图片 | | └── style.styl #*.styl引入需要的css源码 | ├── fancybox #fancybox效果源码 | └── js #javascript源代码 ├── _config.yml #主题配置文件 └── README.md #用GitHub的都知道 如果你需要修改头部，直接修改 hexo\\themes\\modernist\\layout\\_partial\\header.ejs ，比如头上加个搜索框： &lt;div&gt; &lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\\/\\//, &#39;&#39;) %&gt;&quot;&gt; &lt;/form&gt; &lt;/div&gt; 将如上代码加入即可，您需要修改css以便这个搜索框比较美观。再如，你要修改页脚版权信息，直接编辑 hexo\\themes\\modernist\\layout\\_partial\\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。 主题安装 https://www.haomwei.com/technology/maupassant-hexo.html $ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant $ npm install hexo-renderer-pug --save $ npm install hexo-renderer-sass --save npm install hexo-renderer-pug --save安装时可能会报错，以下是解决方案：改用cnpm来安装软件 $ npm install -g cnpm –registry=https://registry.npm.taobao.org目的是直接改npm为淘宝的npm，也为防止某些依赖直接用npm来安装，导致无法顺利安装完成$ npm config set registry https://registry.npm.taobao.org 编辑Hexo目录下的 _config.yml，将theme的值改为maupassant theme: matery 功能配置# 是否启用Fancybox图片灯箱效果 # Disqus评论 shortnam disqus: # 友言评论 id uyan: # 来必力评论 data-uid livere: # 畅言评论 appid changyan: changyan_conf: ## Your changyan conf, e.g. prod_d8a508c2825ab57eeb43e7c69bba0e8b # Gitment评论相关参数 gitment: enable: false owner: repo: client_id: client_secret: # Gitalk评论相关参数 gitalk: enable: false owner: repo: client_id: client_secret: admin: # Valine评论相关参数 valine: enable: false appid: appkey: notify: false # 评论系统中的邮件提醒设置 verify: false ## Validation code. placeholder: Just so so avatar: &#39;mm&#39; pageSize: 10 guest_info: nick,mail,link # 默认使用Google搜索引擎 google_search: true # 若想使用百度搜索，将其设定为 true baidu_search: false # Swiftype 站内搜索key swiftype: # 微搜索 key tinysou: # 基于jQuery的本地搜索引擎，需要安装hexo-generator-search插件使用 self_search: false # Google Analytics 跟踪ID google_analytics: # 百度统计 跟踪ID baidu_analytics: # fancybox: true ## If you want to use fancybox please set the value to true. # 是否显示侧边栏分类数目 show_category_count: false # 是否显示文章中目录列表自动编号 toc_number: true # 是否使用分享按鈕，需要安装hexo-helper-qrcode插件使用 shareto: false # 是否使用不蒜子页面访问计数 busuanzi: false # wordcount: false ## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed. # 是否在移动设备屏幕底部显示侧边栏 widgets_on_small_screens: false ## Set to true to enable widgets on small screens. # 是否使用canvas动态背景 canvas_nest: enable: false color: ## RGB value of the color, e.g. &quot;100,99,98&quot; opacity: ## Transparency of lines, e.g. &quot;0.7&quot; zIndex: ## The z-index property of the background, e.g. &quot;-1&quot; count: ## Quantity of lines, e.g. &quot;150&quot; # 是否启用捐赠按钮 donate: enable: false github: ## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page alipay_qr: ## Path of Alipay QRcode image, e.g. /img/AliPayQR.png wechat_qr: ## Path of Wechat QRcode image, e.g. /img/WeChatQR.png btc_qr: ## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png btc_key: ## Bitcoin key, e.g. 1KuK5eK2BLsqpsFVXXSBG5wbSAwZVadt6L paypal_url: ## Paypal URL, e.g. https://www.paypal.me/tufu9441 post_copyright: enable: false ## If you want to display the copyright info after each post, please set the value to true and fill the following items on your need. author: ## Your author name, e.g. tufu9441 copyright_text: ## Your copyright text, e.g. The author owns the copyright, please indicate the source reproduced. # 自定义页面及菜单，依照已有格式填写。 # 填写后请在source目录下建立相应名称的文件夹，并包含index.md文件，以正确显示页面。 # 导航菜单中集成了FontAwesome图标字体，可以在这里选择新的图标，并按照相关说明使用。 menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: about directory: about/ icon: fa-user - page: rss directory: atom.xml icon: fa-rss # 选择和排列希望使用的侧边栏小工具 widgets: ## Six widgets in sidebar provided: search, category, tag, recent_posts, rencent_comments and links. - search - category - tag - recent_posts - recent_comments - links # 友情链接，请依照格式填写 links: - title: site-name1 url: http://www.example1.com/ - title: site-name2 url: http://www.example2.com/ - title: site-name3 url: http://www.example3.com/ # 网站历史时间线，在页面front-matter中设置layout: timeline可显示 timeline: - num: 1 word: 2014/06/12-Start - num: 2 word: 2014/11/29-XXX - num: 3 word: 2015/02/18-DDD - num: 4 word: More # Static files # 静态文件存储路径，方便设置CDN缓存 js: js css: css # Theme version # 主题版本，便于静态文件更新后刷新CDN缓存 version: 0.0.0 评论Disqus配置使用注册 https://disqus.com/ 主题特性主题目录结构-maupassant |-languages 网站图标网站Favicon：/blog/source/favicon.ico，建议的大小：32px*32px。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"生活","slug":"生活","permalink":"https://www.xiongtianci.com/categories/生活/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.xiongtianci.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.xiongtianci.com/tags/博客/"}],"author":"天赐"},{"title":"hexo d命令报错：ERROR Deployer not found: git","slug":"hexo-d命令报错：ERROR-Deployer-not-found-git","date":"2019-05-15T06:30:17.000Z","updated":"2019-06-18T08:52:53.229Z","comments":true,"path":"2019/05/15/hexo-d命令报错：ERROR-Deployer-not-found-git/","link":"","permalink":"https://www.xiongtianci.com/2019/05/15/hexo-d命令报错：ERROR-Deployer-not-found-git/","excerpt":"","text":"问题使用hexo d或hexo deploy命令时报错： ERROR Deployer not found: git 解决安装hexo-deployer-git： npm install --save hexo-deployer-git 在_config.yml配置中将deploy的type由github改为git： deploy type: git repository: git@github.com:YOUR_ID/YOUR_ID.github.io.git branch: master 将其中的YOUR_ID改成你自己的GitHub账号","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.xiongtianci.com/tags/Hexo/"}],"author":"天赐"},{"title":"彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示","slug":"彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示","date":"2019-05-09T12:17:52.000Z","updated":"2019-06-18T08:53:00.719Z","comments":true,"path":"2019/05/09/彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示/","link":"","permalink":"https://www.xiongtianci.com/2019/05/09/彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示/","excerpt":"","text":"前言Chrome勾选开发者模式安装插件后，每次启动都会弹出请停用以开发者模式运行的扩展程序的提示，最为一枚具有强迫症的程序员，这个绝对不能忍~~ Chrome版本：74.0.3729.131 解决方案方案一：反编译修改chrome.dll文件1.1 下载x64dbg下载地址：https://github.com/x64dbg/x64dbg/releases选择最新版本进行下载：下载好之后，解压打开release，可以点击x96dbg选择x64dbg，也可以直接选择x64文件夹中的x64dbg，如果你是32位的系统还可以选择x32dbg 1.2 反编译chrome.dll通过 右键chrome图标 –&gt; 属性 –&gt; 打开文件的所在位置 找到chrome.dll文件将chrome.dll文件拖入x64.dbg，会出现两个弹窗，其中黑色命令行弹窗不要关掉。如图：然后连续多次点击运行到用户代码按钮（我这里是连续点击6下），直至窗口标题处的模块变成chrome.dll：然后在主面板右键依次选择 搜索 –&gt; 当前模块 –&gt; 字符串：然后会打开一个搜索界面，等待模块搜索进度条100%也就是加载完毕：在搜索框输入ExtensionDeveloperModeWarning进行搜索，会搜到2条结果，双击第1个，跳转到反汇编界面，往上翻一点，找到cmp eax,2（也有可能是 cmp eax,3 ）：双击打开编辑页面，修改成cmp eax,9，然后点击确定，注意只需要点击一次确定即可，点击确定后它还是会继续弹出其它行的编辑界面，此时直接关闭对话框即可：修改完之后Ctrl+P导出修改过的dll文件（点击修补文件按钮就是导出dll文件）：然后把dll文件导出到任意其他位置，然后把原始chrome.dll文件==备份==（以免操作失误，否则只能重装Chrome），先关掉x64dbg，将刚刚导出的修补文件以chrome.dll命名然后覆盖原来的chrome.dll文件，重启Chrome，发现整个世界都清净了~~","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Chrome","slug":"Chrome","permalink":"https://www.xiongtianci.com/tags/Chrome/"}],"author":"天赐"},{"title":"黑马乐优商城","slug":"黑马乐优商城","date":"2019-05-07T03:50:27.000Z","updated":"2019-06-18T08:53:07.304Z","comments":true,"path":"2019/05/07/黑马乐优商城/","link":"","permalink":"https://www.xiongtianci.com/2019/05/07/黑马乐优商城/","excerpt":"","text":"链接：乐优商城（19 天+资料+源码+笔记）密码：java 本资源是博主在网上寻找乐优商城资料时，一位好人所赠 注意：找乐优商城资料的同学应该知道，乐优商城的视频有win和mac版本之分，此资源中的视频是mac版本。资料中的课件是完整的，但是与视频会有所出入 PS：如果链接失效，可通过左侧联系博主","categories":[{"name":"资源","slug":"资源","permalink":"https://www.xiongtianci.com/categories/资源/"}],"tags":[{"name":"黑马","slug":"黑马","permalink":"https://www.xiongtianci.com/tags/黑马/"},{"name":"乐优商城","slug":"乐优商城","permalink":"https://www.xiongtianci.com/tags/乐优商城/"}],"author":"天赐"},{"title":"navicat操作mysql的时候，如何输入null值？","slug":"navicat操作mysql的时候，如何输入null值？","date":"2019-05-05T03:47:07.000Z","updated":"2019-06-18T08:53:14.999Z","comments":true,"path":"2019/05/05/navicat操作mysql的时候，如何输入null值？/","link":"","permalink":"https://www.xiongtianci.com/2019/05/05/navicat操作mysql的时候，如何输入null值？/","excerpt":"","text":"使用右键或菜单栏中的编辑可以设置NULL值","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.xiongtianci.com/tags/Mysql/"},{"name":"Navicat","slug":"Navicat","permalink":"https://www.xiongtianci.com/tags/Navicat/"}],"author":"天赐"},{"title":"POI导入Excel异常Cannot get a text value from a numeric cell","slug":"POI导入Excel异常Cannot-get-a-text-value-from-a-numeric-cell","date":"2019-04-23T09:37:03.000Z","updated":"2019-06-18T08:53:22.639Z","comments":true,"path":"2019/04/23/POI导入Excel异常Cannot-get-a-text-value-from-a-numeric-cell/","link":"","permalink":"https://www.xiongtianci.com/2019/04/23/POI导入Excel异常Cannot-get-a-text-value-from-a-numeric-cell/","excerpt":"","text":"问题POI操作Excel时偶尔会出现Cannot get a text value from a numeric cell的异常错误 java.lang.IllegalStateException: Cannot get a text value from a numeric cell 异常原因：Excel数据cell有不同的类型，当我们试图从一个数字类型的Cell读取出一个字符串并写入数据库时，就会出现Cannot get a text value from a numeric cell的异常错误。 解决通过setCellType()设置cell类型，统一设置成String类型，然后再获取 Row row = sheet.getRow(i); for (int j = 0; j &lt; row.getPhysicalNumberOfCells(); j++) { // row.getCell(j).setCellType(Cell.CELL_TYPE_STRING); // String cellValue = row.getCell(j).getStringCellValue(); System.out.println(cellValue); }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"POI","slug":"POI","permalink":"https://www.xiongtianci.com/tags/POI/"},{"name":"Excel","slug":"Excel","permalink":"https://www.xiongtianci.com/tags/Excel/"}],"author":"天赐"},{"title":"电脑开机后弹窗提示下载名称是cc.png，来源是s3.amazonaws.com的文件","slug":"电脑开机后弹窗提示下载名称是cc-png，来源是s3-amazonaws-com的文件","date":"2019-04-19T01:27:45.000Z","updated":"2019-06-18T08:53:28.654Z","comments":true,"path":"2019/04/19/电脑开机后弹窗提示下载名称是cc-png，来源是s3-amazonaws-com的文件/","link":"","permalink":"https://www.xiongtianci.com/2019/04/19/电脑开机后弹窗提示下载名称是cc-png，来源是s3-amazonaws-com的文件/","excerpt":"","text":"问题电脑开机之后会自动弹窗提示让下载一个名称是cc.png，来源是s3.amazonaws.com的文件 解决网上查询后，了解到是因为我最近下载了Adobe Premiere，而破解工具有瑕疵的原因。网上的解决方案是将Adobe Creative Cloud的默认开机启动改成禁用即可，下面是解决步骤： 1、使用快捷键Ctrl + Shift + Esc打开任务管理器2、在启动中找到Adobe Creative Cloud3、右键，将其改为禁用即可","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"cc.png","slug":"cc-png","permalink":"https://www.xiongtianci.com/tags/cc-png/"}],"author":"天赐"},{"title":"IDEA运行SpringBoot项目控制台输出颜色高亮的日志","slug":"IDEA运行SpringBoot项目控制台输出颜色高亮的日志","date":"2019-04-16T08:43:18.000Z","updated":"2019-06-18T09:00:45.572Z","comments":true,"path":"2019/04/16/IDEA运行SpringBoot项目控制台输出颜色高亮的日志/","link":"","permalink":"https://www.xiongtianci.com/2019/04/16/IDEA运行SpringBoot项目控制台输出颜色高亮的日志/","excerpt":"","text":"问题有时IDEA运行SpringBoot项目，控制台Console输出的日志颜色为白色的 解决配置启动类application的相关参数，添加：-Dspring.output.ansi.enabled=ALWAYS","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.xiongtianci.com/tags/IDEA/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.xiongtianci.com/tags/SpringBoot/"}],"author":"天赐"},{"title":"win10日语输入法切换平片假名","slug":"win10日语输入法切换平片假名","date":"2019-04-16T07:45:21.000Z","updated":"2019-06-18T08:53:35.226Z","comments":true,"path":"2019/04/16/win10日语输入法切换平片假名/","link":"","permalink":"https://www.xiongtianci.com/2019/04/16/win10日语输入法切换平片假名/","excerpt":"","text":"1.切换平假名使用Ctrl + CapsLock切换至平假名输入 2.切换片假名使用Alt + CapsLock切换至片假名输入 3.切换英文输入使用Shift + CapsLock或Alt + ~切换至英文输入 4.语言切换使用win徽标键 + 空格在不同的输入法中切换使用Alt + Shift在输入语言之间切换","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"生活","slug":"生活","permalink":"https://www.xiongtianci.com/categories/生活/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://www.xiongtianci.com/tags/win10/"},{"name":"日语","slug":"日语","permalink":"https://www.xiongtianci.com/tags/日语/"}],"author":"天赐"},{"title":"Chrome历史版本下载","slug":"Chrome历史版本下载","date":"2019-04-01T02:23:02.000Z","updated":"2019-06-18T09:00:53.743Z","comments":true,"path":"2019/04/01/Chrome历史版本下载/","link":"","permalink":"https://www.xiongtianci.com/2019/04/01/Chrome历史版本下载/","excerpt":"","text":"Chrome历史版本","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Chrome","slug":"Chrome","permalink":"https://www.xiongtianci.com/tags/Chrome/"}],"author":"天赐"},{"title":"使用Twitter的Snowflake设置分布式自增长ID","slug":"使用Twitter的Snowflake设置分布式自增长ID","date":"2019-03-29T06:44:44.000Z","updated":"2019-06-18T09:01:02.887Z","comments":true,"path":"2019/03/29/使用Twitter的Snowflake设置分布式自增长ID/","link":"","permalink":"https://www.xiongtianci.com/2019/03/29/使用Twitter的Snowflake设置分布式自增长ID/","excerpt":"","text":"十次方项目工具类IdWorker.java描述：使用Twitter的Snowflake雪花算法设置分布式自增长ID import java.lang.management.ManagementFactory; import java.net.InetAddress; import java.net.NetworkInterface; /** * &lt;p&gt;名称：IdWorker.java&lt;/p&gt; * &lt;p&gt;描述：分布式自增长ID&lt;/p&gt; * &lt;pre&gt; * Twitter的 Snowflake JAVA实现方案 * &lt;/pre&gt; * 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用： * 1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000 * 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间， * 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识）， * 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。 * 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， * 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 * &lt;p&gt; * 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加)) * * @author Polim */ public class IdWorker { // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker() { this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); } /** * @param workerId 工作机器ID * @param datacenterId 序列号 */ public IdWorker(long workerId, long datacenterId) { if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.format(&quot;worker Id can&#39;t be greater than %d or less than 0&quot;, maxWorkerId)); } if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) { throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#39;t be greater than %d or less than 0&quot;, maxDatacenterId)); } this.workerId = workerId; this.datacenterId = datacenterId; } /** * 获取下一个ID * * @return */ public synchronized long nextId() { long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) { throw new RuntimeException(String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp)); } if (lastTimestamp == timestamp) { // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) { // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); } } else { sequence = 0L; } lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; } private long tilNextMillis(final long lastTimestamp) { long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) { timestamp = this.timeGen(); } return timestamp; } private long timeGen() { return System.currentTimeMillis(); } /** * &lt;p&gt; * 获取 maxWorkerId * &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) { StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) { /* * GET jvmPid */ mpid.append(name.split(&quot;@&quot;)[0]); } /* * MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); } /** * &lt;p&gt; * 数据标识id部分 * &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) { long id = 0L; try { InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) { id = 1L; } else { byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); } } catch (Exception e) { System.out.println(&quot; getDatacenterId: &quot; + e.getMessage()); } return id; } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Snowflake","slug":"Snowflake","permalink":"https://www.xiongtianci.com/tags/Snowflake/"},{"name":"自增ID","slug":"自增ID","permalink":"https://www.xiongtianci.com/tags/自增ID/"}],"author":"天赐"},{"title":"bat脚本中以管理员权限执行命令","slug":"bat脚本中以管理员权限执行命令","date":"2019-03-29T06:30:05.000Z","updated":"2019-06-18T09:01:16.153Z","comments":true,"path":"2019/03/29/bat脚本中以管理员权限执行命令/","link":"","permalink":"https://www.xiongtianci.com/2019/03/29/bat脚本中以管理员权限执行命令/","excerpt":"","text":"在bat脚本文件第一行加上下面命令： %1 mshta vbscript:CreateObject(“Shell.Application”).ShellExecute(“cmd.exe”,”/c %~s0 ::”,””,”runas”,1)(window.close)&amp;&amp;exit","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"bat","slug":"bat","permalink":"https://www.xiongtianci.com/tags/bat/"},{"name":"脚本","slug":"脚本","permalink":"https://www.xiongtianci.com/tags/脚本/"}],"author":"天赐"},{"title":"win10开机运行脚本文件","slug":"win10开机运行脚本文件","date":"2019-03-29T06:24:21.000Z","updated":"2019-06-18T09:01:09.958Z","comments":true,"path":"2019/03/29/win10开机运行脚本文件/","link":"","permalink":"https://www.xiongtianci.com/2019/03/29/win10开机运行脚本文件/","excerpt":"","text":"需求 有个bat脚本，希望电脑开机时自动执行此脚本 解决1、打开电脑目录：C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup2、将需要开机启动就执行的脚本放入此目录下3、重启电脑","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://www.xiongtianci.com/tags/win10/"},{"name":"脚本","slug":"脚本","permalink":"https://www.xiongtianci.com/tags/脚本/"}],"author":"天赐"},{"title":"SpringMVC注解@CrossOrigin解决跨域问题","slug":"SpringMVC注解@CrossOrigin解决跨域问题","date":"2019-03-27T01:51:27.000Z","updated":"2019-06-18T09:01:24.478Z","comments":true,"path":"2019/03/27/SpringMVC注解@CrossOrigin解决跨域问题/","link":"","permalink":"https://www.xiongtianci.com/2019/03/27/SpringMVC注解@CrossOrigin解决跨域问题/","excerpt":"","text":"一般的，只要网站的【协议名protocol】、【主机host】、【端口号port】这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用跨域：浏览同源策略的造成，是浏览器对JavaScript施加的安全限制CORS是一种可以解决跨域问题的技术 SprinMVC通过@CrossOrigin注解解决跨域 在Spring MVC4.2之后推出了@CrossOrigin注解来解决跨域问题，而在4.2之前我们都是通过定义注册过滤器的方式来解决跨域问题的 @CrossOrigin的参数：1、origins：允许可访问的域列表；*表示可以是任何来源2、maxAge：准备响应前的缓存持续的最大时间（单位：秒） @CrossOrigin使用在Controller层：1、类上，此类中所有方法启用跨域支持 // 开启跨域支持 @CrossOrigin @RestController @RequestMapping(&quot;/user&quot;) public class UserController { } 2、方法上，仅此方法启用跨域支持 // 开启跨域支持 @CrossOrigin @RequestMapping(value = &quot;/findAll&quot;, method = RequestMethod.GET) public List&lt;User&gt; findAll(){ return userService.findAll(); } 注意1、注解失效问题：此时Controlle的方法上@RequestMapping注解中需要声明请求方式即增加method=RequestMethod.XXX 2、添加注解后session失效问题：此时对的ajax请求中需要添加xhrFields:{withCredentials:true}（每个ajax中都需要加此属性，以保证session一致） $.ajax({ type: &quot;post&quot;, url: &#39;/user/login&#39;, xhrFields: {withCredentials: true}, data: { username: username, password: password }, success: function (msg) { console.log(&#39;登录成功&#39;); }, error: function (msg) { console.log(&#39;请求报错！&#39;); } })","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.xiongtianci.com/tags/SpringMVC/"},{"name":"CrossOrigin","slug":"CrossOrigin","permalink":"https://www.xiongtianci.com/tags/CrossOrigin/"},{"name":"跨域","slug":"跨域","permalink":"https://www.xiongtianci.com/tags/跨域/"}],"author":"天赐"},{"title":"win系统查看连接过的WIFI密码","slug":"win系统查看连接过的WIFI密码","date":"2019-03-26T10:22:36.000Z","updated":"2019-06-18T09:01:31.255Z","comments":true,"path":"2019/03/26/win系统查看连接过的WIFI密码/","link":"","permalink":"https://www.xiongtianci.com/2019/03/26/win系统查看连接过的WIFI密码/","excerpt":"","text":"1. win+R，输入cmd回车打开cmd窗口2. 输入下面命令显示电脑连接过的所有WIFI名：netsh wlan show profiles 在cmd中鼠标右键是粘贴 3. 输入下面命令查看WIFI密码：netsh wlan show profile name=&quot;WIFI名&quot; key=clear “WIFI名称”：使用英文状态下的双引号 在显示的内容中找到安全设置下的关键内容，即为WIFI密码","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://www.xiongtianci.com/tags/win10/"},{"name":"WIFI密码","slug":"WIFI密码","permalink":"https://www.xiongtianci.com/tags/WIFI密码/"}],"author":"天赐"},{"title":"Swagger异常：java.lang.NumberFormatException: For input string: ","slug":"Swagger异常：java-lang-NumberFormatException-For-input-string","date":"2019-03-25T06:36:14.000Z","updated":"2019-06-18T09:01:47.308Z","comments":true,"path":"2019/03/25/Swagger异常：java-lang-NumberFormatException-For-input-string/","link":"","permalink":"https://www.xiongtianci.com/2019/03/25/Swagger异常：java-lang-NumberFormatException-For-input-string/","excerpt":"","text":"问题项目整合Swagger，访问Swagger首页时后台抛出下面异常： i.s.m.p.AbstractSerializableParameter : Illegal DefaultValue null for parameter type integerjava.lang.NumberFormatException: For input string: “” 原因好像是说swagger2本身引用的swagger-models-1.5.20.jar有bug 解决导入下面的maven坐标： &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;version&gt;1.5.21&lt;/version&gt; &lt;/dependency&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Swagger","slug":"Swagger","permalink":"https://www.xiongtianci.com/tags/Swagger/"}],"author":"天赐"},{"title":"上传图片415异常：\"Content type 'multipart/form-data;' .... not supported\"","slug":"上传图片415异常：Content type 'multipartform-data;' ~not supported","date":"2019-03-25T02:23:04.000Z","updated":"2019-06-18T09:01:39.128Z","comments":true,"path":"2019/03/25/上传图片415异常：Content type 'multipartform-data;' ~not supported/","link":"","permalink":"https://www.xiongtianci.com/2019/03/25/上传图片415异常：Content type 'multipartform-data;' ~not supported/","excerpt":"","text":"问题 上传图片时报错：Content type ‘multipart/form-data;boundary=—-WebKitFormBoundarypOpfYxCGU6Q4sciA;charset=UTF-8’ not supported Controller层： @PostMapping(path = &quot;/uploadRotationImg&quot;) public ResponseEntity&lt;String&gt; uploadRotationImg(@RequestParam(&quot;photos&quot;) MultipartFile file, @RequestBody ImgRotation imgRotation) { try { // 进行上传操作 return imgRotationService.uploadRotationImg(file, imgRotation); } catch (Exception e) { // 上传失败 e.printStackTrace(); return new ResponseEntity&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); } } 解决去掉@RequestBody注解就行了 @PostMapping(path = &quot;/uploadRotationImg&quot;) public ResponseEntity&lt;String&gt; uploadRotationImg(@RequestParam(&quot;photos&quot;) MultipartFile file, ImgRotation imgRotation) { try { // 进行上传操作 return imgRotationService.uploadRotationImg(file, imgRotation); } catch (Exception e) { // 上传失败 e.printStackTrace(); return new ResponseEntity&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"415","slug":"415","permalink":"https://www.xiongtianci.com/tags/415/"}],"author":"天赐"},{"title":"@RequestParam和@RequestBody","slug":"@RequestParam和@RequestBody","date":"2019-03-22T07:51:52.000Z","updated":"2019-06-18T09:02:01.116Z","comments":true,"path":"2019/03/22/@RequestParam和@RequestBody/","link":"","permalink":"https://www.xiongtianci.com/2019/03/22/@RequestParam和@RequestBody/","excerpt":"","text":"一、@RequestParam GET和POST请求传的参数会自动转换赋值到@RequestParam所注解的变量上 &lt;form action=&quot;/requestParamDemo&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 用户昵称：&lt;input type=&quot;text&quot; name=&quot;usernick&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; @RequestMapping(value = &quot;/requestParamDemo&quot;, method = RequestMethod.GET) public void requestParamDemo(@RequestParam(value = &quot;username&quot;) String userName, @RequestParam(value = &quot;usernick&quot;) String userNick) { System.out.println(&quot;username: &quot; + userName); System.out.println(&quot;usernick: &quot; + userNick); } 二、@RequestBody @RequestBody注解可以接收json格式的数据，并将其转换成对应的数据类型 // 通过ajax发送json数据 { &quot;id&quot;:1, &quot;username&quot;:&quot;jack&quot;, &quot;password&quot;:&quot;1234&quot; } @RequestMapping(value=&quot;/requestBodyDemo&quot;, method = RequestMethod.POST) public void requestBodyDemo(@RequestBody User user){ System.out.println(&quot;id: &quot; + user.getId()); System.out.println(&quot;name: &quot; + user.getName()); System.out.println(&quot;password: &quot; + user.getPassword()); }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"RequestParam","slug":"RequestParam","permalink":"https://www.xiongtianci.com/tags/RequestParam/"},{"name":"RequestBody","slug":"RequestBody","permalink":"https://www.xiongtianci.com/tags/RequestBody/"}],"author":"天赐"},{"title":"MySQL中datetime类型的字段与JavaBean对应的类型","slug":"MySQL中datetime类型的字段与JavaBean对应的类型","date":"2019-03-22T03:50:18.000Z","updated":"2019-06-18T09:01:54.255Z","comments":true,"path":"2019/03/22/MySQL中datetime类型的字段与JavaBean对应的类型/","link":"","permalink":"https://www.xiongtianci.com/2019/03/22/MySQL中datetime类型的字段与JavaBean对应的类型/","excerpt":"","text":"MySQL数据库中时间格式为datetime类型的字段： JavaBean中对应字段的类型：import com.fasterxml.jackson.annotation.JsonFormat; import org.springframework.format.annotation.DateTimeFormat; // 如果到的是sql下的包(java.sql.Date)，get操作时封装的结果为null、put/post操作时会抛415异常 import java.util.Date; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone=&quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @ApiModelProperty(&quot;创建时间，格式：yyyy-MM-dd HH:mm:ss&quot;) private Date ctime; or import com.fasterxml.jackson.annotation.JsonFormat; import org.springframework.format.annotation.DateTimeFormat; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone=&quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @ApiModelProperty(&quot;创建时间，格式：yyyy-MM-dd HH:mm:ss&quot;) private String ctime;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"},{"name":"datetime","slug":"datetime","permalink":"https://www.xiongtianci.com/tags/datetime/"}],"author":"天赐"},{"title":"SpringBoot中MyBatis属性映射之开启驼峰命名","slug":"SpringBoot中MyBatis属性映射之开启驼峰命名","date":"2019-03-20T06:43:26.000Z","updated":"2019-06-18T09:02:08.408Z","comments":true,"path":"2019/03/20/SpringBoot中MyBatis属性映射之开启驼峰命名/","link":"","permalink":"https://www.xiongtianci.com/2019/03/20/SpringBoot中MyBatis属性映射之开启驼峰命名/","excerpt":"","text":"今天使用SpringBoot整合MyBatis开发时，发现从数据库中查询到的结果封装到javabean中，只要表中有下划线的字段，就会出现null值 MyBatis默认是属性名和数据库字段名一一对应的，即数据库表列：user_name实体类属性：user_name 但是java中一般使用驼峰命名数据库表列：user_name实体类属性：userName 在SpringBoot中，可以通过设置map-underscore-to-camel-case属性为true来开启驼峰功能： mybatis: configuration: map-underscore-to-camel-case: true # 开启驼峰命名","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://www.xiongtianci.com/tags/MyBatis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.xiongtianci.com/tags/SpringBoot/"},{"name":"驼峰命名","slug":"驼峰命名","permalink":"https://www.xiongtianci.com/tags/驼峰命名/"}],"author":"天赐"},{"title":"原生js修改textarea的值","slug":"原生js修改textarea的值","date":"2019-03-19T07:56:17.000Z","updated":"2019-06-18T09:02:14.862Z","comments":true,"path":"2019/03/19/原生js修改textarea的值/","link":"","permalink":"https://www.xiongtianci.com/2019/03/19/原生js修改textarea的值/","excerpt":"","text":"// 设置textarea的值 document.getElementById(&quot;goodstext_id&quot;).value = &quot;值&quot;;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.xiongtianci.com/tags/js/"},{"name":"textarea","slug":"textarea","permalink":"https://www.xiongtianci.com/tags/textarea/"}],"author":"天赐"},{"title":"js获取ModelAndView中的数据","slug":"js获取ModelAndView中的数据","date":"2019-03-19T07:47:05.000Z","updated":"2019-06-18T09:02:37.235Z","comments":true,"path":"2019/03/19/js获取ModelAndView中的数据/","link":"","permalink":"https://www.xiongtianci.com/2019/03/19/js获取ModelAndView中的数据/","excerpt":"","text":"后台封装： @GetMapping(&quot;/findById/{id}&quot;) public ModelAndView findById(@PathVariable(&quot;id&quot;) Integer id) { // 通过id查询商品 Goods dbgoods = goodsService.findById(id); // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); // 跳转到goods_editor.html页面 mv.setViewName(&quot;/goods/goods_editor&quot;); // 封装查询结果 mv.addObject(&quot;dbgoods&quot;,dbgoods); // return mv; } 前端获取： &lt;script th:inline=&quot;javascript&quot;&gt; // 需要添加 th:inline 才能访问 model 中的属性 window.onload = function () { console.log(&quot;页面加载完成&quot;); // 获取ModelAndView中的dbgoods对象 var dbgoods = [[${dbgoods}]]; // 打印 console.log(dbgoods); } &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.xiongtianci.com/tags/js/"},{"name":"ModelAndView","slug":"ModelAndView","permalink":"https://www.xiongtianci.com/tags/ModelAndView/"}],"author":"天赐"},{"title":"SpringBoot使用 thymeleaf+@RestController 跳转页面","slug":"SpringBoot使用-thymeleaf-RestController-跳转页面","date":"2019-03-19T02:19:37.000Z","updated":"2019-06-18T09:02:21.146Z","comments":true,"path":"2019/03/19/SpringBoot使用-thymeleaf-RestController-跳转页面/","link":"","permalink":"https://www.xiongtianci.com/2019/03/19/SpringBoot使用-thymeleaf-RestController-跳转页面/","excerpt":"","text":"thymeleaf推荐使用@Controller进行页面跳转如果用@RestController，则可以通过ModelAndView进行页面跳转eg /** * 跳转到goods_editor.html页面 * @return */ @GetMapping(&quot;/goodsEditor&quot;) public ModelAndView goodsEditor(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;/goods/goods_editor&quot;); return mv; }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.xiongtianci.com/tags/SpringBoot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://www.xiongtianci.com/tags/thymeleaf/"},{"name":"RestController","slug":"RestController","permalink":"https://www.xiongtianci.com/tags/RestController/"}],"author":"天赐"},{"title":"org.xml.sax.SAXParseException: 元素类型 \"link\" 必须由匹配的结束标记 \"</link>\" 终止","slug":"org-xml-sax-SAXParseException-元素类型link必须由匹配的结束标记link终止","date":"2019-03-19T02:02:05.000Z","updated":"2019-06-18T09:02:30.229Z","comments":true,"path":"2019/03/19/org-xml-sax-SAXParseException-元素类型link必须由匹配的结束标记link终止/","link":"","permalink":"https://www.xiongtianci.com/2019/03/19/org-xml-sax-SAXParseException-元素类型link必须由匹配的结束标记link终止/","excerpt":"","text":"问题SpringBoot使用thymeleaf模板引擎时报错： org.xml.sax.SAXParseException: 元素类型 “link” 必须由匹配的结束标记 “&lt;&#47;link&gt;” 终止 or org.xml.sax.SAXParseException: 元素类型 “meta” 必须由匹配的结束标记 “&lt;&#47;meta&gt;” 终止 解决解决方法是在pom.xml文件中指定具体的thymeleaf版本具体如下 &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!--添加下面两项指定thymeleaf的版本--&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.0.5&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"}],"author":"天赐"},{"title":"通过MyBatis向MySQL中插入数据时中文乱码","slug":"通过MyBatis向MySQL中插入数据时中文乱码","date":"2019-03-18T06:20:50.000Z","updated":"2019-06-18T09:02:43.483Z","comments":true,"path":"2019/03/18/通过MyBatis向MySQL中插入数据时中文乱码/","link":"","permalink":"https://www.xiongtianci.com/2019/03/18/通过MyBatis向MySQL中插入数据时中文乱码/","excerpt":"","text":"问题：通过MyBatis向MySQL中插入或更新操作时，中文会显示成??? 解决：在配置文件application.yml中连接数据库的地址url后面加上characterEncoding=utf8即可 spring: application: name: server # 服务名称 datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db?characterEncoding=utf8 username: root # 数据库账号 password: root # 数据库密码","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://www.xiongtianci.com/tags/MyBatis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"},{"name":"乱码","slug":"乱码","permalink":"https://www.xiongtianci.com/tags/乱码/"}],"author":"天赐"},{"title":"A component required a bean of type 'com.renqijie.dao.SellerMapper' that could not be found.","slug":"A-component-required-a-bean-of-type-com-renqijie-dao-SellerMapper-that-could-not-be-found","date":"2019-03-14T09:53:11.000Z","updated":"2019-06-18T09:02:57.058Z","comments":true,"path":"2019/03/14/A-component-required-a-bean-of-type-com-renqijie-dao-SellerMapper-that-could-not-be-found/","link":"","permalink":"https://www.xiongtianci.com/2019/03/14/A-component-required-a-bean-of-type-com-renqijie-dao-SellerMapper-that-could-not-be-found/","excerpt":"","text":"异常：Description:A component required a bean of type ‘com.renqijie.dao.SellerMapper’ that could not be found. 原因：dao层接口SellerMapper未加注解`@org.apache.ibatis.annotations.Mapper`","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"}],"author":"天赐"},{"title":"org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON","slug":"org-springframework-http-converter-HttpMessageNotWritableException-Could-not-write-JSON","date":"2019-03-14T03:52:15.000Z","updated":"2019-06-18T09:02:51.356Z","comments":true,"path":"2019/03/14/org-springframework-http-converter-HttpMessageNotWritableException-Could-not-write-JSON/","link":"","permalink":"https://www.xiongtianci.com/2019/03/14/org-springframework-http-converter-HttpMessageNotWritableException-Could-not-write-JSON/","excerpt":"","text":"记一次踩坑经历：Resolved [org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: (was java.lang.NullPointerException); nested exception is com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: com.renqijie.pojo.vo.IndexBean[&quot;images&quot;]-&gt;java.util.ArrayList[0]-&gt;com.renqijie.pojo.Image[&quot;id&quot;])] 原因：JavaBean类Image中有一个属性类型刚开始设置成int类型，生成getter/setter方法后，又将其改成了Integer类型，结果就出现了上述情况","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"}],"author":"天赐"},{"title":"小程序用户表wx_user设计","slug":"小程序用户表wx-user设计","date":"2019-03-13T02:07:05.000Z","updated":"2019-06-18T09:03:03.679Z","comments":true,"path":"2019/03/13/小程序用户表wx-user设计/","link":"","permalink":"https://www.xiongtianci.com/2019/03/13/小程序用户表wx-user设计/","excerpt":"","text":"CREATE TABLE `wx_user` ( `id` int(20) NOT NULL AUTO_INCREMENT, `openid` varchar(28) DEFAULT NULL COMMENT &#39;小程序用户的openid&#39;, `nickname` varchar(100) DEFAULT NULL COMMENT &#39;用户头像&#39;, `avatarurl` varchar(100) DEFAULT NULL COMMENT &#39;用户头像&#39;, `gender` tinyint(1) DEFAULT NULL COMMENT &#39;性别 0-男、1-女&#39;, `country` varchar(100) DEFAULT NULL COMMENT &#39;所在国家&#39;, `province` varchar(100) DEFAULT NULL COMMENT &#39;省份&#39;, `city` varchar(100) DEFAULT NULL COMMENT &#39;城市&#39;, `language` varchar(100) DEFAULT NULL COMMENT &#39;语种&#39;, `ctime` datetime DEFAULT NULL COMMENT &#39;创建/注册时间&#39;, `mobile` varchar(50) DEFAULT NULL COMMENT &#39;手机号码&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;小程序用户表&#39;;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://www.xiongtianci.com/tags/小程序/"}],"author":"天赐"},{"title":"查看CentOS版本信息","slug":"查看CentOS版本信息","date":"2019-03-12T02:37:43.000Z","updated":"2019-06-18T09:03:09.732Z","comments":true,"path":"2019/03/12/查看CentOS版本信息/","link":"","permalink":"https://www.xiongtianci.com/2019/03/12/查看CentOS版本信息/","excerpt":"","text":"指令：cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://www.xiongtianci.com/tags/CentOS/"}],"author":"天赐"},{"title":"Java操作MongoDB之mongodb-driver","slug":"Java操作MongoDB之mongodb-driver","date":"2019-02-27T13:11:45.000Z","updated":"2019-06-18T09:03:18.318Z","comments":true,"path":"2019/02/27/Java操作MongoDB之mongodb-driver/","link":"","permalink":"https://www.xiongtianci.com/2019/02/27/Java操作MongoDB之mongodb-driver/","excerpt":"","text":"mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。通过一个入门的案例来了解mongodb-driver的基本使用： 1、查询全部记录1.1、创建工程mongoDemo，引入依赖&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt; &lt;version&gt;3.6.3&lt;/version&gt; &lt;/dependency&gt; 1.2、创建测试类public class MongoDemo1 { public static void main(String[] args) { // 创建连接 MongoClient client = new MongoClient(&quot;192.168.206.128&quot;); // 打开数据库spitdb MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 获取集合 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 查询记录，获取文档集 FindIterable&lt;Document&gt; documents = spit.find(); // 循环遍历 for (Document document : documents) { System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;)); System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;)); System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;)); } // 关闭连接 client.close(); } } 2、条件查询BasicDBObject对象：表示一个具体的记录，BasicDBObject实现了DBObject，是key/value的数据结构，用起来和HashMap是基本一致的。 2.1、查询userid为1013的记录public class MongoDemo1 { public static void main(String[] args) { // 创建连接 MongoClient client = new MongoClient(&quot;192.168.206.128&quot;); // 打开数据库spitdb MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 获取集合 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 构建查询条件，通过userid进行查询 BasicDBObject bson = new BasicDBObject(&quot;userid&quot;, &quot;1013&quot;); // 通过userid查询记录获取文档集 FindIterable&lt;Document&gt; documents = spit.find(bson); // 循环遍历 for (Document document : documents) { System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;)); System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;)); System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;)); } // 关闭连接 client.close(); } } 2.2、查询浏览量大于1000的记录public class MongoDemo2 { public static void main(String[] args) { // 创建连接 MongoClient client = new MongoClient(&quot;192.168.206.128&quot;); // 打开数据库spitdb MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 获取集合 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 构建查询条件，查询visits大于1000的结果 BasicDBObject bson = new BasicDBObject(&quot;visits&quot;, new BasicDBObject(&quot;$gt&quot;, 1000)); // 通过userid查询记录获取文档集 FindIterable&lt;Document&gt; documents = spit.find(bson); // 循环遍历 for (Document document : documents) { System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;)); System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;)); System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;)); } // 关闭连接 client.close(); } } 3、插入数据public class MongoDemo3 { public static void main(String[] args) { // 创建连接 MongoClient client = new MongoClient(&quot;192.168.206.128&quot;); // 打开数据库spitdb MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 获取集合 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 准备数据 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;content&quot;, &quot;我要吐槽&quot;); map.put(&quot;userid&quot;, &quot;9999&quot;); map.put(&quot;visits&quot;, 123); map.put(&quot;publishtime&quot;, new Date()); // Document document = new Document(map); // 插入一条数据 spit.insertOne(document); // 关闭连接 client.close(); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.xiongtianci.com/tags/MongoDB/"}],"author":"天赐"},{"title":"使用SpringCache进行缓存数据库查询","slug":"使用SpringCache进行缓存数据库查询","date":"2019-02-26T10:14:18.000Z","updated":"2019-06-18T09:03:32.020Z","comments":true,"path":"2019/02/26/使用SpringCache进行缓存数据库查询/","link":"","permalink":"https://www.xiongtianci.com/2019/02/26/使用SpringCache进行缓存数据库查询/","excerpt":"","text":"1、在SpringBoot的启动类上添加注解@EnableCaching，开启SpringCache缓存支持 @SpringBootApplication // 开启SpringCache缓存支持 @EnableCaching public class GatheringApplication { public static void main(String[] args) { SpringApplication.run(GatheringApplication.class, args); } } 2、在service的方法上添加对应的注解 /** * 根据ID查询 * * @param id * @return */ // 使用SpringCache进行缓存数据库查询 @Cacheable(value = &quot;gathering&quot;, key = &quot;#id&quot;) public Gathering findById(String id) { return gatheringDao.findById(id).get(); } /** * 修改 * * @param gathering */ // 修改数据库数据后需要删除redis中的缓存 @CacheEvict(value = &quot;gathering&quot;, key = &quot;#gathering.id&quot;) public void update(Gathering gathering) { gatheringDao.save(gathering); } /** * 删除 * * @param id */ // 删除数据库数据后需要删除redis中的缓存 @CacheEvict(value = &quot;gathering&quot;, key = &quot;#id&quot;) public void deleteById(String id) { gatheringDao.deleteById(id); }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://www.xiongtianci.com/tags/缓存/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://www.xiongtianci.com/tags/SpringCache/"}],"author":"天赐"},{"title":"MYSQL:WARN: Establishing SSL connection without server's identity verification is not recommended.","slug":"MYSQL-WARN-Establishing-SSL-connection-without-server-s-identity-verification-is-not-recommended","date":"2019-02-26T09:46:40.000Z","updated":"2019-06-18T09:00:08.264Z","comments":true,"path":"2019/02/26/MYSQL-WARN-Establishing-SSL-connection-without-server-s-identity-verification-is-not-recommended/","link":"","permalink":"https://www.xiongtianci.com/2019/02/26/MYSQL-WARN-Establishing-SSL-connection-without-server-s-identity-verification-is-not-recommended/","excerpt":"","text":"连接MySQL数据库时抛出警告：Tue Feb 26 17:38:27 CST 2019 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.这是Mysql数据库的SSL连接问题，提示警告不建议使用没有带服务器身份验证的SSL连接，是在MYSQL5.5.45+, 5.6.26+ and 5.7.6+版本中才有的这个问题 解决在配置文件application.yml中连接数据库的url后添加useSSL=false即可 spring datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.206.128:3306/tensquare_article?characterEncoding=utf8&amp;useSSL=false username: root password: ....","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"SpringDataRedis常用方法","slug":"SpringDataRedis常用方法","date":"2019-02-26T09:30:15.000Z","updated":"2019-06-18T09:00:25.330Z","comments":true,"path":"2019/02/26/SpringDataRedis常用方法/","link":"","permalink":"https://www.xiongtianci.com/2019/02/26/SpringDataRedis常用方法/","excerpt":"","text":"// 向redis里存入数据和设置缓存时间 stringRedisTemplate.opsForValue().set(&quot;test&quot;, &quot;100&quot;, 60 * 10, TimeUnit.SECONDS); // 根据key获取缓存中的val stringRedisTemplate.opsForValue().get(&quot;test&quot;); // val做-1操作 stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(-1); // val +1 stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(1); // 根据key获取过期时间 stringRedisTemplate.getExpire(&quot;test&quot;); // 根据key获取过期时间并换算成指定单位 stringRedisTemplate.getExpire(&quot;test&quot;, TimeUnit.SECONDS); // 根据key删除缓存 stringRedisTemplate.delete(&quot;test&quot;); // 检查key是否存在，返回boolean值 stringRedisTemplate.hasKey(&quot;546545&quot;); // 设置过期时间 stringRedisTemplate.expire(&quot;red_123&quot;, 1000, TimeUnit.MILLISECONDS); // 向指定key中存放set集合 stringRedisTemplate.opsForSet().add(&quot;red_123&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;); // 根据key查看集合中是否存在指定数据 stringRedisTemplate.opsForSet().isMember(&quot;red_123&quot;, &quot;1&quot;); // 根据key获取set集合 stringRedisTemplate.opsForSet().members(&quot;red_123&quot;);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringDataRedis","slug":"SpringDataRedis","permalink":"https://www.xiongtianci.com/tags/SpringDataRedis/"}],"author":"天赐"},{"title":"SpringBoot整合Redis进行缓存数据库查询","slug":"SpringBoot整合Redis进行缓存数据库查询","date":"2019-02-26T08:30:10.000Z","updated":"2019-06-18T09:00:18.103Z","comments":true,"path":"2019/02/26/SpringBoot整合Redis进行缓存数据库查询/","link":"","permalink":"https://www.xiongtianci.com/2019/02/26/SpringBoot整合Redis进行缓存数据库查询/","excerpt":"","text":"1、导入redis的启动器 &lt;!--redis启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、在yml配置文件中配置redis连接信息 spring: redis: host: 192.168.206.128 3、在service中通过RedisTemplate操作redis，使用redis进行缓存数据库查询 /** * 根据ID查询 * * @param id * @return */ public Article findById(String id) { // 从redis缓存中提取数据 Article article = (Article) redisTemplate.opsForValue().get(&quot;article_&quot; + id); // 如果缓存中没有，则从数据库中查询并放入缓存中 if(article == null){ article = articleDao.findById(id).get(); redisTemplate.opsForValue().set(&quot;article_&quot; + id, article); } // 返回从redis缓存中获得的数据 return article; } 4、对数据库进行删除或修改后删除redis中的缓存 /** * 修改 * * @param article */ public void update(Article article) { // 删除redis中的缓存 redisTemplate.delete(&quot;article_&quot; + article.getId()); // 修改操作 articleDao.save(article); } /** * 删除 * * @param id */ public void deleteById(String id) { // 删除redis缓存数据 redisTemplate.delete(&quot;article_&quot; + id); // 删除操作 articleDao.deleteById(id); } 5、缓存过期处理 // 设置缓存过期时间为1天 redisTemplate.opsForValue().set(&quot;article_&quot; + id, article, 1, TimeUnit.DAYS);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.xiongtianci.com/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"https://www.xiongtianci.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"https://www.xiongtianci.com/tags/缓存/"}],"author":"天赐"},{"title":"使用Spring Data JPA报错：javax.persistence.TransactionRequiredException: Executing an update/delete query","slug":"使用Spring-Data-JPA报错：javax-persistence-TransactionRequiredException-Executing-an-update-delete-query","date":"2019-02-26T06:18:54.000Z","updated":"2019-06-18T09:03:24.718Z","comments":true,"path":"2019/02/26/使用Spring-Data-JPA报错：javax-persistence-TransactionRequiredException-Executing-an-update-delete-query/","link":"","permalink":"https://www.xiongtianci.com/2019/02/26/使用Spring-Data-JPA报错：javax-persistence-TransactionRequiredException-Executing-an-update-delete-query/","excerpt":"","text":"Caused by: javax.persistence.TransactionRequiredException: Executing an update/delete query at org.hibernate.query.internal.AbstractProducedQuery.executeUpdate(AbstractProducedQuery.java:1496) 1、 报错原因：SpringData JPA事务导致的异常2、解决：在Service层添加注解@Transactional进行事务管理","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"},{"name":"JPA","slug":"JPA","permalink":"https://www.xiongtianci.com/tags/JPA/"}],"author":"天赐"},{"title":"服务器重启后，Docker安装的mysql怎么重启？","slug":"服务器重启后，Docker安装的mysql怎么重启？","date":"2019-02-26T00:51:59.000Z","updated":"2019-06-18T09:03:38.634Z","comments":true,"path":"2019/02/26/服务器重启后，Docker安装的mysql怎么重启？/","link":"","permalink":"https://www.xiongtianci.com/2019/02/26/服务器重启后，Docker安装的mysql怎么重启？/","excerpt":"","text":"1、重启Docker [root@pinyoyougou-docker ~]# sudo systemctl start docker 2、列出Docker中创建的容器 [root@pinyoyougou-docker ~]# docker ps -a 3、启动mysql [root@pinyoyougou-docker ~]# docker restart 3815a718c8b5 4、查看是否启动成功 [root@pinyoyougou-docker ~]# docker ps","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.xiongtianci.com/tags/Docker/"}],"author":"天赐"},{"title":"IDEA开启Run Dashboard的配置","slug":"IDEA开启Run Dashboard的配置","date":"2019-02-25T01:52:08.000Z","updated":"2019-06-18T09:00:01.310Z","comments":true,"path":"2019/02/25/IDEA开启Run Dashboard的配置/","link":"","permalink":"https://www.xiongtianci.com/2019/02/25/IDEA开启Run Dashboard的配置/","excerpt":"","text":"Run Dashboard面板：IDEA升级到 2017.3.1 版本后，发现找不到Run Dashboard面板了。通过下面步骤教你找回Run Dashboard： 1. 找到.idea文件下的workspace.xml，通过Ctrl+F搜索RunDashboard 2. 加入如下配置，重启服务，Run Dashboard就自动就弹出来了&lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot;/&gt; &lt;/set&gt; &lt;/option&gt; 3. 最终配置如下：最终配置如下：&lt;component name=&quot;RunDashboard&quot;&gt; &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name=&quot;ruleStates&quot;&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt; &lt;option name=&quot;contentProportion&quot; value=&quot;0.20013662&quot; /&gt; &lt;/component&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://www.xiongtianci.com/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.xiongtianci.com/tags/IDEA/"},{"name":"RunDashboard","slug":"RunDashboard","permalink":"https://www.xiongtianci.com/tags/RunDashboard/"}],"author":"天赐"},{"title":"Java中List集合去重的几种方式","slug":"Java中List集合去重的几种方式","date":"2019-02-19T00:52:35.000Z","updated":"2019-06-18T08:59:53.531Z","comments":true,"path":"2019/02/19/Java中List集合去重的几种方式/","link":"","permalink":"https://www.xiongtianci.com/2019/02/19/Java中List集合去重的几种方式/","excerpt":"","text":"准备数据： // 准备数据 List&lt;String&gt; list = new ArrayList(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); list.add(&quot;b&quot;); list.add(&quot;a&quot;); 1. 利用HashSet去重// 利用list中的元素创建HashSet集合，此时set中进行了去重操作 HashSet set = new HashSet(list); // 清空list集合 list.clear(); // 将去重后的元素重新添加到list中 list.addAll(set); 2. 通过List的contains()方法去重// 创建一个新的list集合，用于存储去重后的元素 List listTemp = new ArrayList(); // 遍历list集合 for (int i = 0; i &lt; list.size(); i++) { // 判断listTemp集合中是否包含list中的元素 if (!listTemp.contains(list.get(i))) { // 将未包含的元素添加进listTemp集合中 listTemp.add(list.get(i)); } } 3. 循环List进行去重// 从list中索引为0开始往后遍历 for (int i = 0; i &lt; list.size() - 1; i++) { // 从list中索引为 list.size()-1 开始往前遍历 for (int j = list.size() - 1; j &gt; i; j--) { // 进行比较 if (list.get(j).equals(list.get(i))) { // 去重 list.remove(j); } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"List","slug":"List","permalink":"https://www.xiongtianci.com/tags/List/"}],"author":"天赐"},{"title":"关闭迅雷更新到新版本的提示","slug":"关闭迅雷更新到新版本的提示","date":"2019-01-17T00:36:39.000Z","updated":"2019-06-18T08:59:45.942Z","comments":true,"path":"2019/01/17/关闭迅雷更新到新版本的提示/","link":"","permalink":"https://www.xiongtianci.com/2019/01/17/关闭迅雷更新到新版本的提示/","excerpt":"","text":"每次打开迅雷都会自动检查是否是最新版本，如果不是最新版本，迅雷会一直重复弹窗弹出更新到新版本的提示： 解决方案简介：迅雷提示升级是因为每次迅雷主程序启动时都会同时启动一个叫XLLiveUD.exe的程序，这个程序会检查更新，所以如果不想让他检查更新，就只需要把他替换掉就可以了（因为如果删除它，每次迅雷启动时都会弹出一个错误对话框，提示找不到文件XLLiveUD.exe） 进入迅雷安装目录，找到XLLiveUD.exe( 可直接在迅雷安装目录中搜索这个文件 )，将其删除。这个就是自动升级的程序，但是删除之后下次开启迅雷会提示该文件丢失。 在同一个目录找到迅雷执行程序文件Thunder.exe，这个是就是迅雷桌面快捷方式指到的程序也就是迅雷开启程序。然后复制拷贝Thunder.exe副本，然后将副本文件名更改为迅雷更新执行程序名：XLLiveUD.exe 当迅雷程序调用检查更新的执行文件时，实际上相当于重复点击打开迅雷，而迅雷本身不允许重复打开。这样既不会报错也不会造成重复弹屏的问题。从而算是比较完美的解决了关闭迅雷更新到新版本提示的问题(❁´◡`❁)✲ﾟ","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"迅雷","slug":"迅雷","permalink":"https://www.xiongtianci.com/tags/迅雷/"}],"author":"天赐"},{"title":"XMind8 破解激活教程（win系统）","slug":"XMind8-破解激活教程（win系统）","date":"2019-01-12T05:08:50.000Z","updated":"2019-06-18T08:59:39.334Z","comments":true,"path":"2019/01/12/XMind8-破解激活教程（win系统）/","link":"","permalink":"https://www.xiongtianci.com/2019/01/12/XMind8-破解激活教程（win系统）/","excerpt":"","text":"下载资源链接：XMind8+破解补丁密码：6666 破解安装好XMind8后，接下来进行破解 将破解补丁中的XMindCrack.jar拷贝到一个目录下( 注意：这个位置要是一个不会移动的位置，我就复制在XMind的安装目录下 )，如图 ： 修改XMind的配置文件打开XMind的配置文件XMind.ini，增加内容：-javaagent:刚刚XMindCrack.jar放置的位置 修改电脑的hosts文件，切断Xmind访问网络hosts文件目录：C:\\Windows\\System32\\drivers\\etc添加内容：0.0.0.0 www.xmind.net 添加序列号启动XMind，在帮助里面找到序列号，填写序列号邮箱任意，将破解补丁内序列号.txt文件中的内容复制到序列号中，点击验证出现下面内容证明激活成功了ヾ(๑╹◡╹)ﾉ”ヾ(●´∀｀●)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"XMind","slug":"XMind","permalink":"https://www.xiongtianci.com/tags/XMind/"}],"author":"天赐"},{"title":"连接Oracle报错 ORA-12638: 身份证明检索失败","slug":"连接Oracle报错-ORA-12638-身份证明检索失败","date":"2019-01-08T01:26:18.000Z","updated":"2019-06-18T08:59:33.318Z","comments":true,"path":"2019/01/08/连接Oracle报错-ORA-12638-身份证明检索失败/","link":"","permalink":"https://www.xiongtianci.com/2019/01/08/连接Oracle报错-ORA-12638-身份证明检索失败/","excerpt":"","text":"问题连接Oracle数据库时报错：ORA-12638: 身份证明检索失败 C:\\Users\\***&gt;sqlplus scott/tiger@192.168.56.103:1521/orcl SQL*Plus: Release 10.2.0.1.0 - Production on 星期二 1月 8 09:13:18 2019 Copyright (c) 1982, 2005, Oracle. All rights reserved. ERROR: ORA-12638: 身份证明检索失败 解决将oracle安装路径oracle\\product\\10.2.0\\db_1\\NETWORK\\ADMIN\\sqlnet.ora 文件修改一下把文件中的：SQLNET.AUTHENTICATION_SERVICES= (NTS)修改为：SQLNET.AUTHENTICATION_SERVICES= (BEQ,NONE) 修改前： # sqlnet.ora Network Configuration File: C:\\oracle\\product\\10.2.0\\db_1\\network\\admin\\sqlnet.ora # Generated by Oracle configuration tools. # This file is actually generated by netca. But if customers choose to # install &quot;Software Only&quot;, this file wont exist and without the native # authentication, they will not be able to connect to the database on NT. SQLNET.AUTHENTICATION_SERVICES= (NTS) NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT) 修改后： # sqlnet.ora Network Configuration File: C:\\oracle\\product\\10.2.0\\db_1\\network\\admin\\sqlnet.ora # Generated by Oracle configuration tools. # This file is actually generated by netca. But if customers choose to # install &quot;Software Only&quot;, this file wont exist and without the native # authentication, they will not be able to connect to the database on NT. SQLNET.AUTHENTICATION_SERVICES= (BEQ,NONE) NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"},{"name":"Oracle","slug":"Oracle","permalink":"https://www.xiongtianci.com/tags/Oracle/"}],"author":"天赐"},{"title":"try和finally中都有return语句，执行哪一个return？","slug":"try和finally中都有return语句，执行哪一个return？","date":"2019-01-07T09:51:07.000Z","updated":"2019-06-18T08:59:19.411Z","comments":true,"path":"2019/01/07/try和finally中都有return语句，执行哪一个return？/","link":"","permalink":"https://www.xiongtianci.com/2019/01/07/try和finally中都有return语句，执行哪一个return？/","excerpt":"","text":"try 中的 return 语句调用的函数先于 finally 中调用的函数执行，也就是说 try 中的 return 语句先执行，finally 语句后执行，但try中的 return 并不是让函数马上返回结果，而是 return 语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行 finally 语句后才真正开始返回。但此时会出现两种情况：① 如果finally中也有return，则会直接返回finally中的return结果，并终止程序，函数栈中的return不会被完成② 如果finally中没有return，则在执行完finally中的代码之后，会将函数栈中保存的try return的内容返回并终止程序 注意： 1、不管有没有出现异常，finally块中代码都会执行2、当try和catch中有return时，finally仍然会执行3、finally是在try中return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"try{ return }finally{}中的return","slug":"try{return}finally{}中的return","date":"2019-01-07T08:57:57.000Z","updated":"2019-06-18T08:59:12.430Z","comments":true,"path":"2019/01/07/try{return}finally{}中的return/","link":"","permalink":"https://www.xiongtianci.com/2019/01/07/try{return}finally{}中的return/","excerpt":"","text":"try 中的 return 语句调用的函数先于 finally 中调用的函数执行，也就是说 return 语句先执行，finally 语句后执行，但 return 并不是让函数马上返回结果，而是 return 语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回结果，它要执行 finally 语句后才真正开始返回，，但此时finally块中的代码已经影响不了return返回的值了 public class Demo { public static void main(String[] args) { System.out.println(num()); } public static int num(){ int i = 0; try { i = 1; return i; }catch (Exception e){ }finally { i = 2; } return i; } } 打印结果：1 返回的是基本数据类型，直接返回值 public class Demo { public static void main(String[] args) { System.out.println(num().getI()); } public static Test num() { Test t = new Test(); try { t.setI(1); return t; } catch (Exception e) { } finally { t.setI(2); } return t; } } class Test{ private int i ; public int getI() { return i; } public void setI(int i) { this.i = i; } } 打印结果：2 返回的是对象的引用","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？","slug":"什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？","date":"2019-01-07T07:43:22.000Z","updated":"2019-06-18T08:59:25.745Z","comments":true,"path":"2019/01/07/什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？/","link":"","permalink":"https://www.xiongtianci.com/2019/01/07/什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？/","excerpt":"","text":"一、什么是java虚拟机？java虚拟机(Java Virtual Machine 即 JVM)是执行字节码文件(.class)的虚拟机进程。java源程序(.java)被编译器编译成字节码文件(.class)。然后字节码文件，将由java虚拟机，解释成机器码(不同平台的机器码不同)。利用机器码操作硬件和操作系统 二、为什么java被称为平台无关的编程语言？因为不同的平台装有不同的JVM，它们能够将相同的.class文件，解释成不同平台所需要的机器码。正是因为有JVM的存在，java被称为平台无关的编程语言","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://www.xiongtianci.com/tags/虚拟机/"}],"author":"天赐"},{"title":"MySQL存储引擎","slug":"MySQL存储引擎","date":"2019-01-07T06:47:36.000Z","updated":"2019-06-18T08:59:06.965Z","comments":true,"path":"2019/01/07/MySQL存储引擎/","link":"","permalink":"https://www.xiongtianci.com/2019/01/07/MySQL存储引擎/","excerpt":"","text":"存储引擎概述MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。例如，如果你在研究大量的临时数据，你也许需要使用内存MySQL存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。这些不同的技术以及配套的相关功能在 MySQL中被称作存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活性。 MySQL存储引擎种类 存储引擎 特点 InnoDB 5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢 MyISAM 高速引擎，拥有较高的插入，查询速度，但不支持事务 Memory 内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失 Falcon 一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者 Archive 将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作 CSV CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"如何控制多线程执行顺序","slug":"如何控制多线程执行顺序","date":"2019-01-05T03:03:06.000Z","updated":"2019-06-18T08:58:55.379Z","comments":true,"path":"2019/01/05/如何控制多线程执行顺序/","link":"","permalink":"https://www.xiongtianci.com/2019/01/05/如何控制多线程执行顺序/","excerpt":"","text":"现象public class Test02 { static Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;thread1&quot;); } }); static Thread thread2 = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;thread2&quot;); } }); static Thread thread3 = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;thread3&quot;); } }); public static void main(String[] args) { thread1.start(); thread2.start(); thread3.start(); } } 上面的代码执行结果： // 线程执行顺序是随机的 thread1 thread3 thread2 原因：start()方法只是让子线程处于就绪状态，最终执行状态是不可控的 解决方案方案一：使用join控制多线程执行顺序 join()：让主线程等待子线程结束以后才能继续运行 public static void main(String[] args) throws Exception { thread1.start(); thread1.join(); // 让主线程放弃cpu执行权，让给子线程执行 thread2.start(); thread2.join(); thread3.start(); } 结果： thread1 thread2 thread3 join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll( 调用了JVM底层lock.notify_all(thread)方法来唤醒 )方法唤醒A线程，从而达到同步的目的 jion()源码： public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException(&quot;timeout value is negative&quot;); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } } 最终是调用object的wait方法 public final native void wait(long timeout) throws InterruptedException; join()的调用位于main Thread的main()中，所以这里当然就是阻塞main Thread了。所以thread1.join()调用后，main Thread会阻塞起来。 方案二：利用单线程化线程池(newSingleThreadExecutor)串行执行所有任务利用并发包里的Excutors的newSingleThreadExecuto产生一个单线程的线程池，而这个线程池的底层原理就是一个先进先出（FIFO）的队列。代码中executor.submit依次添加了123线程，按照FIFO的特性，执行顺序也就是123的执行结果，从而保证了执行顺序 static ExecutorService executorService = Executors.newSingleThreadExecutor(); public static void main(String[] args) throws Exception { executorService.submit(thread1); executorService.submit(thread2); executorService.submit(thread3); executorService.shutdown(); }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"https://www.xiongtianci.com/tags/多线程/"}],"author":"天赐"},{"title":"为什么 1000==1000 返回为false，而 100==100 会返回为true","slug":"为什么1000==1000返回为false，而100==100会返回为true","date":"2019-01-05T01:39:06.000Z","updated":"2019-06-18T08:59:01.145Z","comments":true,"path":"2019/01/05/为什么1000==1000返回为false，而100==100会返回为true/","link":"","permalink":"https://www.xiongtianci.com/2019/01/05/为什么1000==1000返回为false，而100==100会返回为true/","excerpt":"","text":"现象Integer a = 1000, b = 1000; System.out.println(a == b);//false Integer c = 100, d = 100; System.out.println(c == d);//true = 运算比较的不是值而是引用** 分析 其实正常情况Integer类型与int是不可能相等的，一个是对象类型（Integer ），一个是基础数据类型（int）。只是Java搞了自动装箱和拆箱机制，会将int转换成Integer，反之亦然。但是转换时正常情况下，装箱与拆箱的对象的内存地址应该是不同的，应该仍然不等才对，但是JVM让对应的-128~127的装箱对象都缓存起来了，这意味着每次装箱在这个范围的，直接从缓存取，不会new，通过这个trick让其相等 但是超出这个范围的默认还是一般原理就不相等了 当我们给一个Integer 对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf 的源代码就知道发生了什么： public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } IntegerCache 是Integer 的内部类，其代码如下所示： /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 简单的说，如果整型字面量的值在-128 ~ 127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以才会出现上面的现象","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"HashMap和HashTable的区别","slug":"HashMap和HashTable的区别","date":"2019-01-05T01:23:58.000Z","updated":"2019-06-18T08:58:47.240Z","comments":true,"path":"2019/01/05/HashMap和HashTable的区别/","link":"","permalink":"https://www.xiongtianci.com/2019/01/05/HashMap和HashTable的区别/","excerpt":"","text":"HashMap和HashTable的区别HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 HashMap是非线程安全的，HashTable是线程安全的HashMap的键和值都允许有null值存在，而HashTable则不行因为线程安全的问题，HashMap效率比HashTable的要高 1、HashMap几乎可以等价于HashTable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而HashTable则不行)。2、HashMap是非synchronized，而HashTable是synchronized，这意味着HashTable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。3、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。4、由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。5、HashMap不能保证随着时间的推移Map中的元素次序是不变的。 注意：1、 sychronized意味着在一次仅有一个线程能够更改HashTable。就是说任何线程要更新HashTable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新HashTable。2、Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。3、结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。 我们能否让HashMap同步？HashMap可以通过下面的语句进行同步： Map map = Collections.synchronizeMap(hashMap);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"打印昨天的当前时刻","slug":"打印昨天的当前时刻","date":"2019-01-04T08:15:38.000Z","updated":"2019-06-18T08:58:29.025Z","comments":true,"path":"2019/01/04/打印昨天的当前时刻/","link":"","permalink":"https://www.xiongtianci.com/2019/01/04/打印昨天的当前时刻/","excerpt":"","text":"方式一：通过Calendar实现Calendar cal = Calendar.getInstance(); cal.add(Calendar.DATE,-1); System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(cal.getTime())); 方式二：通过Date实现// 1天的时间 = 24小时 x 60分钟 x 60秒 x 1000毫秒 单位是L Date yesterday = new Date(new Date().getTime() - 24 * 60 * 60 * 1000); System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(yesterday));","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？","slug":"怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？","date":"2019-01-04T08:05:49.000Z","updated":"2019-06-18T08:58:34.944Z","comments":true,"path":"2019/01/04/怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？/","link":"","permalink":"https://www.xiongtianci.com/2019/01/04/怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？/","excerpt":"","text":"使用的函数： public String(byte bytes[], String charsetName) throws UnsupportedEncodingException { this(bytes, 0, bytes.length, charsetName); } 代码： String s1 = &quot;你好&quot;; String s2 = new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"MyBatis中 # 和 $ 的区别？","slug":"MyBatis中#和$的区别？","date":"2019-01-03T09:20:00.000Z","updated":"2019-06-18T08:58:03.276Z","comments":true,"path":"2019/01/03/MyBatis中#和$的区别？/","link":"","permalink":"https://www.xiongtianci.com/2019/01/03/MyBatis中#和$的区别？/","excerpt":"","text":"#相当于对数据加上双引号，$相当于直接显示数据 &#35;将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by &#35;user_id&#35;，如果传入的值是111，那么解析成sq 时的值为：order by “111”；如果传入的值是id，则解析成的sql为：order by “id” &#36;将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111，那么解析成sql 时的值为：order by user_id,；如果传入的值是id，则解析成的sql为：order by id &#35;方式能够很大程度防止sql 注入 &#36;方式无法防止sql注入 &#36;方式一般用于传入数据库对象，例如传入表名 一般能用&#35;的就别用&#36;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"SQL中limit的用法","slug":"SQL中limit的用法","date":"2019-01-03T08:01:40.000Z","updated":"2019-06-18T08:58:16.855Z","comments":true,"path":"2019/01/03/SQL中limit的用法/","link":"","permalink":"https://www.xiongtianci.com/2019/01/03/SQL中limit的用法/","excerpt":"","text":"limit子句用于限制查询结果返回的数量 格式： select * from tableName limit i,n # tableName：表名 # i：为查询结果的索引值(默认从0开始)，当i=0时可省略i # n：为查询结果返回的数量 # i与n之间使用英文逗号&quot;,&quot;隔开 栗子： select * from Customer LIMIT 10; # 检索前10行数据，显示1-10条数据 select * from Customer LIMIT 1,10; # 检索从第2行开始，累加10条id记录，共显示id为2....11 select * from Customer limit 5,10; # 检索从第6行开始向前加10条数据，共显示id为6,7....15 select * from Customer limit 6,10; # 检索从第7行开始向前加10条记录，显示id为7,8...16 注意： limit n 等同于 limit 0,n","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"SQL","slug":"SQL","permalink":"https://www.xiongtianci.com/tags/SQL/"}],"author":"天赐"},{"title":"事务的基本要素（ACID）","slug":"事务的基本要素（ACID）","date":"2019-01-03T07:11:01.000Z","updated":"2019-06-18T08:58:22.865Z","comments":true,"path":"2019/01/03/事务的基本要素（ACID）/","link":"","permalink":"https://www.xiongtianci.com/2019/01/03/事务的基本要素（ACID）/","excerpt":"","text":"数据库事务(Transanction)正确执行的四个基本要素：1、原子性（Atomicity）：事务开始后所有操作，要么全部完成，要么全部不完成，不可能停滞在中间环节。事务执行过程中出错，会回滚（Rollback）到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账4、持久性（Durability）：事务完成后，该事务所对数据库所作的更改将被保存到数据库之中，不能回滚","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"https://www.xiongtianci.com/tags/事务/"}],"author":"天赐"},{"title":"Mysql的四种隔离级别","slug":"Mysql的四种隔离级别","date":"2019-01-03T06:56:10.000Z","updated":"2019-06-18T08:58:09.974Z","comments":true,"path":"2019/01/03/Mysql的四种隔离级别/","link":"","permalink":"https://www.xiongtianci.com/2019/01/03/Mysql的四种隔离级别/","excerpt":"","text":"一、MySQL事务隔离级别 隔离级别 脏读 不可重复读 幻读 读未提交 是 是 是 读已提交 否 是 是 可重复读 否 否 是 串行化 否 否 否 在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。 未提交读（Read uncommitted）：在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上来说，未提交读不会比其他的级别好太多，但是缺乏其他级别的很多好处，在实际应用中一般很少使用。读已提交（Read committed）：大多数数据库系统的默认隔离级别都是读已提交（但Mysql不是）。读已提交满足隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。可重复读（Repeatable read）：可重复读解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom read）问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务中又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom row）。可重复读是MySQL的默认事务隔离级别。可串行化（Serializable）：可串行化是最高的隔离级别。它通过强制事务串行执行，避免了前面所说的幻读问题。简单来说，可串行化会在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑用该级别。 二、事务的并发问题1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 2、不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 3、幻读：系统管理员1将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员2就在这个时候插入了一条具体分数的记录，当系统管理员1操作结束后发现还有一条记录(2插入的那条)没有改过来，就好像发生了幻觉一样，这就叫幻读。 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"MySQL面试题","slug":"MySQL面试题","date":"2019-01-02T12:05:58.000Z","updated":"2019-06-18T08:57:56.060Z","comments":true,"path":"2019/01/02/MySQL面试题/","link":"","permalink":"https://www.xiongtianci.com/2019/01/02/MySQL面试题/","excerpt":"","text":"1. 主键 超键 候选键 外键主 键： 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。 一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null） 超 键： 在关系中能唯一标识元组的属性集称为关系模式的超键 一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键 超键包含候选键和主键。 候选键： 是最小超键，即没有冗余元素的超键。 外 键： 在一个表中存在的另一个表的主键称此表的外键 2.数据库事务的四个特性及含义 数据库事务( transanction )正确执行的四个基本要素( ACID )：原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 原子性： 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性： 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性： 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 持久性： 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 3.drop,delete与truncate的区别 drop直接删掉表delete删除表中数据，可以加where字句truncate删除表中数据，再插入时自增长id又从1开始 1、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除的数据是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。 2、表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。 3、一般而言，drop &gt; truncate &gt; delete 4、应用范围。truncate 只能对 table；delete 可以是table和view 5、truncate 和 DELETE 只删除数据，而DROP则删除整个表（结构和数据）。 6、truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。 7、delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。 8、truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚 9、在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。 10、Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 11、TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 12、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 4.索引的工作原理及其种类 数据库索引：是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。 图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O($log_2n$)的复杂度内获取到相应数据。 创建索引可以大大提高系统的性能。 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点： 第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。 唯一索引 唯一索引是不允许其中任何两行具有相同索引值的索引。 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。 如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"Google Chrome快捷键","slug":"Google-Chrome快捷键","date":"2018-12-27T06:15:42.000Z","updated":"2019-06-18T08:57:49.211Z","comments":true,"path":"2018/12/27/Google-Chrome快捷键/","link":"","permalink":"https://www.xiongtianci.com/2018/12/27/Google-Chrome快捷键/","excerpt":"","text":"标签页和窗口快捷键 操作 快捷键 打开新窗口 Ctrl + N 在无痕模式下打开新窗口 Ctrl + Shift + N 打开新的标签页，并跳转到该标签页 Ctrl + T 重新打开最后关闭的标签页，并跳转到该标签页 Ctrl + Shift + T 跳转到下一个打开的标签页 Ctrl + Tab 或 Ctrl + PgDn 跳转到上一个打开的标签页 Ctrl + Shift + Tab 或 Ctrl + PgUp 跳转到特定标签页 Ctrl + 1 到 Ctrl + 8 跳转到最后一个标签页 Ctrl + 9 在当前标签页中打开主页 Alt + Home 打开当前标签页浏览记录中记录的上一个页面 Alt + 向左箭头键 打开当前标签页浏览记录中记录的下一个页面 Alt + 向右箭头键 关闭当前标签页 Ctrl + W 或 Ctrl + F4 关闭所有打开的标签页和浏览器 Ctrl + Shift + W 最小化当前窗口 Alt + 空格键 + N 最大化当前窗口 Alt + 空格键 + X 关闭当前窗口 Alt + F4 退出 Google Chrome Ctrl + Shift + q Google Chrome 功能快捷键 操作 快捷键 打开 Chrome 菜单 Alt + F、Alt + E 或 F10 显示或隐藏书签栏 Ctrl + Shift + B 打开书签管理器 Ctrl + Shift + O 在新标签页中打开“历史记录”页 Ctrl + H 在新标签页中打开“下载内容”页 Ctrl + J 打开 Chrome 任务管理器 Shift + Esc 将焦点放置在 Chrome 工具栏中的第一项上 Shift + Alt + T 在地址栏、书签栏（若显示）和页面内容之间向前切换焦点 F6 在地址栏、书签栏（若显示）和页面内容之间向后切换焦点 Shift + F6 打开查找栏搜索当前网页 Ctrl + F 或 F3 跳转到与查找栏中搜索字词相匹配的下一条内容 Ctrl + G 跳转到与查找栏中搜索字词相匹配的上一条内容 Ctrl + Shift + G 打开“开发者工具” Ctrl + Shift + j 或 F12 打开“清除浏览数据”选项 Ctrl + Shift + Delete 在新标签页中打开 Chrome 帮助中心 F1 使用其他帐号登录或以访客身份浏览 Ctrl + Shift + m 打开反馈表单 Alt + Shift + i 地址栏快捷键 操作 快捷键 使用默认搜索引擎进行搜索 输入搜索字词并按 Enter 键 使用其他搜索引擎进行搜索 输入搜索引擎名称并按 Tab 键 为网站名称添加 www. 和 .com，并在当前标签页中打开该网站 输入网站名称并按 Ctrl + Enter 打开新的标签页并执行 Google 搜索 输入搜索字词并按 Alt + Enter 键 跳转到地址栏 Ctrl + l、Alt + d 或 F6 从页面中的任意位置搜索 Ctrl + k 或 Ctrl + e 从地址栏中移除联想查询内容 按向下箭头键以突出显示相应内容，然后按 Shift + Delete 网页快捷键 操作 快捷键 打开选项以打印当前网页 Ctrl + p 打开选项以保存当前网页 Ctrl + s 重新加载当前网页 F5 或 Ctrl + r 重新加载当前网页（忽略缓存的内容） Shift + F5 或 Ctrl + Shift + r 停止加载网页 Esc 浏览下一个可点击项 Tab 浏览上一个可点击项 Shift + Tab 使用 Chrome 打开计算机中的文件 按住 Ctrl + o 键并选择文件 显示当前网页的 HTML 源代码（不可修改） Ctrl + u 将当前网页保存为书签 Ctrl + d 将所有打开的标签页以书签的形式保存在新文件夹中 Ctrl + Shift + d 开启或关闭全屏模式 F11 放大网页上的所有内容 Ctrl 和 + 缩小网页上的所有内容 Ctrl 和 - 将网页上的所有内容恢复到默认大小 Ctrl + 0 向下滚动网页，一次一个屏幕 空格键或 PgDn 向上滚动网页，一次一个屏幕 Shift + 空格键或 PgUp 转到网页顶部 首页 转到网页底部 末尾 在网页上水平滚动 按住 Shift 键并滚动鼠标滚轮 将光标移到文本字段中的上一个字词前面 Ctrl + 向左箭头键 将光标移到文本字段中的上一个字词后面 Ctrl + 向右箭头键 删除文本字段中的上一个字词 Ctrl + Backspace 将焦点移到通知上 Alt + n 在通知中允许 Alt + Shift + a 在通知中拒绝 Alt + Shift + d 在当前标签页中打开主页 Alt + Home 鼠标快捷键 操作 快捷键 在当前标签页中打开链接（仅限鼠标） 将链接拖到标签页中 在新的后台标签页中打开链接 按住 Ctrl 键的同时点击链接 打开链接，并跳转到该链接 按住 Ctrl + Shift 键的同时点击链接 打开链接，并跳转到该链接（仅使用鼠标） 将链接拖到标签栏的空白区域 在新窗口中打开链接 按住 Shift 键的同时点击链接 在新窗口中打开标签页（仅使用鼠标） 将标签页拖出标签栏 将标签页移至当前窗口（仅限鼠标） 将标签页拖到现有窗口中 将标签页移回其原始位置 拖动标签页的同时按 Esc 将当前网页保存为书签 将相应网址拖动到书签栏中 下载链接目标 按住 Alt 键的同时点击链接 显示浏览记录 右键点击“后退”箭头 返回 或“前进”箭头 下一个，或者左键点击（并按住鼠标左键 在最大化模式和窗口模式间切换 双击标签栏的空白区域 放大网页上的所有内容 按住 Ctrl 键的同时向上滚动鼠标滚轮 缩小网页上的所有内容 按住 Ctrl 键的同时向下滚动鼠标滚轮","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Chrome","slug":"Chrome","permalink":"https://www.xiongtianci.com/tags/Chrome/"},{"name":"快捷键","slug":"快捷键","permalink":"https://www.xiongtianci.com/tags/快捷键/"}],"author":"天赐"},{"title":"SpringMVC 常用注解","slug":"SpringMVC-常用注解","date":"2018-12-26T10:22:15.000Z","updated":"2019-06-18T08:57:32.209Z","comments":true,"path":"2018/12/26/SpringMVC-常用注解/","link":"","permalink":"https://www.xiongtianci.com/2018/12/26/SpringMVC-常用注解/","excerpt":"","text":"1、@RequestMapping @RequestMapping：用于处理请求url映射，可以作用于类和方法上 value：定义request请求的映射地址(默认) method：定义地request址请求的方式，包括【GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.】默认接受get请求，如果请求方式和定义的方式不一样则请求无法成功 params：定义request请求中必须包含的参数值。 headers：定义request请求中必须包含某些指定的请求头，如：RequestMapping(value = “/something”, headers = “content-type=text/*”)说明请求中必须要包含”text/html”, “text/plain”这中类型的Content-type头，才是一个匹配的请求。 consumes：定义请求提交内容的类型。 produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 2、@RequestParam 用于Controller层，获取请求的参数。类似于：request.getParameter(“name”) 3、@RequestBody 用于Controller层，将请求中的json格式的数据转换成java对象 4、@ResponseBody 用于Controller层，将返回的对象转换成json格式","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.xiongtianci.com/tags/SpringMVC/"}],"author":"天赐"},{"title":"Typora侧边栏的大纲视图折叠( win系统 )","slug":"Typora侧边栏的大纲视图折叠-win系统","date":"2018-12-26T02:11:23.000Z","updated":"2019-06-18T08:57:39.670Z","comments":true,"path":"2018/12/26/Typora侧边栏的大纲视图折叠-win系统/","link":"","permalink":"https://www.xiongtianci.com/2018/12/26/Typora侧边栏的大纲视图折叠-win系统/","excerpt":"","text":"效果 解决方案文件 &rArr; 偏好设置 &rArr; 勾选”侧边栏”","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Typora","slug":"Typora","permalink":"https://www.xiongtianci.com/tags/Typora/"}],"author":"天赐"},{"title":"MyBatis中通用Mapper接口以及Example的方法解析","slug":"MyBatis中通用Mapper接口以及Example的方法解析","date":"2018-12-25T03:04:39.000Z","updated":"2019-06-18T08:57:09.770Z","comments":true,"path":"2018/12/25/MyBatis中通用Mapper接口以及Example的方法解析/","link":"","permalink":"https://www.xiongtianci.com/2018/12/25/MyBatis中通用Mapper接口以及Example的方法解析/","excerpt":"","text":"一、通用Mapper中的方法解析 方法 功能说明 int countByExample(UserExample example) thorws SQLException 按条件计数 int deleteByPrimaryKey(Integer id) thorws SQLException 按主键删除 int deleteByExample(UserExample example) thorws SQLException 按条件查询 String/Integer insert(User record) thorws SQLException 插入数据（返回值为ID） User selectByPrimaryKey(Integer id) thorws SQLException 按主键查询 List selectByExample(UserExample example) thorws SQLException 按条件查询 List selectByExampleWithBLOGs(UserExample example) thorws SQLException 按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。 int updateByPrimaryKey(User record) thorws SQLException 按主键更新 int updateByPrimaryKeySelective(User record) thorws SQLException 按主键更新值不为null的字段 int updateByExample(User record, UserExample example) thorws SQLException 按条件更新 int updateByExampleSelective(User record, UserExample example) thorws SQLException 按条件更新值不为null的字段 ### 二、Example实例解析mybatis的逆向工程中会生成实例及实例对应的example，example用于添加条件，相当where后面的部分java import tk.mybatis.mapper.entity.Example; Example example = new Example(JavaBean.class); Example.Criteria criteria = example.createCriteria(); 方法 说明 example.setOrderByClause(“字段名 ASC”); 添加升序排列条件，DESC为降序 example.setDistinct(false) 去除重复，boolean型，true为选择不重复的记录。 criteria.andXxxIsNull 添加字段xxx为null的条件 criteria.andXxxIsNotNull 添加字段xxx不为null的条件 criteria.andXxxEqualTo(value) 添加xxx字段等于value条件 criteria.andXxxNotEqualTo(value) 添加xxx字段不等于value条件 criteria.andXxxGreaterThan(value) 添加xxx字段大于value条件 criteria.andXxxGreaterThanOrEqualTo(value) 添加xxx字段大于等于value条件 criteria.andXxxLessThan(value) 添加xxx字段小于value条件 criteria.andXxxLessThanOrEqualTo(value) 添加xxx字段小于等于value条件 criteria.andXxxIn(List&lt;？&gt;) 添加xxx字段值在List&lt;？&gt;条件 criteria.andXxxNotIn(List&lt;？&gt;) 添加xxx字段值不在List&lt;？&gt;条件 criteria.andXxxLike(“%”+value+”%”) 添加xxx字段值为value的模糊查询条件 criteria.andXxxNotLike(“%”+value+”%”) 添加xxx字段值不为value的模糊查询条件 criteria.andXxxBetween(value1,value2) 添加xxx字段值在value1和value2之间条件 criteria.andXxxNotBetween(value1,value2) 添加xxx字段值不在value1和value2之间条件 三、使用案例1.查询① selectByPrimaryKey() 按主键查询 //相当于：select * from user where id = 100; User user = UserMapper.selectByPrimaryKey(100); ② selectByExample() 和 selectByExampleWithBLOGs() //相当于：select * from user where username = &#39;wyw&#39; // and username is null order by username asc,email desc UserExample example = new UserExample(); Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(&quot;wyw&quot;); criteria.andUsernameIsNull(); example.setOrderByClause(&quot;username asc,email desc&quot;); List&lt;?&gt;list = XxxMapper.selectByExample(example); 2.插入数据①insert() //相当于：insert into user(ID,username,password,email) values //(&#39;dsfgsdfgdsfgds&#39;,&#39;jack&#39;,&#39;1234&#39;,&#39;hello@126.com&#39;); User user = new User(); user.setId(&quot;dsfgsdfgdsfgds&quot;); user.setUsername(&quot;jack&quot;); user.setPassword(&quot;1234&quot;) user.setEmail(&quot;hello@163.com&quot;); XxxMapper.insert(user); 3.更新数据①updateByPrimaryKey() //相当于：update user set username=&#39;rose&#39;, password=&#39;5678&#39;, //email=&#39;hello@163.com&#39; where id=&#39;a01&#39; User user =new User(); user.setId(&quot;a01&quot;); user.setUsername(&quot;rose&quot;); user.setPassword(&quot;5678&quot;); user.setEmail(&quot;hello@163.com&quot;); XxxMapper.updateByPrimaryKey(user); ②updateByPrimaryKeySelective() //相当于：update user set password=&#39;7890&#39; where id=&#39;a01&#39; User user = new User(); user.setId(&quot;a01&quot;); user.setPassword(&quot;7890&quot;); XxxMapper.updateByPrimaryKey(user); ③ updateByExample() 和 updateByExampleSelective() //相当于：update user set password=&#39;6666&#39; where username=&#39;jack&#39; UserExample example = new UserExample(); Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(&quot;jack&quot;); User user = new User(); user.setPassword(&quot;6666&quot;); XxxMapper.updateByPrimaryKeySelective(user,example); updateByExample()更新所有的字段，包括字段为null的也更新建议使用 updateByExampleSelective()更新想更新的字段 4.删除数据①deleteByPrimaryKey() //相当于：delete from user where id=1 XxxMapper.deleteByPrimaryKey(1); ②deleteByExample() //相当于：delete from user where username=&#39;jack&#39; UserExample example = new UserExample(); Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(&quot;jack&quot;); XxxMapper.deleteByExample(example); 5.查询数据数量①countByExample() //相当于：select count(*) from user where username=&#39;jack&#39; UserExample example = new UserExample(); Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(&quot;jack&quot;); int count = XxxMapper.countByExample(example);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://www.xiongtianci.com/tags/MyBatis/"}],"author":"天赐"},{"title":"抽象类和接口有什么不同点？","slug":"抽象类和接口有什么不同点？","date":"2018-12-25T01:31:16.000Z","updated":"2019-06-18T08:57:18.559Z","comments":true,"path":"2018/12/25/抽象类和接口有什么不同点？/","link":"","permalink":"https://www.xiongtianci.com/2018/12/25/抽象类和接口有什么不同点？/","excerpt":"","text":"参数 抽象类 接口 默认的方法实现 它可以有默认的方法实现 接口完全是抽象的。它根本不存在方法的实 实现 子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 子类使用关键字 implements 来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常Java类的区别 除了你不能实例化抽象类之外，它和普通Java 类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有 public、protected 和 default 这些修饰符 接口方法默认修饰符是 public。你不可以使用其它修饰符 main 方法 抽象方法可以有main 方法并且我们可以运行它 接口没有main 方法，因此我们不能运行它 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口 速度 它比接口速度要快 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法 添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码 如果你往接口中添加方法，那么你必须改变实现该接口的类","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"面试题：说下原生jdbc 操作数据库流程？","slug":"面试题：说下原生jdbc-操作数据库流程？","date":"2018-12-25T00:25:40.000Z","updated":"2019-06-18T08:57:26.006Z","comments":true,"path":"2018/12/25/面试题：说下原生jdbc-操作数据库流程？/","link":"","permalink":"https://www.xiongtianci.com/2018/12/25/面试题：说下原生jdbc-操作数据库流程？/","excerpt":"","text":"原生的jdbc操作数据库流程：1.注册驱动程序：Class.forName(“com.mysql.jdbc.Driver”);2.使用驱动管理类来获取数据连接对象：conn = DriverManager.getConnection(…);3.获取数据库操作对象：Statement stmt = conn.createStatement();4.定义操作的SQL语句5.执行SQL：stmt.executeQuery(sql);6.处理结果集：ResultSet，如果SQL前有参数值就设置参数值setXXX()7.关闭对象，回收数据库资源（关闭结果集–&gt;关闭数据库操作对象–&gt;关闭连接） public class JDBCTest { /** * 使用JDBC连接并操作mysql数据库 */ public static void main(String[] args) { // 数据库驱动类名的字符串 String driver = &quot;com.mysql.jdbc.Driver&quot;; // 数据库连接串 String url = &quot;jdbc:mysql://127.0.0.1:3306/jdbctest&quot;; // 用户名 String username = &quot;root&quot;; // 密码 String password = &quot;1234&quot;; Connection conn = null; Statement stmt = null; ResultSet rs = null; try { // 1、加载数据库驱动（ 成功加载后，会将Driver类的实例注册到DriverManager类中） Class.forName(driver); // 2、获取数据库连接 conn = DriverManager.getConnection(url, username, password); // 3、获取数据库操作对象 stmt = conn.createStatement(); // 4、定义操作的SQL语句 String sql = &quot;select * from user where id = 100&quot;; // 5、执行数据库操作 rs = stmt.executeQuery(sql); // 6、获取并操作结果集 while (rs.next()) { System.out.println(rs.getInt(&quot;id&quot;)); System.out.println(rs.getString(&quot;name&quot;)); } } catch (Exception e) { e.printStackTrace(); } finally { // 7、关闭对象，回收数据库资源 if (rs != null) { //关闭结果集对象 try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt != null) { // 关闭数据库操作对象 try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { // 关闭数据库连接对象 try { if (!conn.isClosed()) { conn.close(); } } catch (SQLException e) { e.printStackTrace(); } } } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"JDBC","slug":"JDBC","permalink":"https://www.xiongtianci.com/tags/JDBC/"}],"author":"天赐"},{"title":"跨域问题&cors解决跨域","slug":"跨域问题-cors解决跨域","date":"2018-12-21T00:42:19.000Z","updated":"2019-06-18T08:56:59.965Z","comments":true,"path":"2018/12/21/跨域问题-cors解决跨域/","link":"","permalink":"https://www.xiongtianci.com/2018/12/21/跨域问题-cors解决跨域/","excerpt":"","text":"跨域问题 跨域：浏览器对于javascript的同源策略的限制 。 以下情况都属于跨域：| 跨域原因说明 | 示例 || ——— | ————————————- || 域名不同 | www.jd.com 与 www.taobao.com || 域名相同，端口不同 | www.jd.com:8080 与 www.jd.com:8081 || 二级域名不同 | item.jd.com 与 miaosha.jd.com | 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 为什么有跨域问题？跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是与当前页域名相同的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 解决跨域问题的方案目前比较常用的跨域解决方案有3种： Jsonp最早的解决方案，利用script标签可以跨域的原理实现。限制： 需要服务的支持 只能发起GET请求 nginx反向代理思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式缺点：需要在nginx进行额外配置，语义不清晰 CORS规范化的跨域请求解决方案，安全可靠。优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 cors解决跨域1.什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 2.原理有点复杂浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 2.1.简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：Origin.Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： Access-Control-Allow-Origin: http://manage.leyou.com Access-Control-Allow-Credentials: true Content-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名） Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 有关cookie： 要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 2.2.特殊请求不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： OPTIONS /cors HTTP/1.1 Origin: http://manage.leyou.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.leyou.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://manage.leyou.com Access-Control-Allow-Credentials: true Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Max-Age: 1728000 Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 3.实现非常简单虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在leyou-gateway中编写一个配置类，并且注册CorsFilter： import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; @Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(&quot;http://manage.leyou.com&quot;); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(&quot;OPTIONS&quot;); config.addAllowedMethod(&quot;HEAD&quot;); config.addAllowedMethod(&quot;GET&quot;); config.addAllowedMethod(&quot;PUT&quot;); config.addAllowedMethod(&quot;POST&quot;); config.addAllowedMethod(&quot;DELETE&quot;); config.addAllowedMethod(&quot;PATCH&quot;); // 4）允许的头信息 config.addAllowedHeader(&quot;*&quot;); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(&quot;/**&quot;, config); //3.返回新的CorsFilter. return new CorsFilter(configSource); } } 结构：","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"跨域","slug":"跨域","permalink":"https://www.xiongtianci.com/tags/跨域/"}],"author":"天赐"},{"title":"CollectionUtils工具类使用指南","slug":"CollectionUtils工具类使用指南","date":"2018-12-20T12:58:08.000Z","updated":"2019-06-18T08:56:20.171Z","comments":true,"path":"2018/12/20/CollectionUtils工具类使用指南/","link":"","permalink":"https://www.xiongtianci.com/2018/12/20/CollectionUtils工具类使用指南/","excerpt":"","text":"CollectionUtils提供很多对集合的操作方法，常用的方法如下： //并集 Collection&lt;String&gt; union = CollectionUtils.union(a, b); //交集 Collection&lt;String&gt; intersection = CollectionUtils.intersection(a, b); //交集的补集 Collection&lt;String&gt; disjunction = CollectionUtils.disjunction(a, b); //集合相减 Collection&lt;String&gt; subtract = CollectionUtils.subtract(a, b); //判断集合是否为空 Boolean boolean = CollectionUtils.isEmpty(Collection&lt;?&gt; collection); //判断集合是否不为空 Boolean boolean = CollectionUtils.isNotEmpty(Collection&lt;?&gt; collection); 并集@Test public void testUnion(){ String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; }; String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; }; List&lt;String&gt; listA = Arrays.asList(arrayA); List&lt;String&gt; listB = Arrays.asList(arrayB); //2个数组取并集 System.out.println(ArrayUtils.toString(CollectionUtils.union(listA, listB))); //[A, B, C, D, E, F, G, H, K] } 交集@Test public void testIntersection(){ String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; }; String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; }; List&lt;String&gt; listA = Arrays.asList(arrayA); List&lt;String&gt; listB = Arrays.asList(arrayB); //2个数组取交集 System.out.println(ArrayUtils.toString(CollectionUtils.intersection(listA, listB))); //[B, D, F] } 交集的补集（析取）@Test public void testDisjunction(){ String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; }; String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; }; List&lt;String&gt; listA = Arrays.asList(arrayA); List&lt;String&gt; listB = Arrays.asList(arrayB); //2个数组取交集 的补集 System.out.println(ArrayUtils.toString(CollectionUtils.disjunction(listA, listB))); //[A, C, E, G, H, K] } 差集（扣除）@Test public void testSubtract(){ String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; }; String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; }; List&lt;String&gt; listA = Arrays.asList(arrayA); List&lt;String&gt; listB = Arrays.asList(arrayB); //arrayA扣除arrayB System.out.println(ArrayUtils.toString(CollectionUtils.subtract(listA, listB))); //[A, C, E] } 集合是否为空@Test public void testIsEmpty(){ class Person{} class Girl extends Person{} List&lt;Integer&gt; first = new ArrayList&lt;&gt;(); List&lt;Integer&gt; second = null; List&lt;Person&gt; boy = new ArrayList&lt;&gt;(); //每个男孩心里都装着一个女孩 boy.add(new Girl()); //判断集合是否为空 System.out.println(CollectionUtils.isEmpty(first)); //true System.out.println(CollectionUtils.isEmpty(second)); //true System.out.println(CollectionUtils.isEmpty(boy)); //false //判断集合是否不为空 System.out.println(CollectionUtils.isNotEmpty(first)); //false System.out.println(CollectionUtils.isNotEmpty(second)); //false System.out.println(CollectionUtils.isNotEmpty(boy)); //true } 集合是否相等@Test public void testIsEqual(){ class Person{} class Girl extends Person{ } List&lt;Integer&gt; first = new ArrayList&lt;&gt;(); List&lt;Integer&gt; second = new ArrayList&lt;&gt;(); first.add(1); first.add(2); second.add(2); second.add(1); Girl goldGirl = new Girl(); List&lt;Person&gt; boy1 = new ArrayList&lt;&gt;(); //每个男孩心里都装着一个女孩 boy1.add(new Girl()); List&lt;Person&gt; boy2 = new ArrayList&lt;&gt;(); //每个男孩心里都装着一个女孩 boy2.add(new Girl()); //比较两集合值 System.out.println(CollectionUtils.isEqualCollection(first,second)); //true System.out.println(CollectionUtils.isEqualCollection(first,boy1)); //false System.out.println(CollectionUtils.isEqualCollection(boy1,boy2)); //false List&lt;Person&gt; boy3 = new ArrayList&lt;&gt;(); //每个男孩心里都装着一个女孩 boy3.add(goldGirl); List&lt;Person&gt; boy4 = new ArrayList&lt;&gt;(); boy4.add(goldGirl); System.out.println(CollectionUtils.isEqualCollection(boy3,boy4)); //true } 不可修改的集合我们对c进行操作，s也同样获得了和c相同的内容，这样就可以避免其他人员修改这个s对象。有时候需要对它进行保护，避免返回结果被人修改。 @Test public void testUnmodifiableCollection(){ Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); Collection&lt;String&gt; s = CollectionUtils.unmodifiableCollection(c); c.add(&quot;boy&quot;); c.add(&quot;love&quot;); c.add(&quot;girl&quot;); //! s.add(&quot;have a error&quot;); System.out.println(s); } Collections.unmodifiableCollection可以得到一个集合的镜像，它的返回结果是不可直接被改变，否则会提示错误 java.lang.UnsupportedOperationException at org.apache.commons.collections.collection.UnmodifiableCollection.add(UnmodifiableCollection.java:75)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://www.xiongtianci.com/tags/工具类/"},{"name":"CollectionUtils","slug":"CollectionUtils","permalink":"https://www.xiongtianci.com/tags/CollectionUtils/"}],"author":"天赐"},{"title":"通用Mapper的select(T t)的使用","slug":"通用Mapper的select(T t)的使用","date":"2018-12-20T12:35:14.000Z","updated":"2019-06-18T08:56:52.889Z","comments":true,"path":"2018/12/20/通用Mapper的select(T t)的使用/","link":"","permalink":"https://www.xiongtianci.com/2018/12/20/通用Mapper的select(T t)的使用/","excerpt":"","text":"通用mapper类： public interface CategoryMapper extends Mapper&lt;Category&gt; { } 使用select(T t) public List&lt;Category&gt; queryCategoryListByParentId(Long pid) { // select(T t) 将对象c中的非空字段当作查询的条件参数 Category record = new Category(); record.setParentId(pid); return this.categoryMapper.select(record); } select(T t) 将实例对象t中的非空字段作为条件参数上面实例转换的sql语句：select * from category c where c.pid = #{pid}","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Mapper","slug":"Mapper","permalink":"https://www.xiongtianci.com/tags/Mapper/"}],"author":"天赐"},{"title":"使用nginx进行反向代理","slug":"使用nginx进行反向代理","date":"2018-12-20T09:17:17.000Z","updated":"2019-06-18T08:56:46.126Z","comments":true,"path":"2018/12/20/使用nginx进行反向代理/","link":"","permalink":"https://www.xiongtianci.com/2018/12/20/使用nginx进行反向代理/","excerpt":"","text":"什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器(代理服务器)代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图： 安装和使用安装安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！ 下载nginx：http://nginx.org/en/download.html 我们在本地安装一台nginx： 解压后，目录结构： conf：配置目录 contrib：第三方依赖 html：默认的静态资源目录，类似于tomcat的webapps logs：日志目录 nginx.exe：启动程序。可双击运行，但不建议这么做。 反向代理配置示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server { listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / { proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; } } server { listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / { proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; } } } 使用nginx可以通过命令行来启动，操作命令： 启动：start nginx.exe 停止：nginx.exe -s stop 重新加载：nginx.exe -s reload 启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程： 测试启动nginx，然后用域名访问后台管理系统：现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问 http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口： http://127.0.0.1:80本机的nginx一直监听 80 端口，因此捕获这个请求 nginx中配置了反向代理规则，将 manage.leyou.com 代理到 127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.xiongtianci.com/tags/Nginx/"},{"name":"反向代理","slug":"反向代理","permalink":"https://www.xiongtianci.com/tags/反向代理/"}],"author":"天赐"},{"title":"win10使用Switchhost显示无修改权限","slug":"win10使用Switchhost显示无修改权限","date":"2018-12-20T08:41:06.000Z","updated":"2019-06-18T08:56:40.395Z","comments":true,"path":"2018/12/20/win10使用Switchhost显示无修改权限/","link":"","permalink":"https://www.xiongtianci.com/2018/12/20/win10使用Switchhost显示无修改权限/","excerpt":"","text":"现象使用Switchhost!操作电脑hosts文件时，显示无修改权限，即使使用管理员身份运行Switchhost!也是如此 解决方案 找到hosts文件路径：C:\\Windows\\System32\\drivers\\etc 右键hosts，点击属性，选择安全 点击编辑，赋予Users 完全权限","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"win10","slug":"win10","permalink":"https://www.xiongtianci.com/tags/win10/"}],"author":"天赐"},{"title":"IDEA报错：Lombok Requires Annotation Processing","slug":"IDEA报错：Lombok Requires Annotation Processing","date":"2018-12-20T08:17:49.000Z","updated":"2019-06-18T08:56:26.972Z","comments":true,"path":"2018/12/20/IDEA报错：Lombok Requires Annotation Processing/","link":"","permalink":"https://www.xiongtianci.com/2018/12/20/IDEA报错：Lombok Requires Annotation Processing/","excerpt":"","text":"现象Lombok安装完成之后，启动项目时出现 Lombok Requires Annotation Processing 的错误提示 16:08 Lombok Requires Annotation Processing Annotation processing seems to be disabled for the project &quot;leyou&quot;. For the plugin to function correctly, please enable it under &quot;Settings &gt; Build &gt; Compiler &gt; Annotation Processors&quot; 解决方案依次点 File &rarr; Settings &rarr; Build, Execution, Deploymen &rarr; Annotation Processors 打开编辑页面，勾上 Enable annotation processing 前面的选框，保存重启IDEA即可解决","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.xiongtianci.com/tags/IDEA/"},{"name":"踩坑","slug":"踩坑","permalink":"https://www.xiongtianci.com/tags/踩坑/"}],"author":"天赐"},{"title":"Java中clone()与new的区别？","slug":"Java中clone()与new的区别？","date":"2018-12-20T03:27:48.000Z","updated":"2019-06-18T08:56:34.171Z","comments":true,"path":"2018/12/20/Java中clone()与new的区别？/","link":"","permalink":"https://www.xiongtianci.com/2018/12/20/Java中clone()与new的区别？/","excerpt":"","text":"为什么要使用clone()？在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A 中已经包含了一些有效值，此时可能会需要一个和A 完全相同新对象B，并且此后对B 任何改动都不会影响到A 中的值，也就是说，A 与B 是两个独立的对象，但B 的初始值是由A 对象确定的。在Java 语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现clone()方法是其中最简单，也是最高效的手段 clone()与new的区别 clone()不会调用构造方法；new会调用构造方法 clone()更快。clone()能快速创建一个已有对象的副本，即创建对象并且将已有对象中所有属性值克隆；new只能在JVM中申请一个空的内存区域，对象的属性值要通过构造方法赋值","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"基本数据类型与String之间的转换","slug":"基本数据类型与String之间的转换","date":"2018-12-19T13:12:35.000Z","updated":"2019-06-18T08:56:04.860Z","comments":true,"path":"2018/12/19/基本数据类型与String之间的转换/","link":"","permalink":"https://www.xiongtianci.com/2018/12/19/基本数据类型与String之间的转换/","excerpt":"","text":"字符串转基本数据类型调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型。 基本数据类型转字符串一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String类中的valueOf()方法返回相应字符串","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"为何short s1=1;是对的，而float f=3.4;是错的？","slug":"为何short s1=1;是对的，而float f=3.4;是错的？","date":"2018-12-19T12:42:28.000Z","updated":"2019-06-18T08:56:10.419Z","comments":true,"path":"2018/12/19/为何short s1=1;是对的，而float f=3.4;是错的？/","link":"","permalink":"https://www.xiongtianci.com/2018/12/19/为何short s1=1;是对的，而float f=3.4;是错的？/","excerpt":"","text":"在Java中，没小数点的默认是int ,有小数点的默认是 double 编译器可以自动向上转型，如 int 转成 long 系统自动转换没有问题，因为后者精度更高 ；但如果是向下转型，就需要强制类型转换 short类型变量的初始化语句，只要不超过short范围( -215 ~ 215-1 )的就可以直接初始化，所以short s1 = 1;是对的；而对于小数，默认情况下：float f=3.4;中的小数3.4此时为double类型。此时，等式float f=3.4;左边为float类型，等式右边为double类型，将涉及到强制类型转换，所以float f=3.4;这个写法是错误的，","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"ES6语法指南","slug":"ES6语法指南","date":"2018-12-18T08:10:28.000Z","updated":"2019-06-18T08:55:42.495Z","comments":true,"path":"2018/12/18/ES6语法指南/","link":"","permalink":"https://www.xiongtianci.com/2018/12/18/ES6语法指南/","excerpt":"","text":"作者：阮一峰 链接：http://es6.ruanyifeng.com/ ES6 语法指南后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： for(var i = 0; i &lt; 5; i++){ console.log(i); } console.log(&quot;循环外：&quot; + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： for(let i = 0; i &lt; 5; i++){ console.log(i); } console.log(&quot;循环外：&quot; + i) 结果： const const声明的变量是常量，不能被修改 3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 3.3.解构表达式 数组解构 比如有一个数组： let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值 // 然后打印 console.log(x,y,z); 结果： 对象解构 例如有个person对象： const person = { name:&quot;jack&quot;, age:21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } 我们可以这么做： // 解构表达式获取值 const {name,age,language} = person; // 打印 console.log(name); console.log(age); console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： function add(a , b) { // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b; } // 传一个参数 console.log(add(10)); 现在可以这么写： function add(a , b = 1) { return a + b; } // 传一个参数 console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： var print = function (obj) { console.log(obj); } // 简写为： var print2 = obj =&gt; console.log(obj); 多个参数： // 两个参数的情况： var sum = function (a , b) { return a + b; } // 简写为： var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 var sum3 = (a,b) =&gt; { return a + b; } 对象的函数属性简写 比如一个Person对象，里面有eat方法： let person = { name: &quot;jack&quot;, // 以前： eat: function (food) { console.log(this.name + &quot;在吃&quot; + food); }, // 箭头函数版： eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food),// 这里拿不到this // 简写版： eat3(food){ console.log(this.name + &quot;在吃&quot; + food); } } 箭头函数结合解构表达式 比如有一个函数： const person = { name:&quot;jack&quot;, age:21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } function hello(person) { console.log(&quot;hello,&quot; + person.name) } 如果用箭头函数和解构表达式 var hi = ({name}) =&gt; console.log(&quot;hello,&quot; + name); 3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 let arr = [&#39;1&#39;,&#39;20&#39;,&#39;-5&#39;,&#39;3&#39;]; console.log(arr) arr = arr.map(s =&gt; parseInt(s)); console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： const arr = [1,20,-5,3] 没有初始值： 指定初始值： 3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： const promise = new Promise(function(resolve, reject) { // ... 执行异步操作 if (/* 异步操作成功 */){ resolve(value);// 调用resolve，代表Promise将返回成功的结果 } else { reject(error);// 调用reject，代表Promise会返回失败结果 } }); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： promise.then(function(value){ // 异步执行成功后的回调 }); 如果想要处理promise异步执行失败的事件，还可以跟上catch： promise.then(function(value){ // 异步执行成功后的回调 }).catch(function(error){ // 异步执行失败后的回调 }) 示例： const p = new Promise(function (resolve, reject) { // 这里我们用定时任务模拟异步 setTimeout(() =&gt; { const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) { resolve(&quot;成功！num:&quot; + num) } else { reject(&quot;出错了！num:&quot; + num) } }, 300) }) // 调用promise p.then(function (msg) { console.log(msg); }).catch(function (msg) { console.log(msg); }) 结果： 3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： // Set构造函数可以接收一个数组或空 let set = new Set(); set.add(1);// [1] // 接收数组 let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： set.add(1);// 添加 set.clear();// 清空 set.delete(2);// 删除指定元素 set.has(2); // 判断是否存在 set.keys();// 返回所有key set.values();// 返回所有值 set.entries();// 返回键值对集合 // 因为set没有键值对，所有其keys、values、entries方法返回值一样的。 set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： // map接收一个数组，数组中的元素是键值对数组 const map = new Map([ [&#39;key1&#39;,&#39;value1&#39;], [&#39;key2&#39;,&#39;value2&#39;], ]) // 或者接收一个set const set = new Set([ [&#39;key1&#39;,&#39;value1&#39;], [&#39;key2&#39;,&#39;value2&#39;], ]) const map2 = new Map(set) // 或者其它map const map3 = new Map(map); 方法： 3.8.模块化3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： const util = { sum(a,b){ return a + b; } } 我可以使用export将这个对象导出： const util = { sum(a,b){ return a + b; } } export util; 当然，也可以简写为： export const util = { sum(a,b){ return a + b; } } export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： var name = &quot;jack&quot; var age = 21 export {name,age} 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： // 无需声明对象的名字 export default { sum(a,b){ return a + b; } } 这样，当使用者导入时，可以任意起名字 3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： // 导入util import util from &#39;hello.js&#39; // 调用util中的属性 util.sum(1,2) 要批量导入前面导出的name和age： import {name, age} from &#39;user.js&#39; console.log(name + &quot; , 今年&quot;+ age +&quot;岁了&quot;) 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"},{"name":"转载","slug":"转载","permalink":"https://www.xiongtianci.com/categories/转载/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.xiongtianci.com/tags/ES6/"}],"author":"天赐"},{"title":"IntellijIDEA使用时的小技巧","slug":"Intellij IDEA使用时的小技巧","date":"2018-12-17T10:24:16.000Z","updated":"2019-06-18T08:55:35.753Z","comments":true,"path":"2018/12/17/Intellij IDEA使用时的小技巧/","link":"","permalink":"https://www.xiongtianci.com/2018/12/17/Intellij IDEA使用时的小技巧/","excerpt":"","text":"使用Inject language编写JSON字符串如果你使用IDEA在编写JSON字符串的时候，然后要一个一个\\去转义双引号的话，就实在太不应该了，又烦又容易出错。在IDEA可以使用Inject language帮我们自动转义双引号 在双引号内 Alt+回车，选择Inject language or reference，然后回车 输入 json，在列表中选择 json组件，回车 选择完后，在双引号内Alt+回车，选择Edit JSON Fragment，回车 此时将弹出编辑JSON文件的视图了 可以看到IDEA确实帮我们自动转义双引号了。如果要退出编辑JSON信息的视图，只需要使用Ctrl+F4快捷键即可。 Structure展示一个类的所有方法或者使用Ctrl+F12弹框查看当前类的所有方法","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"自定义百度云分享密码","slug":"自定义百度云分享密码","date":"2018-12-14T01:13:35.000Z","updated":"2019-06-18T08:55:28.421Z","comments":true,"path":"2018/12/14/自定义百度云分享密码/","link":"","permalink":"https://www.xiongtianci.com/2018/12/14/自定义百度云分享密码/","excerpt":"","text":"第一步打开百度云盘网页版 第二步找到需要分享的资源，点击分享之后看见下面内容： 别动，重点的在后面 第三步按下F12，进入开发者模式，点击 consle 进入控制台，如下图： 第四步在控制台中输入下面代码，按下回车 avascript:require([“function-widget-1:share/util/shareFriend/createLinkShare.js”]).prototype.makePrivatePassword=function(){return prompt(“请输入自定义的密码”,”1234”)} 第五步关闭开发者模式，点击“创建链接”，输入你想要自定义的密码，回车确定即可","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"百度网盘","slug":"百度网盘","permalink":"https://www.xiongtianci.com/tags/百度网盘/"}],"author":"天赐"},{"title":"微信小程序笔记","slug":"微信小程序笔记","date":"2018-12-11T13:15:58.000Z","updated":"2019-06-18T08:55:22.552Z","comments":true,"path":"2018/12/11/微信小程序笔记/","link":"","permalink":"https://www.xiongtianci.com/2018/12/11/微信小程序笔记/","excerpt":"","text":"微信小程序账号与工具在线文档：https://mp.weixin.qq.com/debug/wxadoc/dev/ 小程序开发者账号注册微信公众平台：https://mp.weixin.qq.com/ 小程序开发者账号注册：https://mp.weixin.qq.com/wxopen/waregister?action=step1 微信开发者工具微信开发者工具：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html 小程序在线Demo二维码体验小程序官方源码：https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip 微信小程序文件结构主体文件结构主体部分由三个文件组成，必须放在项目的根目录，如下： 文件 必填 作用 app.js 是 小程序逻辑 app.json 是 小程序公共设置 app.wxss 否 小程序公共样式表 页面文件结构页面由四个文件组成，分别是： 文件类型 必填 作用 js 是 页面逻辑 ( 微信小程序没有window和document对象 ) wxml 是 页面结构 ( XML语法，不是HTML语法 ) wxss 否 页面样式表 ( 拓展了rpx尺寸单位，微信专属响应式像素 ) json 否 页面配置 ( 不能写注释，否则编译报错 ) WXML 结构_基础 (标签、组件)组件文档：https://mp.weixin.qq.com/debug/wxadoc/dev/component/ 常用布局标签(组件)&lt;view&gt;&lt;/view&gt; 相当于 &lt;div&gt;&lt;/div&gt; &lt;text&gt;&lt;/text&gt; 相当于 &lt;span&gt;&lt;/span&gt; &lt;image&gt;&lt;/image&gt; 相当于 &lt;img /&gt; &lt;navigator&gt;&lt;/navigator&gt; 相当于 &lt;a&gt;&lt;/a&gt; &lt;block&gt;&lt;/block&gt; 区块标签，不会渲染到页面 注意：image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高 常用表单标签(组件)&lt;button&gt;&lt;/button&gt; &lt;input type=&quot;text&quot; /&gt; &lt;checkbox /&gt; &lt;radio/&gt; 轮播图组件&lt;swiper indicator-dots=&quot;是否显示面板指示点&quot; autoplay=&quot;是否自动切换&quot; interval=&quot;自动切换时间间隔&quot; duration=&quot;滑动动画时长&quot;&gt; &lt;swiper-item&gt; &lt;image src=&quot;图片路径1&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&quot;图片路径2&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; 探索：实现无缝轮播怎么办？ WXSS 样式WXSS (WeiXin Style Sheets) 是一套样式语言。 WXSS文档： https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html WXSS 新增特性与 CSS 相比，WXSS 扩展以下2个特性： 尺寸单位 rpx ( responsive pixel 响应式像素) 样式导入 @import “样式表路径”; 尺寸单位 rpx ( responsive pixel 响应式像素) : 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 JSON 配置配置文档：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html app.json 配置项列表 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口表现 tabBar Object 否 设置底部 tab 的表现 networkTimeout Object 否 设置网络超时时间 debug Boolean 否 设置是否开启 debug 模式 如：app.json { &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;: { &quot;navigationBarTitleText&quot;: &quot;小程序标题&quot; }, &quot;tabBar&quot;: { &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; }, { &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;Tab栏&quot; }] }, &quot;networkTimeout&quot;: { &quot;request&quot;: 10000, &quot;downloadFile&quot;: 10000 }, &quot;debug&quot;: true } window 配置 用于设置小程序的状态栏、导航条、标题、窗口背景色。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉背景字体、loading 图的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数。 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px window 配置图示 window 配置注意事项 !! 注意：页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个关键词。 如：/pages/message/message.json { &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;内页标题修改&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot; } tabBar 配置如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 属性说明： 属性 类型 必填 默认值 描述 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black/white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top，设置成top是无图标 其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 tabBar 配置图示 tabBar 配置注意事项 当设置 position 为 top 时，将不会显示 icon。 tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 icon 大小限制为40kb，建议尺寸为 81px * 81px。 JS 行为(逻辑)微信小程序生命周期函数Page({ /** 页面的初始数据 */ data: { }, /** 生命周期函数--监听页面加载 */ onLoad: function (options) { console.log(options); }, /** 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** 生命周期函数--监听页面显示 */ onShow: function () { }, /** 生命周期函数--监听页面隐藏 */ onHide: function () { }, /** 生命周期函数--监听页面卸载 */ onUnload: function () { } }) 页面相关事件处理函数 /** 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { }, /** 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /** 用户点击右上角分享 */ onShareAppMessage: function () { } 注意事项 微信小程序没有BOM和DOM概念，所以不能使用window对象和document对象。 WXML 高级(指令、事件)数据绑定 &#123;&#123; &#125;&#125;&lt;!--wxml--&gt; &lt;view&gt; {{message}} &lt;/view&gt; // page.js Page({ data: { message: &#39;Hello MINA!&#39; } }) 特别注意 花括号和引号之间不能有空格。 不要直接写 checked=”false”，其计算结果是一个字符串，转成 boolean 类型后代表真值。 &lt;checkbox checked=&quot;false&quot;&gt; &lt;/checkbox&gt; 其计算结果是一个字符串，转成 boolean 类型后变成了 true &lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt; 正确写法 列表渲染 wx:for&lt;!--wxml--&gt; &lt;view wx:for=&quot;{{array}}&quot;&gt; {{item}} &lt;/view&gt; // page.js Page({ data: { array: [1, 2, 3, 4, 5] } }) wx:key主要功能：提高列表渲染时排序的效率。 wx:key 的值以两种形式提供： 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 条件渲染 wx:if wx:else wx:elif&lt;!--wxml--&gt; &lt;view wx:if=&quot;{{length >= 80}}&quot;&gt; 优秀 &lt;/view&gt; &lt;view wx:elif=&quot;{{length >= 60}}&quot;&gt; 良好 &lt;/view&gt; &lt;view wx:else&gt; 加油 &lt;/view&gt; // page.js Page({ data: { length: &#39;95&#39; } }) wx:if 与 hidden 区别 wx:if 是否渲染， hidden 是否隐藏。 一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。 因此，如果需要频繁切换的情景下，用 hidden 更好。 事件 事件对象可以获取额外信息，如 id, dataset(自定义属性集合), touches(触摸点坐标)。 事件绑定和冒泡 冒泡事件 bind事件类型 如 bindtap bindlongpress 非冒泡事件 catch事件类型 如 catchtap catchlongpress 常用事件类型 类型 触发条件 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 &lt;!--wxml--&gt; &lt;view data-index=&quot;自定义属性&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt; // page.js Page({ tapHandle: function(event) { console.log(event) } }) 事件传参注意小程序绑定事件只能写函数名称，不能通过括号方式传参。 &lt;!--wxml--&gt; &lt;view bindtap=&quot;tapHandle(520)&quot;&gt; 点我触发事件 &lt;/view&gt; 错误，事件不能触发 &lt;view data-index=&quot;520&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt; // page.js Page({ tapHandle: function(event) { console.log( event.target.dataset.index ); // 输出标签自定义属性上的index值 } }) WXS 脚本WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，功能类似&lt;script&gt;标签，主要用于在视图层定义函数(比较少用)。 注意 wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。 wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。 wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。 wxs 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 &lt;!--wxml--&gt; &lt;wxs module=&quot;foo&quot;&gt; var sum = function(a,b){ return a+b; }; // 这里可以导出一个对象，这个对象可以直接在界面上使用 module.exports.sum = sum; &lt;/wxs&gt; &lt;view&gt; {{foo.sum(1,2)}} &lt;/view&gt; 微信开发者工具常用快捷键 快捷键 说明 Shift + Alt + F 格式化代码 Ctrl + P 跳到文件 Ctrl + E 跳到最近文件 Ctrl + Shift + P 上传扫码预览 Ctrl + Shift + I 显示/隐藏调试器","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.xiongtianci.com/tags/微信小程序/"}],"author":"天赐"},{"title":"Hystrix状态","slug":"Hystrix状态","date":"2018-12-07T00:12:05.000Z","updated":"2019-06-18T08:55:15.751Z","comments":true,"path":"2018/12/07/Hystrix状态/","link":"","permalink":"https://www.xiongtianci.com/2018/12/07/Hystrix状态/","excerpt":"","text":"@SpringCloudApplication 相当于：@EnableCircuitBreaker、@EnableDiscoveryClilent、@SpringBootApplication 熔断器状态的相关配置@HystrixProperty相关配置在抽象类：package com.netflix.hystrix.HystrixCommandProperties 中 熔断器开启或者关闭的条件： 1、 当满足一定的阀值的时候（默认10秒内超过20个请求次数） 2、 当失败率达到一定的时候（默认10秒内超过50%的请求失败） 3、 到达以上阀值，断路器将会开启 4、 当开启的时候，所有请求都不会进行转发 5、 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。 // 开启服务降级 @HystrixCommand( // 熔断器状态相关配置 commandProperties = { // 当请求次数达到10次时才能开启熔断 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), // 状态变换的时间，由开启 --&gt; 半开 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;20000&quot;), // 失败请求/所有请求=60% --&gt; 开启熔断器 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;) } )","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://www.xiongtianci.com/tags/SpringCloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://www.xiongtianci.com/tags/Hystrix/"}],"author":"天赐"},{"title":"HashSet如何去重？","slug":"HashSet如何去重","date":"2018-12-06T02:37:51.000Z","updated":"2019-06-18T08:55:08.385Z","comments":true,"path":"2018/12/06/HashSet如何去重/","link":"","permalink":"https://www.xiongtianci.com/2018/12/06/HashSet如何去重/","excerpt":"","text":"&lt; !– more –&gt;HashSet存储元素的原理：往hashSet添加元素的时候，首先会调用元素的 hashCode 方法得到元素的哈希码值，然后把哈希码值经过运算算出该元素存在哈希表中的位置。有两种情况： 情况1：如果算出的位置目前还没有存在任何的元素，那么该元素可以直接添加到哈希表中。 情况2： 如果算出的位置目前已经存在其他的元素，那么还会调用元素的 equals 方法再与这个位置上的元素比较一次。如果 equals 方法返回的是true，那么该元素被视为重复元素，不允许添加。如果equals方法返回的是false，那么该元素也可以被添加。 先看个最简单的构造方法* Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() { map = new HashMap&lt;&gt;(); } 很明显，HashSet底层是Hashmap存储的。借大神的话 HashSet 就是HashMap的马甲 —–someone 再看看add方法// Dummy value to associate with an Object in the backing Map private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); /** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) { return map.put(e, PRESENT)==null; } add方法的参数： map：map是一个HashMap的实例 e：我们要存储的值，是HashMap的key PRESENT：固定值( Object PRESENT = new Object(); )，空的obj对象 Set偷偷的用了HashMap的 put 方法，然而HashMap并没有去重的功能呀，那么Set是如何做到去重的呢？ 从add方法中可以看到，E是我们要存储的值，而到了HashMap里面却变成了Key，PRESENT就是个空对象。 在HashMap中Key的HashCode是决定底层数组的下标，进一步使用 equals 进行遍历对象链表中的Key进而覆盖原来的Value。 那么对于HashSet，如果 e 已经存在（先HashCode相同定位到链表，然后equals比较定位到具体的Node），那么覆盖oldValue（value其实就是个傀儡，没啥用），Key不变；如果不存在，就添加一个新的节点（即加了一个新的Key）。 HashMap的返回值是oldValue，oldValue==null说明节点之前不存在；反之说明节点存在，虽然返回false但实际上还是对底层数据进行了改变（即旧的空对象变成了新的空对象）。 总而言之，HashSet确定相同的方式其实就是HashCode相同（才能找到同一链表），然后equals的返回值（才能比较具体节点进行覆盖）。 重点看key（敲黑板）HashMap中的put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 这里边有两个看点： HashMap中key存储是hash后的值，对于String类型的相同值的hash值是一致的（其他接触类型类似，自定义对象类型需要重写hashcode方法与equel方法）。换句话说相同的值在hashMap中的存储位置是一样的。 基于上一点来看看怎么存储重复值的。如下代码对于hashMap中已经存在的key，key不变，新value覆盖就value。对于HashSet而言新旧value都是PRESENT对象，所以set在存储的时候就不会重复。 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } 所以hashset中存储的值输出的顺序和存储的先后顺序不一致，这是因为hashset是按照值的hash顺序进行输出。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"HashSet","slug":"HashSet","permalink":"https://www.xiongtianci.com/tags/HashSet/"}],"author":"天赐"},{"title":"IDEA常用快捷键","slug":"IDEA常用快捷键","date":"2018-12-04T07:45:52.000Z","updated":"2019-06-18T08:54:55.798Z","comments":true,"path":"2018/12/04/IDEA常用快捷键/","link":"","permalink":"https://www.xiongtianci.com/2018/12/04/IDEA常用快捷键/","excerpt":"","text":"Ctrl+Alt+D –&gt; 查看当前类的实现类 ctrl+l –&gt; 重写方法","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"IDEA创建SpringBoot开启找回RunDashboard","slug":"IDEA创建SpringBoot开启找回RunDashboard","date":"2018-12-04T06:32:05.000Z","updated":"2019-06-18T08:55:01.865Z","comments":true,"path":"2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/","link":"","permalink":"https://www.xiongtianci.com/2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/","excerpt":"","text":"Run Dashboard 面板Run Dashboard：微服务项目的开发过程中，工程会非常多，经常要启动很多个服务，才能完成一项测试。启动的多了，容易给开发者带来错乱的感觉，很不方便管理。IDEA开发工具推荐了一个很好用的功能–Run Dashboard。他是 Run 的升级版 我们可以对比一下这个是Run Dashboard的窗口 普通的Run窗口： 显然如果启动多个端口Run Dashboard窗口显得更好管理。一般有时候创建springboot项目的时候右下角可以提示你打开Run Dashboard，但是如果不提醒就需要自己配置了。 配置方法方式一新建项目或者通过 open 打开项目时，可能会弹出提示 “Multiple Spring Boot run configurations were detected. Run Dashboard allows to manage multiple run configurations at once.” 见下图： 点击 Show run configurations in Run Dashboard ，Run Dashboard 面板重新在底部区域展示了出来。 如没有此提示，请选择方式二或方式三 方式二打开Run Dashboard：View –&gt; Tool Windows –&gt; Run Dashboard 方式三如果上述的方式都没有打开 Run Dashboard 面板，可以在工程目录下找 .idea 文件夹下的 workspace.xml文件，通过修改此文件可达到打开 Run Dashboard 面板的目的 找到当前项目中 .idea 文件下的 workspace.xml 文件，双击打开 接下来找到 &lt;component name=&quot;RunDashboard&quot;&gt; 加入如下配置： &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; 这样 Run Dashboard 自动就弹出来了 最终配置如下： &lt;component name=&quot;RunDashboard&quot;&gt; &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name=&quot;ruleStates&quot;&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt; &lt;/component&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://www.xiongtianci.com/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"Vue基础-基本语法","slug":"Vue基础-基本语法","date":"2018-11-30T09:37:11.000Z","updated":"2019-06-18T08:54:48.400Z","comments":true,"path":"2018/11/30/Vue基础-基本语法/","link":"","permalink":"https://www.xiongtianci.com/2018/11/30/Vue基础-基本语法/","excerpt":"","text":"1. 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 2. 安装 Vue2.1 下载安装下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件 2.2 使用CDN或者也可以直接使用公共的CDN服务： &lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 或者： &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 3. 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template 4. Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别（了解内容） MVC 主要是后端的分层开发思想；把 一个完整的后端项目，分成了三个部分： Model：（数据层）主要负责 数据库的操作； View：（视图层）所有前端页面，统称为 View 层 Controller：（业务逻辑层）主要处理对应的业务逻辑；（对于后台来说，这是开发的重点） MVVM是前端页面的分层开发思想，主要关注于 视图层 分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View, ViewModel Model 是 页面中，需要用到的数据 View 是页面中的HTML结构； ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念； 为什么有了MVC还要有MVVM 因为 MVC是后端的开发思想，并没有明确定义前端的页面该如何开发； MVVM 是前端的页面的开发思想，把每个页面，分成了三个部分，同时 VM 作为 MVVM 的核心，提供了双向数据绑定的概念，前端程序员，不需要手动渲染页面了，而且，页面数据发送变化，也不需要程序员手动把 数据的变化同步到Model中；这所有的操作，都是 VM 自动完成的！ 有了 MVVM 的思想以后，前端只关心 页面交互逻辑，不关心页面如何渲染； 4.2 Vue.js 基本代码 和 MVVM 之间的对应关系 注意：Vue中，不推荐程序员手动操作DOM元素；所以，在Vue项目中，没有极其变态的需求，一般不要引入 Jquery； Vue代码解析执行的步骤： 当 VM 实例对象，被 创建完成之后，会立即解析 el 指定区域中的所有代码； 当 VM 在解析 el 区域中所有代码的时候，会把 data 中的数据，按需，填充到 页面指定的区域； 注意：每当 vm 实例对象，监听到 data 中数据发生了变化，就会立即 重新解析 执行 el 区域内，所有的代码； mvvm是前端思想，mvc是后台思想 5. Vue调试工具vue-devtools的安装和使用Vue.js devtools - 翻墙安装方式 - 推荐 6. 快速入门7. Vue实例7.1 创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： var vm = new Vue({ // 选项 }) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods 等等 接下来我们一 一介绍。 7.2 模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div var vm = new Vue({ el:&quot;#app&quot; }) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 7.3 数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt; &lt;/div&gt; js: var vm = new Vue({ el:&quot;#app&quot;, data:{ name:&quot;刘德华&quot; } }) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 7.4 方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue的作用范围内使用。 html: &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; js写法一： &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ num:0 }, methods:{ add:function(){ this.num++; } } }); &lt;/script&gt; js写法二： &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ num:0 }, methods:{ add(){ this.num++; } } }); &lt;/script&gt; 7.5 生命周期7.5.1 生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 7.5.2 钩子函数钩子函数：生命周期函数的别名； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板【当 vm 实例的 data 和 methods 初始化完毕后，vm 实例会自动执行 created 函数】 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示【如果要通过某些插件操作页面上的DOM元素节点，最早要在 mounted 中进行】 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 例1：created代表在vue实例创建后； 我们可以在Vue中定义一个created函数，代表这个时期的构造函数： html: &lt;div id=&quot;app&quot;&gt; {{hello}} &lt;/div&gt; js: &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ hello:&#39;&#39; }, created(){ this.hello = &#39;czdx,一统江湖，千秋万代&#39; } }); &lt;/script&gt; 结果： 例2： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;vuejs生命周期&lt;/title&gt; &lt;script src=&quot;vuejs-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{message}} &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { message: &#39;hello world&#39; }, beforeCreate: function() { showData(&#39;创建vue实例前&#39;, this); }, created: function() { showData(&#39;创建vue实例后&#39;, this); }, beforeMount: function() { showData(&#39;挂载到dom前&#39;, this); }, mounted: function() { showData(&#39;挂载到dom后&#39;, this); }, beforeUpdate: function() { showData(&#39;数据变化更新前&#39;, this); }, updated: function() { showData(&#39;数据变化更新后&#39;, this); }, beforeDestroy: function() { showData(&#39;vue实例销毁前&#39;, this); }, destroyed: function() { showData(&#39;vue实例销毁后&#39;, this); } }); function realDom() { console.log(&#39;真实dom结构：&#39; + document.getElementById(&#39;app&#39;).innerHTML); } function showData(process, obj) { console.log(process); console.log(&#39;data 数据：&#39; + obj.message) console.log(&#39;挂载的对象：&#39;) console.log(obj.$el) realDom(); console.log(&#39;------------------&#39;) console.log(&#39;------------------&#39;) } vm.message = &quot;good...&quot;; vm.$destroy(); &lt;/script&gt; &lt;/html&gt; 7.5.3 this我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this var vm = new Vue({ el:&quot;#app&quot;, data:{ hello: &#39;&#39; // hello初始化为空 }, created(){ this.hello = &quot;czdx,一统江湖，千秋万代&quot;; console.log(this); } }) 控制台的输出： 8. 指令指令 (Directives)： 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 8.1 插值表达式8.1.1 大括号 u007B;u007B; 格式： u007B;u007B;表达式 说明：","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.xiongtianci.com/tags/Vue/"}],"author":"天赐"},{"title":"Java线程状态","slug":"Java线程状态","date":"2018-11-30T09:23:50.000Z","updated":"2019-06-18T08:47:27.647Z","comments":true,"path":"2018/11/30/Java线程状态/","link":"","permalink":"https://www.xiongtianci.com/2018/11/30/Java线程状态/","excerpt":"","text":"Java线程状态网上流传了很久的线程具备5种状态，这样是不贴切JDK中描述的，JDK中描述线程状态只有6种，而网络流传的5种状态就是进程的五态模型。那张广为流传的来自网络的图如下： 很明显这是操作系统中进程的5种状态，在很多操作系统书中也由介绍分别为new，ready，running，waiting，terminated。不幸的是，有很多的书上常常把这些进程状态，线程状态与Java线程状态混在一起谈。 进程与线程的区分总图： 很多人觉得在JVM线程中应该有，Running运行状态。对JAVA而言，Runnable包含了就绪与运行，那为什么JAVA不区分开呢？这跟CPU分配的时间片有关，而且JAVA进行的是抢占式轮转调度，由于我们的JVM线程是服务于监控，线程又是切换的如此之快，那么区分ready与running又没有多大意义了。再者，我们都知道现在使用的很多JVM底层都将线程映射到操作系统上了，JVM本身没有做什么调度，因为虚拟机看到的都是底层的映射与封装，故而将ready与running映射来也没有太大意义，不如统一为Runnable 总之还是有些乱的，我们不妨就拿Windows系统为例，用的就是“进程”和“线程”这两种较为标准的叫法，这时一个进程下至少有一个线程，线程是CPU调度的基本单位，进程不参与CPU调度，CPU根本不知道进程的存在。 为了避免混乱，下面说的线程状态，只是站在JVM层面上 我们先来看下，这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 初始(NEW)：新创建了一个线程对象，但还没有调用 start() 方法。 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running） 阻塞(BLOCKED)：表示线程阻塞于锁 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断） 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回 终止(TERMINATED)：表示该线程已经执行完毕 1. NEW(新建)状态 概念：线程对象创建了，但是还没有启动之前，就是新建状态 实现 Runnable接口 或继承 Thread 可以得到一个线程类，new一个实例出来，线程就进入了初始状态。 这里强调两点： 线程对象创建之后，还未开启( 调用start()方法 )时候，就处于NEW的状态 开启线程，指的是调用start方法，并不是run方法，run方法仅仅作为一个普通方法存在 线程对象调用 run() 方法不开启线程，仅是对象调用方法。线程对象调用 start() 方法开启线程，并让jvm调用 run() 方法在开启的线程中执行 当我们执行 new Thread(target) 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 Runnable (可运行)状态。 在我们研究线程状态时，采用Thread中的getState()方法进行研究 通过代码演示： public class MyThread extends Thread{ @Override public void run() { // 线程执行的代码 } } /** * 研究新建线程状态 * 新建状态：至今还未启动的线程处于这一状态 */ public class ThreadStateTest1 { public static void main(String[] args) { // 创建线程对象 MyThread myThread = new MyThread(); // 线程默认名：Thread-0 Thread-1... System.out.println(myThread.getName()); System.out.println(&quot;线程创建之后处于：&quot; + myThread.getState()); myThread.run(); System.out.println(&quot;线程run之后处于：&quot; + myThread.getState()); myThread.start(); System.out.println(&quot;线程start之后处于：&quot; + myThread.getState()); } } // 输出： // 线程创建之后处于：NEW // 线程run之后处于：NEW // 线程start之后处于：RUNNABLE 当我们执行 new Thread(target) 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 Runnable (可运行)状态。所以说 当业务需要频繁创建线城市，最好使用线程池，提高效率减轻JVM的压力。当然如果大量线程进行频繁上下文切换，此时多线程的效率会大打折扣。 2. RUNNABLE(可运行)状态 可运行状态：一个在JVM中执行的线程处于这个状态中，等待JVM调度，德能在执行，也可能在等待 注：这里的等待指的是等待调度，等待的是系统资源，如IO、CPU时间片，与 sleep、lock 的等待有着本质差别。 接下来使用代码演示一个最简单的可运行状态： public class MyThread extends Thread { @Override public void run() { System.out.println(&quot;线程开始执行&quot;); System.out.println(&quot;线程开始执行具体的任务&quot;); // 假设这个任务使用5秒钟 long beiginTime = System.currentTimeMillis(); while (System.currentTimeMillis()-beiginTime &lt; 5000){ // 假设做了5秒钟的任务 } System.out.println(&quot;线程执行完毕&quot;); } } /** * 可运行状态 * 当线程有资格运行，调用了start方法，线程首先进入可运行状态 * 这种可运行状态不一定被线程调度运行 * 简单来说，调用start方法之后，该线程处于可运行状态，但未运行 * 此时存放在&quot;可运行池&quot;中 * 线程在运行的过程中，自然该线程也是处于可运行状态 * * JDK中处于可运行状态的线程，有两种，一种是正在JVM中运行， * 另一种是可能正在等待操作系统其它资源，比如处理器 */ public class Demo { public static void main(String[] args) { // 创建线程对象 MyThread myThread = new MyThread(); System.out.println(&quot;创建完成之后：&quot; + myThread.getState()); // 开启线程 myThread.start(); System.out.println(&quot;开启线程之后：&quot; + myThread.getState()); } } 3. BLOCHED(阻塞)状态我们还是使用代码来解析一下锁阻塞状态： public class ThreadA extends Thread { private Object obj; public ThreadA(String name,Object obj){ super(name); this.obj = obj; } @Override public void run() { // 同步代码块 synchronized (obj){ System.out.println(&quot;线程A开始执行&quot;); System.out.println(&quot;线程A真正开始执行代码了&quot;); long beginTime = System.currentTimeMillis(); // 模拟5秒钟的任务 while(System.currentTimeMillis()-beginTime &lt; 5000){ } System.out.println(&quot;线程A执行完毕&quot;); } } } public class ThreadB extends Thread{ private Object obj; public ThreadB(String name,Object obj){ super(name); this.obj = obj; } @Override public void run() { // 同步代码块 synchronized (obj){ System.out.println(&quot;线程B开始执行&quot;); System.out.println(&quot;线程B真正开始执行代码了&quot;); long beginTime = System.currentTimeMillis(); // 模拟5秒钟的任务 while(System.currentTimeMillis()-beginTime &lt; 5000){ } System.out.println(&quot;线程B执行完毕&quot;); } } } /** * 线程状态之阻塞状态BLOCKED * JDK：锁阻塞并且正在等待监视器锁的某一线程状态 * 处于受阻状态的某一线程正在等待监视器锁，以便进入一个同步代码块/同步方 * 还有就是 调用Object.wart方法之后，再次进入同步中时 * */ public class BlockedDemo { public static void main(String[] args) throws InterruptedException { // 创建一个锁对象 Object obj = new Object(); // 创建线程A、B ThreadA a = new ThreadA(&quot;线程A&quot;, obj); ThreadB b = new ThreadB(&quot;线程B&quot;, obj); // 开启线程 a.start(); b.start(); // Thread.sleep(3000); System.out.println(&quot;线程A的状态是：&quot; + a.getState()); System.out.println(&quot;线程B的状态是：&quot; + b.getState()); // Thread.sleep(3000); System.out.println(&quot;线程A的状态是：&quot; + a.getState()); System.out.println(&quot;线程B的状态是：&quot; + b.getState()); } } 在这里我们只是对之前分析的情况一进行了阐释 4. Timed Waiting(计时等待)状态 带指定的等待时间的等待线程所处的状态。一个线程处于这一状态是因为用一个指定的正的等待时间（为参数）调用了一下方法中的其一： Thread.sleep 带时限（timeout）的 Object.wait 带时限（timeout）的 Thread.join LockSupport.parkNanos LockSupport.parkUntil Timed Waiting 在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 注：sleep的使用时区别去其他方法的。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting（计时等待），那么我们通过一个案例加深对该状态的一个理解： 实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串 代码： /** * 限时等待 */ public class MyThread extends Thread { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;mt的线程状态： &quot; + myThread.getState()); } } // 实现一个计算器，0-99计数，在每个数字之间暂停1秒，每个10个数字输出一个字符串 @Override public void run() { for (int i = 0; i &lt; 99; i++) { if (i%10 == 0){ System.out.println(&quot;oewewowllskd &quot; + i); } System.out.println(i); try { Thread.sleep(1000); System.out.println(&quot; 休息了1秒&quot;); } catch (Exception e) { e.printStackTrace(); } } } } 通过案例可以发西咸，sleep方法的使用还是很简单的。我们需要记住下面几点： 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 为了让其他线程有机会执行，可以将Thread.sleep() 的调用放线程run()之内，这样才能保证该线程执行过程中会睡眠 sleep 与锁无关，线程睡眠到期自动苏醒，并返回到 Runnable（可运行）状态 小提示：sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep() 方法不能保证该线程睡眠到期后就开始立刻执行 5. WAITING(无限等待)状态Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 一个线程进入 WAITING 状态是因为调用了以下方法： 不带时限的 Object.wait 方法 不带时限的 Thread.join 方法 LockSupport.park 然后会等其他线程执行一个特别的动作，比如： 一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 或 Object.notifyAll() 一个调用了 Thread.join 方法的线程会等待指定的线程结束 代码演示： /** * 无限等待 * Object中的wait方法完成 * 使用当前线程 进入无限等待状态，直到其他线程有唤醒 notify 或 notifyAll 才能被唤醒 * * 线程间通信 两个线程执行不同的操作 关联的 * 两个线程 使用同样的锁 只能使用锁对象调用wait方法或者notify方法 */ public class WaitingTest { private static Object obj = new Object(); public static void main(String[] args) throws InterruptedException { // 使用匿名函数创建线程 Thread t1 = new Thread() { @Override public void run() { synchronized (obj){ System.out.println(&quot;获取到锁，调用wait方法，当前线程进入无线等待状态。。。等待着别的线程来唤醒&quot;); try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;唤醒了这个线程，就不再是线程等待了，线程执行完毕&quot;); } } }; // 开启线程t1 t1.start(); // 使用匿名内部内方式创建一个新的线程，用来唤醒t1线程 new Thread(){ @Override public void run() { // 获取到锁 synchronized (obj){ try { // 3秒钟后执行唤醒操作 Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;获取到锁 执行 唤醒操作&quot;); // 唤醒操作 obj.notify(); } } }.start(); // 4秒后查看线程t1状态 Thread.sleep(4000); System.out.println(&quot;查看t1的线程状态&quot; + t1.getState()); } } 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 方法或 Object.notifyAll() 方法 其实 waiting 状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司了你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作一完成某些任务。 6. TEMINATED(终止)状态线程因如下两个原因之一将被终止： run() 方法正常退出而自然死亡 一个没有捕获的异常终止了 run() 方法而意外死亡 线程的方法1. wait(), notify(), notifyAll()等方法介绍在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait() 的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify() 是唤醒单个线程，而 notifyAll() 是唤醒所有的线程。 Object类中关于等待/唤醒的API详细信息如下：notify() – 唤醒在此对象监视器上等待的单个线程。notifyAll() – 唤醒在此对象监视器上等待的所有线程。wait() – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout, int nanos) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Java线程","slug":"Java线程","permalink":"https://www.xiongtianci.com/tags/Java线程/"}],"author":"天赐"},{"title":"Flex布局","slug":"Flex布局","date":"2018-11-30T09:12:44.000Z","updated":"2019-06-18T08:47:20.783Z","comments":true,"path":"2018/11/30/Flex布局/","link":"","permalink":"https://www.xiongtianci.com/2018/11/30/Flex布局/","excerpt":"","text":"Flex 布局教程：语法篇 作者： 阮一峰链接： http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 网页布局（layout）是 CSS 的一个重点应用 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的 Flex 写法。网友JailBreak 为本文的所有示例制作了 Demo，也可以参考。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 .box{ display: flex; } 行内元素也可以使用 Flex 布局。 .box{ display: inline-flex; } Webkit 内核的浏览器，必须加上-webkit前缀。 .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性 (紫色大盒子) *以下6个属性设置在容器上。 flex-direction √ flex-wrap √ flex-flow justify-content √ align-items √ align-content 3.1 flex-direction属性 **flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性 **默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } 3.4 justify-content属性 **justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性 **align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性 (橙色小盒子) *以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性 **flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"},{"name":"装载","slug":"装载","permalink":"https://www.xiongtianci.com/categories/装载/"}],"tags":[{"name":"Flex","slug":"Flex","permalink":"https://www.xiongtianci.com/tags/Flex/"}],"author":"天赐"},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2018-11-30T08:19:55.000Z","updated":"2019-06-18T08:53:46.047Z","comments":true,"path":"2018/11/30/Linux常用命令/","link":"","permalink":"https://www.xiongtianci.com/2018/11/30/Linux常用命令/","excerpt":"","text":"1. Linux介绍（了解）1.1、Linux和Windows的区别Linux是一款操作系统。正规开发服务器项目部署都是放在Linux操作系统上。 Windows一款操作系统，民用操作系统。娱乐、影音、上网。 1.2、Linux历史及使用场景Linux诞生90年代，仿制Unix操作系统。 Linux是免费的，开源的 Unix是收费的，封闭的。 Linux使用场景：服务器操作系统，移动设备（安卓手机，平板电脑），路由器（WIFI），交换机，智能家居，Java程序开发 1.3、Linux的版本Linux的版本分为两种：内核版本(https://www.kernel.org/)和发行版本 Linux内核版本：Linux内核运维开发小组。 源码在一定程度上不是开源的。 Linux发行版本：由各大互联网/软件公司定制。 外围的样式功能的源码完全开源 一个内核版本是有多种多样的发行版本 Ubuntu：以强大的桌面应用为主，吸收不少Windows用户。 因为桌面应用会在一定程度上大量占用系统资源，开发。 服务器部署上，不会优先选择Ubuntu CentOS：对服务器性能进行了一定程度的优化，性能比较高，比较稳定。 服务器操作系统的优选CentOS 2、Linux安装【重点】2.1、虚拟机、Linux安装2.2、CentOS安装jdk、tomcat、mysql2.3、Linux目录介绍 /：Linux系统根目录 /etc：(etcetera) 系统配置文件存放的目录，不建议在此目录下存放可执行文件。 重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。 注：/etc/X11存放与 x windows 有关的设置（防火墙文件，网络设置文件，JDK环境配置文件，mysql） home:存放所有普通用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /root： 系统管理员root(超级用户)的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下 每一个用户都有家目录，超级管理员root家目录 /root Linux命令行模式中相当于Windows的桌面 /usr：(unix shared resources)：应用程序存放目录，比较重要的目录/usr/local本地系统管理员软件安装目录（安装系统级的应用） /usr/bin 存放应用程序 /usr/share 存放共享数据 /usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local:存放软件升级包 /usr/share/doc: 系统说明文件存放目录 /usr/share/man: 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间。​ Jdk,tomcat,mysql,redis,nginx /opt：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里 以上建议并不是强制性约束 2.4 网络三种连接方式2.4.1 桥接模式桥接模式(Bridged)：虚拟机是一台独立的电脑，直接连接到实际的网络上，与宿主机没有任何联系。 2.4.2 仅主机模式 这种方式下，虚拟机的网卡连接到宿主的 VMnet1 上，但系统并不为虚拟机提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。 仅主机模式(host-only)：虚拟机可以访问宿主机，宿主机无法访问虚拟机，虚拟机无法上网 2.4.3 NAT 模式 这种方式下，虚拟机的网卡连接到宿主的 VMnet8 上。此时系统的 VMWare NAT Service 服务就充当了路由器的作用，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。VMWare DHCP Service 负责为虚拟机提供 DHCP 服务。 NAT模式： 虚拟机可以访问宿主机，宿主机可以访问虚拟机 此时宿主机相当于路由器，虚拟机可以通过宿主机上网 宿主机可以配置254个虚拟机 3、常用命令【重点】Linux命令中参数，一般都是无序的。特殊情况下除外 注意：Linux中的命令严格区分大小写的！ 3.1、磁盘管理命令ls 列出目录内容 ls（list）功能：列出目录内容 格式： ls [参数] [文件或目录] # 参数 -a或--all 查询所有文件和文件夹，包含隐藏。注意隐藏文件、特殊目录、. 和 .. -l 查询详细列表 ls -l--&gt;简写：ll -h 友好展示信息 ll -h (d目录，-普通文件, l链接) -t 用文件和目录的更改时间排序。 -r 反向排序 --help 在线帮助 常用： ls -l --&gt; 此命令非常常用，提供简化版命令 ll ls -al ll /home/ --&gt; 显示指定目录下的内容 eg: 需求：展示某个目录下的内容 ls 目录名 所在位置：/root 想要查看:/etc目录下的内容 命令：ll -h /etc cd 切换目录 cd(change directory) 功能：切换目录 语法： # 格式 cd [目录] # 常用 cd /目录名 ，任意目录切换到指定目录中 /目录名--&gt;Linux的绝对路径 windows绝对路径--&gt;c:/xxxx/xxx.jpg?raw=true cd ../ ，向上一层目录 cd ~ ，切换到当前用户 家目录。root用户家目录 /root cd / ，切换到Linux的 根目录 cd - ，切换到上一次访问的目录。 只能两个目录相互切换 cd .. ，上一级目录 cd ，缺省当前用户目录 Linux绝对： eg：cd /etc/x1 先切换到 /目录，然后在 /目录 中找到子目录 etc，在 etc 中找 子目录x1 特点：在任意目录都可以随意切换 Linux相对： eg：cd x1/x2 在当前目录中寻找子目录x1, 在x1中寻找子目录x2 特点：必须确定 当前目录 下有子目录x1 pwd 显示当前的所在目录 pwd(print working directory) 功能：显示工作目录(当前的所在目录)。返回绝对路径 mkdir 创建目录 mkdir（make directoriy）功能： 创建目录 语法： # 格式 mkdir -p 文件夹名称 # 参数 -p 父目录不存在情况下先生成父目录 （parents） -v 显示命令执行过程中的详细信息 注意： 使用mkdir创建带后缀的文件时，创建的是目录，不是文件（创建文件使用touch命令） eg: # 1 需要在/root/t1目录下创建一个t2目录 位置：/root 命令：相对路径：mkdir t1/t2 绝对：mkdir /root/t1/t2 # 2 需要在/root/t3目录下创建一个t4目录 位置：/root 条件：t3和t4都不存在 命令：mkdir -p t3/t4 rmdir 删除空目录 rmdir(remove directory) 功能：删除空目录 指令快捷键 历史输入使用上、下箭头可以找出上一条指令和下一条指令 Tab代码补全使用tab键可以快速输入指令比如：我要输入shutdown指令，这时，我们可以只输入shut然后按下tab键，即可自动把shutdown补全 注意：使用两下Tab补全时，如果匹配的结果有多个，这时候将会把所有匹配的结果展示出来。当结果很多时将会出现以下结果： 按y之后会列出所有匹配的结果，但因为129个比较多，而在电脑中无法一次全显示出来，所以先显示一部分：（More代表还有更多，这时按回车就可以向下滚动，按下Ctrl+C将会退出） 3.2、文件浏览(管理)命令日志文件,XML,properties文件 cat 快捷查看当前文件的内容 cat（catenate）功能：快捷查看当前文件的内容 cat适合查看少量信息的文件 语法： # 格式 cat 文件名 more 分页显示文件内容 more功能：分页显示文件内容，还支持直接跳转行等功能 语法： more 文件名 操作： Enter 向下n行，需要定义。默认为1行 空格键 向下滚动一屏 或 Ctrl+F B 返回上一屏 或 Ctrl+B q 退出more less 分页显示文件内容 less功能：分页显示文件内容，操作更详细 语法： # 格式 less -mN 文件名 # 参数 -m 显示类似more命令的百分比 -N 显示每行的行号 操作： Enter 向下n行，需要定义。默认为1行 空格键 向下滚动一屏 或 Ctrl+F B 返回上一屏 或 Ctrl+B q 退出more d 前进半页 u 后退半页 回车键 前进一行 或 方向键向下 y 后退一行 或 方向键向上 v 进入vim编辑器 /字符串 向下搜索 ?字符串 向上搜索 左右方向键 相当于水平滚动条 特点： 适用于大量数据的查看 tail 指定文件末尾内容 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件 语法： # 格式 tail[必要参数][选择参数][文件] # 参数 -n&lt;行数&gt; 显示行数 -f 循环读取 eg： &amp; 表示后台运行，否则占用终端 ctrl + c 退出 3.3、文件操作命令文件 隐藏文件 Linux中以 点. 开头的是隐藏文件，使用ls命令是查看不到的，需使用ls -a 目录与文件的区别 当我们使用ls命令列出目录中的所有子目录和文件时，如何区分哪些是文件哪些是目录？可以通过详细信息中第一列的信息来区分：以 d 开头的是目录，以 - 开头的是文件 touch创建文件 功能：创建文件 语法： touch 绝对路径/相对路径 cp 复制 cp（copy）：复制文件或者复制目录 复制文件： 语法： cp 需要复制的文件 复制的位置 注意：cp可以进行重命名操作： cp demo1.java t1/ddd.java 当将一个 文件位置 以不同名字复制到当前文件时，意思是复制并重命名；即 将demo1.java复制到t1目录中，并重命名成ddd.java eg： 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中 位置：/root 命令：cp Demo1.java t1 cp /root/Demo1.java /root/t1 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中，改名为ddd.java 位置：/root 命令：cp Demo1.java t1/ddd.java 复制目录： 语法： # 格式 cp -r 需要复制的目录 复制的位置 # 参数 -r或--recursive 递归处理，将指定目录下的文件与子目录一并处理 复制目录必须使用-r eg： 需求：把/root/t5目录 复制到 /root/t1目录中 位置：/root 命令：cp -r t5 t1 cp -r /root/t5 /root/t1 cp ./abc ./xxx #无法复制目录 cp -r ./abc ./xxx #复制目录必须使用 -r参数 mv 移动、更名 mv(move) 功能： 移动 或 更名 现有的文件或目录 移动文件： 语法： # 格式 mv -f 需要移动的文件 移动的位置 # 参数 -f或--force 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录，不进行询问 eg： 需求：把/root/t5 目录 移动到 /root/t3目录中 位置：/root 命令：mv t5 t3 需求：把/root/t5 目录 移动到 /root/t3目录中 不询问，直接覆盖 位置：/root 已知：/root/t3目录中 已经有一个t5目录了 命令：mv -f t5 t3 文件更名： 格式： mv 需要移动的文件 新名字 ## 必须是在同一目录中进行此操作 eg： 文件/目录更名操作： 需求：把/root/Demo1.java 改名为 hehe.java 位置：/root 命令：mv Demo1.java hehe.java rm 删除 rm(remove) 功能：删除文件或目录 删除文件： 语法： rm 文件名 删除目录： 语法： # 格式 rm -rf 目录名 # 参数 -f或--force 强制删除文件或目录，不进行询问 -r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。删除目录必须使用-r 注意： rm -rf * 删除 当前目录 下所有内容 rm –rf /* 删除Linux系统 根目录 下所有内容 eg： 需求：删除/root/t5 目录， 位置：/root 已知：t5目录下有子目录或者文件 命令：rm -rf t5 find 查找 find功能：查找文件或目录 语法： find 目录名 -name &#39;需要查找的字符串&#39; -name 指定字符串作为寻找文件或目录的范本样式 * 表示0~多个任意字符 eg：find t1 -name &#39;*.txt&#39; eg: 需求：查找/root目录下 所有以ins开头的文件或者目录 位置：/root 命令：find /root -name &#39;ins*&#39; 3.4、文档编辑命令Windows是有记事本Linux也有类似的记事本功能 VIM编辑器 VI 编辑 操作： 输入 vi 文件名 进入 “命令(一般)模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 vim 命令 操作： 输入 vim 文件名 或 vi 文件名 进入 “一般模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 一般(命令)模式: 可以浏览文件内容，可以进行文本快捷操作（单行复制，多行复制，单行删除，多行删除…） 按 i/a/o 可以切换到 插入模式按 : 可以切换到 底行模式 插入模式： 可以编辑文件内容。 按 ESC 可以切回 一般模式 底行模式： 可以进行强制退出不保存操作 q! 可以进行保存并退出操作 wq 3.5、grep 、 管道|、重定向输出&gt;&gt;grep 正则表达式 grep：正则表达式，进行字符串搜索工作 用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活 语法： # 格式 grep -i 需要搜索的字符串 搜索的文件 # 参数 -i 忽略大小写查找数据 符合规则，就会返回符合规则的行 管道 管道命令： 可以连接多个Linux命令，其作用是将一个命令的输出用在另一个命令的输入 格式： 命令1 | 命令2 | 命令3…… eg： 需求：查询当前目录中，所有带ins关键字的行数据 位置：/root 思考：查询当前目录内容 ll 查询字符串，返回字符串所在行 grep 命令：ll | grep ins 需求：分页显示ls的help信息 命令：ls --help | more 重定向输出&gt; &gt;&gt; 重定向输出 &gt; 定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空 &gt;&gt; 将输出内容追加到目标文件中。如果文件不存在，就创建文件；如果文件存在，则将新的内容追加到那个文件的末尾，该文件中的原有内容不受影响 格式： 注意： 使用： 将一个文件夹的内容保存到文本文件中去，也就是将ls命令打印出来的内容都写到文本中去可以这样： # a.txt文件中就是ls命令打印出来的内容了 ls -al &gt;&gt; a.txt 3.6、压缩、解压命令【重要】 Linux常见压缩包： .tar 打包，大小不会进行压缩​ .tar.gz 打包并压缩文件大小 压缩：(参数顺序不变) # 格式 tar -zcvf 压缩包名字.tar.gz 需要压缩的内容 # 参数 -z 是否需要用 gzip 压缩 -c 建立一个压缩文件的参数指令（create）--压缩 -v 压缩的过程中显示文件（verbose） -f 使用档案名称，在 f 之后要立即接档名（file） eg： 例如：tar -zcvf hehe.tar.gz * 将当前目录下所有内容进行打包压缩，文件名hehe.tar.gz 解压：(参数顺序不变) # 解压到当前目录 tar -zxvf 需要解压的压缩包名称 解压到当前目录 # 解压到指定目录 tar -zxvf 需要解压的压缩包名称 -C 指定压缩路径 解压到指定目录中 # 参数 -z 是否需要用 gzip 压缩 -x 解开一个压缩文件的参数指令（extract）--解压 -v 压缩的过程中显示文件（verbose） -f 使用档名，在 f 之后要立即接档名（file） eg： 需求：需要把/root/t5/hehe.tar.gz 压缩包 解压到 指定目录中。指定目录/root/t5/t5 位置：/root/t5 命令：tar -zxvf hehe.tar.gz -C /root/t5/t5 tar -zxvf hehe.tar.gz -C t5 3.7、系统命令系统服务服务，是指常期运行，常驻内存中的进程，比如，apache、mysql、ssh等 服务与端口每个服务软件一般在运行时都会对应一个端口。查看监听的端口： ss –lntp 防火墙及防火墙设置CentOS 7.0默认使用的是firewall作为防火墙，使用iptables必须重新设置一下 查看防火墙状态： firewall-cmd --state # running 防火墙处于开启状态 # not running 防火墙处于关闭状态 直接关闭防火墙停止firewall： systemctl stop firewalld.service 禁止firewall开机启动： systemctl disable firewalld.service 查看系统进程：ps -ef需求：查看进程中 和 vim相关的进程 命令：ps -ef|grep -i vim -e 此参数的效果和指定&quot;A&quot;参数相同，显示所有程序 -f 显示UID,PPIP,C与STIME栏位 强制杀死某个进程：kill -9 pid号需求：查看进程 和 vim相关的进程有哪些，并将vim进程杀死 命令：ps -ef|grep -i vim Kill -9 pid号 -l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称 kill 9 表示强制终止 查看网络配置：ifconfig 显示网络设备 测试和目标的连通性：ping 主机名或ip地址 测试与目标主机的连通性 会持续不断一直测试，直到ctrl+c Linux centos重启命令：reboot Linux centos关机命令：halt 3.8、其他命令（了解）chmod 文件权限 hmod(change mode) 功能：变更文件或目录的权限 语法： # 格式 chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;] # 参数 -R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理 权限范围的表示法如下： u：User，即文件或目录的拥有者 g：Group，即文件或目录的所属群组 o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围 a：All，即全部的用户，包含拥有者，所属群组以及其他用户 符号： ‘+’添加权限 ‘-‘取消权限 有关权限代号的部分，列表于下： r：读取权限，数字代号为”4” w：写入权限，数字代号为”2” x：执行或切换权限，数字代号为”1” -：不具任何权限，数字代号为”0” eg: mkdir xxx ll | grep xxx chmod u-rwx xxx #取消xxx目录，用户“读写执行”权限 chmod g-rwx xxx #取消xxx目录，组“读写执行”权限 chmod 777 xxx #给xxx目录添加所有权限 linux 权限格式：&lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt; 网络配置 VIM命令配置 网卡配置 cat /etc/sysconfig/network-scripts/ifcfg-eth0 概要信息如下: DEVICE=eth0 #网卡名称 TYPE=Ethernet #网卡类型 ONBOOT=yes #是否开机启动网卡 BOOTPROTO=static #静态获取IP，其他取值：dhcp （如果设置dhcp下面红色不需要） IPADDR=192.168.44.100 #ip地址 GATEWAY=192.168.44.2 #网关 NETMASK=255.255.255.0 #子网掩码 setup设置 选择“网络配置” 选择“设备配置” 选择“第一块网卡” 设置IP地址等详细信息 命令总结 和 帮助 内部命令：属于Shell解析器的一部分 （系统启动直接加载到内存的） cd 切换目录（change directory） pwd 显示当前工作目录（print working directory） help 帮助 外部命令：独立于Shell解析器之外的文件程序（独立的可执行文件） ls 显示文件和目录列表（list） mkdir 创建目录（make directoriy） cp 复制文件或目录（copy） 查看帮助文档 内部命令：help + 命令（eg：help cd） 外部命令：man + 命令（eg：man ls） 不用特意记忆命令分类，开发中，如果需要查看命令参数，先使用man，如果没有结果，再使用help","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.xiongtianci.com/tags/Linux/"}],"author":"天赐"},{"title":"豆瓣Top250资源合集","slug":"豆瓣Top250资源合集","date":"2018-11-28T17:45:30.000Z","updated":"2019-06-18T08:47:13.026Z","comments":true,"path":"2018/11/29/豆瓣Top250资源合集/","link":"","permalink":"https://www.xiongtianci.com/2018/11/29/豆瓣Top250资源合集/","excerpt":"","text":"点击影片”名称”即可获取资源链接 # 更新至Top1-Top100，敬请期待… 排名名称年份评分Top1肖申克的救赎19949.6Top2霸王别姬19939.6Top3这个杀手不太冷19949.4Top4阿甘正传19949.4Top5美丽人生19979.5Top6泰坦尼克号19979.3Top7千与千寻20019.3Top8辛德勒的名单19939.5Top9盗梦空间20109.3Top10机器人总动员20089.3Top11忠犬八公的故事20099.3Top12三傻大闹宝莱坞20099.2Top13海上钢琴师19989.2Top14放牛班的春天20049.2Top15大话西游之大圣娶亲19959.2Top16楚门的世界19989.2Top17教父19729.2Top18星际穿越20149.2Top19龙猫19889.1Top20熔炉20119.3Top21无间道20029.1Top22当幸福来敲门20069.0Top23触不可及20119.2Top24怦然心动20109.0Top25乱世佳人19399.2Top26疯狂动物城20169.2Top27蝙蝠侠：黑暗骑士20089.1Top28天堂电影院19889.1Top29活着19949.1Top30少年派的奇幻漂流20129.0Top31十二怒汉19579.4Top32鬼子来了20009.2Top33指环王3：王者无敌20039.1Top34控方证人19579.6Top35搏击俱乐部19999.0Top36天空之城19869.0Top37飞屋环游记20098.9Top38大话西游之月光宝盒19958.9Top39罗马假日19539.0Top40摔跤吧！爸爸20169.1Top41窃听风暴20069.1Top42辩护人20139.2Top43两杆大烟枪19989.1Top44闻香识女人19929.0Top45哈尔的移动城堡20048.9Top46飞越疯人院19759.0Top47死亡诗社19899.0Top48V字仇杀队20058.8Top49海豚湾20099.3Top50教父219749.1Top51指环王2：双塔奇兵20029.0Top52指环王1：魔戒再现20018.9Top53美丽心灵20018.9Top54饮食男女19949.1Top55情书19958.8Top56素媛20139.1Top57狮子王19948.9Top58钢琴家20029.1Top59美国往事19849.1Top60小鞋子19979.2Top61七宗罪19958.8Top62被嫌弃的松子的一生20068.9Top63致命魔术20068.8Top64本杰明·巴顿奇事20088.8Top65末代皇帝19879.0Top66西西里的美丽传说20008.8Top67天使爱美丽20018.7Top68黑客帝国19998.9Top69让子弹飞20108.7Top70拯救大兵瑞恩19988.9Top71看不见的客人20168.7Top72音乐之声19658.9Top73低俗小说19948.8Top74勇敢的心19958.8Top75剪刀手爱德华19908.7Top76大闹天宫19611964197820049.3Top77沉默的羔羊19918.8Top78蝴蝶效应20048.7Top79哈利·波特与魔法石20018.8Top80春光乍泄19978.8Top81入殓师20088.8Top82心灵捕手19978.8Top83猫鼠游戏20028.8Top84布达佩斯大饭店20148.8Top85禁闭岛20108.7Top86玛丽和马克思20098.9Top87阳光灿烂的日子19948.8Top88第六感19998.8Top89幽灵公主19978.8Top90重庆森林19948.7Top91狩猎20129.1Top92致命ID20038.7Top93穿条纹睡衣的男孩20088.9Top94断背山20058.7Top95加勒比海盗20038.6Top96大鱼20038.7Top97阿凡达20098.6Top98摩登时代19369.2Top99告白20108.7Top100一一20009.0Top101射雕英雄传之东成西就19938.7Top102甜蜜蜜19968.8Top103阳光姐妹淘20118.8Top104消失的爱人20148.7Top105爱在黎明破晓前19958.7Top106上帝之城20028.9Top107小森林 夏秋篇20148.9Top108侧耳倾听19958.8Top109喜剧之王19998.6Top110倩女幽魂19878.6Top111恐怖直播20138.7Top112风之谷19848.8Top113爱在日落黄昏时20048.8Top114超脱20118.8Top115红辣椒20068.9Top116菊次郎的夏天19998.8Top117驯龙高手20108.7Top118幸福终点站20048.7Top119神偷奶爸20108.5Top120借东西的小人阿莉埃蒂20108.7Top121杀人回忆20038.7Top122七武士19549.2Top123岁月神偷20108.6Top124请以你的名字呼唤我20178.8Top125萤火虫之墓19888.7Top126怪兽电力公司20018.6Top127小森林 冬春篇20159.0Top128哈利·波特与死亡圣器(下)20118.7Top129谍影重重320078.7Top130喜宴19938.8Top131东邪西毒19948.6Top132电锯惊魂20048.7Top133贫民窟的百万富翁20088.5Top134疯狂原始人20138.7Top135记忆碎片20008.6Top1367号房的礼物20138.7Top137黑天鹅20108.5Top138萤火之森20118.8Top139真爱至上20038.5Top140英雄本色19868.6Top141超能陆战队20148.6Top142雨人19888.6Top143心迷宫20148.7Top144蝙蝠侠：黑暗骑士崛起20128.6Top145卢旺达饭店20048.9Top146唐伯虎点秋香19938.5Top147海洋20099.0Top148傲慢与偏见20058.5Top149荒蛮故事20148.8Top150纵横四海19918.7Top151海边的曼彻斯特20168.6Top152教父319908.8Top153虎口脱险19668.9Top154无人知晓20049.1Top155时空恋旅人20138.7Top156完美的世界19939.0Top157寻梦环游记20179.0Top158玩具总动员320108.8Top159燃情岁月19948.7Top160花样年华20008.5Top161恋恋笔记本20048.5Top162达拉斯买家俱乐部20138.7Top163血战钢锯岭20168.7Top164二十二20158.7Top165雨中曲19529.0Top166魂断蓝桥19408.8Top167穿越时空的少女20068.6Top168猜火车19968.5Top169我是山姆20018.8Top170冰川时代20028.5Top171人工智能20018.6Top172爆裂鼓手20148.6Top173头脑特工队20158.7Top174被解救的姜戈20128.6Top175未麻的部屋19978.8Top176罗生门19508.7Top177浪潮20088.7Top178香水20068.4Top179朗读者20088.5Top180阿飞正传19908.5Top181你的名字。20168.4Top182房间20158.8Top183可可西里20048.7Top184恐怖游轮20098.4Top185模仿游戏20148.6Top186一个叫欧维的男人决定去死20158.8Top187一次别离20118.7Top188忠犬八公物语19879.1Top189战争之王20058.6Top190追随19988.9Top191魔女宅急便19898.5Top192撞车20048.6Top193谍影重重20028.5Top194完美陌生人20168.6Top195地球上的星星20078.9Top196牯岭街少年杀人事件19918.8Top197谍影重重220048.6Top198哪吒闹海19798.9Top199惊魂记19608.9Top200青蛇19938.5Top201梦之安魂曲20008.7Top202无敌破坏王20128.7Top203黑客帝国3：矩阵革命20038.6Top204小萝莉的猴神大叔20158.5Top205再次出发之纽约遇见你20138.5Top206海街日记20158.7Top207新龙门客栈19928.5Top208东京物语19539.2Top209步履不停20088.8Top210终结者2：审判日19918.6Top211源代码20118.4Top212初恋这件小事20108.3Top213绿里奇迹19998.7Top214城市之光19319.2Top215末路狂花19918.7Top216爱在午夜降临前20138.8Top217疯狂的石头20068.3Top218秒速5厘米20078.3Top219无耻混蛋20098.5Top220这个男人来自地球20078.5Top221勇闯夺命岛19968.6Top222E.T. 外星人19828.5Top223碧海蓝天19888.7Top224变脸19978.4Top225卡萨布兰卡19428.6Top226黄金三镖客19669.1Top227发条橙19718.5Top228彗星来的那一夜20138.4Top229聚焦20158.8Top230海盗电台20098.6Top231美国丽人19998.5Top232血钻20068.5Top233非常嫌疑犯19958.6Top234国王的演讲20108.3Top235荒野生存20078.6Top236英国病人19968.5Top237黑鹰坠落20018.6Top238我爱你20119.0Top239迁徙的鸟20019.1Top240遗愿清单20078.5Top241勇士20118.9Top242荒岛余生20008.5Top2432001太空漫游19688.7Top244枪火19998.7Top245燕尾蝶19968.6Top246叫我第一名20088.6Top247穆赫兰道20018.3Top248千钧一发19978.7Top249大卫·戈尔的一生20038.6Top250上帝也疯狂19808.7","categories":[{"name":"资源","slug":"资源","permalink":"https://www.xiongtianci.com/categories/资源/"}],"tags":[{"name":"公众号文章","slug":"公众号文章","permalink":"https://www.xiongtianci.com/tags/公众号文章/"},{"name":"Top电影","slug":"Top电影","permalink":"https://www.xiongtianci.com/tags/Top电影/"},{"name":"电仪","slug":"电仪","permalink":"https://www.xiongtianci.com/tags/电仪/"}],"author":"天赐"},{"title":"使用 Hexo+GitHub 搭建个人博客","slug":"使用Hexo+GitHub搭建个人博客","date":"2018-11-28T07:36:06.000Z","updated":"2019-06-18T08:46:58.515Z","comments":true,"path":"2018/11/28/使用Hexo+GitHub搭建个人博客/","link":"","permalink":"https://www.xiongtianci.com/2018/11/28/使用Hexo+GitHub搭建个人博客/","excerpt":"","text":"昨天偶然看见一篇有关使用Hexo搭建个人博客的文章，瞬间吸引我的注意。今天使用的一天的时间在GitHub上搭建了一个个人博客，感觉还不错，分享给大家，并记录下我搭建过程中趟过的坑 环境：Win10 + Hexo + GitHub 效果展示：脚印的博客 一、准备工作1. 了解Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官方文档：https://hexo.io/zh-cn/docs/ 2. 搭建Node.js环境Hexo基于Node.js环境，那么我们搭建博客网站首先需要安装Node.js环境 下载地址：http://nodejs.cn/download 详细安装文档：http://www.runoob.com/nodejs/nodejs-install-setup.html 测试安装：命令行使用 node -v 、npm -v，查看显示版本号即成功。如下图： 3. 注册Github账号这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件 注册地址：https://github.com注册流程：https://blog.csdn.net/p10010/article/details/51336332 注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦 4. 安装Git版本工具 使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步 下载地址：https://git-scm.com/downloads Windows系统需下载，Mac系统因为自带Git无需操作 详细安装文档：https://blog.csdn.net/u013295518/article/details/78746007 测试安装：git --version，查看显示版本号即成功。如下图： 配置SSH：https://blog.csdn.net/qq_35246620/article/details/69061355 SSH key添加之后，就可以在本机git bash中进行测试，输入ssh -T git@github.com进行测试 显示 Hi username ！You&#39;ve successfully... 说明ssh配置成功了 5. 在本地安装 Hexo Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件 npm install -g hexo-cli 注意：在回车之后，可能会出现一行WARN的警告语句，不用管它，这个不妨碍安装 过一段时间如果出现hexo版本号之类的语句就代表差不多了 然后输入 npm install hexo --save 这个时候你会看到命令行出现了一堆白字，紧接着输入hexo v查看是否安装成功： 此时，Hexo已经安装完成 二、搭建博客1. 开启GitHub Pages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是： 仓库名固定：你的github的username.github.io 这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。 点击Create Repository后，选着仓库的Setting进入设置 往下滑找到 Github Pages 如下： 这里我们需要点击 Choose a theme 任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 点击 Select theme 选着主题后，此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 输入你的 GitHub 的用户名和密码，成功后复制https://username.github.io/到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！ 2. 创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下： hexo init myHexoBlog //myHexoBlog是项目名 等一会，如果出现橙色的 WARN 没关系，只要不出现红色的 ERROR 就行。好了后，输入命令： hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 然后点开 http://localhost:4000/ ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！ 3. 同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地博客目录的配置：修改本地博客根目录下的_config.yml文件，修改deploy下的配置，如下： deploy: type: git repository: git@github.com:xiongtianci-tc/xiongtianci-tc.github.io.git #复制的仓库地址 branch: master 注意： repository后面的内容是 git@gitbub.com:username/库地址 的形式 type、repository、branch冒号的后面都有一个空格（切记~~） 最后执行控制台命令： npm install hexo-deployer-git --save //安装部署插件 hexo d //部署到github 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三、发布你的第一篇博客终于可以发布自己的第一篇博客了，是不是很激动？（博主当时可是超级激动的~）首先，在本地博客文件夹根目录输入： hexo new &quot;我个人博客的第一篇博客，激动~&quot; hexo g //生成网页 hexo d //部署到远端(github) 现在打开我们的博客网站：http://UserName.github.io,会看到网页如下(可能需要刷新几次页面)： 需要编写博客内容时，只需编写本地博客的 _posts 的博客原文，然后通过 hexo g &amp;&amp; hexo d 重新部署到github即可 四、更换主题此时，我们的个人博客已经搭建完成。但是我们需要网站更加高大上，更加美观些，我们可以通过更换主题来实现个性化博客 这里以使用github上的next主题为例： 1. 下载主题next主题：https://github.com/iissnan/hexo-theme-next 在控制台中切换到本地博客根目录输入： $ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next 下载成之后我们会看到next的主题已经存在 thems 里了如下： 2. 更换主题修改博客根目录(不是next主题)下的 _config.yml 文件，搜索 theme 字段，并将其值修改为 next 然后在控制台下输入如下命令： hexo clean //清理缓存 hexo g //重新生成博客代码 hexo d //部署到本地 // 或者直接输入：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 再次打开我们的博客网站：https://UserName.github.io，将会发现我们的博客主题已经发生了改变 五、个性化通过此步骤我们可以设置博客的作者、格言、语言… 在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项 1. 站点配置在本地的博客根目录下找到_config.yml，用编辑器打开进行内容的设置，如下： 这里可以修改博客网站的标题、描述，语言等属性 2. 主题设置网上有个超级详细的教程，我就不赘述了： 文档地址：http://theme-next.iissnan.com/getting-started.html 终于结束了， 最后，","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"},{"name":"生活","slug":"生活","permalink":"https://www.xiongtianci.com/categories/生活/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.xiongtianci.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.xiongtianci.com/tags/博客/"},{"name":"GitHub","slug":"GitHub","permalink":"https://www.xiongtianci.com/tags/GitHub/"}],"author":"天赐"},{"title":"java中的&#92;t&#92;r&#92;n&#92;b分别是什么？","slug":"java中的-t-r-n-b分别是什么？","date":"2018-11-27T08:29:04.000Z","updated":"2019-06-18T08:46:42.832Z","comments":true,"path":"2018/11/27/java中的-t-r-n-b分别是什么？/","link":"","permalink":"https://www.xiongtianci.com/2018/11/27/java中的-t-r-n-b分别是什么？/","excerpt":"","text":"描述 \\t 相当于tab，缩进 \\r 回车 \\n 换行符 \\b 换成一个黑点 \\” 转义” \\’ 转义’ \\ 转义\\","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"使用Notepad++替换某一特定中文后面的所有内容","slug":"使用Notepad++替换某一特定中文后面的所有内容","date":"2018-11-27T02:48:26.000Z","updated":"2019-06-18T08:46:49.915Z","comments":true,"path":"2018/11/27/使用Notepad++替换某一特定中文后面的所有内容/","link":"","permalink":"https://www.xiongtianci.com/2018/11/27/使用Notepad++替换某一特定中文后面的所有内容/","excerpt":"","text":"需求：删除”电影描述”以及其后面的内容 Top1 肖申克的救赎 评分：9.6 电影描述：希望让人自由Top2 霸王别姬 评分：9.5 电影描述：风华绝代Top3 这个杀手不太冷 评分：9.4 电影描述：怪蜀黍和小萝莉不得不说的故事Top4 阿甘正传 评分：9.4 电影描述：一部美国近现代史Top5 美丽人生 评分：9.5 电影描述：最美的谎言Top6 千与千寻 评分：9.2 电影描述：最好的宫崎骏，最好的久石让Top7 泰坦尼克号 评分：9.2 电影描述：失去的才是永恒的Top8 辛德勒的名单 评分：9.4 电影描述：拯救一个人，就是拯救整个世界Top9 盗梦空间 评分：9.3 电影描述：诺兰给了我们一场无法盗取的梦Top10 机器人总动员 评分：9.3 电影描述：小瓦力，大人生Top11 海上钢琴师 评分：9.2 电影描述：每个人都要走一条自己坚定了的路，就算是粉身碎骨Top12 三傻大闹宝莱坞 评分：9.1 电影描述：英俊版憨豆，高情商版谢耳朵Top13 忠犬八公的故事 评分：9.2 电影描述：永远都不能忘记你所爱的人Top14 放牛班的春天 评分：9.2 电影描述：天籁一般的童声，是最接近上帝的存在Top15 大话西游之大圣娶亲 评分：9.2 电影描述：一生所爱 解决： Ctrl+R 打开替换窗口 在”查找目标”中输入：特定字符.* 选择右下角的”正则表达式” 点击”全部替换” 结果： Top1 肖申克的救赎 评分：9.6Top2 霸王别姬 评分：9.5Top3 这个杀手不太冷 评分：9.4Top4 阿甘正传 评分：9.4Top5 美丽人生 评分：9.5Top6 千与千寻 评分：9.2Top7 泰坦尼克号 评分：9.2Top8 辛德勒的名单 评分：9.4Top9 盗梦空间 评分：9.3Top10 机器人总动员 评分：9.3Top11 海上钢琴师 评分：9.2Top12 三傻大闹宝莱坞 评分：9.1Top13 忠犬八公的故事 评分：9.2Top14 放牛班的春天 评分：9.2Top15 大话西游之大圣娶亲 评分：9.2","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Notepad","slug":"Notepad","permalink":"https://www.xiongtianci.com/tags/Notepad/"}],"author":"天赐"},{"title":"win10常用快捷键","slug":"win10常用快捷键","date":"2018-11-26T08:52:44.000Z","updated":"2019-06-18T08:46:35.190Z","comments":true,"path":"2018/11/26/win10常用快捷键/","link":"","permalink":"https://www.xiongtianci.com/2018/11/26/win10常用快捷键/","excerpt":"","text":"常用快捷键 快捷键 描述 Alt + F4 关闭活动项，或者退出活动应用 Alt + Tab 在打开的应用之间切换 Win + L 锁定电脑 Win + D 显示和隐藏桌面 Ctrl + D（或 Delete） 删除选定项并将其移动到“回收站” 快捷键 描述 Win + A 打开操作中心 Win + E 打开文件资源管理器 Win + I 打开Windows设置 Win + Q / Win + S 打开Cortana Win + R 打开运行 Win + L 锁定笔记本 Ctrl + Shift + Esc 打开任务管理器 Win + X 打开开始菜单左侧选项 Win + 加号 打开放大镜并放大屏幕内容 Win + 减号 打开放大镜并缩小屏幕内容 Win + Esc 退出放大镜 运行(Win+R)的常用命令 命令 描述 notepad 打开记事本 calc 打开计算器 mspaint 打开画图 osk 打开虚拟键盘 sysdm.cpl 打开系统设置（常用于配置环境变量） appwiz.cpl 打开控制面板（常用于卸载程序） psr.exe 打开步骤记录器（常用于记录操作步骤） cmd 打开命令行窗口 管理窗口 快捷键 描述 Win + D 最小化所有窗口，重复按下可还原 Win + 1…9 打开任务栏对应窗口 Win + T 将焦点切换到任务栏图标，并在图标之间进行切换 Win + 上/下 使窗口在最大化，正常状态以及最小化之间切换 Win + 左/右 使窗口在左半屏幕，正常状态以及右半屏幕之间切换 Ctrl + Tab 切换当前程序中的不同页面 Alt + Tab 切换当前程序 Ctrl + F4 关闭当前程序中的当前页面 Alt + F4 关闭当前程序 虚拟窗口 快捷键 描述 Win + Ctrl + D 创建新的虚拟桌面 Win + Ctrl + F4 关闭当前虚拟桌面 Win + Ctrl + 左/右 切换虚拟桌面 录频和截图 快捷键 描述 Win + G 打开屏幕录制工具栏 PtrSc 全屏截图并保存到剪贴板 Alt + PtrSc 当前窗口截图并保存到剪贴板 Win + PtrSc 全屏截图并保存到本地 输入法 快捷键 描述 Shift 切换输入法 Shift + Space 切换全半角 触控板常用手势 操作 描述 单指双击拖动 拖拽文件 两指上下移动 滚动屏幕 两指缩放 缩放 两指旋转 旋转 三指扩张 显示所有窗口 三指上下移动 隐藏或显示窗口 三指左右移动 切换窗口","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://www.xiongtianci.com/tags/win10/"},{"name":"快捷键","slug":"快捷键","permalink":"https://www.xiongtianci.com/tags/快捷键/"}],"author":"天赐"},{"title":"Java中的线程安全问题","slug":"Java中的线程安全问题","date":"2018-11-22T17:07:37.000Z","updated":"2019-06-18T08:46:26.831Z","comments":true,"path":"2018/11/23/Java中的线程安全问题/","link":"","permalink":"https://www.xiongtianci.com/2018/11/23/Java中的线程安全问题/","excerpt":"","text":"线程安全线程安全：如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，此时我们就称之为是线程安全的。 我们通过一个案例，演示线程的安全问题： 电影院卖票，使用了A、B、C三个窗口进行卖票，电影票总数为100张 采用线程对象来模拟卖票窗口A、B、C；使用Runnable接口的子类来模拟买的电影票 模拟电影票： public class Ticket implements Runnable{ // 在成员位置 定义票的总数100 int ticket = 100; @Override public void run() { // 模拟买票窗口 // 买票窗口永远开启 while (true){ // 判断是否还有票可以卖 if(ticket &gt; 0){ // 使用sleep增加“程序的时间”--每张票卖50ms try { Thread.sleep(50); } catch (Exception e) { e.printStackTrace(); } // 获得线程名称 即买票窗口名称 String name = Thread.currentThread().getName(); System.out.println(name + &quot;卖掉第&quot; + ticket-- + &quot;票&quot;); } } } } 模拟买票： /** * 模拟买票操作 * 假设一场电影有100张票 * 三个窗口同时买票 * * 窗口 线程对象 * 买票 线程任务 实现runnable接口 */ public class Demo { public static void main(String[] args) { // 创建买票任务对象 Ticket ticket = new Ticket(); // 创建三个窗口 Thread t1 = new Thread(ticket, &quot;窗口A&quot;); Thread t2 = new Thread(ticket, &quot;窗口B&quot;); Thread t3 = new Thread(ticket, &quot;窗口C&quot;); // 开启线程 t1.start(); t2.start(); t3.start(); } } 运行结果： 窗口A卖掉第100张票 窗口C卖掉第98张票 窗口B卖掉第99张票 窗口A卖掉第97张票 窗口B卖掉第95张票 窗口C卖掉第96张票 窗口C卖掉第94张票 ⇐ 窗口B卖掉第94张票 ⇐ 窗口A卖掉第94张票 ⇐ ... 窗口C卖掉第1张票 窗口A卖掉第0张票 窗口B卖掉第-1张票 ⇐ 发现程序出现了两个问题： 1. 相同的票数被卖了多次，如第94张被三个窗口都卖了 2. 卖出了不存在的票，如窗口B卖掉了第-1张票 此时，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 线程安全问题都是有全局变量即静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作。一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有些的操作，就容易出现线程安全问题要解决上述多想成并发访问一个资源的安全性问题：也就是解决重复卖同一张票和卖不存在的票问题，Java中提供了同步机制(synchronized)来解决根据案例简述： 窗口A线程进入操作(买票)的时候，窗口B和窗口C线程只能在外等着， 窗口A操作结束，窗口A、窗口B和窗口C(CPU分配内存是随机的，所以还有可能是窗口A进入)才有机会进入代码去执行。 也就是说，在某个线程修改共享资源的时候，其他线程不能修改该资源， 等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。 有三种方式完成同步操作： 1. 同步代码块 2. 同步方法 3. 锁机制 同步代码块同步代码块：synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式： synchronized(同步锁){ // 需要同步的操作的代码 } 同步锁： 对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。 1. 锁对象可以是任意类型 2. 多个线程对象要使用同一把锁 注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到就进入代码块，其他的线程只能在外等着 使用同步代码块解决卖票问题： /** * synchronized(锁对象){ * * } * 1. 锁对象可以是任意类型 * 2. 互斥线程需要使用同一把锁 */ public class Ticket implements Runnable{ // 在成员位置 定义票的总数100 int ticket = 100; Object obj = new Object(); @Override public void run() { // 模拟买票窗口 // 买票窗口永远开启 while (true){ // 同步锁 synchronized (obj){ // 判断是否还有票可以卖 if(ticket &gt; 0){ // 使用sleep增加“程序的时间”--每张票卖50ms try { Thread.sleep(50); } catch (Exception e) { e.printStackTrace(); } // 获得线程名称 即买票窗口名称 String name = Thread.currentThread().getName(); System.out.println(name + &quot;卖掉第&quot; + ticket-- + &quot;票&quot;); } } } } } 执行结果： 窗口A卖掉第100票 窗口C卖掉第99票 窗口B卖掉第98票 窗口B卖掉第97票 ... 窗口C卖掉第4票 窗口A卖掉第3票 窗口A卖掉第2票 窗口A卖掉第1票 此时，每张票都只会被卖掉一次，不会存在卖掉不存在的电影票的问题。 当使用了同步代码块后，上述的线程的安全问题即可解决","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"https://www.xiongtianci.com/tags/多线程/"}],"author":"天赐"},{"title":"Word2016问题导致无法创建其他博客账号","slug":"Word2016问题导致无法创建其他博客账号","date":"2018-11-22T11:23:57.000Z","updated":"2019-06-18T08:46:19.943Z","comments":true,"path":"2018/11/22/Word2016问题导致无法创建其他博客账号/","link":"","permalink":"https://www.xiongtianci.com/2018/11/22/Word2016问题导致无法创建其他博客账号/","excerpt":"","text":"网友介绍能够在word上直接将博文发布到CSDN上，纯洁的我跟着网友的说法一顿操作，结果凉凉~按照网友说法在word中创建博客账号时，需要选择“其他”，就是这个&darr;&darr;&darr;结果&darr;&darr;&darr;网上搜了半天，终于找到一篇看似有用的文章：Word 2016 无法创建其他博客账号然并卵，我并没有找到所谓的补丁( 一群羊驼奔腾而过~ )希望各位大神赐教","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Word2016","slug":"Word2016","permalink":"https://www.xiongtianci.com/tags/Word2016/"}],"author":"天赐"},{"title":"JS中Cookie、LocalStorage与SessionStorage","slug":"JS中Cookie、LocalStorage与SessionStorage","date":"2018-11-22T07:56:16.000Z","updated":"2019-06-18T08:46:13.825Z","comments":true,"path":"2018/11/22/JS中Cookie、LocalStorage与SessionStorage/","link":"","permalink":"https://www.xiongtianci.com/2018/11/22/JS中Cookie、LocalStorage与SessionStorage/","excerpt":"","text":"一、基本概念1. Cookie cookie：主要用途有保存登录信息。cookie 非常小，它的大小限制为4KB左右。用途：比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 2. LocalStorage localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信 3. SessionStorage sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 二、区别 特性 Cookie LocalStorage SessionStorage 数据的生命周期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 LocalStorage和SessionStorage： 不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。 相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。 这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的 三、LocalStorage 和 SessionStorage 的操作LocalStorage 和 SessionStorage 具有相同的操作方法，例如setItem、 getItem 和 removeItem 等 1. 添加value描述：使用 key/value 的形式将数据存储进本地存储中格式： sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;); localStorage.setItem(&quot;site&quot;, &quot;js8.in&quot;); 2.获取value描述：获取指定 key 本地存储的值格式： var value = sessionStorage.getItem(&quot;key&quot;); var site = localStorage.getItem(&quot;site&quot;); 3.删除value描述：删除指定 key 本地存储的值格式： sessionStorage.removeItem(&quot;key&quot;); localStorage.removeItem(&quot;site&quot;); 4.清除value描述：清除所有的 key/value格式： sessionStorage.clear(); localStorage.clear();","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"JS","slug":"JS","permalink":"https://www.xiongtianci.com/tags/JS/"}],"author":"天赐"},{"title":"Java中创建线程的两种方式","slug":"Java中创建线程的两种方式","date":"2018-11-22T03:35:47.000Z","updated":"2019-06-18T08:46:05.669Z","comments":true,"path":"2018/11/22/Java中创建线程的两种方式/","link":"","permalink":"https://www.xiongtianci.com/2018/11/22/Java中创建线程的两种方式/","excerpt":"","text":"创建线程方式一 通过继承Thread类来创建并启动多线程 Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 自定义线程类： /** * 自定义线程类 */ public class MyThread extends Thread { public MyThread(String name){ super(name); } @Override public void run() { for(int i = 1; i &lt;= 20; i++){ System.out.println(getName() + &quot; &quot; + i); } } } 测试类： /** * 创建线程方式一： * 1. 创建自定义类继承Thread类 * 2. 重写run方法(run方法就是新的线程要执行的代码) * 3. 创建自定义类对象(线程对象) * 4. 调用start方法开启新的线程 */ public class Demo01 { public static void main(String[] args) { System.out.println(&quot;main线程开启&quot;); // 创建线程对象 MyThread myThread = new MyThread(&quot;线程A&quot;); // 开启新的线程myThread myThread.start(); // 这个循环在main线程中执行 for (int i = 1; i &lt;= 20; i++) { System.out.println(&quot;mian线程 &quot; + i); } } } 创建线程方式二 通过实现Runnable类来创建并启动多线程 采用java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象 调用线程对象的start()方法来启动线程 代码如下： public class MyRunnable implements Runnable { @Override public void run() { for (int i = 1; i &lt;= 20; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } /** * 创建线程方式二： * 1. 定义自定义类实现Runnable接口 * 2. 重写run方法 * 3. 创建自定义对象 * 4. 创建Threed对象的时候，作为构造方法的参数进行传递 * 5. 启动线程start方法 */ public class Demo02 { public static void main(String[] args) { // 创建线程任务对象 MyRunnable myRunnable = new MyRunnable(); // 创建线程对象 Thread t1 = new Thread(myRunnable, &quot;线程A&quot;); Thread t2 = new Thread(myRunnable, &quot;线程B&quot;); // 开启线程 t1.start(); t2.start(); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"线程","slug":"线程","permalink":"https://www.xiongtianci.com/tags/线程/"}],"author":"天赐"},{"title":"重载(overload)和重写(override)的区别？","slug":"重载(overload)和重写(override)的区别？","date":"2018-11-21T12:04:30.000Z","updated":"2019-06-18T08:45:56.688Z","comments":true,"path":"2018/11/21/重载(overload)和重写(override)的区别？/","link":"","permalink":"https://www.xiongtianci.com/2018/11/21/重载(overload)和重写(override)的区别？/","excerpt":"","text":"方法重载： 方法名相同，参数列表【参数的顺序，类型，个数】不同 重载与方法的返回值无关，发生在同一类中 是编译时的多态性 方法重写： 参数列表和返回值类型必须相同 重写发生在子类与父类之间 子类抛出的异常不能超过父类相应方法抛出的异常 子类方法的的访问级别不能低于父类相应方法的访问级别 是运行时的多态性","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"常用转义字符","slug":"常用转义字符","date":"2018-11-20T10:01:33.000Z","updated":"2019-06-26T03:42:30.159Z","comments":true,"path":"2018/11/20/常用转义字符/","link":"","permalink":"https://www.xiongtianci.com/2018/11/20/常用转义字符/","excerpt":"","text":"提示：请直接按Ctrl+F搜索您要查找的转义字符 常用表常用表 字符 转义字符 描述 ‘ &amp;#39; 单引号 “ &amp;quot; 双引号 &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; 不断开空格(non-breaking space) &amp;nbsp; 空格 # &amp;#35; &amp; &amp;#38; . &amp;#46; 句号 ¥ &amp;yen; ¦ &amp;brvbar; § &amp;sect; ¨ &amp;uml; © &amp;copy; « &amp;laquo; ® &amp;reg; ¼ &amp;frac14; ½ &amp;frac12; ¾ &amp;frac34; $ &amp;#36; % &amp;#37; ( &amp;#40; ) &amp;#41; * &amp;#42; + &amp;#43; , &amp;#44; 逗号 ; &amp;#59; 分号 = &amp;#61; - &amp;#45; 连字号 / &amp;#47; 斜杠 \\ &amp;#92; 反斜杠 | &amp;#124; 竖杠 &#166; &amp;#166; 断竖杠 : &amp;#58; 冒号 [ &amp;#91; ] &amp;#93; ^ &amp;#94; _ &amp;#95; 下划线 ` &amp;#96; 尖重音符 ISO 8859-1 charactersISO 8859-1 characters char glyphHTML tag空格&amp;nbsp;¡&amp;iexcl;¢&amp;cent;£&amp;pound;¤&amp;curren;¥&amp;yen;¦&amp;brvbar;§&amp;sect;¨&amp;uml;©&amp;copy;ª&amp;ordf;«&amp;laquo;¬&amp;not; &amp;shy;®&amp;reg;¯&amp;macr;°&amp;deg;±&amp;plusmn;²&amp;sup2;³&amp;sup3;´&amp;acute;µ&amp;micro;¶&amp;para;·&amp;middot;¸&amp;cedil;¹&amp;sup1;º&amp;ordm;»&amp;raquo;¼&amp;frac14;½&amp;frac12;¾&amp;frac34;¿&amp;iquest;À&amp;Agrave;Á&amp;Aacute;Â&amp;Acirc;Ã&amp;Atilde;Ä&amp;Auml;Å&amp;Aring;Æ&amp;AElig;Ç&amp;Ccedil;È&amp;Egrave;É&amp;Eacute;Ê&amp;Ecirc;Ë&amp;Euml;Ì&amp;Igrave;Í&amp;Iacute;Î&amp;Icirc;Ï&amp;Iuml;Ð&amp;ETH;Ñ&amp;Ntilde;Ò&amp;Ograve;Ó&amp;Oacute;Ô&amp;Ocirc;Õ&amp;Otilde;Ö&amp;Ouml;×&amp;times;Ø&amp;Oslash;Ù&amp;Ugrave;Ú&amp;Uacute;Û&amp;Ucirc;Ü&amp;Uuml;Ý&amp;Yacute;Þ&amp;THORN;ß&amp;szlig;à&amp;agrave;á&amp;aacute;â&amp;acirc;ã&amp;atilde;ä&amp;auml;å&amp;aring;æ&amp;aelig;ç&amp;ccedil;è&amp;egrave;é&amp;eacute;ê&amp;ecirc;ë&amp;euml;ì&amp;igrave;í&amp;iacute;î&amp;icirc;ï&amp;iuml;ð&amp;eth;ñ&amp;ntilde;ò&amp;ograve;ó&amp;oacute;ô&amp;ocirc;õ&amp;otilde;ö&amp;ouml;÷&amp;divide;ø&amp;oslash;ù&amp;ugrave;ú&amp;uacute;û&amp;ucirc;ü&amp;uuml;ý&amp;yacute;þ&amp;thorn;ÿ&amp;yuml;# Math symbolsMath symbolsLatin Extended-Bchar glyphHTML tagƒ&amp;fnof;Arrowschar glyphHTML tag←&amp;larr;↑&amp;uarr;→&amp;rarr;↓&amp;darr;↔&amp;harr;↵&amp;crarr;⇐&amp;lArr;⇑&amp;uArr;⇒&amp;rArr;⇓&amp;dArr;⇔&amp;hArr;Mathematical Operatorschar glyphHTML tag∀&amp;forall;∂&amp;part;∃&amp;exist;∅&amp;empty;∇&amp;nabla;∈&amp;isin;∉&amp;notin;∋&amp;ni;∏&amp;prod;∑&amp;sum;−&amp;minus;∗&amp;lowast;√&amp;radic;∝&amp;prop;∞&amp;infin;∠&amp;ang;∧&amp;and;∨&amp;or;∩&amp;cap;∪&amp;cup;∫&amp;int;∴&amp;there4;∼&amp;sim;≅&amp;cong;≈&amp;asymp;≠&amp;ne;≡&amp;equiv;≤&amp;le;≥&amp;ge;⊂&amp;sub;⊃&amp;sup;⊄&amp;nsub;⊆&amp;sube;⊇&amp;supe;⊕&amp;oplus;⊗&amp;otimes;⊥&amp;perp;⋅&amp;sdot;General Punctuationchar glyphHTML tag•&amp;bull;…&amp;hellip;′&amp;prime;″&amp;Prime;‾&amp;oline;⁄&amp;frasl;Miscellaneous Technicalchar glyphHTML tag⌈&amp;lceil;⌉&amp;rceil;⌊&amp;lfloor;⌋&amp;rfloor;⟨&amp;lang;⟩&amp;rang;Geometric Shapeschar glyphHTML tag◊&amp;loz;Miscellaneous Symbolschar glyphHTML tag♠&amp;spades;♣&amp;clubs;♥&amp;hearts;♦&amp;diams;Letterlike Symbolschar glyphHTML tag℘&amp;weierp;ℑ&amp;image;ℜ&amp;real;™&amp;trade;ℵ&amp;alefsym;Greekchar glyphHTML tagΑ&amp;Alpha;Β&amp;Beta;Γ&amp;Gamma;Δ&amp;Delta;Ε&amp;Epsilon;Ζ&amp;Zeta;Η&amp;Eta;Θ&amp;Theta;Ι&amp;Iota;Κ&amp;Kappa;Λ&amp;Lambda;Μ&amp;Mu;Ν&amp;Nu;Ξ&amp;Xi;Ο&amp;Omicron;Π&amp;Pi;Ρ&amp;Rho;Σ&amp;Sigma;Τ&amp;Tau;Υ&amp;Upsilon;Φ&amp;Phi;Χ&amp;Chi;Ψ&amp;Psi;Ω&amp;Omega;α&amp;alpha;β&amp;beta;γ&amp;gamma;δ&amp;delta;ε&amp;epsilon;ζ&amp;zeta;η&amp;eta;θ&amp;theta;ι&amp;iota;κ&amp;kappa;λ&amp;lambda;μ&amp;mu;ν&amp;nu;ξ&amp;xi;ο&amp;omicron;π&amp;pi;ρ&amp;rho;ς&amp;sigmaf;σ&amp;sigma;τ&amp;tau;υ&amp;upsilon;φ&amp;phi;χ&amp;chi;ψ&amp;psi;ω&amp;omega;ϑ&amp;thetasym;ϒ&amp;upsih;ϖ&amp;piv;# Special characters for HTMLSpecial characters for HTMLC0 Controls and Basic Latinchar glyphHTML tag“&amp;quot;&amp;&amp;amp;&lt;&amp;lt;&gt;&amp;gt;Latin Extended-Achar glyphHTML tagŒ&amp;OElig;œ&amp;oelig;Š&amp;Scaron;š&amp;scaron;Ÿ&amp;Yuml;Spacing Modifier Letterschar glyphHTML tagˆ&amp;circ;˜&amp;tilde;General Punctuationchar glyphHTML tag &amp;ensp; &amp;emsp; &amp;thinsp;‌&amp;zwnj;‍&amp;zwj;‎&amp;lrm;‏&amp;rlm;–&amp;ndash;—&amp;mdash;‘&amp;lsquo;’&amp;rsquo;‚&amp;sbquo;“&amp;ldquo;”&amp;rdquo;„&amp;bdquo;†&amp;dagger;‡&amp;Dagger;‰&amp;permil;‹&amp;lsaquo;›&amp;rsaquo;€&amp;euro;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"转义字符","slug":"转义字符","permalink":"https://www.xiongtianci.com/tags/转义字符/"}],"author":"天赐"},{"title":"js中window&#46;location&#46;search的用法和作用","slug":"js中window-46-location-46-search的用法和作用","date":"2018-11-20T09:29:20.000Z","updated":"2019-06-18T08:45:43.599Z","comments":true,"path":"2018/11/20/js中window-46-location-46-search的用法和作用/","link":"","permalink":"https://www.xiongtianci.com/2018/11/20/js中window-46-location-46-search的用法和作用/","excerpt":"","text":"window.location.search的作用为：获取页面 URL 地址 属性 描述 hash 从 # 开始的 URL（锚） host 主机名和当前 URL 的端口号 hostname 当前 URL 的主机名 href 完整的 URL pathname 当前 URL 的路径部分 port 当前 URL 的端口号 protocol 当前 URL 的协议 search 从问号 (?) 开始的 URL（查询部分）","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://www.xiongtianci.com/tags/JS/"}],"author":"天赐"},{"title":"JSP九大内置对象及其作用和四大作用域详解","slug":"JSP九大内置对象及其作用和四大作用域详解","date":"2018-11-20T06:33:08.000Z","updated":"2019-06-18T08:45:36.219Z","comments":true,"path":"2018/11/20/JSP九大内置对象及其作用和四大作用域详解/","link":"","permalink":"https://www.xiongtianci.com/2018/11/20/JSP九大内置对象及其作用和四大作用域详解/","excerpt":"","text":"一、什么是内置对象？在JSP开发中会频繁使用到一些对象，SUN公司为简化开发，在设计JSP时规定JSP页面加载完毕之后自动帮开发者创建好了这些对象，开发者只需要使用相应的对象调用相应的方法即可。这些系统创建好的对象就叫做内置对象。 二、九大内置对象内置对象名 类型 request HttpServletRequest response HttpServletResponse config ServletConfig application ServletContext session HttpSession exception Throwable page Object(this) out JspWriter pageContext PageContext 1、request对象request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。 2、response对象response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。 3、session对象session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。 4、application对象 application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。 5、out 对象out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。 6、pageContext 对象pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。 7、config 对象config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。 8、page 对象page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。 9、exception 对象exception 对象的作用是显示异常信息，只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。 三、四大作用域page域: 只能在当前jsp页面使用 (当前页面) request域: 只能在同一个请求中使用 (转发) session域: 只能在同一个会话(session对象)中使用 (私有的) context域: 只能在同一个web应用中使用 (全局的)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"JSP","slug":"JSP","permalink":"https://www.xiongtianci.com/tags/JSP/"}],"author":"天赐"},{"title":"==和equals()的区别","slug":"==和equals的区别","date":"2018-11-20T02:26:33.000Z","updated":"2019-06-18T08:45:25.210Z","comments":true,"path":"2018/11/20/==和equals的区别/","link":"","permalink":"https://www.xiongtianci.com/2018/11/20/==和equals的区别/","excerpt":"","text":"equals 和 == 最大的区别是一个是方法一个是运算符 ==：如果比较的对象是==基本数据类型==，则比较的是数值是否相等；如果比较的是==引用数据类型==，则比较的是对象的地址值是否相等。 equals()：用来比较方法两个对象的内容是否相等。注意：equals 方法不能用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是==引用类型==的变量所指向的对象的地址。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"String、StringBuffer、StringBuilder以及对String不变性的理解","slug":"String、StringBuffer、StringBuilder以及对String不变性的理解","date":"2018-11-20T01:21:22.000Z","updated":"2019-06-18T08:45:50.297Z","comments":true,"path":"2018/11/20/String、StringBuffer、StringBuilder以及对String不变性的理解/","link":"","permalink":"https://www.xiongtianci.com/2018/11/20/String、StringBuffer、StringBuilder以及对String不变性的理解/","excerpt":"","text":"String、StringBuffer、StringBuilder 都是final 类, 都不允许被继承 String 长度是不可变的, StringBuffer、StringBuilder 长度是可变的; StringBuffer 是线程安全的, StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer在StringBuilder的方法之上添加了synchronized修饰，保证线程安全 StringBuilder比StringBuffer拥有更好的性能 如果一个String类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时String的速度比StringBuffer和StringBuilder的性能好的多 String不变性的理解 String 类是被final进行修饰的，不能被继承 在用+号链接字符串的时候会创建新的字符串；对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象 String s = new String(“Hello world”); 可能创建两个对象也可能创建一个对象。如果静态区中有“Hello world”字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有“Hello world”对象，则堆上和静态区中都需要创建对象 在java 中, 通过使用”+” 符号来串联字符串的时候, 实际上底层会转成通过StringBuilder 实例的append() 方法来实现","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"同源策略与JS跨域","slug":"同源策略与JS跨域","date":"2018-11-19T02:49:12.000Z","updated":"2019-06-18T08:45:17.523Z","comments":true,"path":"2018/11/19/同源策略与JS跨域/","link":"","permalink":"https://www.xiongtianci.com/2018/11/19/同源策略与JS跨域/","excerpt":"","text":"为什么要跨域为了用户的信息安全，浏览器就引入了同源策略那么同源策略是如何保证用户的信息安全的呢？ 如果没有同源策略，你打开了你的银行账户页面A，又打开了另一个不相关的页面B，这时候如果B是恶意网站，B可以通过Javascript轻松访问和修改A页面中的内容 现在我们广泛的使用cookie来维护用户的登录状态，而如果没有同源策略，这些cookie信息就会泄露，其他网站就可以冒充这个登录用户 由此可以看出，同源策略确实是必不可少的，那么它会带来哪些限制呢？ Cookie、LocalStorage和IndexDB无法读取 DOM无法获得 AJAX请求不能发送 有时候我们需要突破上述限制，就需要用跨域的方法来解决 跨域是什么？ 什么叫做不同的域？协议（http）、域名（www.a.com）、端口（8000）三者中有一个不同就叫不同的域 跨域就是不同的域间相互访问时使用某些方法来突破上述限制 协议或者端口的不同，只能通过后台来解决如何实现跨域？一、解决上面提到的1、2两点限制：1. 通过document.domain跨子域 适用范围： 两个域只是子域不同 只适用于iframe窗口与父窗口之间互相获取cookie和DOM节点，不能突破LocalStorage和IndexDB的限制 当两个不同的域只是子域不同时，可以通过把document.domain设置为他们共同的父域来解决 eg:A: http://www.example.com/a.htmlB: http://example.com/b.html 当A、B想要获取对方的cookie或者DOM节点时，可以设置: document.domain=’example.com’; 这时A网页通过脚本设置: document.cookie = “testA=hello”; B网页就可以拿到这个cookie： var aCookie = document.cookie; 2. 通过window.name跨域 使用范围： 可以是两个完全不同源的域 同一个窗口内：即同一个标签页内先后打开的窗口 window.name属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。 基于这个思想，我们可以在某个页面设置好 window.name 的值，然后在本标签页内跳转到另外一个域下的页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。 结合iframe还有更高级的用法： 父窗口先打开一个与自己不同源的子窗口，在这个子窗口里设置： window.name = data; 然后让子窗口跳转到一个与父窗口同域的网址： location=’http://www.parent.com/a.html&#39;; 这时，因为同域并且同一窗口window.name是不变的，所以父窗口可以获取到子窗口下的window.name。 var data = document.getElementById(‘myFrame’).contentWindow.name; 优点：window.name容量很大，可以放置非常长的字符串；缺点：必须监听子窗口window.name属性的变化，影响网页性能。 3. 使用HTML5的window.postMessage跨域window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。 otherWindow.postMessage(message, targetOrigin); otherWindow:接受消息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message:所要发送的数据，string类型。targetOrigin:用于限制otherWindow，*表示不做限制。 eg1:在父页面中嵌入子页面，通过postMessage发送数据。parent.com/index.html中的代码： &lt;iframe id=&quot;ifr&quot; src=&quot;child.com/index.html&quot;&gt;&lt;/iframe&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { var ifr = document.getElementById(&#39;ifr&#39;); var targetOrigin = &#39;http://child.com&#39;; // 若写成&#39;http://child.com/c/proxy.html&#39;效果一样 // 若写成&#39;http://c.com&#39;就不会执行postMessage了 ifr.contentWindow.postMessage(&#39;I was there!&#39;, targetOrigin); }; &lt;/script&gt; 在子页面中通过message事件监听父页面发送来的消息并显示。child.com/index.html中的代码： &lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#39;message&#39;, function(event){ // 通过origin属性判断消息来源地址 if (event.origin == &#39;http://parent.com&#39;) { alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对parent.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 } }, false); &lt;/script&gt; eg2:假设在a.html里嵌套个 &lt;iframe src=&quot;http://www.child.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 在这两个页面里互相通信 a.html window.onload = function() { window.addEventListener(&quot;message&quot;, function(e) { alert(e.data); }); window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.child.com/b.html&quot;); } b.html window.onload = function() { window.addEventListener(&quot;message&quot;, function(e) { alert(e.data); }); window.parent.postMessage(&quot;a data&quot;, &quot;http://www.parent.com/a.html&quot;); } 这样打开a页面，首先监听到了b.html通过postMessage传来的消息，就先弹出 a data，然后a通过postMessage传递消息给子页面b.html，这时会弹出 b data 二、解决第3点限制： AJAX请求不能发送 4. 通过JSONP跨域 适用范围： 可以是两个完全不同源的域； 只支持HTTP请求中的GET方式； 老式浏览器全部支持； 需要服务端支持 JSONP(JSON with Padding)是资料格式JSON的一种使用模式，可以让网页从别的网域要资料。 由于浏览器的同源策略，在网页端出现了这个“跨域”的问题，然而我们发现，所有的 src 属性并没有受到相关的限制，比如 img / script 等。 JSONP 的原理就要从 script 说起。script 可以引用其他域的脚本文件，比如这样： a.html ... &lt;script&gt; function callback(data) { console.log(data.url) } &lt;/script&gt; &lt;script src=&#39;b.js&#39;&gt;&lt;/script&gt; ... b.js callback({url: &#39;http://www.rccoder.net&#39;}) 这就类似于JSONP的原理了。 JSONP的基本思想是：先在网页上添加一个script标签，设置这个script标签的src属性用于向服务器请求JSON数据 ，需要注意的是，src属性的查询字符串一定要加一个callback参数，用来指定回调函数的名字 。而这个函数是在资源加载之前就已经在前端定义好的，这个函数接受一个参数并利用这个参数做一些事情。向服务器请求后，服务器会将JSON数据放在一个指定名字的回调函数里作为其参数传回来。这时，因为函数已经在前端定义好了，所以会直接调用。 eg： function addScriptTag(src) { var script = document.createElement(&#39;script&#39;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script); } window.onload = function () { addScriptTag(&#39;http://example.com/ip?callback=foo&#39;);//请求服务器数据并规定回调函数为foo } function foo(data) { console.log(&#39;Your public IP address is: &#39; + data.ip); }; 向服务器example.com请求数据，这时服务器会先生成JSON数据，这里是{“ip”: “8.8.8.8”}，然后以JS语法的方式生成一个函数，函数名就是传递上来的callback参数的值，最后将数据放在函数的参数中返回： foo({ &quot;ip&quot;: &quot;8.8.8.8&quot; }); 客户端解析script标签，执行返回的JS代码，调用函数。 5. 通过CORS跨域 适用范围： 可以是两个完全不同源的域； 支持所有类型的HTTP请求； 被绝大多数现代浏览器支持，老式浏览器不支持； 需要服务端支持 对于前端开发者来说，跨域的CORS通信与同源的AJAX通信没有差别，代码完全一样。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 简单请求：下面是一次跨源AJAX请求，浏览器发现它是简单请求，就会直接在头信息中加一个origin字段： GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 服务器收到这条请求，如果这个origin指定的源在许可范围内，那么服务器返回的头信息中会包含Access-Control-Allow-Origin字段，值与origin的值相同，以及其他几个相关字段： Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Access-Control-Allow-Origin: 该字段是必须的。要么与origin相同，要么为*Access-Control-Allow-Credentials: 该字段可选。设为true表示服务器允许发送cookieAccess-Control-Expose-Headers: 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 想要发送cookie，这里还有两点需要额外注意： 1）开发者必须在AJAX请求中打开withCredentials属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则即使服务器允许，客户端也不会发送。 2）Access-Control-Allow-Origin不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求：1.预检请求： 非简单请求会在正式通信前加一次预检（preflight）请求。作用是浏览器先询问服务器当前网页所在域名是否在服务器的许可名单中，以及可以使用哪些HTTP方法以及头信息字段。只有得到肯定答复，浏览器才会发送XMLHttpRequest，否则报错。一个例子： var url = &#39;http://api.alice.com/cors&#39;; var xhr = new XMLHttpRequest(); xhr.open(&#39;PUT&#39;, url, true); xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;); xhr.send(); HTTP请求方法为PUT，并发送一个自定义头信息”X-Custom-Header”，浏览器发现这是一个非简单请求，就会自动发送一个预检请求，预检请求的HTTP头信息如下： OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 请求方法是OPTIONS，表示这个请求是用来询问的，头信息中的关键信息有3个： （1）表示请求来自哪个源 Origin: http://api.bob.com （2）列出浏览器的CORS请求会用到哪些HTTP方法 Access-Control-Request-Method: PUT （3）指定浏览器CORS请求会额外发送的头信息字段 Access-Control-Request-Headers: X-Custom-Header 2.预检请求的回应（有两种情况：A允许、B不允许） A.服务器允许这次跨域请求 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 服务器返回中要注意的字段： （1）服务器同意的跨域请求源： Access-Control-Allow-Origin: http://api.bob.com （2）服务器支持的所有跨域请求的方法： Access-Control-Allow-Methods: GET, POST, PUT （3）表明服务器支持的所有头信息字段： Access-Control-Allow-Headers: X-Custom-Header （4）指定本次预检请求的有效期，单位为秒，即允许请求该条回应在有效期之前都不用再发送预检请求： Access-Control-Max-Age: 1728000 B.服务器不允许这次跨域请求即origin指定的源不在许可范围内，服务器会返回一个正常的HTTP回应。但是头信息中没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。但是要注意的是，这种HTTP回应的状态码很有可能是200，所以无法通过状态码识别这种错误。 3.正式请求过了预检请求，非简单请求的正式请求就与简单请求一样了。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题、","slug":"面试题、","permalink":"https://www.xiongtianci.com/tags/面试题、/"},{"name":"同源策略","slug":"同源策略","permalink":"https://www.xiongtianci.com/tags/同源策略/"},{"name":"JS跨域","slug":"JS跨域","permalink":"https://www.xiongtianci.com/tags/JS跨域/"}],"author":"天赐"},{"title":"电商项目中的SPU和SKU概念","slug":"电商项目中的SPU和SKU概念","date":"2018-11-16T06:58:37.000Z","updated":"2019-06-18T08:45:10.386Z","comments":true,"path":"2018/11/16/电商项目中的SPU和SKU概念/","link":"","permalink":"https://www.xiongtianci.com/2018/11/16/电商项目中的SPU和SKU概念/","excerpt":"","text":"SPUSPU：Standard Product Unit，标准产品单位。 概念：SPU 是商品信息聚合的最小单位【即：商品共同的属性】，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的货品就可以称为一个 SPU SPU是用来定位的例如：iphone8 就是一个 SPU，与商家、颜色、款式、套餐都无关 SKUSKU：Stock Keeping Unit，库存量单位。 概念：SKU 即库存进出计量的单位， 可以是以件、盒、托盘等为单位，是物理上不可分割的最小存货单元。在使用时要根据不同业务，不同管理模式来处理 SKU是用来定价和管理库存的iphone8 有很多颜色，很多配置，每个颜色和配置的组合都会形成新的产品，这时就产生很多SKU例如：银色 64G 的 iphone8 就是一个SKU；纺织品中一个 SKU 通常表示：规格、颜色、款式","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"Servlet简介及其生命周期详解","slug":"Servlet简介及其生命周期详解","date":"2018-11-16T02:36:38.000Z","updated":"2019-06-18T08:41:35.620Z","comments":true,"path":"2018/11/16/Servlet简介及其生命周期详解/","link":"","permalink":"https://www.xiongtianci.com/2018/11/16/Servlet简介及其生命周期详解/","excerpt":"","text":"一、什么是Servlet？Servlet：是用Java编写的服务器端程序，一门用于开发动态web资源的技术。其主要功能在与交互式的浏览和修改数据，生成动态web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet的类。一般对Servlet的理解是后者。若想开发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 1、编写一个Java类，实现servlet接口。 2、把开发好的Java类部署到web服务器中。按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet 二、Servlet的运行流程Servlet程序是由WEB服务器调用，WEB服务器收到客户端的Servlet访问请求后： Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步 装载并创建该Servlet的一个实例对象 调用Servlet实例对象的init()方法 创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去 WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法 三、Servlet的生命周期Servlet运行在Servlet容器中，其生命周期由容器来管理。Servlet的生命周期通过javax.servlet.Servlet接口中的init()、service()和destroy()方法来表示Servlet的生命周期包含了下面4个阶段： 加载和实例化：第一次请求时创建，通过服务器反射机制创建Servlet对象 初始化：调用Servlet对象的init()方法，初始化Servlet的信息，init()方法只会在创建后被调用一次 请求处理：调用service()或者是doGet()，doPost()方法来处理请求 服务终止：在长时间没有被调用或者是服务器关闭时，会调用destroy()方法来销毁Servlet对象 在整个Servlet的生命周期过程中，创建Servlet实例、调用实例的init()和destroy()方法都只执行一次，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的service()方法，为接收到的请求服务","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"Servlet","slug":"Servlet","permalink":"https://www.xiongtianci.com/tags/Servlet/"}],"author":"天赐"},{"title":"反向安装jar包到Mave本地仓库","slug":"反向安装jar包到Mave本地仓库","date":"2018-11-14T17:17:48.000Z","updated":"2019-06-18T08:41:21.334Z","comments":true,"path":"2018/11/15/反向安装jar包到Mave本地仓库/","link":"","permalink":"https://www.xiongtianci.com/2018/11/15/反向安装jar包到Mave本地仓库/","excerpt":"","text":"当maven中央仓库没有所需jar的坐标时，需要自行将jar包反向安装到maven的本地仓库中步骤： 注意：前提是安装好Maven并且配置好maven的环境变量 准备所需的jar包 打开命令行，输入以下命令，按下回车即可安装mvn install:install-file -Dfile=d:\\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar 可以在Maven本地仓库中查看是否安装成功 在pom文件中导入坐标`xml com.alibaba dubbo 2.8.4`","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://www.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://www.xiongtianci.com/tags/maven/"}],"author":"天赐"},{"title":"SpringMVC的工作原理","slug":"SpringMVC的工作原理","date":"2018-11-09T13:17:04.000Z","updated":"2019-06-18T08:40:48.196Z","comments":true,"path":"2018/11/09/SpringMVC的工作原理/","link":"","permalink":"https://www.xiongtianci.com/2018/11/09/SpringMVC的工作原理/","excerpt":"","text":"1. SpringMVC的主要组件 DispatchServlet：前端控制器，接收请求，响应结果，返回可以是json,String等数据类型，也可以是页面（Model） HandlerMapping：处理器映射器，根据URL去查找处理器，一般通过xml配置或者注解进行查找 Handler：处理器，即Controller控制器，由我们程序员编写 HandlerAdapter：处理器适配器，可以将处理器包装成适配器，这样就可以支持多种类型的处理器 ViewResolver：视图解析器，进行视图解析，返回view对象（常见的有JSP,FreeMark等） 2. SpringMVC的工作原理 用户向服务器发送请求，请求被 SpringMVC 前端控制器DispatchServlet 捕获 DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping将请求映射到处理器 HandlerExcutionChain DispatchServlet 根据获得 Handler 选择一个合适的 HandlerAdapter 适配器处理； Handler 对数据处理完成以后将返回一个 ModelAndView() 对象给 DisPatchServlet; Handler 返回的 ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet 通过 ViewResolver 试图解析器将逻辑视图转化为真正的视图View; DispatcherServle 通过model 解析出 ModelAndView() 中的参数进行解析最终展现出完整的 view 并返回给客户端","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://www.xiongtianci.com/tags/SpringMVC/"}],"author":"天赐"},{"title":"Java 的基本数据类型都有哪些，各占几个字节","slug":"Java的基本数据类型都有哪些，各占几个字节","date":"2018-11-09T09:37:25.000Z","updated":"2019-06-18T08:40:42.299Z","comments":true,"path":"2018/11/09/Java的基本数据类型都有哪些，各占几个字节/","link":"","permalink":"https://www.xiongtianci.com/2018/11/09/Java的基本数据类型都有哪些，各占几个字节/","excerpt":"","text":"四类 八种 字节数 数据表示范围 整型 byte 1 -128~127 short 2 -32768~32767 int 4 -2147483648～2147483647 long 8 -2^63^～2^63^-1 浮点型 float 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308 字符型 char 2 表示一个字符，如(‘a’，’A’，’0’，’家’) 布尔型 boolean 1 只有两个值true与false","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"final、finally、finalize 的区别","slug":"final、finally、finalize-的区别","date":"2018-11-09T08:33:44.000Z","updated":"2019-06-18T08:40:13.502Z","comments":true,"path":"2018/11/09/final、finally、finalize-的区别/","link":"","permalink":"https://www.xiongtianci.com/2018/11/09/final、finally、finalize-的区别/","excerpt":"","text":"final：用于声明属性( 变量 )，方法和类。分别表示属性不可变( 不可二次赋值 )，方法不可覆盖，被其修饰的类不可继承 finally：异常处理语句 try/catch 结构的一部分，表示总是执行 finalize：Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"数组的两种排序方式：选择排序和冒泡排序","slug":"数组的两种排序方式：选择排序和冒泡排序","date":"2018-11-09T08:23:06.000Z","updated":"2019-06-18T08:40:55.552Z","comments":true,"path":"2018/11/09/数组的两种排序方式：选择排序和冒泡排序/","link":"","permalink":"https://www.xiongtianci.com/2018/11/09/数组的两种排序方式：选择排序和冒泡排序/","excerpt":"","text":"选择排序 原理：在数组中选择出最小（大）的一个数，与第一个位置的数进行交换位置；`int[] arr = {5,8,3,9,10,2};System.out.println(“排序前：” + Arrays.toString(arr)); // 使用两层循环遍历数组，将前一位数值与后面以为数值进行比较，// 如果前一位数值要大于后一位数值，则交换他们的位置。故而可以实现排序for(int m = 0; m&lt;arr.length-1; m++){ for(int n = m+1; n&lt;arr.length; n++){ if(arr[m] &gt; arr[n]){ // 用于临时储存需要交换位置的某一个值 int temp = arr[m]; // 交换位置 arr[m] = arr[n]; arr[n] = temp; } }}System.out.println(“排序后：” + Arrays.toString(arr)); ## 冒泡排序 int[] arr = {5,8,3,9,10,2};System.out.println(“排序前：” + Arrays.toString(arr)); // 使用两层循环遍历数组for(int m = 0; m&lt;arr.length-1; m++){ // 第二层循环，将 arr 索引为 0~arr.length-1-m 中最大的一个数移动到 arr[arr.length-1-m] 的位置 for(int n = 0; n&lt;arr.length-1-m; n++){ if(arr[n] &gt; arr[n+1]){ // 用于临时储存需要交换位置的某一个值 int temp = arr[n]; // 交换位置 arr[n] = arr[n+1]; arr[n+1] = temp; } }}System.out.println(“排序后：” + Arrays.toString(arr));`","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.xiongtianci.com/tags/面试题/"},{"name":"数组","slug":"数组","permalink":"https://www.xiongtianci.com/tags/数组/"},{"name":"排序","slug":"排序","permalink":"https://www.xiongtianci.com/tags/排序/"}],"author":"天赐"},{"title":"如何显示隐藏的Chrome扩展程序图标","slug":"如何显示隐藏的Chrome扩展程序图标","date":"2018-11-08T07:33:35.000Z","updated":"2019-06-18T08:40:26.294Z","comments":true,"path":"2018/11/08/如何显示隐藏的Chrome扩展程序图标/","link":"","permalink":"https://www.xiongtianci.com/2018/11/08/如何显示隐藏的Chrome扩展程序图标/","excerpt":"","text":"1. 将扩展程序图标在 Chrome 菜单中隐藏将鼠标移动到需要隐藏的扩展程序上面，点击鼠标右键，选择“在 Chrome 菜单中隐藏”即可进行隐藏 2. 将隐藏的扩展程序图标在 Chrome 菜单中重新显示在浏览器地址栏最右边，待鼠标变成左右双向箭头图标的时候向左拖动，会发现隐藏的扩展程序出现了","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Chrome","slug":"Chrome","permalink":"https://www.xiongtianci.com/tags/Chrome/"},{"name":"扩展程序","slug":"扩展程序","permalink":"https://www.xiongtianci.com/tags/扩展程序/"}],"author":"天赐"},{"title":"Typora设置图片的相对路径（win系统）","slug":"Typora设置图片的相对路径（win系统）","date":"2018-09-30T07:17:41.000Z","updated":"2019-06-18T08:40:32.328Z","comments":true,"path":"2018/09/30/Typora设置图片的相对路径（win系统）/","link":"","permalink":"https://www.xiongtianci.com/2018/09/30/Typora设置图片的相对路径（win系统）/","excerpt":"","text":"Typora设置图片的相对路径（win系统）步骤：文件–&gt;偏好设置–&gt;图片插入结果：将插入的图片路径设置成相对路径（./assets目录）","categories":[{"name":"技术","slug":"技术","permalink":"https://www.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://www.xiongtianci.com/tags/软件/"},{"name":"Typora","slug":"Typora","permalink":"https://www.xiongtianci.com/tags/Typora/"}],"author":"天赐"}]}