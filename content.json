{"meta":{"title":"天赐","subtitle":null,"description":null,"author":"天赐","url":"","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-05-31T23:21:46.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-05-31T23:21:46.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-05-31T23:21:46.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-05-31T23:21:46.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"重新搭建博客","slug":"重新搭建博客","date":"2019-05-20T12:49:00.000Z","updated":"2019-06-02T15:53:12.783Z","comments":true,"path":"2019/05/20/重新搭建博客/","link":"","permalink":"/2019/05/20/重新搭建博客/","excerpt":"","text":"前言3月份初，许久没写博客（主要就是懒）的博主在莫一天心血来潮写好一篇文章后，使用hexo d部署博客文章时，发现hexo抛出各种错误。但由于当时准备面试的面试题（主要就是懒），然后就放着没管它。紧接着面试实习岗位，工作后也一直没有闲下来。最近终于抽出时间来重构博客，写下这篇文章，记录一下重构博客的过程~ 博客目录介绍. ├── .deploy ├── public ├── scaffolds ├── scripts ├── source | ├── _drafts | └── _posts ├── themes ├── _config.yml └── package.json .deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章 _posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的 关于 按钮 接下来是重头戏 _config.yml ，做个简单说明： # Hexo Configuration ## Docs: http://zespia.tw/hexo/docs/configure.html ## Source: https://github.com/tommy351/hexo/ # Site #整站的基本信息 title: 不如 #网站标题 subtitle: 码农，程序猿，未来的昏析师 #网站副标题 description: bruce sha&#39;s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到 author: bruce #网站作者，在下方显示 email: bu.ru@qq.com #联系邮箱 language: zh-CN #语言 # URL #域名和文件结构 ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: http://ibruce.info #你的域名 root: / permalink: :year/:month/:day/:title/ tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code # Writing #写文章选项 new_post_name: :title.md # File name of new posts default_layout: post #默认layout方式 auto_spacing: false # Add spaces between asian characters and western characters titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab max_open_file: 100 multi_thread: true filename_case: 0 render_drafts: false highlight: #代码高亮 enable: true #是否启用 line_number: false #是否显示行号 tab_replace: # Category &amp; Tag #分类与标签 default_category: uncategorized # default category_map: tag_map: # Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突 ## 2: Enable pagination ## 1: Disable pagination ## 0: Fully Disable archive: 1 category: 1 tag: 1 # Server #本地服务参数 ## Hexo uses Connect as a server ## You can customize the logger format as defined in ## http://www.senchalabs.org/connect/logger.html port: 4000 logger: true logger_format: # Date / Time format #日期显示格式 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: MMM D YYYY time_format: H:mm:ss # Pagination #分页设置 ## Set per_page to 0 to disable pagination per_page: 10 #每页10篇文章 pagination_dir: page # Disqus #社会化评论disqus，我使用多说，在主题中配置 disqus_shortname: # Extensions #插件，暂时未安装插件 ## Plugins: https://github.com/tommy351/hexo/wiki/Plugins ## Themes: https://github.com/tommy351/hexo/wiki/Themes ## 主题 theme: modernist # raytaylorism # pacman # modernist # light exclude_generator: # Deployment #部署 ## Docs: http://zespia.tw/hexo/docs/deploy.html deploy: type: github repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库 主题目录介绍. ├── languages #多语言 | ├── default.yml #默认语言 | └── zh-CN.yml #中文语言 ├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制 | ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制 | └── _widget #小挂件的布局，页面下方小挂件的控制 ├── source #源码 | ├── css #css源码 | | ├── _base #*.styl基础css | | ├── _partial #*.styl局部css | | ├── fonts #字体 | | ├── images #图片 | | └── style.styl #*.styl引入需要的css源码 | ├── fancybox #fancybox效果源码 | └── js #javascript源代码 ├── _config.yml #主题配置文件 └── README.md #用GitHub的都知道 如果你需要修改头部，直接修改 hexo\\themes\\modernist\\layout\\_partial\\header.ejs ，比如头上加个搜索框： &lt;div&gt; &lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\\/\\//, &#39;&#39;) %&gt;&quot;&gt; &lt;/form&gt; &lt;/div&gt; 将如上代码加入即可，您需要修改css以便这个搜索框比较美观。再如，你要修改页脚版权信息，直接编辑 hexo\\themes\\modernist\\layout\\_partial\\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。 主题安装 https://www.haomwei.com/technology/maupassant-hexo.html $ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant $ npm install hexo-renderer-pug --save $ npm install hexo-renderer-sass --save npm install hexo-renderer-pug --save安装时可能会报错，以下是解决方案：改用cnpm来安装软件 $ npm install -g cnpm –registry=https://registry.npm.taobao.org目的是直接改npm为淘宝的npm，也为防止某些依赖直接用npm来安装，导致无法顺利安装完成$ npm config set registry https://registry.npm.taobao.org 编辑Hexo目录下的 _config.yml，将theme的值改为maupassant theme: matery 功能配置# 是否启用Fancybox图片灯箱效果 # Disqus评论 shortnam disqus: # 友言评论 id uyan: # 来必力评论 data-uid livere: # 畅言评论 appid changyan: changyan_conf: ## Your changyan conf, e.g. prod_d8a508c2825ab57eeb43e7c69bba0e8b # Gitment评论相关参数 gitment: enable: false owner: repo: client_id: client_secret: # Gitalk评论相关参数 gitalk: enable: false owner: repo: client_id: client_secret: admin: # Valine评论相关参数 valine: enable: false appid: appkey: notify: false # 评论系统中的邮件提醒设置 verify: false ## Validation code. placeholder: Just so so avatar: &#39;mm&#39; pageSize: 10 guest_info: nick,mail,link # 默认使用Google搜索引擎 google_search: true # 若想使用百度搜索，将其设定为 true baidu_search: false # Swiftype 站内搜索key swiftype: # 微搜索 key tinysou: # 基于jQuery的本地搜索引擎，需要安装hexo-generator-search插件使用 self_search: false # Google Analytics 跟踪ID google_analytics: # 百度统计 跟踪ID baidu_analytics: # fancybox: true ## If you want to use fancybox please set the value to true. # 是否显示侧边栏分类数目 show_category_count: false # 是否显示文章中目录列表自动编号 toc_number: true # 是否使用分享按鈕，需要安装hexo-helper-qrcode插件使用 shareto: false # 是否使用不蒜子页面访问计数 busuanzi: false # wordcount: false ## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed. # 是否在移动设备屏幕底部显示侧边栏 widgets_on_small_screens: false ## Set to true to enable widgets on small screens. # 是否使用canvas动态背景 canvas_nest: enable: false color: ## RGB value of the color, e.g. &quot;100,99,98&quot; opacity: ## Transparency of lines, e.g. &quot;0.7&quot; zIndex: ## The z-index property of the background, e.g. &quot;-1&quot; count: ## Quantity of lines, e.g. &quot;150&quot; # 是否启用捐赠按钮 donate: enable: false github: ## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page alipay_qr: ## Path of Alipay QRcode image, e.g. /img/AliPayQR.png wechat_qr: ## Path of Wechat QRcode image, e.g. /img/WeChatQR.png btc_qr: ## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png btc_key: ## Bitcoin key, e.g. 1KuK5eK2BLsqpsFVXXSBG5wbSAwZVadt6L paypal_url: ## Paypal URL, e.g. https://www.paypal.me/tufu9441 post_copyright: enable: false ## If you want to display the copyright info after each post, please set the value to true and fill the following items on your need. author: ## Your author name, e.g. tufu9441 copyright_text: ## Your copyright text, e.g. The author owns the copyright, please indicate the source reproduced. # 自定义页面及菜单，依照已有格式填写。 # 填写后请在source目录下建立相应名称的文件夹，并包含index.md文件，以正确显示页面。 # 导航菜单中集成了FontAwesome图标字体，可以在这里选择新的图标，并按照相关说明使用。 menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: about directory: about/ icon: fa-user - page: rss directory: atom.xml icon: fa-rss # 选择和排列希望使用的侧边栏小工具 widgets: ## Six widgets in sidebar provided: search, category, tag, recent_posts, rencent_comments and links. - search - category - tag - recent_posts - recent_comments - links # 友情链接，请依照格式填写 links: - title: site-name1 url: http://www.example1.com/ - title: site-name2 url: http://www.example2.com/ - title: site-name3 url: http://www.example3.com/ # 网站历史时间线，在页面front-matter中设置layout: timeline可显示 timeline: - num: 1 word: 2014/06/12-Start - num: 2 word: 2014/11/29-XXX - num: 3 word: 2015/02/18-DDD - num: 4 word: More # Static files # 静态文件存储路径，方便设置CDN缓存 js: js css: css # Theme version # 主题版本，便于静态文件更新后刷新CDN缓存 version: 0.0.0 评论Disqus配置使用注册 https://disqus.com/ 主题特性主题目录结构-maupassant |-languages 网站图标网站Favicon：/blog/source/favicon.ico，建议的大小：32px*32px。","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"/categories/技术笔记/"},{"name":"博客记录","slug":"技术笔记/博客记录","permalink":"/categories/技术笔记/博客记录/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"/tags/Hexo/"}]},{"title":"MySQL面试题","slug":"MySQL面试题","date":"2019-01-02T12:05:58.000Z","updated":"2019-06-02T15:54:12.547Z","comments":true,"path":"2019/01/02/MySQL面试题/","link":"","permalink":"/2019/01/02/MySQL面试题/","excerpt":"","text":"1. 主键 超键 候选键 外键主 键： 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。 一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null） 超 键： 在关系中能唯一标识元组的属性集称为关系模式的超键 一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键 超键包含候选键和主键。 候选键： 是最小超键，即没有冗余元素的超键。 外 键： 在一个表中存在的另一个表的主键称此表的外键 2.数据库事务的四个特性及含义 数据库事务( transanction )正确执行的四个基本要素( ACID )：原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 原子性： 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性： 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性： 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 持久性： 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 3.drop,delete与truncate的区别 drop直接删掉表delete删除表中数据，可以加where字句truncate删除表中数据，再插入时自增长id又从1开始 1、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除的数据是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。 2、表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。 3、一般而言，drop &gt; truncate &gt; delete 4、应用范围。truncate 只能对 table；delete 可以是table和view 5、truncate 和 DELETE 只删除数据，而DROP则删除整个表（结构和数据）。 6、truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。 7、delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。 8、truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚 9、在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。 10、Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 11、TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 12、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 4.索引的工作原理及其种类 数据库索引：是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。 图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O($log_2n$)的复杂度内获取到相应数据。 创建索引可以大大提高系统的性能。 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点： 第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。 唯一索引 唯一索引是不允许其中任何两行具有相同索引值的索引。 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。 如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"}]},{"title":"ES6语法指南","slug":"ES6语法指南","date":"2018-12-18T08:10:28.000Z","updated":"2019-06-02T15:29:13.183Z","comments":true,"path":"2018/12/18/ES6语法指南/","link":"","permalink":"/2018/12/18/ES6语法指南/","excerpt":"","text":"ES6 语法指南后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： for(var i = 0; i &lt; 5; i++){ console.log(i); } console.log(&quot;循环外：&quot; + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： for(let i = 0; i &lt; 5; i++){ console.log(i); } console.log(&quot;循环外：&quot; + i) 结果： const const声明的变量是常量，不能被修改 3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 3.3.解构表达式 数组解构 比如有一个数组： let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值 // 然后打印 console.log(x,y,z); 结果： 对象解构 例如有个person对象： const person = { name:&quot;jack&quot;, age:21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } 我们可以这么做： // 解构表达式获取值 const {name,age,language} = person; // 打印 console.log(name); console.log(age); console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： function add(a , b) { // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b; } // 传一个参数 console.log(add(10)); 现在可以这么写： function add(a , b = 1) { return a + b; } // 传一个参数 console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： var print = function (obj) { console.log(obj); } // 简写为： var print2 = obj =&gt; console.log(obj); 多个参数： // 两个参数的情况： var sum = function (a , b) { return a + b; } // 简写为： var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 var sum3 = (a,b) =&gt; { return a + b; } 对象的函数属性简写 比如一个Person对象，里面有eat方法： let person = { name: &quot;jack&quot;, // 以前： eat: function (food) { console.log(this.name + &quot;在吃&quot; + food); }, // 箭头函数版： eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food),// 这里拿不到this // 简写版： eat3(food){ console.log(this.name + &quot;在吃&quot; + food); } } 箭头函数结合解构表达式 比如有一个函数： const person = { name:&quot;jack&quot;, age:21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } function hello(person) { console.log(&quot;hello,&quot; + person.name) } 如果用箭头函数和解构表达式 var hi = ({name}) =&gt; console.log(&quot;hello,&quot; + name); 3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 let arr = [&#39;1&#39;,&#39;20&#39;,&#39;-5&#39;,&#39;3&#39;]; console.log(arr) arr = arr.map(s =&gt; parseInt(s)); console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： const arr = [1,20,-5,3] 没有初始值： 指定初始值： 3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： const promise = new Promise(function(resolve, reject) { // ... 执行异步操作 if (/* 异步操作成功 */){ resolve(value);// 调用resolve，代表Promise将返回成功的结果 } else { reject(error);// 调用reject，代表Promise会返回失败结果 } }); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： promise.then(function(value){ // 异步执行成功后的回调 }); 如果想要处理promise异步执行失败的事件，还可以跟上catch： promise.then(function(value){ // 异步执行成功后的回调 }).catch(function(error){ // 异步执行失败后的回调 }) 示例： const p = new Promise(function (resolve, reject) { // 这里我们用定时任务模拟异步 setTimeout(() =&gt; { const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) { resolve(&quot;成功！num:&quot; + num) } else { reject(&quot;出错了！num:&quot; + num) } }, 300) }) // 调用promise p.then(function (msg) { console.log(msg); }).catch(function (msg) { console.log(msg); }) 结果： 3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： // Set构造函数可以接收一个数组或空 let set = new Set(); set.add(1);// [1] // 接收数组 let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： set.add(1);// 添加 set.clear();// 清空 set.delete(2);// 删除指定元素 set.has(2); // 判断是否存在 set.keys();// 返回所有key set.values();// 返回所有值 set.entries();// 返回键值对集合 // 因为set没有键值对，所有其keys、values、entries方法返回值一样的。 set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： // map接收一个数组，数组中的元素是键值对数组 const map = new Map([ [&#39;key1&#39;,&#39;value1&#39;], [&#39;key2&#39;,&#39;value2&#39;], ]) // 或者接收一个set const set = new Set([ [&#39;key1&#39;,&#39;value1&#39;], [&#39;key2&#39;,&#39;value2&#39;], ]) const map2 = new Map(set) // 或者其它map const map3 = new Map(map); 方法： 3.8.模块化3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： const util = { sum(a,b){ return a + b; } } 我可以使用export将这个对象导出： const util = { sum(a,b){ return a + b; } } export util; 当然，也可以简写为： export const util = { sum(a,b){ return a + b; } } export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： var name = &quot;jack&quot; var age = 21 export {name,age} 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： // 无需声明对象的名字 export default { sum(a,b){ return a + b; } } 这样，当使用者导入时，可以任意起名字 3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： // 导入util import util from &#39;hello.js&#39; // 调用util中的属性 util.sum(1,2) 要批量导入前面导出的name和age： import {name, age} from &#39;user.js&#39; console.log(name + &quot; , 今年&quot;+ age +&quot;岁了&quot;) 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"/categories/技术笔记/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"}]},{"title":"自定义百度云分享密码","slug":"自定义百度云分享密码","date":"2018-12-14T01:13:35.000Z","updated":"2019-06-02T15:30:42.594Z","comments":true,"path":"2018/12/14/自定义百度云分享密码/","link":"","permalink":"/2018/12/14/自定义百度云分享密码/","excerpt":"","text":"第一步打开百度云盘网页版 第二步找到需要分享的资源，点击分享之后看见下面内容： 别动，重点的在后面 第三步按下F12，进入开发者模式，点击 consle 进入控制台，如下图： 第四步在控制台中输入下面代码，按下回车 avascript:require([“function-widget-1:share/util/shareFriend/createLinkShare.js”]).prototype.makePrivatePassword=function(){return prompt(“请输入自定义的密码”,”1234”)} 第五步关闭开发者模式，点击“创建链接”，输入你想要自定义的密码，回车确定即可","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"/categories/技术笔记/"}],"tags":[{"name":"百度网盘","slug":"百度网盘","permalink":"/tags/百度网盘/"}]},{"title":"微信小程序笔记","slug":"微信小程序笔记","date":"2018-12-11T13:15:58.000Z","updated":"2019-06-02T15:33:04.197Z","comments":true,"path":"2018/12/11/微信小程序笔记/","link":"","permalink":"/2018/12/11/微信小程序笔记/","excerpt":"","text":"微信小程序账号与工具在线文档：https://mp.weixin.qq.com/debug/wxadoc/dev/ 小程序开发者账号注册微信公众平台：https://mp.weixin.qq.com/ 小程序开发者账号注册：https://mp.weixin.qq.com/wxopen/waregister?action=step1 微信开发者工具微信开发者工具：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html 小程序在线Demo二维码体验小程序官方源码：https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip 微信小程序文件结构主体文件结构主体部分由三个文件组成，必须放在项目的根目录，如下： 文件 必填 作用 app.js 是 小程序逻辑 app.json 是 小程序公共设置 app.wxss 否 小程序公共样式表 页面文件结构页面由四个文件组成，分别是： 文件类型 必填 作用 js 是 页面逻辑 ( 微信小程序没有window和document对象 ) wxml 是 页面结构 ( XML语法，不是HTML语法 ) wxss 否 页面样式表 ( 拓展了rpx尺寸单位，微信专属响应式像素 ) json 否 页面配置 ( 不能写注释，否则编译报错 ) WXML 结构_基础 (标签、组件)组件文档：https://mp.weixin.qq.com/debug/wxadoc/dev/component/ 常用布局标签(组件)&lt;view&gt;&lt;/view&gt; 相当于 &lt;div&gt;&lt;/div&gt; &lt;text&gt;&lt;/text&gt; 相当于 &lt;span&gt;&lt;/span&gt; &lt;image&gt;&lt;/image&gt; 相当于 &lt;img /&gt; &lt;navigator&gt;&lt;/navigator&gt; 相当于 &lt;a&gt;&lt;/a&gt; &lt;block&gt;&lt;/block&gt; 区块标签，不会渲染到页面 注意：image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高 常用表单标签(组件)&lt;button&gt;&lt;/button&gt; &lt;input type=&quot;text&quot; /&gt; &lt;checkbox /&gt; &lt;radio/&gt; 轮播图组件&lt;swiper indicator-dots=&quot;是否显示面板指示点&quot; autoplay=&quot;是否自动切换&quot; interval=&quot;自动切换时间间隔&quot; duration=&quot;滑动动画时长&quot;&gt; &lt;swiper-item&gt; &lt;image src=&quot;图片路径1&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&quot;图片路径2&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; 探索：实现无缝轮播怎么办？ WXSS 样式WXSS (WeiXin Style Sheets) 是一套样式语言。 WXSS文档： https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html WXSS 新增特性与 CSS 相比，WXSS 扩展以下2个特性： 尺寸单位 rpx ( responsive pixel 响应式像素) 样式导入 @import “样式表路径”; 尺寸单位 rpx ( responsive pixel 响应式像素) : 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 JSON 配置配置文档：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html app.json 配置项列表 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口表现 tabBar Object 否 设置底部 tab 的表现 networkTimeout Object 否 设置网络超时时间 debug Boolean 否 设置是否开启 debug 模式 如：app.json { &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;: { &quot;navigationBarTitleText&quot;: &quot;小程序标题&quot; }, &quot;tabBar&quot;: { &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; }, { &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;Tab栏&quot; }] }, &quot;networkTimeout&quot;: { &quot;request&quot;: 10000, &quot;downloadFile&quot;: 10000 }, &quot;debug&quot;: true } window 配置 用于设置小程序的状态栏、导航条、标题、窗口背景色。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉背景字体、loading 图的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数。 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px window 配置图示 window 配置注意事项 !! 注意：页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个关键词。 如：/pages/message/message.json { &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;内页标题修改&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot; } tabBar 配置如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 属性说明： 属性 类型 必填 默认值 描述 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black/white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top，设置成top是无图标 其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 tabBar 配置图示 tabBar 配置注意事项 当设置 position 为 top 时，将不会显示 icon。 tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 icon 大小限制为40kb，建议尺寸为 81px * 81px。 JS 行为(逻辑)微信小程序生命周期函数Page({ /** 页面的初始数据 */ data: { }, /** 生命周期函数--监听页面加载 */ onLoad: function (options) { console.log(options); }, /** 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** 生命周期函数--监听页面显示 */ onShow: function () { }, /** 生命周期函数--监听页面隐藏 */ onHide: function () { }, /** 生命周期函数--监听页面卸载 */ onUnload: function () { } }) 页面相关事件处理函数 /** 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { }, /** 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /** 用户点击右上角分享 */ onShareAppMessage: function () { } 注意事项 微信小程序没有BOM和DOM概念，所以不能使用window对象和document对象。 WXML 高级(指令、事件)数据绑定 &#123;&#123; &#125;&#125;&lt;!--wxml--&gt; &lt;view&gt; {{message}} &lt;/view&gt; // page.js Page({ data: { message: &#39;Hello MINA!&#39; } }) 特别注意 花括号和引号之间不能有空格。 不要直接写 checked=”false”，其计算结果是一个字符串，转成 boolean 类型后代表真值。 &lt;checkbox checked=&quot;false&quot;&gt; &lt;/checkbox&gt; 其计算结果是一个字符串，转成 boolean 类型后变成了 true &lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt; 正确写法 列表渲染 wx:for&lt;!--wxml--&gt; &lt;view wx:for=&quot;{{array}}&quot;&gt; {{item}} &lt;/view&gt; // page.js Page({ data: { array: [1, 2, 3, 4, 5] } }) wx:key主要功能：提高列表渲染时排序的效率。 wx:key 的值以两种形式提供： 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 条件渲染 wx:if wx:else wx:elif&lt;!--wxml--&gt; &lt;view wx:if=&quot;{{length >= 80}}&quot;&gt; 优秀 &lt;/view&gt; &lt;view wx:elif=&quot;{{length >= 60}}&quot;&gt; 良好 &lt;/view&gt; &lt;view wx:else&gt; 加油 &lt;/view&gt; // page.js Page({ data: { length: &#39;95&#39; } }) wx:if 与 hidden 区别 wx:if 是否渲染， hidden 是否隐藏。 一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。 因此，如果需要频繁切换的情景下，用 hidden 更好。 事件 事件对象可以获取额外信息，如 id, dataset(自定义属性集合), touches(触摸点坐标)。 事件绑定和冒泡 冒泡事件 bind事件类型 如 bindtap bindlongpress 非冒泡事件 catch事件类型 如 catchtap catchlongpress 常用事件类型 类型 触发条件 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 &lt;!--wxml--&gt; &lt;view data-index=&quot;自定义属性&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt; // page.js Page({ tapHandle: function(event) { console.log(event) } }) 事件传参注意小程序绑定事件只能写函数名称，不能通过括号方式传参。 &lt;!--wxml--&gt; &lt;view bindtap=&quot;tapHandle(520)&quot;&gt; 点我触发事件 &lt;/view&gt; 错误，事件不能触发 &lt;view data-index=&quot;520&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt; // page.js Page({ tapHandle: function(event) { console.log( event.target.dataset.index ); // 输出标签自定义属性上的index值 } }) WXS 脚本WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，功能类似&lt;script&gt;标签，主要用于在视图层定义函数(比较少用)。 注意 wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。 wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。 wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。 wxs 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 &lt;!--wxml--&gt; &lt;wxs module=&quot;foo&quot;&gt; var sum = function(a,b){ return a+b; }; // 这里可以导出一个对象，这个对象可以直接在界面上使用 module.exports.sum = sum; &lt;/wxs&gt; &lt;view&gt; {{foo.sum(1,2)}} &lt;/view&gt; 微信开发者工具常用快捷键 快捷键 说明 Shift + Alt + F 格式化代码 Ctrl + P 跳到文件 Ctrl + E 跳到最近文件 Ctrl + Shift + P 上传扫码预览 Ctrl + Shift + I 显示/隐藏调试器","categories":[{"name":"小程序","slug":"小程序","permalink":"/categories/小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"/tags/微信小程序/"}]},{"title":"Hystrix状态","slug":"Hystrix状态","date":"2018-12-07T00:12:05.000Z","updated":"2019-06-02T15:36:28.039Z","comments":true,"path":"2018/12/07/Hystrix状态/","link":"","permalink":"/2018/12/07/Hystrix状态/","excerpt":"","text":"@SpringCloudApplication 相当于：@EnableCircuitBreaker、@EnableDiscoveryClilent、@SpringBootApplication 熔断器状态的相关配置@HystrixProperty相关配置在抽象类：package com.netflix.hystrix.HystrixCommandProperties 中 熔断器开启或者关闭的条件： 1、 当满足一定的阀值的时候（默认10秒内超过20个请求次数） 2、 当失败率达到一定的时候（默认10秒内超过50%的请求失败） 3、 到达以上阀值，断路器将会开启 4、 当开启的时候，所有请求都不会进行转发 5、 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。 // 开启服务降级 @HystrixCommand( // 熔断器状态相关配置 commandProperties = { // 当请求次数达到10次时才能开启熔断 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), // 状态变换的时间，由开启 --&gt; 半开 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;20000&quot;), // 失败请求/所有请求=60% --&gt; 开启熔断器 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;) } )","categories":[{"name":"后台开发","slug":"后台开发","permalink":"/categories/后台开发/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"/tags/SpringCloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"/tags/Hystrix/"}]},{"title":"HashSet如何去重?","slug":"HashSet如何去重","date":"2018-12-06T02:37:51.000Z","updated":"2019-06-02T15:57:52.158Z","comments":true,"path":"2018/12/06/HashSet如何去重/","link":"","permalink":"/2018/12/06/HashSet如何去重/","excerpt":"","text":"&lt; !– more –&gt;HashSet存储元素的原理：往hashSet添加元素的时候，首先会调用元素的 hashCode 方法得到元素的哈希码值，然后把哈希码值经过运算算出该元素存在哈希表中的位置。有两种情况： 情况1：如果算出的位置目前还没有存在任何的元素，那么该元素可以直接添加到哈希表中。 情况2： 如果算出的位置目前已经存在其他的元素，那么还会调用元素的 equals 方法再与这个位置上的元素比较一次。如果 equals 方法返回的是true，那么该元素被视为重复元素，不允许添加。如果equals方法返回的是false，那么该元素也可以被添加。 先看个最简单的构造方法* Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() { map = new HashMap&lt;&gt;(); } 很明显，HashSet底层是Hashmap存储的。借大神的话 HashSet 就是HashMap的马甲 —–someone 再看看add方法// Dummy value to associate with an Object in the backing Map private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); /** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) { return map.put(e, PRESENT)==null; } add方法的参数： map：map是一个HashMap的实例 e：我们要存储的值，是HashMap的key PRESENT：固定值( Object PRESENT = new Object(); )，空的obj对象 Set偷偷的用了HashMap的 put 方法，然而HashMap并没有去重的功能呀，那么Set是如何做到去重的呢？ 从add方法中可以看到，E是我们要存储的值，而到了HashMap里面却变成了Key，PRESENT就是个空对象。 在HashMap中Key的HashCode是决定底层数组的下标，进一步使用 equals 进行遍历对象链表中的Key进而覆盖原来的Value。 那么对于HashSet，如果 e 已经存在（先HashCode相同定位到链表，然后equals比较定位到具体的Node），那么覆盖oldValue（value其实就是个傀儡，没啥用），Key不变；如果不存在，就添加一个新的节点（即加了一个新的Key）。 HashMap的返回值是oldValue，oldValue==null说明节点之前不存在；反之说明节点存在，虽然返回false但实际上还是对底层数据进行了改变（即旧的空对象变成了新的空对象）。 总而言之，HashSet确定相同的方式其实就是HashCode相同（才能找到同一链表），然后equals的返回值（才能比较具体节点进行覆盖）。 重点看key（敲黑板）HashMap中的put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 这里边有两个看点： HashMap中key存储是hash后的值，对于String类型的相同值的hash值是一致的（其他接触类型类似，自定义对象类型需要重写hashcode方法与equel方法）。换句话说相同的值在hashMap中的存储位置是一样的。 基于上一点来看看怎么存储重复值的。如下代码对于hashMap中已经存在的key，key不变，新value覆盖就value。对于HashSet而言新旧value都是PRESENT对象，所以set在存储的时候就不会重复。 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } 所以hashset中存储的值输出的顺序和存储的先后顺序不一致，这是因为hashset是按照值的hash顺序进行输出。","categories":[{"name":"后台开发","slug":"后台开发","permalink":"/categories/后台开发/"}],"tags":[{"name":"HashSet","slug":"HashSet","permalink":"/tags/HashSet/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}]},{"title":"IDEA常用快捷键","slug":"IDEA常用快捷键","date":"2018-12-04T07:45:52.000Z","updated":"2019-06-02T15:38:00.428Z","comments":true,"path":"2018/12/04/IDEA常用快捷键/","link":"","permalink":"/2018/12/04/IDEA常用快捷键/","excerpt":"","text":"Ctrl+Alt+D –&gt; 查看当前类的实现类 ctrl+l –&gt; 重写方法","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"/categories/技术笔记/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"}]},{"title":"IDEA创建SpringBoot开启找回RunDashboard","slug":"IDEA创建SpringBoot开启找回RunDashboard","date":"2018-12-04T06:32:05.000Z","updated":"2019-06-02T15:39:44.166Z","comments":true,"path":"2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/","link":"","permalink":"/2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/","excerpt":"","text":"Run Dashboard 面板Run Dashboard：微服务项目的开发过程中，工程会非常多，经常要启动很多个服务，才能完成一项测试。启动的多了，容易给开发者带来错乱的感觉，很不方便管理。IDEA开发工具推荐了一个很好用的功能–Run Dashboard。他是 Run 的升级版 我们可以对比一下这个是Run Dashboard的窗口 普通的Run窗口： 显然如果启动多个端口Run Dashboard窗口显得更好管理。一般有时候创建springboot项目的时候右下角可以提示你打开Run Dashboard，但是如果不提醒就需要自己配置了。 配置方法方式一新建项目或者通过 open 打开项目时，可能会弹出提示 “Multiple Spring Boot run configurations were detected. Run Dashboard allows to manage multiple run configurations at once.” 见下图： 点击 Show run configurations in Run Dashboard ，Run Dashboard 面板重新在底部区域展示了出来。 如没有此提示，请选择方式二或方式三 方式二打开Run Dashboard：View –&gt; Tool Windows –&gt; Run Dashboard 方式三如果上述的方式都没有打开 Run Dashboard 面板，可以在工程目录下找 .idea 文件夹下的 workspace.xml文件，通过修改此文件可达到打开 Run Dashboard 面板的目的 找到当前项目中 .idea 文件下的 workspace.xml 文件，双击打开 接下来找到 &lt;component name=&quot;RunDashboard&quot;&gt; 加入如下配置： &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; 这样 Run Dashboard 自动就弹出来了 最终配置如下： &lt;component name=&quot;RunDashboard&quot;&gt; &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name=&quot;ruleStates&quot;&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt; &lt;/component&gt;","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"/categories/技术笔记/"}],"tags":[{"name":"工具","slug":"工具","permalink":"/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"}]},{"title":"Vue基础-基本语法","slug":"Vue基础-基本语法","date":"2018-11-30T09:37:11.000Z","updated":"2019-06-02T15:41:26.528Z","comments":true,"path":"2018/11/30/Vue基础-基本语法/","link":"","permalink":"/2018/11/30/Vue基础-基本语法/","excerpt":"","text":"1. 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 2. 安装 Vue2.1 下载安装下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件 2.2 使用CDN或者也可以直接使用公共的CDN服务： &lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 或者： &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 3. 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template 4. Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别（了解内容） MVC 主要是后端的分层开发思想；把 一个完整的后端项目，分成了三个部分： Model：（数据层）主要负责 数据库的操作； View：（视图层）所有前端页面，统称为 View 层 Controller：（业务逻辑层）主要处理对应的业务逻辑；（对于后台来说，这是开发的重点） MVVM是前端页面的分层开发思想，主要关注于 视图层 分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View, ViewModel Model 是 页面中，需要用到的数据 View 是页面中的HTML结构； ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念； 为什么有了MVC还要有MVVM 因为 MVC是后端的开发思想，并没有明确定义前端的页面该如何开发； MVVM 是前端的页面的开发思想，把每个页面，分成了三个部分，同时 VM 作为 MVVM 的核心，提供了双向数据绑定的概念，前端程序员，不需要手动渲染页面了，而且，页面数据发送变化，也不需要程序员手动把 数据的变化同步到Model中；这所有的操作，都是 VM 自动完成的！ 有了 MVVM 的思想以后，前端只关心 页面交互逻辑，不关心页面如何渲染； 4.2 Vue.js 基本代码 和 MVVM 之间的对应关系 注意：Vue中，不推荐程序员手动操作DOM元素；所以，在Vue项目中，没有极其变态的需求，一般不要引入 Jquery； Vue代码解析执行的步骤： 当 VM 实例对象，被 创建完成之后，会立即解析 el 指定区域中的所有代码； 当 VM 在解析 el 区域中所有代码的时候，会把 data 中的数据，按需，填充到 页面指定的区域； 注意：每当 vm 实例对象，监听到 data 中数据发生了变化，就会立即 重新解析 执行 el 区域内，所有的代码； mvvm是前端思想，mvc是后台思想 5. Vue调试工具vue-devtools的安装和使用Vue.js devtools - 翻墙安装方式 - 推荐 6. 快速入门7. Vue实例7.1 创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： var vm = new Vue({ // 选项 }) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods 等等 接下来我们一 一介绍。 7.2 模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div var vm = new Vue({ el:&quot;#app&quot; }) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 7.3 数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt; &lt;/div&gt; js: var vm = new Vue({ el:&quot;#app&quot;, data:{ name:&quot;刘德华&quot; } }) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 7.4 方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue的作用范围内使用。 html: &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; js写法一： &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ num:0 }, methods:{ add:function(){ this.num++; } } }); &lt;/script&gt; js写法二： &lt;div id=&quot;app&quot;&gt; {{num}} &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ num:0 }, methods:{ add(){ this.num++; } } }); &lt;/script&gt; 7.5 生命周期7.5.1 生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 7.5.2 钩子函数钩子函数：生命周期函数的别名； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板【当 vm 实例的 data 和 methods 初始化完毕后，vm 实例会自动执行 created 函数】 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示【如果要通过某些插件操作页面上的DOM元素节点，最早要在 mounted 中进行】 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 例1：created代表在vue实例创建后； 我们可以在Vue中定义一个created函数，代表这个时期的构造函数： html: &lt;div id=&quot;app&quot;&gt; {{hello}} &lt;/div&gt; js: &lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ hello:&#39;&#39; }, created(){ this.hello = &#39;czdx,一统江湖，千秋万代&#39; } }); &lt;/script&gt; 结果： 例2： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;vuejs生命周期&lt;/title&gt; &lt;script src=&quot;vuejs-2.5.17.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{message}} &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { message: &#39;hello world&#39; }, beforeCreate: function() { showData(&#39;创建vue实例前&#39;, this); }, created: function() { showData(&#39;创建vue实例后&#39;, this); }, beforeMount: function() { showData(&#39;挂载到dom前&#39;, this); }, mounted: function() { showData(&#39;挂载到dom后&#39;, this); }, beforeUpdate: function() { showData(&#39;数据变化更新前&#39;, this); }, updated: function() { showData(&#39;数据变化更新后&#39;, this); }, beforeDestroy: function() { showData(&#39;vue实例销毁前&#39;, this); }, destroyed: function() { showData(&#39;vue实例销毁后&#39;, this); } }); function realDom() { console.log(&#39;真实dom结构：&#39; + document.getElementById(&#39;app&#39;).innerHTML); } function showData(process, obj) { console.log(process); console.log(&#39;data 数据：&#39; + obj.message) console.log(&#39;挂载的对象：&#39;) console.log(obj.$el) realDom(); console.log(&#39;------------------&#39;) console.log(&#39;------------------&#39;) } vm.message = &quot;good...&quot;; vm.$destroy(); &lt;/script&gt; &lt;/html&gt; 7.5.3 this我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this var vm = new Vue({ el:&quot;#app&quot;, data:{ hello: &#39;&#39; // hello初始化为空 }, created(){ this.hello = &quot;czdx,一统江湖，千秋万代&quot;; console.log(this); } }) 控制台的输出： 8. 指令指令 (Directives)： 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 8.1 插值表达式8.1.1 大括号 u007B;u007B; 格式： u007B;u007B;表达式 说明：","categories":[{"name":"前端开发","slug":"前端开发","permalink":"/categories/前端开发/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}]},{"title":"Java线程状态","slug":"Java线程状态","date":"2018-11-30T09:23:50.000Z","updated":"2019-06-02T15:49:27.328Z","comments":true,"path":"2018/11/30/Java线程状态/","link":"","permalink":"/2018/11/30/Java线程状态/","excerpt":"","text":"Java线程状态网上流传了很久的线程具备5种状态，这样是不贴切JDK中描述的，JDK中描述线程状态只有6种，而网络流传的5种状态就是进程的五态模型。那张广为流传的来自网络的图如下： 很明显这是操作系统中进程的5种状态，在很多操作系统书中也由介绍分别为new，ready，running，waiting，terminated。不幸的是，有很多的书上常常把这些进程状态，线程状态与Java线程状态混在一起谈。 进程与线程的区分总图： 很多人觉得在JVM线程中应该有，Running运行状态。对JAVA而言，Runnable包含了就绪与运行，那为什么JAVA不区分开呢？这跟CPU分配的时间片有关，而且JAVA进行的是抢占式轮转调度，由于我们的JVM线程是服务于监控，线程又是切换的如此之快，那么区分ready与running又没有多大意义了。再者，我们都知道现在使用的很多JVM底层都将线程映射到操作系统上了，JVM本身没有做什么调度，因为虚拟机看到的都是底层的映射与封装，故而将ready与running映射来也没有太大意义，不如统一为Runnable 总之还是有些乱的，我们不妨就拿Windows系统为例，用的就是“进程”和“线程”这两种较为标准的叫法，这时一个进程下至少有一个线程，线程是CPU调度的基本单位，进程不参与CPU调度，CPU根本不知道进程的存在。 为了避免混乱，下面说的线程状态，只是站在JVM层面上 我们先来看下，这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 初始(NEW)：新创建了一个线程对象，但还没有调用 start() 方法。 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running） 阻塞(BLOCKED)：表示线程阻塞于锁 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断） 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回 终止(TERMINATED)：表示该线程已经执行完毕 1. NEW(新建)状态 概念：线程对象创建了，但是还没有启动之前，就是新建状态 实现 Runnable接口 或继承 Thread 可以得到一个线程类，new一个实例出来，线程就进入了初始状态。 这里强调两点： 线程对象创建之后，还未开启( 调用start()方法 )时候，就处于NEW的状态 开启线程，指的是调用start方法，并不是run方法，run方法仅仅作为一个普通方法存在 线程对象调用 run() 方法不开启线程，仅是对象调用方法。线程对象调用 start() 方法开启线程，并让jvm调用 run() 方法在开启的线程中执行 当我们执行 new Thread(target) 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 Runnable (可运行)状态。 在我们研究线程状态时，采用Thread中的getState()方法进行研究 通过代码演示： public class MyThread extends Thread{ @Override public void run() { // 线程执行的代码 } } /** * 研究新建线程状态 * 新建状态：至今还未启动的线程处于这一状态 */ public class ThreadStateTest1 { public static void main(String[] args) { // 创建线程对象 MyThread myThread = new MyThread(); // 线程默认名：Thread-0 Thread-1... System.out.println(myThread.getName()); System.out.println(&quot;线程创建之后处于：&quot; + myThread.getState()); myThread.run(); System.out.println(&quot;线程run之后处于：&quot; + myThread.getState()); myThread.start(); System.out.println(&quot;线程start之后处于：&quot; + myThread.getState()); } } // 输出： // 线程创建之后处于：NEW // 线程run之后处于：NEW // 线程start之后处于：RUNNABLE 当我们执行 new Thread(target) 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 Runnable (可运行)状态。所以说 当业务需要频繁创建线城市，最好使用线程池，提高效率减轻JVM的压力。当然如果大量线程进行频繁上下文切换，此时多线程的效率会大打折扣。 2. RUNNABLE(可运行)状态 可运行状态：一个在JVM中执行的线程处于这个状态中，等待JVM调度，德能在执行，也可能在等待 注：这里的等待指的是等待调度，等待的是系统资源，如IO、CPU时间片，与 sleep、lock 的等待有着本质差别。 接下来使用代码演示一个最简单的可运行状态： public class MyThread extends Thread { @Override public void run() { System.out.println(&quot;线程开始执行&quot;); System.out.println(&quot;线程开始执行具体的任务&quot;); // 假设这个任务使用5秒钟 long beiginTime = System.currentTimeMillis(); while (System.currentTimeMillis()-beiginTime &lt; 5000){ // 假设做了5秒钟的任务 } System.out.println(&quot;线程执行完毕&quot;); } } /** * 可运行状态 * 当线程有资格运行，调用了start方法，线程首先进入可运行状态 * 这种可运行状态不一定被线程调度运行 * 简单来说，调用start方法之后，该线程处于可运行状态，但未运行 * 此时存放在&quot;可运行池&quot;中 * 线程在运行的过程中，自然该线程也是处于可运行状态 * * JDK中处于可运行状态的线程，有两种，一种是正在JVM中运行， * 另一种是可能正在等待操作系统其它资源，比如处理器 */ public class Demo { public static void main(String[] args) { // 创建线程对象 MyThread myThread = new MyThread(); System.out.println(&quot;创建完成之后：&quot; + myThread.getState()); // 开启线程 myThread.start(); System.out.println(&quot;开启线程之后：&quot; + myThread.getState()); } } 3. BLOCHED(阻塞)状态我们还是使用代码来解析一下锁阻塞状态： public class ThreadA extends Thread { private Object obj; public ThreadA(String name,Object obj){ super(name); this.obj = obj; } @Override public void run() { // 同步代码块 synchronized (obj){ System.out.println(&quot;线程A开始执行&quot;); System.out.println(&quot;线程A真正开始执行代码了&quot;); long beginTime = System.currentTimeMillis(); // 模拟5秒钟的任务 while(System.currentTimeMillis()-beginTime &lt; 5000){ } System.out.println(&quot;线程A执行完毕&quot;); } } } public class ThreadB extends Thread{ private Object obj; public ThreadB(String name,Object obj){ super(name); this.obj = obj; } @Override public void run() { // 同步代码块 synchronized (obj){ System.out.println(&quot;线程B开始执行&quot;); System.out.println(&quot;线程B真正开始执行代码了&quot;); long beginTime = System.currentTimeMillis(); // 模拟5秒钟的任务 while(System.currentTimeMillis()-beginTime &lt; 5000){ } System.out.println(&quot;线程B执行完毕&quot;); } } } /** * 线程状态之阻塞状态BLOCKED * JDK：锁阻塞并且正在等待监视器锁的某一线程状态 * 处于受阻状态的某一线程正在等待监视器锁，以便进入一个同步代码块/同步方 * 还有就是 调用Object.wart方法之后，再次进入同步中时 * */ public class BlockedDemo { public static void main(String[] args) throws InterruptedException { // 创建一个锁对象 Object obj = new Object(); // 创建线程A、B ThreadA a = new ThreadA(&quot;线程A&quot;, obj); ThreadB b = new ThreadB(&quot;线程B&quot;, obj); // 开启线程 a.start(); b.start(); // Thread.sleep(3000); System.out.println(&quot;线程A的状态是：&quot; + a.getState()); System.out.println(&quot;线程B的状态是：&quot; + b.getState()); // Thread.sleep(3000); System.out.println(&quot;线程A的状态是：&quot; + a.getState()); System.out.println(&quot;线程B的状态是：&quot; + b.getState()); } } 在这里我们只是对之前分析的情况一进行了阐释 4. Timed Waiting(计时等待)状态 带指定的等待时间的等待线程所处的状态。一个线程处于这一状态是因为用一个指定的正的等待时间（为参数）调用了一下方法中的其一： Thread.sleep 带时限（timeout）的 Object.wait 带时限（timeout）的 Thread.join LockSupport.parkNanos LockSupport.parkUntil Timed Waiting 在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 注：sleep的使用时区别去其他方法的。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting（计时等待），那么我们通过一个案例加深对该状态的一个理解： 实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串 代码： /** * 限时等待 */ public class MyThread extends Thread { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;mt的线程状态： &quot; + myThread.getState()); } } // 实现一个计算器，0-99计数，在每个数字之间暂停1秒，每个10个数字输出一个字符串 @Override public void run() { for (int i = 0; i &lt; 99; i++) { if (i%10 == 0){ System.out.println(&quot;oewewowllskd &quot; + i); } System.out.println(i); try { Thread.sleep(1000); System.out.println(&quot; 休息了1秒&quot;); } catch (Exception e) { e.printStackTrace(); } } } } 通过案例可以发西咸，sleep方法的使用还是很简单的。我们需要记住下面几点： 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 为了让其他线程有机会执行，可以将Thread.sleep() 的调用放线程run()之内，这样才能保证该线程执行过程中会睡眠 sleep 与锁无关，线程睡眠到期自动苏醒，并返回到 Runnable（可运行）状态 小提示：sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep() 方法不能保证该线程睡眠到期后就开始立刻执行 5. WAITING(无限等待)状态Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 一个线程进入 WAITING 状态是因为调用了以下方法： 不带时限的 Object.wait 方法 不带时限的 Thread.join 方法 LockSupport.park 然后会等其他线程执行一个特别的动作，比如： 一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 或 Object.notifyAll() 一个调用了 Thread.join 方法的线程会等待指定的线程结束 代码演示： /** * 无限等待 * Object中的wait方法完成 * 使用当前线程 进入无限等待状态，直到其他线程有唤醒 notify 或 notifyAll 才能被唤醒 * * 线程间通信 两个线程执行不同的操作 关联的 * 两个线程 使用同样的锁 只能使用锁对象调用wait方法或者notify方法 */ public class WaitingTest { private static Object obj = new Object(); public static void main(String[] args) throws InterruptedException { // 使用匿名函数创建线程 Thread t1 = new Thread() { @Override public void run() { synchronized (obj){ System.out.println(&quot;获取到锁，调用wait方法，当前线程进入无线等待状态。。。等待着别的线程来唤醒&quot;); try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;唤醒了这个线程，就不再是线程等待了，线程执行完毕&quot;); } } }; // 开启线程t1 t1.start(); // 使用匿名内部内方式创建一个新的线程，用来唤醒t1线程 new Thread(){ @Override public void run() { // 获取到锁 synchronized (obj){ try { // 3秒钟后执行唤醒操作 Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;获取到锁 执行 唤醒操作&quot;); // 唤醒操作 obj.notify(); } } }.start(); // 4秒后查看线程t1状态 Thread.sleep(4000); System.out.println(&quot;查看t1的线程状态&quot; + t1.getState()); } } 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 方法或 Object.notifyAll() 方法 其实 waiting 状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司了你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作一完成某些任务。 6. TEMINATED(终止)状态线程因如下两个原因之一将被终止： run() 方法正常退出而自然死亡 一个没有捕获的异常终止了 run() 方法而意外死亡 线程的方法1. wait(), notify(), notifyAll()等方法介绍在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait() 的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify() 是唤醒单个线程，而 notifyAll() 是唤醒所有的线程。 Object类中关于等待/唤醒的API详细信息如下：notify() – 唤醒在此对象监视器上等待的单个线程。notifyAll() – 唤醒在此对象监视器上等待的所有线程。wait() – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout, int nanos) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。","categories":[{"name":"后台开发","slug":"后台开发","permalink":"/categories/后台开发/"}],"tags":[{"name":"Java线程","slug":"Java线程","permalink":"/tags/Java线程/"}]},{"title":"Flex布局","slug":"Flex布局","date":"2018-11-30T09:12:44.000Z","updated":"2019-06-02T15:51:30.755Z","comments":true,"path":"2018/11/30/Flex布局/","link":"","permalink":"/2018/11/30/Flex布局/","excerpt":"","text":"Flex 布局教程：语法篇作者： 阮一峰 日期： 2015年7月10日 网页布局（layout）是 CSS 的一个重点应用 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的 Flex 写法。网友JailBreak 为本文的所有示例制作了 Demo，也可以参考。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 .box{ display: flex; } 行内元素也可以使用 Flex 布局。 .box{ display: inline-flex; } Webkit 内核的浏览器，必须加上-webkit前缀。 .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性 (紫色大盒子) *以下6个属性设置在容器上。 flex-direction √ flex-wrap √ flex-flow justify-content √ align-items √ align-content 3.1 flex-direction属性 **flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性 **默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } 3.4 justify-content属性 **justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性 **align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性 (橙色小盒子) *以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性 **flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"/categories/前端开发/"}],"tags":[{"name":"Flex","slug":"Flex","permalink":"/tags/Flex/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2018-11-30T08:19:55.000Z","updated":"2019-06-02T15:42:57.815Z","comments":true,"path":"2018/11/30/Linux常用命令/","link":"","permalink":"/2018/11/30/Linux常用命令/","excerpt":"","text":"1. Linux介绍（了解）1.1、Linux和Windows的区别Linux是一款操作系统。正规开发服务器项目部署都是放在Linux操作系统上。 Windows一款操作系统，民用操作系统。娱乐、影音、上网。 1.2、Linux历史及使用场景Linux诞生90年代，仿制Unix操作系统。 Linux是免费的，开源的 Unix是收费的，封闭的。 Linux使用场景：服务器操作系统，移动设备（安卓手机，平板电脑），路由器（WIFI），交换机，智能家居，Java程序开发 1.3、Linux的版本Linux的版本分为两种：内核版本(https://www.kernel.org/)和发行版本 Linux内核版本：Linux内核运维开发小组。 源码在一定程度上不是开源的。 Linux发行版本：由各大互联网/软件公司定制。 外围的样式功能的源码完全开源 一个内核版本是有多种多样的发行版本 Ubuntu：以强大的桌面应用为主，吸收不少Windows用户。 因为桌面应用会在一定程度上大量占用系统资源，开发。 服务器部署上，不会优先选择Ubuntu CentOS：对服务器性能进行了一定程度的优化，性能比较高，比较稳定。 服务器操作系统的优选CentOS 2、Linux安装【重点】2.1、虚拟机、Linux安装2.2、CentOS安装jdk、tomcat、mysql2.3、Linux目录介绍 /：Linux系统根目录 /etc：(etcetera) 系统配置文件存放的目录，不建议在此目录下存放可执行文件。 重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。 注：/etc/X11存放与 x windows 有关的设置（防火墙文件，网络设置文件，JDK环境配置文件，mysql） home:存放所有普通用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /root： 系统管理员root(超级用户)的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下 每一个用户都有家目录，超级管理员root家目录 /root Linux命令行模式中相当于Windows的桌面 /usr：(unix shared resources)：应用程序存放目录，比较重要的目录/usr/local本地系统管理员软件安装目录（安装系统级的应用） /usr/bin 存放应用程序 /usr/share 存放共享数据 /usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local:存放软件升级包 /usr/share/doc: 系统说明文件存放目录 /usr/share/man: 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间。​ Jdk,tomcat,mysql,redis,nginx /opt：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里 以上建议并不是强制性约束 2.4 网络三种连接方式2.4.1 桥接模式桥接模式(Bridged)：虚拟机是一台独立的电脑，直接连接到实际的网络上，与宿主机没有任何联系。 2.4.2 仅主机模式 这种方式下，虚拟机的网卡连接到宿主的 VMnet1 上，但系统并不为虚拟机提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。 仅主机模式(host-only)：虚拟机可以访问宿主机，宿主机无法访问虚拟机，虚拟机无法上网 2.4.3 NAT 模式 这种方式下，虚拟机的网卡连接到宿主的 VMnet8 上。此时系统的 VMWare NAT Service 服务就充当了路由器的作用，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。VMWare DHCP Service 负责为虚拟机提供 DHCP 服务。 NAT模式： 虚拟机可以访问宿主机，宿主机可以访问虚拟机 此时宿主机相当于路由器，虚拟机可以通过宿主机上网 宿主机可以配置254个虚拟机 3、常用命令【重点】Linux命令中参数，一般都是无序的。特殊情况下除外 注意：Linux中的命令严格区分大小写的！ 3.1、磁盘管理命令ls 列出目录内容 ls（list）功能：列出目录内容 格式： ls [参数] [文件或目录] # 参数 -a或--all 查询所有文件和文件夹，包含隐藏。注意隐藏文件、特殊目录、. 和 .. -l 查询详细列表 ls -l--&gt;简写：ll -h 友好展示信息 ll -h (d目录，-普通文件, l链接) -t 用文件和目录的更改时间排序。 -r 反向排序 --help 在线帮助 常用： ls -l --&gt; 此命令非常常用，提供简化版命令 ll ls -al ll /home/ --&gt; 显示指定目录下的内容 eg: 需求：展示某个目录下的内容 ls 目录名 所在位置：/root 想要查看:/etc目录下的内容 命令：ll -h /etc cd 切换目录 cd(change directory) 功能：切换目录 语法： # 格式 cd [目录] # 常用 cd /目录名 ，任意目录切换到指定目录中 /目录名--&gt;Linux的绝对路径 windows绝对路径--&gt;c:/xxxx/xxx.jpg?raw=true cd ../ ，向上一层目录 cd ~ ，切换到当前用户 家目录。root用户家目录 /root cd / ，切换到Linux的 根目录 cd - ，切换到上一次访问的目录。 只能两个目录相互切换 cd .. ，上一级目录 cd ，缺省当前用户目录 Linux绝对： eg：cd /etc/x1 先切换到 /目录，然后在 /目录 中找到子目录 etc，在 etc 中找 子目录x1 特点：在任意目录都可以随意切换 Linux相对： eg：cd x1/x2 在当前目录中寻找子目录x1, 在x1中寻找子目录x2 特点：必须确定 当前目录 下有子目录x1 pwd 显示当前的所在目录 pwd(print working directory) 功能：显示工作目录(当前的所在目录)。返回绝对路径 mkdir 创建目录 mkdir（make directoriy）功能： 创建目录 语法： # 格式 mkdir -p 文件夹名称 # 参数 -p 父目录不存在情况下先生成父目录 （parents） -v 显示命令执行过程中的详细信息 注意： 使用mkdir创建带后缀的文件时，创建的是目录，不是文件（创建文件使用touch命令） eg: # 1 需要在/root/t1目录下创建一个t2目录 位置：/root 命令：相对路径：mkdir t1/t2 绝对：mkdir /root/t1/t2 # 2 需要在/root/t3目录下创建一个t4目录 位置：/root 条件：t3和t4都不存在 命令：mkdir -p t3/t4 rmdir 删除空目录 rmdir(remove directory) 功能：删除空目录 指令快捷键 历史输入使用上、下箭头可以找出上一条指令和下一条指令 Tab代码补全使用tab键可以快速输入指令比如：我要输入shutdown指令，这时，我们可以只输入shut然后按下tab键，即可自动把shutdown补全 注意：使用两下Tab补全时，如果匹配的结果有多个，这时候将会把所有匹配的结果展示出来。当结果很多时将会出现以下结果： 按y之后会列出所有匹配的结果，但因为129个比较多，而在电脑中无法一次全显示出来，所以先显示一部分：（More代表还有更多，这时按回车就可以向下滚动，按下Ctrl+C将会退出） 3.2、文件浏览(管理)命令日志文件,XML,properties文件 cat 快捷查看当前文件的内容 cat（catenate）功能：快捷查看当前文件的内容 cat适合查看少量信息的文件 语法： # 格式 cat 文件名 more 分页显示文件内容 more功能：分页显示文件内容，还支持直接跳转行等功能 语法： more 文件名 操作： Enter 向下n行，需要定义。默认为1行 空格键 向下滚动一屏 或 Ctrl+F B 返回上一屏 或 Ctrl+B q 退出more less 分页显示文件内容 less功能：分页显示文件内容，操作更详细 语法： # 格式 less -mN 文件名 # 参数 -m 显示类似more命令的百分比 -N 显示每行的行号 操作： Enter 向下n行，需要定义。默认为1行 空格键 向下滚动一屏 或 Ctrl+F B 返回上一屏 或 Ctrl+B q 退出more d 前进半页 u 后退半页 回车键 前进一行 或 方向键向下 y 后退一行 或 方向键向上 v 进入vim编辑器 /字符串 向下搜索 ?字符串 向上搜索 左右方向键 相当于水平滚动条 特点： 适用于大量数据的查看 tail 指定文件末尾内容 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件 语法： # 格式 tail[必要参数][选择参数][文件] # 参数 -n&lt;行数&gt; 显示行数 -f 循环读取 eg： &amp; 表示后台运行，否则占用终端 ctrl + c 退出 3.3、文件操作命令文件 隐藏文件 Linux中以 点. 开头的是隐藏文件，使用ls命令是查看不到的，需使用ls -a 目录与文件的区别 当我们使用ls命令列出目录中的所有子目录和文件时，如何区分哪些是文件哪些是目录？可以通过详细信息中第一列的信息来区分：以 d 开头的是目录，以 - 开头的是文件 touch创建文件 功能：创建文件 语法： touch 绝对路径/相对路径 cp 复制 cp（copy）：复制文件或者复制目录 复制文件： 语法： cp 需要复制的文件 复制的位置 注意：cp可以进行重命名操作： cp demo1.java t1/ddd.java 当将一个 文件位置 以不同名字复制到当前文件时，意思是复制并重命名；即 将demo1.java复制到t1目录中，并重命名成ddd.java eg： 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中 位置：/root 命令：cp Demo1.java t1 cp /root/Demo1.java /root/t1 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中，改名为ddd.java 位置：/root 命令：cp Demo1.java t1/ddd.java 复制目录： 语法： # 格式 cp -r 需要复制的目录 复制的位置 # 参数 -r或--recursive 递归处理，将指定目录下的文件与子目录一并处理 复制目录必须使用-r eg： 需求：把/root/t5目录 复制到 /root/t1目录中 位置：/root 命令：cp -r t5 t1 cp -r /root/t5 /root/t1 cp ./abc ./xxx #无法复制目录 cp -r ./abc ./xxx #复制目录必须使用 -r参数 mv 移动、更名 mv(move) 功能： 移动 或 更名 现有的文件或目录 移动文件： 语法： # 格式 mv -f 需要移动的文件 移动的位置 # 参数 -f或--force 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录，不进行询问 eg： 需求：把/root/t5 目录 移动到 /root/t3目录中 位置：/root 命令：mv t5 t3 需求：把/root/t5 目录 移动到 /root/t3目录中 不询问，直接覆盖 位置：/root 已知：/root/t3目录中 已经有一个t5目录了 命令：mv -f t5 t3 文件更名： 格式： mv 需要移动的文件 新名字 ## 必须是在同一目录中进行此操作 eg： 文件/目录更名操作： 需求：把/root/Demo1.java 改名为 hehe.java 位置：/root 命令：mv Demo1.java hehe.java rm 删除 rm(remove) 功能：删除文件或目录 删除文件： 语法： rm 文件名 删除目录： 语法： # 格式 rm -rf 目录名 # 参数 -f或--force 强制删除文件或目录，不进行询问 -r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。删除目录必须使用-r 注意： rm -rf * 删除 当前目录 下所有内容 rm –rf /* 删除Linux系统 根目录 下所有内容 eg： 需求：删除/root/t5 目录， 位置：/root 已知：t5目录下有子目录或者文件 命令：rm -rf t5 find 查找 find功能：查找文件或目录 语法： find 目录名 -name &#39;需要查找的字符串&#39; -name 指定字符串作为寻找文件或目录的范本样式 * 表示0~多个任意字符 eg：find t1 -name &#39;*.txt&#39; eg: 需求：查找/root目录下 所有以ins开头的文件或者目录 位置：/root 命令：find /root -name &#39;ins*&#39; 3.4、文档编辑命令Windows是有记事本Linux也有类似的记事本功能 VIM编辑器 VI 编辑 操作： 输入 vi 文件名 进入 “命令(一般)模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 vim 命令 操作： 输入 vim 文件名 或 vi 文件名 进入 “一般模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 一般(命令)模式: 可以浏览文件内容，可以进行文本快捷操作（单行复制，多行复制，单行删除，多行删除…） 按 i/a/o 可以切换到 插入模式按 : 可以切换到 底行模式 插入模式： 可以编辑文件内容。 按 ESC 可以切回 一般模式 底行模式： 可以进行强制退出不保存操作 q! 可以进行保存并退出操作 wq 3.5、grep 、 管道|、重定向输出&gt;&gt;grep 正则表达式 grep：正则表达式，进行字符串搜索工作 用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活 语法： # 格式 grep -i 需要搜索的字符串 搜索的文件 # 参数 -i 忽略大小写查找数据 符合规则，就会返回符合规则的行 管道 管道命令： 可以连接多个Linux命令，其作用是将一个命令的输出用在另一个命令的输入 格式： 命令1 | 命令2 | 命令3…… eg： 需求：查询当前目录中，所有带ins关键字的行数据 位置：/root 思考：查询当前目录内容 ll 查询字符串，返回字符串所在行 grep 命令：ll | grep ins 需求：分页显示ls的help信息 命令：ls --help | more 重定向输出&gt; &gt;&gt; 重定向输出 &gt; 定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空 &gt;&gt; 将输出内容追加到目标文件中。如果文件不存在，就创建文件；如果文件存在，则将新的内容追加到那个文件的末尾，该文件中的原有内容不受影响 格式： 注意： 使用： 将一个文件夹的内容保存到文本文件中去，也就是将ls命令打印出来的内容都写到文本中去可以这样： # a.txt文件中就是ls命令打印出来的内容了 ls -al &gt;&gt; a.txt 3.6、压缩、解压命令【重要】 Linux常见压缩包： .tar 打包，大小不会进行压缩​ .tar.gz 打包并压缩文件大小 压缩：(参数顺序不变) # 格式 tar -zcvf 压缩包名字.tar.gz 需要压缩的内容 # 参数 -z 是否需要用 gzip 压缩 -c 建立一个压缩文件的参数指令（create）--压缩 -v 压缩的过程中显示文件（verbose） -f 使用档案名称，在 f 之后要立即接档名（file） eg： 例如：tar -zcvf hehe.tar.gz * 将当前目录下所有内容进行打包压缩，文件名hehe.tar.gz 解压：(参数顺序不变) # 解压到当前目录 tar -zxvf 需要解压的压缩包名称 解压到当前目录 # 解压到指定目录 tar -zxvf 需要解压的压缩包名称 -C 指定压缩路径 解压到指定目录中 # 参数 -z 是否需要用 gzip 压缩 -x 解开一个压缩文件的参数指令（extract）--解压 -v 压缩的过程中显示文件（verbose） -f 使用档名，在 f 之后要立即接档名（file） eg： 需求：需要把/root/t5/hehe.tar.gz 压缩包 解压到 指定目录中。指定目录/root/t5/t5 位置：/root/t5 命令：tar -zxvf hehe.tar.gz -C /root/t5/t5 tar -zxvf hehe.tar.gz -C t5 3.7、系统命令系统服务服务，是指常期运行，常驻内存中的进程，比如，apache、mysql、ssh等 服务与端口每个服务软件一般在运行时都会对应一个端口。查看监听的端口： ss –lntp 防火墙及防火墙设置CentOS 7.0默认使用的是firewall作为防火墙，使用iptables必须重新设置一下 查看防火墙状态： firewall-cmd --state # running 防火墙处于开启状态 # not running 防火墙处于关闭状态 直接关闭防火墙停止firewall： systemctl stop firewalld.service 禁止firewall开机启动： systemctl disable firewalld.service 查看系统进程：ps -ef需求：查看进程中 和 vim相关的进程 命令：ps -ef|grep -i vim -e 此参数的效果和指定&quot;A&quot;参数相同，显示所有程序 -f 显示UID,PPIP,C与STIME栏位 强制杀死某个进程：kill -9 pid号需求：查看进程 和 vim相关的进程有哪些，并将vim进程杀死 命令：ps -ef|grep -i vim Kill -9 pid号 -l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称 kill 9 表示强制终止 查看网络配置：ifconfig 显示网络设备 测试和目标的连通性：ping 主机名或ip地址 测试与目标主机的连通性 会持续不断一直测试，直到ctrl+c Linux centos重启命令：reboot Linux centos关机命令：halt 3.8、其他命令（了解）chmod 文件权限 hmod(change mode) 功能：变更文件或目录的权限 语法： # 格式 chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;] # 参数 -R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理 权限范围的表示法如下： u：User，即文件或目录的拥有者 g：Group，即文件或目录的所属群组 o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围 a：All，即全部的用户，包含拥有者，所属群组以及其他用户 符号： ‘+’添加权限 ‘-‘取消权限 有关权限代号的部分，列表于下： r：读取权限，数字代号为”4” w：写入权限，数字代号为”2” x：执行或切换权限，数字代号为”1” -：不具任何权限，数字代号为”0” eg: mkdir xxx ll | grep xxx chmod u-rwx xxx #取消xxx目录，用户“读写执行”权限 chmod g-rwx xxx #取消xxx目录，组“读写执行”权限 chmod 777 xxx #给xxx目录添加所有权限 linux 权限格式：&lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt; 网络配置 VIM命令配置 网卡配置 cat /etc/sysconfig/network-scripts/ifcfg-eth0 概要信息如下: DEVICE=eth0 #网卡名称 TYPE=Ethernet #网卡类型 ONBOOT=yes #是否开机启动网卡 BOOTPROTO=static #静态获取IP，其他取值：dhcp （如果设置dhcp下面红色不需要） IPADDR=192.168.44.100 #ip地址 GATEWAY=192.168.44.2 #网关 NETMASK=255.255.255.0 #子网掩码 setup设置 选择“网络配置” 选择“设备配置” 选择“第一块网卡” 设置IP地址等详细信息 命令总结 和 帮助 内部命令：属于Shell解析器的一部分 （系统启动直接加载到内存的） cd 切换目录（change directory） pwd 显示当前工作目录（print working directory） help 帮助 外部命令：独立于Shell解析器之外的文件程序（独立的可执行文件） ls 显示文件和目录列表（list） mkdir 创建目录（make directoriy） cp 复制文件或目录（copy） 查看帮助文档 内部命令：help + 命令（eg：help cd） 外部命令：man + 命令（eg：man ls） 不用特意记忆命令分类，开发中，如果需要查看命令参数，先使用man，如果没有结果，再使用help","categories":[{"name":"Linux","slug":"Linux","permalink":"/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"豆瓣Top250资源合集","slug":"豆瓣Top250资源合集","date":"2018-11-28T17:45:30.000Z","updated":"2019-06-02T15:55:40.528Z","comments":true,"path":"2018/11/29/豆瓣Top250资源合集/","link":"","permalink":"/2018/11/29/豆瓣Top250资源合集/","excerpt":"","text":"点击影片”名称”即可获取资源链接 # 更新至Top1-Top100，敬请期待… 排名名称年份评分Top1肖申克的救赎19949.6Top2霸王别姬19939.6Top3这个杀手不太冷19949.4Top4阿甘正传19949.4Top5美丽人生19979.5Top6泰坦尼克号19979.3Top7千与千寻20019.3Top8辛德勒的名单19939.5Top9盗梦空间20109.3Top10机器人总动员20089.3Top11忠犬八公的故事20099.3Top12三傻大闹宝莱坞20099.2Top13海上钢琴师19989.2Top14放牛班的春天20049.2Top15大话西游之大圣娶亲19959.2Top16楚门的世界19989.2Top17教父19729.2Top18星际穿越20149.2Top19龙猫19889.1Top20熔炉20119.3Top21无间道20029.1Top22当幸福来敲门20069.0Top23触不可及20119.2Top24怦然心动20109.0Top25乱世佳人19399.2Top26疯狂动物城20169.2Top27蝙蝠侠：黑暗骑士20089.1Top28天堂电影院19889.1Top29活着19949.1Top30少年派的奇幻漂流20129.0Top31十二怒汉19579.4Top32鬼子来了20009.2Top33指环王3：王者无敌20039.1Top34控方证人19579.6Top35搏击俱乐部19999.0Top36天空之城19869.0Top37飞屋环游记20098.9Top38大话西游之月光宝盒19958.9Top39罗马假日19539.0Top40摔跤吧！爸爸20169.1Top41窃听风暴20069.1Top42辩护人20139.2Top43两杆大烟枪19989.1Top44闻香识女人19929.0Top45哈尔的移动城堡20048.9Top46飞越疯人院19759.0Top47死亡诗社19899.0Top48V字仇杀队20058.8Top49海豚湾20099.3Top50教父219749.1Top51指环王2：双塔奇兵20029.0Top52指环王1：魔戒再现20018.9Top53美丽心灵20018.9Top54饮食男女19949.1Top55情书19958.8Top56素媛20139.1Top57狮子王19948.9Top58钢琴家20029.1Top59美国往事19849.1Top60小鞋子19979.2Top61七宗罪19958.8Top62被嫌弃的松子的一生20068.9Top63致命魔术20068.8Top64本杰明·巴顿奇事20088.8Top65末代皇帝19879.0Top66西西里的美丽传说20008.8Top67天使爱美丽20018.7Top68黑客帝国19998.9Top69让子弹飞20108.7Top70拯救大兵瑞恩19988.9Top71看不见的客人20168.7Top72音乐之声19658.9Top73低俗小说19948.8Top74勇敢的心19958.8Top75剪刀手爱德华19908.7Top76大闹天宫19611964197820049.3Top77沉默的羔羊19918.8Top78蝴蝶效应20048.7Top79哈利·波特与魔法石20018.8Top80春光乍泄19978.8Top81入殓师20088.8Top82心灵捕手19978.8Top83猫鼠游戏20028.8Top84布达佩斯大饭店20148.8Top85禁闭岛20108.7Top86玛丽和马克思20098.9Top87阳光灿烂的日子19948.8Top88第六感19998.8Top89幽灵公主19978.8Top90重庆森林19948.7Top91狩猎20129.1Top92致命ID20038.7Top93穿条纹睡衣的男孩20088.9Top94断背山20058.7Top95加勒比海盗20038.6Top96大鱼20038.7Top97阿凡达20098.6Top98摩登时代19369.2Top99告白20108.7Top100一一20009.0Top101射雕英雄传之东成西就19938.7Top102甜蜜蜜19968.8Top103阳光姐妹淘20118.8Top104消失的爱人20148.7Top105爱在黎明破晓前19958.7Top106上帝之城20028.9Top107小森林 夏秋篇20148.9Top108侧耳倾听19958.8Top109喜剧之王19998.6Top110倩女幽魂19878.6Top111恐怖直播20138.7Top112风之谷19848.8Top113爱在日落黄昏时20048.8Top114超脱20118.8Top115红辣椒20068.9Top116菊次郎的夏天19998.8Top117驯龙高手20108.7Top118幸福终点站20048.7Top119神偷奶爸20108.5Top120借东西的小人阿莉埃蒂20108.7Top121杀人回忆20038.7Top122七武士19549.2Top123岁月神偷20108.6Top124请以你的名字呼唤我20178.8Top125萤火虫之墓19888.7Top126怪兽电力公司20018.6Top127小森林 冬春篇20159.0Top128哈利·波特与死亡圣器(下)20118.7Top129谍影重重320078.7Top130喜宴19938.8Top131东邪西毒19948.6Top132电锯惊魂20048.7Top133贫民窟的百万富翁20088.5Top134疯狂原始人20138.7Top135记忆碎片20008.6Top1367号房的礼物20138.7Top137黑天鹅20108.5Top138萤火之森20118.8Top139真爱至上20038.5Top140英雄本色19868.6Top141超能陆战队20148.6Top142雨人19888.6Top143心迷宫20148.7Top144蝙蝠侠：黑暗骑士崛起20128.6Top145卢旺达饭店20048.9Top146唐伯虎点秋香19938.5Top147海洋20099.0Top148傲慢与偏见20058.5Top149荒蛮故事20148.8Top150纵横四海19918.7Top151海边的曼彻斯特20168.6Top152教父319908.8Top153虎口脱险19668.9Top154无人知晓20049.1Top155时空恋旅人20138.7Top156完美的世界19939.0Top157寻梦环游记20179.0Top158玩具总动员320108.8Top159燃情岁月19948.7Top160花样年华20008.5Top161恋恋笔记本20048.5Top162达拉斯买家俱乐部20138.7Top163血战钢锯岭20168.7Top164二十二20158.7Top165雨中曲19529.0Top166魂断蓝桥19408.8Top167穿越时空的少女20068.6Top168猜火车19968.5Top169我是山姆20018.8Top170冰川时代20028.5Top171人工智能20018.6Top172爆裂鼓手20148.6Top173头脑特工队20158.7Top174被解救的姜戈20128.6Top175未麻的部屋19978.8Top176罗生门19508.7Top177浪潮20088.7Top178香水20068.4Top179朗读者20088.5Top180阿飞正传19908.5Top181你的名字。20168.4Top182房间20158.8Top183可可西里20048.7Top184恐怖游轮20098.4Top185模仿游戏20148.6Top186一个叫欧维的男人决定去死20158.8Top187一次别离20118.7Top188忠犬八公物语19879.1Top189战争之王20058.6Top190追随19988.9Top191魔女宅急便19898.5Top192撞车20048.6Top193谍影重重20028.5Top194完美陌生人20168.6Top195地球上的星星20078.9Top196牯岭街少年杀人事件19918.8Top197谍影重重220048.6Top198哪吒闹海19798.9Top199惊魂记19608.9Top200青蛇19938.5Top201梦之安魂曲20008.7Top202无敌破坏王20128.7Top203黑客帝国3：矩阵革命20038.6Top204小萝莉的猴神大叔20158.5Top205再次出发之纽约遇见你20138.5Top206海街日记20158.7Top207新龙门客栈19928.5Top208东京物语19539.2Top209步履不停20088.8Top210终结者2：审判日19918.6Top211源代码20118.4Top212初恋这件小事20108.3Top213绿里奇迹19998.7Top214城市之光19319.2Top215末路狂花19918.7Top216爱在午夜降临前20138.8Top217疯狂的石头20068.3Top218秒速5厘米20078.3Top219无耻混蛋20098.5Top220这个男人来自地球20078.5Top221勇闯夺命岛19968.6Top222E.T. 外星人19828.5Top223碧海蓝天19888.7Top224变脸19978.4Top225卡萨布兰卡19428.6Top226黄金三镖客19669.1Top227发条橙19718.5Top228彗星来的那一夜20138.4Top229聚焦20158.8Top230海盗电台20098.6Top231美国丽人19998.5Top232血钻20068.5Top233非常嫌疑犯19958.6Top234国王的演讲20108.3Top235荒野生存20078.6Top236英国病人19968.5Top237黑鹰坠落20018.6Top238我爱你20119.0Top239迁徙的鸟20019.1Top240遗愿清单20078.5Top241勇士20118.9Top242荒岛余生20008.5Top2432001太空漫游19688.7Top244枪火19998.7Top245燕尾蝶19968.6Top246叫我第一名20088.6Top247穆赫兰道20018.3Top248千钧一发19978.7Top249大卫·戈尔的一生20038.6Top250上帝也疯狂19808.7","categories":[{"name":"电影资源","slug":"电影资源","permalink":"/categories/电影资源/"}],"tags":[{"name":"公众号文章","slug":"公众号文章","permalink":"/tags/公众号文章/"},{"name":"Top电影","slug":"Top电影","permalink":"/tags/Top电影/"}]},{"title":"使用 Hexo+GitHub 搭建个人博客","slug":"使用Hexo+GitHub搭建个人博客","date":"2018-11-28T07:36:06.000Z","updated":"2019-06-02T15:59:51.065Z","comments":true,"path":"2018/11/28/使用Hexo+GitHub搭建个人博客/","link":"","permalink":"/2018/11/28/使用Hexo+GitHub搭建个人博客/","excerpt":"","text":"昨天偶然看见一篇有关使用Hexo搭建个人博客的文章，瞬间吸引我的注意。今天使用的一天的时间在GitHub上搭建了一个个人博客，感觉还不错，分享给大家，并记录下我搭建过程中趟过的坑 环境：Win10 + Hexo + GitHub 效果展示：脚印的博客 一、准备工作1. 了解Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官方文档：https://hexo.io/zh-cn/docs/ 2. 搭建Node.js环境Hexo基于Node.js环境，那么我们搭建博客网站首先需要安装Node.js环境 下载地址：http://nodejs.cn/download 详细安装文档：http://www.runoob.com/nodejs/nodejs-install-setup.html 测试安装：命令行使用 node -v 、npm -v，查看显示版本号即成功。如下图： 3. 注册Github账号这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件 注册地址：https://github.com注册流程：https://blog.csdn.net/p10010/article/details/51336332 注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦 4. 安装Git版本工具 使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步 下载地址：https://git-scm.com/downloads Windows系统需下载，Mac系统因为自带Git无需操作 详细安装文档：https://blog.csdn.net/u013295518/article/details/78746007 测试安装：git --version，查看显示版本号即成功。如下图： 配置SSH：https://blog.csdn.net/qq_35246620/article/details/69061355 SSH key添加之后，就可以在本机git bash中进行测试，输入ssh -T git@github.com进行测试 显示 Hi username ！You&#39;ve successfully... 说明ssh配置成功了 5. 在本地安装 Hexo Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件 npm install -g hexo-cli 注意：在回车之后，可能会出现一行WARN的警告语句，不用管它，这个不妨碍安装 过一段时间如果出现hexo版本号之类的语句就代表差不多了 然后输入 npm install hexo --save 这个时候你会看到命令行出现了一堆白字，紧接着输入hexo v查看是否安装成功： 此时，Hexo已经安装完成 二、搭建博客1. 开启GitHub Pages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是： 仓库名固定：你的github的username.github.io 这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。 点击Create Repository后，选着仓库的Setting进入设置 往下滑找到 Github Pages 如下： 这里我们需要点击 Choose a theme 任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 点击 Select theme 选着主题后，此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 输入你的 GitHub 的用户名和密码，成功后复制https://username.github.io/到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！ 2. 创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下： hexo init myHexoBlog //myHexoBlog是项目名 等一会，如果出现橙色的 WARN 没关系，只要不出现红色的 ERROR 就行。好了后，输入命令： hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 然后点开 http://localhost:4000/ ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！ 3. 同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地博客目录的配置：修改本地博客根目录下的_config.yml文件，修改deploy下的配置，如下： deploy: type: git repository: git@github.com:xiongtianci-tc/xiongtianci-tc.github.io.git #复制的仓库地址 branch: master 注意： repository后面的内容是 git@gitbub.com:username/库地址 的形式 type、repository、branch冒号的后面都有一个空格（切记~~） 最后执行控制台命令： npm install hexo-deployer-git --save //安装部署插件 hexo d //部署到github 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三、发布你的第一篇博客终于可以发布自己的第一篇博客了，是不是很激动？（博主当时可是超级激动的~）首先，在本地博客文件夹根目录输入： hexo new &quot;我个人博客的第一篇博客，激动~&quot; hexo g //生成网页 hexo d //部署到远端(github) 现在打开我们的博客网站：http://UserName.github.io,会看到网页如下(可能需要刷新几次页面)： 需要编写博客内容时，只需编写本地博客的 _posts 的博客原文，然后通过 hexo g &amp;&amp; hexo d 重新部署到github即可 四、更换主题此时，我们的个人博客已经搭建完成。但是我们需要网站更加高大上，更加美观些，我们可以通过更换主题来实现个性化博客 这里以使用github上的next主题为例： 1. 下载主题next主题：https://github.com/iissnan/hexo-theme-next 在控制台中切换到本地博客根目录输入： $ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next 下载成之后我们会看到next的主题已经存在 thems 里了如下： 2. 更换主题修改博客根目录(不是next主题)下的 _config.yml 文件，搜索 theme 字段，并将其值修改为 next 然后在控制台下输入如下命令： hexo clean //清理缓存 hexo g //重新生成博客代码 hexo d //部署到本地 // 或者直接输入：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 再次打开我们的博客网站：https://UserName.github.io，将会发现我们的博客主题已经发生了改变 五、个性化通过此步骤我们可以设置博客的作者、格言、语言… 在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项 1. 站点配置在本地的博客根目录下找到_config.yml，用编辑器打开进行内容的设置，如下： 这里可以修改博客网站的标题、描述，语言等属性 2. 主题设置网上有个超级详细的教程，我就不赘述了： 文档地址：http://theme-next.iissnan.com/getting-started.html 终于结束了， 最后，","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"/categories/技术笔记/"},{"name":"博客记录","slug":"技术笔记/博客记录","permalink":"/categories/技术笔记/博客记录/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"/tags/Hexo/"}]}]}