{"meta":{"title":"天赐の小站","subtitle":"You Only Live Once","description":null,"author":"天赐","url":"https://blog.xiongtianci.com","root":"/"},"pages":[{"title":"","date":"2020-04-01T08:01:29.074Z","updated":"2019-06-11T09:47:49.936Z","comments":true,"path":"googleb2e7c27c164ee2f9.html","permalink":"https://blog.xiongtianci.com/googleb2e7c27c164ee2f9.html","excerpt":"","text":"google-site-verification: googleb2e7c27c164ee2f9.html"},{"title":"","date":"2020-04-01T08:01:29.040Z","updated":"2019-06-14T02:46:40.863Z","comments":true,"path":"baidu_verify_S4IxG3JiC9.html","permalink":"https://blog.xiongtianci.com/baidu_verify_S4IxG3JiC9.html","excerpt":"","text":"S4IxG3JiC9"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-09-16T08:40:04.369Z","comments":false,"path":"about/index.html","permalink":"https://blog.xiongtianci.com/about/index.html","excerpt":"","text":"关于我建站日志 2019-06-12: 换用新主题 Sakura 2018-11-30: 购入域名 xiongtianci.com 2018-11-28: 使用 Hexo 建站，选用 Next主题"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-06-04T16:31:44.716Z","comments":false,"path":"bangumi/index.html","permalink":"https://blog.xiongtianci.com/bangumi/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-09-16T01:35:43.221Z","comments":false,"path":"client/index.html","permalink":"https://blog.xiongtianci.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-07-31T04:31:13.420Z","comments":true,"path":"comment/index.html","permalink":"https://blog.xiongtianci.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-03-07T06:15:51.180Z","comments":false,"path":"donate/index.html","permalink":"https://blog.xiongtianci.com/donate/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-06-18T03:34:38.073Z","comments":false,"path":"lab/index.html","permalink":"https://blog.xiongtianci.com/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-03-09T01:47:12.364Z","comments":true,"path":"links/index.html","permalink":"https://blog.xiongtianci.com/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-06-18T03:44:25.191Z","comments":false,"path":"music/index.html","permalink":"https://blog.xiongtianci.com/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-06-18T03:38:10.531Z","comments":true,"path":"rss/index.html","permalink":"https://blog.xiongtianci.com/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-05-31T23:21:46.000Z","comments":false,"path":"video/index.html","permalink":"https://blog.xiongtianci.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-07-03T09:20:10.431Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://blog.xiongtianci.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-06-18T03:50:51.657Z","comments":true,"path":"tags/index.html","permalink":"https://blog.xiongtianci.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WR30U路由器救砖记录","slug":"WR30U路由器救砖记录","date":"2025-10-17T23:45:34.000Z","updated":"2025-10-26T01:45:44.340Z","comments":true,"path":"2025/10/18/WR30U路由器救砖记录/","link":"","permalink":"https://blog.xiongtianci.com/2025/10/18/WR30U路由器救砖记录/","excerpt":"","text":"前言最近在海鲜市场淘了个 WR30U 路由器。结果收到后不到半天就被我刷成砖了🤪 我是 uboot 刷成功了，但是在刷完 openwrt 后，系统启动不了，右侧网络黄灯常亮，系统灯不亮： 尝试完各种重启、长按 REST 后仍无反应。最后，就只能 TTL 救砖了。 救砖过程一、准备工具1、usb转串口设备。我这里用的 CH340G 模块（Windows10 系统通常可自动安装驱动，未自动安装时可联系商家获取） 2、公对母杜邦线 3 根 买 CH340G 时店家会赠送杜邦线，但一般都是母对母，而 WR30U 的 TTL 接口是孔状结构没有针脚，所以还需要购买几根 2.54 间距公对母的杜邦线。 也可以用 2.54mm 间距的 4P 单排针结合母对母杜邦线： 也可以选择烧录夹，不过贵点： 3、螺丝刀（拆机用） 4、一台电脑（需有网口，关闭防火墙和杀毒软件） 5、串口调试工具（如 Putty、SecureCRT、Xshell 等）、tftp 工具 6、WR30U 的 U-Boot 固件（我这里用的 hanwckf 制作的固件：bl-mt798x） 固件文件名：mt7981_wr30u-fip-fixed-parts-multi-layout.bin 另：可以顺便准备 openwrt 的固件，救砖后一并刷入 二、硬件连接1、连接 USB 转 TTL 模块拆开路由器外壳： 用螺丝刀卸下 WR30U 底部螺丝，壳子底部标签下左右各一个； 翻到正面，撬开顶部盖板。 找到 WR30U 主板的 TTL 接口。WR30U 路由器 TTL 接口在主板正面右上方，如下图： 接线原则（关键） CH340G 与主板的 TTL 引脚需按照 “交叉连接” 原则接线（模块 TX 接主板 RX，模块 RX 接主板 TX，GND 共地），即： CH340G 的 TXD → 连接 WR30U 主板的 RX（模块发送接主板接收） CH340G 的 GND → 连接 WR30U 主板的 GND（共地，必须接） CH340G 的 RXD → 连接 WR30U 主板的 TX（模块接收接主板发送） TXD（Transmit Data）：即发送数据线，用于设备将数据发送给与其通信的另一个设备。 RXD（Receive Data）：即接收数据线，用于设备接收来自通信伙伴的数据。 GND（Ground）：即地线，是公共接地端，为电路提供一个公共参考电位，确保发送端和接收端的地电位相同，以保证数据传输的稳定性。 注意： 不要接 CH340G 的 VCC（5V 或 3.3V）到主板，WR30U 主板通常由自身电源供电，外接 VCC 可能导致短路烧坏设备！ 若接线后无数据，可能是 TX/RX 接反，可尝试交换两根线。 最终效果： 杜邦线和接口连接不是特别牢固，可以用电烙铁焊接下。 2、连接电脑与路由器 路由器先不通电。TTL 模块的 USB 端插入电脑，安装驱动后在 “设备管理器” 中确认 COM 端口（如 COM5）；并在设备管理器中双击此设备，将速率修改为 115200 用网线将电脑网口与路由器 LAN 口连接，电脑手动设置静态 IP（如 192.168.1.100，子网掩码 255.255.255.0，网关 192.168.1.1） 在电脑中搭建 tftp 服务（用于上传 uboot 至路由器）。下载 tftp、安装、启动并设置 三、通过串口强制进入 U-Boot 打开串口调试工具用软件（如 Putty、SecureCRT）连接 TTL 模块的 COM 口。配置：选择 “Serial” 模式，填写串口端口号（如 COM5），波特率为 115200，数据位：8，停止位：1，校验位：None，流控：None。我这里用的 xshell： 启动路由器并进入uboot 给 WR30U 通电，串口工具应会滚动打印启动日志（如 U-Boot 启动信息、系统加载过程）。在日志滚动时快速按 方向下键 即可中断启动，进入 U-Boot 控制台； 窗口日志会停在 U-Boot Boot Menu 选项中，移动上下键选择 4（4. Upgrade ATF FIP） *** U-Boot Boot Menu *** 1. Startup system (Default) 2. Upgrade firmware 3. Upgrade ATF BL2 4. Upgrade ATF FIP 5. Upgrade single image 6. Load image 7. Start Web failsafe 0. U-Boot console 然后在 Upgrading ATF FIP 选项中选择 0 *** Upgrading ATF FIP *** Available load methods: 0 - TFTP client (Default) 1 - Xmodem 2 - Ymodem 3 - Kermit 4 - S-Record Select (enter for default): 0 随后，配置 TFTP Server 的相关信息 # 设置uboot即路由器IP Input U-Boot&#39;s IP address: 192.168.1.1 # 设置TFTP服务器IP，即电脑ip Input TFTP server&#39;s IP address: 192.168.1.100 # 设置路由器子网掩码 Input IP netmask: 255.255.255.0 # 这个填入下载的 uboot 固件的文件名 Input file name: mt7981_wr30u-fip-fixed-parts-multi-layout.bin 按下回车，会将本地的 uboot 上传至路由器并自动写入，相关日志信息： Input U-Boot&#39;s IP address: 192.168.1.1 Input TFTP server&#39;s IP address: 192.168.1.100 Input IP netmask: 255.255.255.0 Input file name: mt7981_wr30u-fip-fixed-parts-multi-layout.bin Using ethernet@15100000 device TFTP from server 192.168.1.100; our IP address is 192.168.1.1 Filename &#39;mt7981_wr30u-fip-fixed-parts-multi-layout.bin&#39;. Load address: 0x46000000 Loading: #################################################### 1.3 MiB/s done Bytes transferred = 757473 (b8ee1 hex) Saving Environment to MTD... Erasing on MTD device &#39;Nvram&#39;... OK Writing to MTD device &#39;Nvram&#39;... OK OK *** Loaded 757473 (0xb8ee1) bytes at 0x46000000 *** Erasing &#39;fip&#39; from 0x380000, size 0xc0000 ... OK Writing &#39;fip&#39; from 0x46000000 to 0x380000, size 0xb8ee1 ... OK *** ATF FIP upgrade completed! *** 访问 uboot 后台：http://192.168.1.1 至此，已经成功救砖🎉🎉🎉 最后，我们也可以顺便刷入 openwrt 固件（上传后注意校验 MD5） 另如果是刷 uboot 就失败成砖的，可以试试：MediaTek Filogic 系列路由器串口救砖教程 参考教程","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://blog.xiongtianci.com/tags/路由器/"},{"name":"软路由","slug":"软路由","permalink":"https://blog.xiongtianci.com/tags/软路由/"}],"author":"木浅"},{"title":"在同一台电脑上配置SSH管理多个GitHub账户","slug":"在同一台电脑上配置SSH管理多个GitHub账户","date":"2025-07-19T00:25:50.000Z","updated":"2025-10-26T02:19:07.247Z","comments":true,"path":"2025/07/19/在同一台电脑上配置SSH管理多个GitHub账户/","link":"","permalink":"https://blog.xiongtianci.com/2025/07/19/在同一台电脑上配置SSH管理多个GitHub账户/","excerpt":"","text":"前言 SSH（Secure Shell） 是一种加密的网络协议，用于安全地远程访问和管理计算机系统。它通过加密通信防止数据被窃听或篡改，广泛用于： 远程登录服务器（如 ssh user@host） 安全传输文件（scp/sftp） Git 等版本控制的认证 在 GitHub 中配置 SSH 密钥的主要目的是 替代账号密码，实现更安全、便捷的身份认证，最主要的是免密码操作 Git 仓库。 而同一台机器上同一个 ssh key 只能添加至一个 Github 账户，如果添加至多个就会报错：Key is already in use 现在我有多个 Github 账户，个人账户和公司账户，我希望都能配置 ssh。 配置1、生成密钥 ls -al ~/.ssh 列出现有的公钥和私钥对 生成个人账户的ssh： ssh-keygen -t rsa 对于保存密钥的位置，按回车键使用默认位置。一个私钥和公钥 ~/.ssh/id_rsa.pub 将在默认的 SSH 位置 ~/.ssh/ 创建。 生成工作账号的ssh： ssh-keygen -t rsa -C &quot;email@work_mail.com&quot; -f &quot;id_rsa_work_user1&quot; ssh-keygenOpenSSH 自带的密钥生成工具，用于创建认证密钥（公钥和私钥）。 -t rsa指定密钥类型为 ​​RSA​​（默认算法，兼容性最好）。其他可选类型有 ed25519、ecdsa 等。 -C &quot;email@work_mail.com&quot;在公钥末尾添加注释（通常是邮箱或标识符）。 注释不会影响密钥功能，仅作为备注。 例如生成的公钥文件会包含：ssh-rsa AAAAB3N... email@work_mail.com。 -f &quot;id_rsa_work_user1&quot;指定密钥文件的名称（默认路径是 ~/.ssh/）。 私钥：id_rsa_work_user1 公钥：id_rsa_work_user1.pub 如果省略 -f，默认生成 id_rsa 和 id_rsa.pub 创建好后在 ~/.ssh 目录下就有了两对不同的密钥： ~/.ssh/id_rsa ~/.ssh/id_rsa.pub ~/.ssh/id_rsa_work_user1 ~/.ssh/id_rsa_work_user1.pub 私钥（Private Key）：id_rsa、id_rsa_work_user1 作用：用于身份认证的机密文件，相当于你的“密码”。 用途：本地 SSH 客户端（如 Git、终端）用它来证明你的身份。当你执行 git push 或 ssh user@host 时，系统会自动匹配对应的私钥。 注意必须严格保密，不能泄露给任何人。 公钥（Public Key）：id_rsa.pub、id_rsa_work_user1.pub 作用：用于公开分发的文件，相当于“锁”，其他人可以用它验证你的身份。 用途：需要将它添加到远程服务（如 GitHub、GitLab、服务器等） 必须添加公钥到 GitHub，私钥绝对不能上传或分享给任何人！ 2、将公钥添加到 GitHub分别将两个公钥添加至 GitHub 个人账户和公司账户。 复制公钥内容： cat ~/.ssh/id_rsa_work_user1.pub 或直接打开文件复制全部内容（包括 ssh-rsa 和邮箱注释）。 在 GitHub 中添加公钥： 进入 Settings → SSH and GPG Keys → New SSH Key。 粘贴公钥内容，标题可写备注（如 Work Laptop）。 3、配置 SSH 配置文件默认情况下，SSH 只会自动使用 ~/.ssh/id_rsa。如果密钥文件名不同（如 id_rsa_work_user1），每次连接需通过 -i 指定密钥： ssh -i ~/.ssh/id_rsa_work_user1 user@github.com 通过 config 文件可自动匹配密钥，无需额外输入。 1、创建 SSH 配置文件 ~/.ssh/config： $ cd ~/.ssh/ $ touch config 2、在 ~/.ssh/config 中复制下面配置： # Personal account, - the default config Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # Work account-1 Host github.com-work_user1 HostName github.com User git IdentityFile ~/.ssh/id_rsa_work_user1 关键配置项说明： Host：自定义别名，用于简化命令（ssh github.com） # 代替完整的 ssh -i ~/.ssh/id_rsa git@github.com ssh github.com 注意：设置 remote origin 时需要与这里配置的别名保持一致 HostName：实际的主机地址，可配置公司服务器地址；可用 * 匹配多个主机（如：*.company.com） User：登录用户名，Git 服务通常为 git，服务器可能是你的公司用户名 IdentityFile：指定对应的私钥路径 IdentitiesOnly：强制只使用指定的密钥，避免 SSH 尝试其他密钥导致失败 Port：如果服务使用非默认端口（22），需手动指定 4、测试 SSH 连接命令格式： # 命令格式 ssh -T git@&lt;主机地址&gt; 示例： GitHub：ssh -T git@github.com 成功时会返回： Hi &lt;你的用户名&gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access. GitLab：ssh -T git@gitlab.com 成功时会返回： Welcome to GitLab, @&lt;你的用户名&gt;! 这里我们配置了多密钥： $ ssh -T git@github.com $ ssh -T git@github.com-work_user1 调试模式（查看详细错误）。添加 -v（verbose）参数显示详细连接过程，帮助定位问题： ssh -vT git@github.com 5、不同repo配置不同用户信息不同 repo 我希望配置不同的 user 信息，比如个人账户 GitHub 中我希望隐藏邮箱，而公司账户中需要使用公司邮箱。 通常个人账户的用户信息是设置的全局配置： $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;your.email@example.com&quot; 查看全局配置： $ git config --global --list # or $ git config --global user.name $ git config --global user.email 而在公司的 repo 中设置局部配置（仅对当前仓库生效）： $ cd /path/to/your/repo $ git config [--local] user.name &quot;Your Work Name&quot; $ git config [--local] user.email &quot;your.work@company.com&quot; 查看局部配置： git config --local --list 由于我们配置了多个 HostName 都是 github.com 的 ssh，最后对公司 repo 进行 git 操作之前需要修改 remote 地址： git remote set-url origin git@github.com-work_user1:user/repo.git # 个人账户 git@github.com:user/repo.git # 公司账户 git@github.com-work_user1:user/repo.git 相关操作git clone git@github.com-work_user1:user/repo.git","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"Java并发：FutureTask能确保在高并发环境下任务只执行一次","slug":"Java并发：FutureTask能确保在高并发环境下任务只执行一次","date":"2025-05-21T14:10:26.000Z","updated":"2025-10-26T02:19:41.045Z","comments":true,"path":"2025/05/21/Java并发：FutureTask能确保在高并发环境下任务只执行一次/","link":"","permalink":"https://blog.xiongtianci.com/2025/05/21/Java并发：FutureTask能确保在高并发环境下任务只执行一次/","excerpt":"","text":"FutureTask 是 Java 并发包 JUC 中一个重要的类，它实现了 Future 接口和 Runnable 接口，能够确保在高并发环境下任务只执行一次： classDiagram direction BT class FunctionalInterface class Future~V~ { &lt;&lt;Interface&gt;&gt; } class FutureTask~V~ class Runnable { &lt;&lt;Interface&gt;&gt; } class RunnableFuture~V~ { &lt;&lt;Interface&gt;&gt; } FutureTask~V~ ..&gt; RunnableFuture~V~ FunctionalInterface .. Runnable RunnableFuture~V~ --&gt; Future~V~ RunnableFuture~V~ --&gt; Runnable 源码分析1. 状态机设计FutureTask内部维护了一个状态变量state，定义了任务的7种状态： private volatile int state; private static final int NEW = 0; // 初始状态 private static final int COMPLETING = 1; // 正在完成 private static final int NORMAL = 2; // 正常完成 private static final int EXCEPTIONAL = 3; // 异常完成 private static final int CANCELLED = 4; // 已取消 private static final int INTERRUPTING = 5; // 正在中断 private static final int INTERRUPTED = 6; // 已中断 2. CAS操作保证原子性状态变更使用Unsafe类的CAS操作保证原子性： // java.util.concurrent.FutureTask#run public void run() { if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; // ... } // sun.misc.Unsafe#compareAndSwapObject private boolean compareAndSetState(int expect, int update) { return UNSAFE.compareAndSwapInt(this, stateOffset, expect, update); } 3. 执行逻辑保护在run()方法中，通过状态检查确保任务只执行一次： public void run() { if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) { V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } 确保任务只执行一次的关键点 初始状态检查：只有在NEW状态时才可能执行任务 CAS设置runner：确保只有一个线程能成功设置当前线程为执行者 二次状态检查：在真正执行前再次检查状态 状态转换原子性：使用CAS操作保证状态变更的原子性 丰富的测试案例测试案例1：基本单次执行验证@Test public void testExecuteOnlyOnce() throws Exception { AtomicInteger counter = new AtomicInteger(0); Callable&lt;Integer&gt; task = () -&gt; counter.incrementAndGet(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task); new Thread(futureTask).start(); new Thread(futureTask).start(); // 第二个线程尝试执行 assertEquals(1, futureTask.get().intValue()); assertEquals(1, counter.get()); // 确保只执行了一次 } 测试案例2：高并发环境测试@Test public void testHighConcurrency() throws Exception { int threadCount = 100; ExecutorService executor = Executors.newFixedThreadPool(threadCount); AtomicInteger counter = new AtomicInteger(0); Callable&lt;Integer&gt; task = () -&gt; { Thread.sleep(100); // 模拟耗时操作 return counter.incrementAndGet(); }; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task); List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; threadCount; i++) { futures.add(executor.submit(futureTask)); } // 所有线程应该返回相同的结果 Integer result = futureTask.get(); for (Future&lt;?&gt; future : futures) { assertEquals(result, future.get()); } assertEquals(1, counter.get()); // 确保只执行了一次 executor.shutdown(); } 测试案例3：取消任务后的行为@Test public void testAfterCancellation() throws Exception { AtomicBoolean executed = new AtomicBoolean(false); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; { executed.set(true); return &quot;result&quot;; }); // 先取消任务 futureTask.cancel(true); // 然后尝试执行 futureTask.run(); assertFalse(executed.get()); // 任务不应执行 assertTrue(futureTask.isCancelled()); } 测试案例4：异常情况处理@Test public void testExceptionHandling() { FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; { throw new RuntimeException(&quot;Test exception&quot;); }); new Thread(futureTask).start(); new Thread(futureTask).start(); // 第二次尝试执行 try { futureTask.get(); fail(&quot;Should throw exception&quot;); } catch (Exception e) { assertTrue(e.getCause() instanceof RuntimeException); } } 测试案例5：混合读写操作@Test public void testMixedReadWriteOperations() throws Exception { AtomicInteger counter = new AtomicInteger(0); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; { Thread.sleep(50); return counter.incrementAndGet(); }); // 启动多个线程，有的执行任务，有的直接获取结果 ExecutorService executor = Executors.newFixedThreadPool(10); List&lt;Future&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { results.add(executor.submit(futureTask)); // 执行任务 } for (int i = 0; i &lt; 5; i++) { results.add(executor.submit(() -&gt; futureTask.get())); // 只获取结果 } // 所有结果应该相同 Integer expected = results.get(0).get(); for (Future&lt;Integer&gt; result : results) { assertEquals(expected, result.get()); } assertEquals(1, counter.get()); // 确保只执行了一次 executor.shutdown(); } 结论FutureTask通过以下机制确保在高并发环境下任务只执行一次： 使用volatile变量保证状态可见性 使用CAS操作保证状态变更的原子性 在关键执行路径上进行多重状态检查 通过runner字段确保只有一个线程能真正执行任务 这种设计使得FutureTask非常适合作为高并发环境下的一次性任务执行器，既保证了线程安全，又避免了不必要的资源浪费。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"RabbitMQ如何保证消息的可靠性传输","slug":"RabbitMQ如何保证消息的可靠性传输","date":"2025-03-24T06:19:04.000Z","updated":"2025-10-26T01:45:44.249Z","comments":true,"path":"2025/03/24/RabbitMQ如何保证消息的可靠性传输/","link":"","permalink":"https://blog.xiongtianci.com/2025/03/24/RabbitMQ如何保证消息的可靠性传输/","excerpt":"","text":"消息丢失的场景RabbitMQ丢失消息的3种情况： 生产者丢失消息 场景： 生产者发送消息后，RabbitMQ 服务器崩溃或网络中断，导致消息未到达 RabbitMQ。 解决方案： 使用 Confirm 模式，确保消息成功到达 RabbitMQ RabbitMQ 服务器丢失消息 场景： RabbitMQ 服务器崩溃，且消息未持久化。 解决方案： 将队列和消息都设置为持久化（durable=true 和 deliveryMode=2）。 消费者丢失消息 场景： 消费者处理消息后，未发送 ACK，且消费者崩溃，导致 RabbitMQ 认为消息未被处理。 解决方案： 使用 手动 ACK，确保消息处理成功后再发送 ACK。 消息过期 场景： 消息设置了 TTL（Time-To-Live），在过期后会被自动删除。 解决方案： 合理设置消息的 TTL，或监控过期消息。 队列溢出 场景： 队列达到最大长度限制，新消息会被丢弃。 解决方案： 监控队列长度，合理设置队列的最大长度。 RabbitMQ 提供了以下机制来确保消息传输的可靠性： 消息持久化 队列持久化： 将队列设置为持久化（durable=true），即使 RabbitMQ 服务器重启，队列也不会丢失。 消息持久化： 将消息设置为持久化（deliveryMode=2），即使 RabbitMQ 服务器重启，消息也不会丢失。 生产者确认机制（Publisher Confirm） Confirm 模式： 生产者发送消息后，RabbitMQ 会返回一个确认（ack），表示消息已经成功到达 RabbitMQ 服务器。 Return 模式： 如果消息无法路由到队列，RabbitMQ 会返回一个 return，生产者可以处理这种异常情况。 消费者确认机制（Consumer Ack） 手动 ACK： 消费者处理完消息后，手动发送一个确认（ack）给 RabbitMQ，RabbitMQ 才会将消息从队列中移除。 NACK 或 Reject： 如果消费者处理消息失败，可以发送 nack 或 reject，RabbitMQ 会将消息重新入队或丢弃。 事务机制 事务模式： 生产者可以使用事务机制确保消息的原子性，但性能较差，通常不推荐使用。 如何确保消息不丢失 为了确保消息不丢失，可以采取以下措施： 生产者端 使用 Confirm 模式，确保消息成功到达 RabbitMQ。 实现消息重试机制，在消息发送失败时重试。 RabbitMQ 端 将队列和消息都设置为持久化。 使用镜像队列（Mirrored Queues），确保消息在多个节点上备份。 消费者端 使用 手动 ACK，确保消息处理成功后再发送 ACK。 实现消息重试机制，在消息处理失败时重试。 监控和报警 监控 RabbitMQ 的状态，包括队列长度、消息堆积情况等。 设置报警机制，及时发现和处理异常情况。 实现parent：org.springframework.boot:spring-boot-starter-parent:2.7.10 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; config： import org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { // 定义队列 @Bean public Queue myQueue() { return QueueBuilder.durable(&quot;myQueue&quot;) // 持久化队列 // 将处理失败的消息转移到死信队列，避免阻塞正常队列 .withArgument(&quot;x-dead-letter-exchange&quot;, &quot;myDLX&quot;) // 绑定死信交换机 .withArgument(&quot;x-dead-letter-routing-key&quot;, &quot;myDLRoutingKey&quot;) // 绑定死信路由键 .build(); } // 定义交换机 @Bean public DirectExchange myExchange() { return new DirectExchange(&quot;myExchange&quot;, true, false); } // 绑定队列和交换机 @Bean public Binding binding(Queue myQueue, DirectExchange myExchange) { return BindingBuilder.bind(myQueue) .to(myExchange) .with(&quot;myRoutingKey&quot;); } // 定义死信队列 @Bean public Queue myDLQueue() { return QueueBuilder.durable(&quot;myDLQueue&quot;) // 持久化死信队列 .build(); } // 定义死信交换机 @Bean public DirectExchange myDLX() { return ExchangeBuilder.directExchange(&quot;myDLX&quot;) .durable(true) // 持久化死信交换机 .build(); } // 绑定死信队列和死信交换机 @Bean public Binding dlBinding(Queue myDLQueue, DirectExchange myDLX) { return BindingBuilder.bind(myDLQueue) .to(myDLX) .with(&quot;myDLRoutingKey&quot;); } } 死信队列（Dead Letter Queue, DLQ）：是 RabbitMQ 的一种容错机制，用于接收无法被正常消费的消息（即“死信”）。可以将无法处理的消息从主队列分离，避免阻塞正常业务。 持久化机制：默认继承原消息属性。原始消息设置了 deliveryMode=2（持久化），则死信消息自动持久化到磁盘。 超时机制（TTL）：死信消息本身没有默认TTL，除非显式设置，否则死信消息会永久保留在队列中。 配置 confirm 回调和 return 回调： import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.core.MessageProperties; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @Slf4j public class RabbitMQTemplateConfig { @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory); // 开启强制标志（确保消息路由失败时能触发ReturnCallback） rabbitTemplate.setMandatory(true); // 设置Confirm回调 rabbitTemplate.setConfirmCallback(confirmCallback()); // 设置Return回调（新版本推荐使用setReturnsCallback） rabbitTemplate.setReturnsCallback(returnsCallback()); return rabbitTemplate; } // Confirm 回调 private RabbitTemplate.ConfirmCallback confirmCallback() { return (correlationData, ack, cause) -&gt; { if (correlationData == null) { log.warn(&quot;Confirm回调收到null correlationData&quot;); return; } if (ack) { log.info(&quot;消息发送成功: [ID={}]&quot;, correlationData.getId()); } else { log.error(&quot;消息发送失败: [ID={}] [原因:{}]&quot;, correlationData.getId(), cause); // 这里可以添加失败处理逻辑，如记录到数据库等待重试 } }; } // Return 回调处理路由失败（当消息无法路由到队列时触发） private RabbitTemplate.ReturnsCallback returnsCallback() { return returned -&gt; { Message message = returned.getMessage(); MessageProperties properties = message.getMessageProperties(); log.error(&quot;消息无法路由到队列: [Body={}] [原因:{}] [Exchange={}] [RoutingKey={}] [Headers={}]&quot;, new String(message.getBody()), returned.getReplyText(), returned.getExchange(), returned.getRoutingKey(), properties.getHeaders()); // 这里可以添加路由失败处理逻辑，如记录到数据库等待人工干预 }; } } 生产者： import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.core.MessageDeliveryMode; import org.springframework.amqp.core.MessageProperties; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; import java.util.UUID; @Slf4j @Service public class MessageProducer { @Autowired private RabbitTemplate rabbitTemplate; public void sendMessage(String message) { // 1. 构建消息属性（设置消息持久化） MessageProperties properties = new MessageProperties(); properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); // 2. 设置消息头（包括重试次数和唯一 correlationId） Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;(); // 添加 retryCount 头信息，初始值为 0 headers.put(&quot;retryCount&quot;, 0); String correlationId = UUID.randomUUID().toString(); // 全局唯一ID headers.put(&quot;correlationId&quot;, correlationId); headers.put(&quot;traceId&quot;, UUID.randomUUID().toString()); // 用于全链路追踪 properties.setHeaders(headers); // 3. 创建消息和 CorrelationData Message msg = new Message(message.getBytes(), properties); CorrelationData correlationData = new CorrelationData(correlationId); // 4. 发送消息（携带 CorrelationData） rabbitTemplate.convertAndSend(&quot;myExchange&quot;, &quot;myRoutingKey&quot;, msg, correlationData); log.debug(&quot;消息已发送: [ID={}] [TraceID={}]&quot;, correlationId, headers.get(&quot;traceId&quot;)); } } CorrelationData 是 Spring AMQP 提供的一个消息关联标识对象，主要用于 Publisher Confirm 模式下关联发送的消息和确认结果。通过 id 字段（通常是业务ID或UUID）唯一标识消息。 几个ID： correlationId：关联ID。用于生产者确认（Publisher Confirm）模式，关联发送的消息和服务器确认回执。在需要幂等性处理的场景中，用于识别重复消息。 traceId：追踪ID。用于全链路追踪，跨服务、跨系统的调用链追踪；在分布式系统中，通过TraceId将不同服务的日志串联起来。 消费者： import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.core.MessageDeliveryMode; import org.springframework.amqp.core.MessageProperties; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.io.IOException; import java.util.HashMap; import java.util.Map; @Slf4j @Service public class MessageConsumer { @Autowired private RabbitTemplate rabbitTemplate; private static final int MAX_RETRY_COUNT = 3; // 最大重试次数 @RabbitListener(queues = &quot;myQueue&quot;) public void handleMessage(Message message, Channel channel) throws IOException { try { // 1. 解析消息 String msgBody = new String(message.getBody()); Map&lt;String, Object&gt; headers = message.getMessageProperties().getHeaders(); log.info(&quot;收到消息: [Body={}] [TraceID={}]&quot;, msgBody, headers.get(&quot;traceId&quot;)); // 2. 模拟业务处理失败 if (msgBody.contains(&quot;error&quot;)) { throw new RuntimeException(&quot;模拟业务处理失败&quot;); } // 3. 处理成功，手动ACK channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); } catch (Exception e) { // 4. 处理失败逻辑 handleRetry(message, channel, e); } } private void handleRetry(Message message, Channel channel, Exception e) throws IOException { MessageProperties originalProps = message.getMessageProperties(); Map&lt;String, Object&gt; headers = originalProps.getHeaders(); // 获取消息头中的重试次数 int retryCount = (int) headers.getOrDefault(&quot;retryCount&quot;, 0); if (retryCount &gt;= MAX_RETRY_COUNT) { // 超过最大重试次数，转入死信队列 channel.basicNack(originalProps.getDeliveryTag(), false, false); log.error(&quot;消息处理失败，已达到最大重试次数，转移到死信队列: [TraceID={}]&quot;, headers.get(&quot;traceId&quot;)); } else { // 未超最大重试次数，重新入队 headers.put(&quot;retryCount&quot;, retryCount + 1); // 更新重试次数 // 创建新消息属性 MessageProperties newProps = new MessageProperties(); // 1) 拷贝持久化设置 MessageDeliveryMode receivedMode = originalProps.getReceivedDeliveryMode(); if (receivedMode != null) { newProps.setDeliveryMode(receivedMode); } else { // 默认设置为持久化（安全策略） newProps.setDeliveryMode(MessageDeliveryMode.PERSISTENT); } // 2) 拷贝其他必要属性 newProps.setHeaders(new HashMap&lt;&gt;(originalProps.getHeaders())); // 保留原始 correlationId 和 traceId newProps.setContentType(originalProps.getContentType()); newProps.setContentEncoding(originalProps.getContentEncoding()); newProps.setCorrelationId(originalProps.getCorrelationId()); newProps.setReplyTo(originalProps.getReplyTo()); // 发布新消息到队列（必须传递 CorrelationData） rabbitTemplate.convertAndSend( &quot;myExchange&quot;, &quot;myRoutingKey&quot;, new Message(message.getBody(), newProps), new CorrelationData(headers.get(&quot;correlationId&quot;).toString()) // 防止生产者 Confirm 回调出现 NPE ); // 确认原消息已处理（即使失败） channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); log.warn(&quot;消息重试中: [次数={}] [TraceID={}]&quot;, retryCount + 1, headers.get(&quot;traceId&quot;)); } } // 指数退避算法 private long calculateBackoffDelay(int retryCount) { long baseDelay = 5000; // 基础延迟5秒 long maxDelay = 60000; // 最大延迟60秒 return Math.min(baseDelay * (1 &lt;&lt; retryCount), maxDelay); } // 增加死信处理 @RabbitListener(queues = &quot;myDLQueue&quot;) public void handleDeadLetter(Message message, Channel channel) throws IOException { try { String msg = new String(message.getBody()); log.error(&quot;收到死信消息: {}&quot;, msg); // 可选操作： // 1. 记录到数据库（如MySQL、Elasticsearch） // 2. 发送告警（邮件/短信/钉钉） // 3. 人工介入或自动修复 // 手动确认消息 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); log.info(&quot;死信消息已确认处理完成&quot;); } catch (Exception e) { // 处理失败时拒绝消息（避免死循环） channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); log.error(&quot;死信消息处理失败: {}&quot;, e.getMessage()); } } } CorrelationData 传递：重试时从消息 Header 中读取原始 correlationId 并重建 消息追踪：生产者在消息头中添加追踪ID（traceId）字段，通过唯一ID串联消息经过的所有服务（生产者→MQ→消费者→其他服务），以支持完整的消息生命周期追踪。消费者重试逻辑中需要保持原始 traceId。 消费者重试机制的逻辑是 重建新消息+ACK原消息 的设计，主要是因为如果直接 basicNack(requeue=true) 会导致消息头（如 retryCount ）无法更新。 originalProps.getReceivedDeliveryMode() controller： @RestController public class TestController { @Autowired private MessageProducer messageProducer; @GetMapping(&quot;/send&quot;) public ResponseEntity&lt;String&gt; sendMessage(@RequestParam String message) { messageProducer.sendMessage(message); return new ResponseEntity&lt;&gt;(&quot;消息已发送: &quot; + message, HttpStatus.OK); } } 配置信息： spring: rabbitmq: host: localhost port: 5672 username: guest password: guest # 开启生产者确认模式 # NONE-禁用 Confirm 模式 # SIMPLE-启用 Confirm 模式，并同步等待确认结果 # CORRELATED-启用 Confirm 模式，并异步处理确认结果 publisher-confirm-type: correlated # 开启生产者返回模式 publisher-returns: true # 开启消费者手动 ACK listener: simple: acknowledge-mode: manual retry: enabled: false # 禁用Spring的自动重试，使用我们自定义的重试逻辑 启动类： @SpringBootApplication @EnableRabbit // 启用 RabbitMQ 监听功能 public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 测试 访问 http://localhost:8080/send?message=Hello RabbitMQ，发送正常消息 访问 http://localhost:8080/send?message=error，发送会失败的消息 失败的消息大致生命周期： sequenceDiagram participant Broker participant Consumer Broker-&gt;&gt;Consumer: 消息A(retryCount=0) Consumer-&gt;&gt;Broker: ACK消息A + 发送消息B(retryCount=1) Broker-&gt;&gt;Consumer: 消息B(retryCount=1) Consumer-&gt;&gt;Broker: ACK消息B + 发送消息C(retryCount=2) Broker-&gt;&gt;Consumer: 消息C(retryCount=2) Consumer-&gt;&gt;Broker: NACK消息C → 转入死信队列 扩展优化重试机制消费者重试不建议立即重试，而是应该采用延迟重试策略。很多情况下立即重试仍会失败，浪费资源；消息持续失败导致高频重试，CPU/内存飙升，拖垮整个服务。 立即重试的问题分析： 问题 风险 解决方案 资源风暴 消息处理失败后立即重试，可能引发瞬时高负载 引入指数退避延迟 无效重试 若失败原因是下游服务短暂不可用，立即重试大概率再次失败 逐步增加重试间隔 消息堆积 高频重试会占用队列资源，阻塞其他消息处理 使用独立延迟队列 常见的重试策略： 指数退避重试 (Exponential Backoff) 重试间隔随时间指数增长（如1s, 2s, 4s, 8s…） 防止短时间内大量重试导致系统雪崩 固定间隔重试 每次重试之间保持固定时间间隔 比立即重试更温和，但不如指数退避灵活 死信队列(DLX) + 延迟队列 处理失败的消息先进入死信队列 通过TTL或插件实现延迟重试 这是RabbitMQ中最常见的生产级方案 接下来基于指数退避重试机制，结合延迟交换机（Delayed Exchange）优化重试机制。 消息流转大致流程： sequenceDiagram participant Producer participant MainQueue participant Consumer participant RetryQueue participant DLQ Producer-&gt;&gt;MainQueue: 发送消息 Consumer-&gt;&gt;MainQueue: 消费消息 alt 处理成功 Consumer-&gt;&gt;MainQueue: ACK else 处理失败且可重试 Consumer-&gt;&gt;RetryQueue: 转发消息(带延迟) RetryQueue--&gt;&gt;MainQueue: TTL到期后重新投递 else 彻底失败 Consumer-&gt;&gt;DLQ: NACK转入死信 end 需安装 rabbitmq_delayed_message_exchange 插件，声明 x-delayed-message 类型交换机。RabbitMQ官方插件支持每条消息独立延迟： # linux # 进入RabbitMQ容器执行 rabbitmq-plugins enable rabbitmq_delayed_message_exchange # 验证插件列表应包含 rabbitmq-plugins list | grep delay # windows rabbitmq_server-3.7.14\\sbin&gt;rabbitmq-plugins.bat enable rabbitmq_delayed_message_exchange rabbitmq_server-3.7.14\\sbin&gt;rabbitmq-plugins.bat list | find &quot;delay&quot; 修正RabbitMQ配置类（确保交换机、队列、绑定关系一致） @Configuration public class RabbitMQConfig { // 主业务队列（保持不变） @Bean public Queue myQueue() { /* ... */ } @Bean public DirectExchange myExchange() { /* ... */ } @Bean public Binding binding() { /* ... */ } // 死信队列和交换机（保持不变） @Bean public Queue myDLQueue() { /* ... */ } @Bean public DirectExchange myDLX() { /* ... */ } @Bean public Binding dlBinding() { /* ... */ } // 延迟交换机（插件支持）（新增） @Bean public CustomExchange delayExchange() { Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(); args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;); // 底层仍用direct路由 return new CustomExchange(&quot;myDelayExchange&quot;, &quot;x-delayed-message&quot;, true, false, args); } // 绑定延迟交换机到延迟队列（新增） @Bean public Binding delayBinding(Queue myQueue, CustomExchange delayExchange) { return BindingBuilder.bind(myQueue) .to(delayExchange) .with(&quot;myRoutingKey&quot;) // 和主队列的 routingKey 一致 .noargs(); } } 延迟消息不会 立即 进入队列，而是由 x-delayed-message 插件 暂存，直到延迟时间到期后才投递，会导致 ReturnCallback 可能在消息被暂存时误触发。所以需要修改 RabbitMQTemplateConfig#returnsCallback() 方法： private RabbitTemplate.ReturnsCallback returnsCallback() { return returned -&gt; { // 如果是延迟交换机，忽略 ReturnCallback if (&quot;myDelayExchange&quot;.equals(returned.getExchange())) { log.debug(&quot;延迟消息暂存，忽略 ReturnCallback&quot;); return; } Message message = returned.getMessage(); MessageProperties properties = message.getMessageProperties(); log.error(&quot;消息无法路由到队列: [Body={}] [原因:{}] [Exchange={}] [RoutingKey={}] [Headers={}]&quot;, new String(message.getBody()), returned.getReplyText(), returned.getExchange(), returned.getRoutingKey(), properties.getHeaders()); // 这里可以添加路由失败处理逻辑，如记录到数据库等待人工干预 }; } 生产者无需修改，消费者需要修改 handleRetry() 方法，将重试消息发布到延迟交换机而不是直接重发给主队列： private void handleRetry(Message message, Channel channel, Exception e) throws IOException { // ... 原有业务逻辑 ... if (retryCount &gt;= MAX_RETRY_COUNT) { // ... 原有业务逻辑 ... } else { // ... 原有业务逻辑 ... // 计算动态延迟（指数退避：5s, 10s, 20s...） long delayMs = calculateBackoffDelay(retryCount); // 设置重试相关属性 newProps.setHeader(&quot;x-delay&quot;, delayMs); // 添加延迟头 newProps.setHeader(&quot;retryCount&quot;, retryCount + 1); // 更新重试次数 // 发布到延迟交换机 rabbitTemplate.convertAndSend( &quot;myDelayExchange&quot;, // 使用延迟交换机 &quot;myRoutingKey&quot;, // 使用主队列的 routingKey new Message(message.getBody(), newProps), m -&gt; { // 设置消息级延迟（单位：毫秒） m.getMessageProperties().setHeader(&quot;x-delay&quot;, delayMs); return m; }, new CorrelationData(headers.get(&quot;correlationId&quot;).toString()) ); // 确认原消息 channel.basicAck(originalProps.getDeliveryTag(), false); log.warn(&quot;消息将在 {}ms 后重试 (第{}次)&quot;, delayMs, retryCount + 1); } } // 指数退避算法 private long calculateBackoffDelay(int retryCount) { long baseDelay = 5000; // 基础延迟5秒 long maxDelay = 60000; // 最大延迟60秒 return Math.min(baseDelay * (1 &lt;&lt; retryCount), maxDelay); } 其他RabbitMQ命令查看持久化配置 消息持久化需要三个条件同时满足： 交换机持久化 队列持久化 消息发布时设置 properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); # 1、列出所有交换机及其属性 rabbitmqctl list_exchanges name type durable auto_delete arguments # durable 列为 true 表示交换机设置了持久化 # 2、列出所有队列及其属性 rabbitmqctl list_queues name durable auto_delete arguments # durable 列为 true 表示队列设置了持久化 # 3、查看消息持久化 (取决于发布时设置的delivery_mode：1-非持久化、2-持久化) # 获取队列中的消息详情：properties.delivery_mode (需要安装rabbitmq_management插件) # linux rabbitmqadmin get queue=&lt;queue_name&gt; count=1 # windows python rabbitmqadmin get queue=myQueue count=1 --format=raw_json 绑定关系验证： # 列出所有交换机 rabbitmqadmin list exchanges name type arguments # 列出队列 rabbitmqadmin list queues name messages # 列出绑定关系 rabbitmqadmin list bindings windows 需要从 http://localhost:15672/cli/ 下载 rabbitmqadmin，并且用 python rabbitmqadmin ... 运行命令。 消费者重试时丢失了deliveryMode=2在上面代码中，重试机制里面有段代码： // 1) 拷贝持久化设置 MessageDeliveryMode receivedMode = originalProps.getReceivedDeliveryMode(); if (receivedMode != null) { newProps.setDeliveryMode(receivedMode); } else { // 默认设置为持久化（安全策略） newProps.setDeliveryMode(MessageDeliveryMode.PERSISTENT); } 这里如果只是通过 message.getMessageProperties() 获取原消息属性 originalProps 直接设置给新消息属性 newProps，这样子就会导致新消息会丢失 deliveryMode=2 （持久化）配置信息，最后导致消息不会进行持久化了。 原因： 当生产者发送消息时，deliveryMode=2（持久化）是 AMQP 协议层的属性，保存在消息的 BasicProperties 中。 Spring AMQP 在 @RabbitListener 中会将原始 AMQP 消息转换为 Message 对象时，会丢失部分协议层属性（包括 deliveryMode）。 在 Spring AMQP 2.3 及以上版本中，可以直接通过 MessageProperties 的 getReceivedDeliveryMode() 方法获取生产者设置的原始 deliveryMode 值。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"加密存储在数据库中的数据如何进行模糊查询","slug":"加密存储在数据库中的数据如何进行模糊查询","date":"2025-03-23T12:09:26.000Z","updated":"2025-10-26T01:45:44.231Z","comments":true,"path":"2025/03/23/加密存储在数据库中的数据如何进行模糊查询/","link":"","permalink":"https://blog.xiongtianci.com/2025/03/23/加密存储在数据库中的数据如何进行模糊查询/","excerpt":"","text":"前言有些系统对于敏感信息（如：手机号码、身份证号码、家庭地址等）需要加密后将密文入库，不能明文存储。普通的加密模式下，整段内容会被整体加密，密文就不再具备被模糊查询的功能。 应用层次在应用层中实现，通过 MyBatis 的 TypeHandler 拦截数据的读写操作。 每次查询前先从数据库查询所有记录，且在内存中对加密字段进行解密，在内存中对解密后的明文进行模糊匹配。适用于加密的字段不多且数据量不大的场景。但当数据量较大时，内存消耗会非常高，性能也会受到影响。 优点 灵活性：加解密逻辑完全由应用层控制，可以自定义加密算法。 数据库无关性：不依赖数据库的加解密功能，适用于多种数据库。 缺点 性能开销：加解密操作在应用层进行，可能增加 CPU 和内存的开销。 模糊查询困难：密文存储导致无法直接在数据库中进行模糊查询。 实现通过MyBatis的TypeHandler进行加解密，并将所有数据加载到内存中进行过滤匹配。 配置MyBatis的TypeHandlerMyBatis 中的自定义类型处理器（TypeHandler），用于处理 Java 类型和 JDBC 类型之间的转换。 创建一个自定义的TypeHandler来处理手机号的加密和解密操作。 import org.apache.ibatis.type.BaseTypeHandler; import org.apache.ibatis.type.JdbcType; import org.apache.ibatis.type.MappedTypes; import org.example.utils.CryptoUtils; import java.sql.CallableStatement; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; @MappedTypes(String.class) // 指定处理的 Java 类型 public class EncryptedStringTypeHandler extends BaseTypeHandler&lt;String&gt; { @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException { try { // 写入数据库时加密 String encrypted = CryptoUtils.encrypt(parameter); ps.setString(i, encrypted); } catch (Exception e) { throw new SQLException(&quot;加密失败&quot;, e); } } @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException { String encrypted = rs.getString(columnName); try { // 从数据库读取时解密 return encrypted == null ? null : CryptoUtils.decrypt(encrypted); } catch (Exception e) { throw new SQLException(&quot;解密失败&quot;, e); } } @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException { String encrypted = rs.getString(columnIndex); try { return encrypted == null ? null : CryptoUtils.decrypt(encrypted); } catch (Exception e) { throw new SQLException(&quot;解密失败&quot;, e); } } @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException { String encrypted = cs.getString(columnIndex); try { return encrypted == null ? null : CryptoUtils.decrypt(encrypted); } catch (Exception e) { throw new SQLException(&quot;解密失败&quot;, e); } } } 使用 AES 进行加解密： import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; // 使用对称加密算法（如AES）对手机号进行加密和解密 public class CryptoUtils { private static final String KEY = &quot;1234567890123456&quot;; // 密钥，长度是 16、24或32字节 public static String encrypt(String data) throws Exception { SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(), &quot;AES&quot;); Cipher cipher = Cipher.getInstance(&quot;AES&quot;); cipher.init(Cipher.ENCRYPT_MODE, secretKey); byte[] encryptedBytes = cipher.doFinal(data.getBytes()); return Base64.getEncoder().encodeToString(encryptedBytes); } public static String decrypt(String encryptedData) throws Exception { SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(), &quot;AES&quot;); Cipher cipher = Cipher.getInstance(&quot;AES&quot;); cipher.init(Cipher.DECRYPT_MODE, secretKey); byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedData)); return new String(decryptedBytes); } } 配置MyBatis的SqlSessionFactory需要在MyBatis的配置中注册这个TypeHandler，以便MyBatis在操作数据库时使用它 import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.annotation.MapperScan; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import javax.sql.DataSource; @Configuration @MapperScan(&quot;org.example.mapper&quot;) public class MyBatisConfig { @Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper/*.xml&quot;)); // 避免 EncryptedStringTypeHandler 被全局注册 // sessionFactory.setTypeHandlers(new EncryptedStringTypeHandler()); // 注册 TypeHandler return sessionFactory.getObject(); } } 编写Mapper接口和XMLimport org.apache.ibatis.annotations.Mapper; import org.example.entity.User; import java.util.List; @Mapper public interface UserMapper { List&lt;User&gt; selectAllUsers(); void insertUser(User user); } UserMapper.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;org.example.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;UserResultMap&quot; type=&quot;org.example.entity.User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;phone&quot; column=&quot;phone&quot; typeHandler=&quot;org.example.handler.EncryptedStringTypeHandler&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectAllUsers&quot; resultMap=&quot;UserResultMap&quot;&gt; SELECT id, phone, name FROM user &lt;/select&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;org.example.entity.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO user (phone, name) VALUES (#{phone, typeHandler=org.example.handler.EncryptedStringTypeHandler}, #{name}) &lt;/insert&gt; &lt;/mapper&gt; 在 MyBatis 的 resultMap 中，通过 typeHandler 属性指定某个字段使用 EncryptedStringTypeHandler 其他service： import org.example.entity.User; import org.example.mapper.UserMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; import java.util.stream.Collectors; @Service public class UserService { @Autowired private UserMapper userMapper; public List&lt;User&gt; queryByPhonePattern(String phonePattern) { // 查询所有用户（MyBatis 会自动解密） List&lt;User&gt; allUsers = userMapper.selectAllUsers(); // 在内存中模糊匹配 return allUsers.stream() .filter(user -&gt; user.getPhone().contains(phonePattern)) .collect(Collectors.toList()); } public void addUser(User user) { userMapper.insertUser(user); } } java bean： public class User { private Long id; private String phone; private String name; // Getters and Setters } sql： CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `phone` varchar(255) COLLATE utf8mb4_bin NOT NULL COMMENT &#39;加密后的手机号&#39;, `name` varchar(50) COLLATE utf8mb4_bin DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin; 启动类： @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 测试： import org.example.entity.User; import org.example.service.UserService; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; @SpringBootTest(classes = Application.class) public class UserServiceTest { @Autowired private UserService userService; @Test public void testAddAndQueryUser() { // 添加用户 User user = new User(); user.setPhone(&quot;13800138000&quot;); // 明文手机号 user.setName(&quot;张三&quot;); userService.addUser(user); // 查询用户 List&lt;User&gt; users = userService.queryByPhonePattern(&quot;138&quot;); assertFalse(users.isEmpty()); assertEquals(&quot;13800138000&quot;, users.get(0).getPhone()); // 解密后的手机号 } } 基于数据库函数在数据库层实现，通过数据库的加解密函数（如 MySQL 的 AES_ENCRYPT 和 AES_DECRYPT）对数据进行加解密。 在插入数据时，调用数据库的加密函数对敏感字段（如手机号）进行加密存储。在查询数据时，调用数据库的解密函数对加密字段进行解密，然后再进行模糊匹配。 不同的数据库提供了不同的加密函数，例如： MySQL：AES_ENCRYPT 和 AES_DECRYPT PostgreSQL：pgp_sym_encrypt 和 pgp_sym_decrypt Oracle：DBMS_CRYPTO 优点 简化应用层代码：加解密逻辑由数据库处理，应用层无需关心加解密细节。 支持模糊查询：可以通过数据库函数实现模糊查询（如 AES_DECRYPT(column) LIKE &#39;%...%&#39;） 缺点 数据库依赖：依赖数据库的加解密功能，切换数据库时可能需要调整实现。 性能开销：加解密操作在数据库层进行，可能增加数据库的 CPU 和内存开销。 密钥管理：密钥需要在数据库 SQL 语句中传递，存在泄露风险。 MySQL 的 AES_ENCRYPT 和 AES_DECRYPT 函数使用的是 AES 加密算法，支持的密钥长度如下： 128 位密钥：16 个字符（例如：1234567890123456） 192 位密钥：24 个字符（例如：123456789012345678901234） 256 位密钥：32 个字符（例如：12345678901234567890123456789012） -- 插入数据时加密 INSERT INTO user (phone, name) VALUES (AES_ENCRYPT(&#39;13800138000&#39;, &#39;my_secret_key&#39;), &#39;张三&#39;); -- 查询数据时解密并模糊匹配 SELECT * FROM user WHERE AES_DECRYPT(phone, &#39;my_secret_key&#39;) LIKE &#39;%138%&#39;; 也可以使用 MySQL 的 HEX 函数将二进制数据转换为十六进制字符串，存储到 VARCHAR 字段中。查询时，使用 UNHEX 函数将十六进制字符串转换回二进制数据。 INSERT INTO user (phone, name) VALUES (HEX(AES_ENCRYPT(&#39;13800138000&#39;, &#39;my_secret_key&#39;)), &#39;张三&#39;); SELECT id, AES_DECRYPT(UNHEX(phone), &#39;my_secret_key&#39;) AS phone, name FROM user WHERE AES_DECRYPT(UNHEX(phone), &#39;my_secret_key&#39;) LIKE &#39;%8001%&#39;; 如果使用 HEX 函数，加密后的数据长度会翻倍（因为每个字节转换为 2 个十六进制字符），转换后的字符串长度是原始二进制数据长度的 2 倍。 实现需要将 phone 字段的类型改为 BLOB 或 VARBINARY，以支持存储二进制数据。 CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `phone` varbinary(128) DEFAULT NULL, `name` varchar(50) COLLATE utf8mb4_bin DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin; java bean： public class User { private Long id; private String phone; private String name; } mapper： import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; import org.example.entity.User; import java.util.List; @Mapper public interface UserMapper { void insertUser(@Param(&quot;phone&quot;) String phone, @Param(&quot;name&quot;) String name); List&lt;User&gt; queryByPhonePattern(@Param(&quot;phonePattern&quot;) String phonePattern); } mapper xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;org.example.mapper.UserMapper&quot;&gt; &lt;insert id=&quot;insertUser&quot;&gt; INSERT INTO user (phone, name) VALUES (AES_ENCRYPT(#{phone}, &#39;1234567890123456&#39;), #{name}) &lt;/insert&gt; &lt;select id=&quot;queryByPhonePattern&quot; resultType=&quot;org.example.entity.User&quot;&gt; SELECT id, AES_DECRYPT(phone, &#39;1234567890123456&#39;) AS phone, name FROM user WHERE AES_DECRYPT(phone, &#39;1234567890123456&#39;) LIKE CONCAT(&#39;%&#39;, #{phonePattern}, &#39;%&#39;) &lt;/select&gt; &lt;/mapper&gt; service： import org.example.entity.User; import org.example.mapper.UserMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserService { @Autowired private UserMapper userMapper; public void addUser(String phone, String name) { userMapper.insertUser(phone, name); } public List&lt;User&gt; queryByPhonePattern(String phonePattern) { return userMapper.queryByPhonePattern(phonePattern); } } 配置： # 数据源配置 spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC spring.datasource.username=root spring.datasource.password=1234 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # MyBatis 配置 mybatis.mapper-locations=classpath:mapper/*.xml mybatis.type-aliases-package=org.example.entity # 开启驼峰命名映射 mybatis.configuration.map-underscore-to-camel-case=true mybatis.type-handlers-package=org.example.handler # MyBatis 日志 logging.level.org.mybatis=DEBUG logging.level.org.example.mapper=DEBUG 启动类： @SpringBootApplication @MapperScan(&quot;org.example.mapper&quot;) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 测试： import org.example.entity.User; import org.example.service.UserService; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; @SpringBootTest(classes = Application.class) public class UserServiceTest { @Autowired private UserService userService; @Test public void testAddAndQueryUser() { // 添加用户 userService.addUser(&quot;13800138000&quot;, &quot;张三&quot;); // 查询用户 List&lt;User&gt; users = userService.queryByPhonePattern(&quot;138&quot;); assertFalse(users.isEmpty()); // 验证查询结果 User queriedUser = users.get(0); assertEquals(&quot;13800138000&quot;, queriedUser.getPhone()); // 解密后的手机号 assertEquals(&quot;张三&quot;, queriedUser.getName()); } } 基于分词密文映射表基于 分词密文映射表 的模糊查询方案，核心思想是将敏感字段拆分为多个分词，对每个分词进行加密，并建立分词密文与目标数据行的关联关系。在查询时，对查询关键字进行加密，通过分词密文映射表进行模糊匹配，最终返回目标数据。 优点 支持模糊查询：通过分词密文映射表实现模糊查询。 灵活性：分词规则和加密算法可以自定义。 缺点 存储开销：分词密文映射表会显著增加存储空间。 性能开销：分词和加密操作在应用层进行，查询时需要多次数据库交互。 实现复杂度：需要维护分词密文映射表，增加了系统复杂性。 如果分词长度过短（如 2 个字符），攻击者可以通过穷举法（暴力破解）轻易猜测出分词内容，从而破解加密数据。分词长度越长，单个字段生成的分词数量越少，从而减少分词密文映射表的数据量。分词长度通常为 4 个英文字符（半角） 或 2 个中文字符（全角），在安全性和查询效率之间取得较好的平衡。 思路 数据存储 目标表：存储原始数据，包含敏感字段（如手机号）。 分词密文映射表：存储敏感字段的分词密文与目标表主键的关联关系。 分词规则 对敏感字段进行固定长度的分词（如 4 个字符一组）。 例如，手机号 15503770537 的分词结果为： 1550 5503 5037 0377 3770 7705 7053 0537 加密分词 对每个分词进行加密，生成密文。 例如，1550 加密后为 abc123，5503 加密后为 def456 查询流程 对查询关键字进行分词和加密。 在分词密文映射表中，使用 LIKE 查询匹配的密文。 根据匹配的密文，获取目标表的主键。 根据主键，从目标表中查询完整数据。 实现目标表，存储用户信息，包含手机号等敏感字段： CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键 phone VARCHAR(16) NOT NULL, -- 手机号（明文存储） name VARCHAR(64) NOT NULL -- 用户名 ); 分词密文映射表，存储手机号的分词密文与用户主键的关联关系： CREATE TABLE phone_index ( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键 user_id INT NOT NULL, -- 关联的用户 ID token_cipher VARCHAR(128) NOT NULL -- 分词密文 ); java bean： public class PhoneIndex { private Long id; private Long userId; private String tokenCipher; } public class User { private Long id; private String phone; private String name; } mapper： @Mapper public interface PhoneIndexMapper { void batchInsertPhoneIndex(@Param(&quot;list&quot;) List&lt;PhoneIndex&gt; phoneIndices); List&lt;Integer&gt; findUserIdsByTokenCipher(@Param(&quot;tokenCipher&quot;) String tokenCipher); } @Mapper public interface UserMapper { void insertUser(User user); List&lt;User&gt; selectUsersByIds(@Param(&quot;userIds&quot;) List&lt;Integer&gt; userIds); } mapper xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;org.example.mapper.PhoneIndexMapper&quot;&gt; &lt;insert id=&quot;batchInsertPhoneIndex&quot;&gt; INSERT INTO phone_index (user_id, token_cipher) VALUES &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt; (#{item.userId}, #{item.tokenCipher}) &lt;/foreach&gt; &lt;/insert&gt; &lt;select id=&quot;findUserIdsByTokenCipher&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT DISTINCT user_id FROM phone_index WHERE token_cipher LIKE CONCAT(&#39;%&#39;, #{tokenCipher}, &#39;%&#39;) &lt;/select&gt; &lt;/mapper&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;org.example.mapper.UserMapper&quot;&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;org.example.entity.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO user (phone, name) VALUES (#{phone}, #{name}) &lt;/insert&gt; &lt;select id=&quot;selectUsersByIds&quot; resultType=&quot;org.example.entity.User&quot;&gt; SELECT id, phone, name FROM user WHERE id IN &lt;foreach collection=&quot;userIds&quot; item=&quot;userId&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{userId} &lt;/foreach&gt; &lt;/select&gt; &lt;/mapper&gt; service： import org.example.entity.PhoneIndex; import org.example.entity.User; import org.example.mapper.PhoneIndexMapper; import org.example.mapper.UserMapper; import org.example.utils.CryptoUtils; import org.example.utils.Tokenizer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.ArrayList; import java.util.List; @Service public class UserService { @Autowired private UserMapper userMapper; @Autowired private PhoneIndexMapper phoneIndexMapper; @Transactional public void addUser(User user) { // 插入用户信息 userMapper.insertUser(user); // 对手机号进行分词和加密 List&lt;String&gt; tokens = Tokenizer.tokenize(user.getPhone(), 4); List&lt;PhoneIndex&gt; phoneIndices = new ArrayList&lt;&gt;(); for (String token : tokens) { String tokenCipher = null; try { tokenCipher = CryptoUtils.encrypt(token); } catch (Exception e) { throw new RuntimeException(&quot;解密失败&quot;, e); } phoneIndices.add(new PhoneIndex(user.getId(), tokenCipher)); } // 批量插入分词密文 phoneIndexMapper.batchInsertPhoneIndex(phoneIndices); } /** * 根据手机号模糊查询用户 * * @param phonePattern 手机号查询关键字 * @return 用户列表 */ public List&lt;User&gt; queryByPhonePattern(String phonePattern) { // 对查询关键字进行加密 String patternCipher = null; try { patternCipher = CryptoUtils.encrypt(phonePattern); } catch (Exception e) { throw new RuntimeException(&quot;加密失败&quot;, e); } // 在分词密文映射表中进行模糊查询 List&lt;Integer&gt; userIds = phoneIndexMapper.findUserIdsByTokenCipher(patternCipher); // 根据用户 ID 查询用户信息 return userMapper.selectUsersByIds(userIds); } } 分词工具类： import java.util.ArrayList; import java.util.List; public class Tokenizer { /** * 对字符串进行固定长度的分词 * * @param input 输入字符串 * @param length 分词长度 * @return 分词结果列表 */ public static List&lt;String&gt; tokenize(String input, int length) { List&lt;String&gt; tokens = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= input.length() - length; i++) { tokens.add(input.substring(i, i + length)); } return tokens; } } 加密工具类： import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; // 使用对称加密算法（如AES）对手机号进行加密和解密 public class CryptoUtils { private static final String KEY = &quot;1234567890123456&quot;; // 密钥，长度是 16、24或32字节 public static String encrypt(String data) throws Exception { SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(), &quot;AES&quot;); Cipher cipher = Cipher.getInstance(&quot;AES&quot;); cipher.init(Cipher.ENCRYPT_MODE, secretKey); byte[] encryptedBytes = cipher.doFinal(data.getBytes()); return Base64.getEncoder().encodeToString(encryptedBytes); } public static String decrypt(String encryptedData) throws Exception { SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(), &quot;AES&quot;); Cipher cipher = Cipher.getInstance(&quot;AES&quot;); cipher.init(Cipher.DECRYPT_MODE, secretKey); byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedData)); return new String(decryptedBytes); } } 启动类： import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.transaction.annotation.EnableTransactionManagement; @SpringBootApplication @EnableTransactionManagement @MapperScan(&quot;org.example.mapper&quot;) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 配置： # 数据源配置 spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC spring.datasource.username=root spring.datasource.password=1234 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # MyBatis 配置 mybatis.mapper-locations=classpath:mapper/*.xml mybatis.type-aliases-package=org.example.entity # 开启驼峰命名映射 mybatis.configuration.map-underscore-to-camel-case=true mybatis.type-handlers-package=org.example.handler # MyBatis 日志 logging.level.org.mybatis=DEBUG logging.level.org.example.mapper=DEBUG 测试： import org.example.entity.User; import org.example.service.UserService; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertFalse; @SpringBootTest(classes = Application.class) public class UserServiceTest { @Autowired private UserService userService; @Test public void testAddAndQueryUser() { // 添加用户 User user = new User(); user.setPhone(&quot;15503770537&quot;); // 明文手机号 user.setName(&quot;张三&quot;); userService.addUser(user); // 查询用户 List&lt;User&gt; users = userService.queryByPhonePattern(&quot;5503&quot;); assertFalse(users.isEmpty()); assertEquals(&quot;15503770537&quot;, users.get(0).getPhone()); // 验证查询结果 } } 参考 阿里巴巴：密文字段检索方案 京东：加解密对接的典型方案","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"分布式锁的几种实现方案","slug":"分布式锁的几种实现方案","date":"2025-03-21T01:48:29.000Z","updated":"2025-10-26T01:45:44.215Z","comments":true,"path":"2025/03/21/分布式锁的几种实现方案/","link":"","permalink":"https://blog.xiongtianci.com/2025/03/21/分布式锁的几种实现方案/","excerpt":"","text":"基于MySQL悲观锁通过 select ... for update 实现 原理： 利用数据库的唯一索引特性，通过插入一条记录来获取锁，删除记录来释放锁。 实现： 创建一张锁表，包含资源名称和唯一索引。 获取锁时，尝试插入一条记录；如果插入成功，则获取锁；如果插入失败（唯一索引冲突），则锁已被占用。 释放锁时，删除对应的记录。 优点： 实现简单，依赖数据库。 缺点： 性能较差，不适合高并发场景。 需要处理数据库连接和事务问题。 CREATE TABLE `distributed_lock` ( `key_resource` varchar(64) NOT NULL COMMENT &#39;资源键&#39;, `status` enum(&#39;S&#39;,&#39;F&#39;,&#39;P&#39;) NOT NULL DEFAULT &#39;F&#39; COMMENT &#39;状态：S（成功）、F（失败）、P（处理中）&#39;, `lock_flag` tinyint(1) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;锁标志：1（已锁）、0（未锁）&#39;, `begin_time` datetime(3) DEFAULT NULL COMMENT &#39;开始时间（毫秒精度）&#39;, `end_time` datetime(3) DEFAULT NULL COMMENT &#39;结束时间（毫秒精度）&#39;, `client_ip` varchar(45) DEFAULT NULL COMMENT &#39;抢到锁的客户端IP地址&#39;, `timeout` int(10) unsigned DEFAULT NULL COMMENT &#39;锁的超时时间（单位：秒）&#39;, PRIMARY KEY (`key_resource`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;分布式锁表&#39;; import com.zaxxer.hikari.HikariConfig; import com.zaxxer.hikari.HikariDataSource; import java.sql.*; // MySQL 驱动坐标：mysql:mysql-connector-java:8.0.22 public class UniqueIndexDistributedLock { /** * 尝试获取锁 * * @param keyResource 资源键 * @param clientIp 客户端IP地址 * @param timeoutSeconds 锁的超时时间（单位：秒） * @return 是否获取成功 */ public boolean tryLock(String keyResource, String clientIp, int timeoutSeconds) { String selectSql = &quot;SELECT * FROM distributed_lock WHERE key_resource = ? FOR UPDATE&quot;; String insertSql = &quot;INSERT INTO distributed_lock (key_resource, status, lock_flag, begin_time, client_ip, timeout) VALUES (?, &#39;P&#39;, 1, NOW(3), ?, ?)&quot;; String updateSql = &quot;UPDATE distributed_lock SET lock_flag = 1, status = &#39;P&#39;, begin_time = NOW(3), client_ip = ?, timeout = ? WHERE key_resource = ?&quot;; try (Connection connection = DataSourceUtil.getConnection()) { connection.setAutoCommit(false); // 开启事务 try (PreparedStatement selectStatement = connection.prepareStatement(selectSql)) { selectStatement.setString(1, keyResource); try (ResultSet rs = selectStatement.executeQuery()) { if (rs.next()) { // 检查锁是否已被占用 int lockFlag = rs.getInt(&quot;lock_flag&quot;); if (lockFlag == 1) { // 检查锁是否已超时 long beginTime = rs.getTimestamp(&quot;begin_time&quot;).getTime(); long currentTime = System.currentTimeMillis(); if (currentTime - beginTime &lt; rs.getInt(&quot;timeout&quot;) * 1000L) { connection.rollback(); return false; // 锁已被占用且未超时 } } // 锁已超时或未占用，更新锁 try (PreparedStatement updateStatement = connection.prepareStatement(updateSql)) { updateStatement.setString(1, clientIp); updateStatement.setInt(2, timeoutSeconds); updateStatement.setString(3, keyResource); updateStatement.executeUpdate(); } } else { // 插入新锁 try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) { insertStatement.setString(1, keyResource); insertStatement.setString(2, clientIp); insertStatement.setInt(3, timeoutSeconds); insertStatement.executeUpdate(); } } } } connection.commit(); // 提交事务 return true; } catch (SQLException e) { throw new RuntimeException(&quot;获取锁失败&quot;, e); } } /** * 释放锁 * * @param keyResource 资源键 */ public void unlock(String keyResource) { String sql = &quot;UPDATE distributed_lock SET lock_flag = 0, status = &#39;S&#39;, end_time = NOW(3) WHERE key_resource = ?&quot;; try (Connection connection = DataSourceUtil.getConnection(); PreparedStatement statement = connection.prepareStatement(sql)) { statement.setString(1, keyResource); statement.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(&quot;释放锁失败&quot;, e); } } // 测试 public static void main(String[] args) throws SQLException { UniqueIndexDistributedLock lock = new UniqueIndexDistributedLock(); String keyResource = &quot;resource_1&quot;; String clientIp = &quot;192.168.1.1&quot;; int timeoutSeconds = 10; // 锁的超时时间为 10 秒 if (lock.tryLock(keyResource, clientIp, timeoutSeconds)) { try { System.out.println(&quot;获取锁成功，执行业务逻辑...&quot;); Thread.sleep(5000); // 模拟业务逻辑 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(keyResource); System.out.println(&quot;释放锁成功&quot;); } } else { System.out.println(&quot;获取锁失败&quot;); } } } // 是用 HikariCP 连接池来管理数据库连接，避免频繁创建和关闭连接 // 适配 Java 8，使用 HikariCP 4.x 版本: com.zaxxer:HikariCP:4.0.3 class DataSourceUtil { private static final HikariDataSource dataSource; static { HikariConfig config = new HikariConfig(); config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&quot;); config.setUsername(&quot;root&quot;); config.setPassword(&quot;1234&quot;); config.setMaximumPoolSize(10); // 根据需求调整 dataSource = new HikariDataSource(config); } public static Connection getConnection() throws SQLException { return dataSource.getConnection(); } } 乐观锁 原理： 通过版本号或时间戳实现乐观锁。 实现： 在数据表中增加一个版本号字段。 获取锁时，读取当前版本号，更新时检查版本号是否一致。 如果版本号一致，则更新成功并获取锁；否则，获取锁失败。 优点： 避免悲观锁的性能问题。 缺点： 需要重试机制，可能增加复杂度。 在商品表中添加一个 version 字段，表示数据的版本号；每次更新库存时，检查版本号是否匹配： CREATE TABLE `product` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;商品ID&#39;, `name` varchar(255) NOT NULL COMMENT &#39;商品名称&#39;, `stock` int(10) NOT NULL COMMENT &#39;库存数量&#39;, `version` int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;版本号&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;商品表&#39;; 更新库存的 SQL： UPDATE product SET stock = stock - 1, version = version + 1 WHERE id = ? AND version = ? AND stock &gt; 0; public boolean reduceStock(long productId, int quantity) { String selectSql = &quot;SELECT stock, version FROM product WHERE id = ?&quot;; String updateSql = &quot;UPDATE product SET stock = stock - ?, version = version + 1 WHERE id = ? AND version = ? AND stock &gt;= ?&quot;; try (Connection connection = DataSourceUtil.getConnection(); PreparedStatement selectStatement = connection.prepareStatement(selectSql)) { selectStatement.setLong(1, productId); try (ResultSet rs = selectStatement.executeQuery()) { if (rs.next()) { int stock = rs.getInt(&quot;stock&quot;); int version = rs.getInt(&quot;version&quot;); if (stock &gt;= quantity) { try (PreparedStatement updateStatement = connection.prepareStatement(updateSql)) { updateStatement.setInt(1, quantity); updateStatement.setLong(2, productId); updateStatement.setInt(3, version); updateStatement.setInt(4, quantity); int rows = updateStatement.executeUpdate(); return rows &gt; 0; // 更新成功表示库存扣减成功 } } } } return false; // 库存不足或版本号不匹配 } catch (SQLException e) { throw new RuntimeException(&quot;库存扣减失败&quot;, e); } } 基于Redis 原理： 利用 Redis 的 SETNX（SET if Not eXists）命令实现锁的获取和释放。 实现： 获取锁时，使用 SETNX 设置一个键值对，并设置过期时间（避免死锁）。 释放锁时，删除对应的键。 优化： 使用 Redlock 算法（Redis 官方推荐的分布式锁算法），通过多个 Redis 实例实现高可用。 优点： 性能高，适合高并发场景。 缺点： 需要处理锁的过期时间和续期问题。 基于 SETNX 的实现使用 SETNX（SET if Not eXists）命令尝试设置一个键值对。如果键不存在，则设置成功，获取锁；否则，获取锁失败。 Redis 在 2.6.12 版本之前，set 不支持 nx 参数，只能通过 setnx + expire 完成一个锁 import redis.clients.jedis.Jedis; public class DistributedLock { private Jedis jedis; public DistributedLock(Jedis jedis) { this.jedis = jedis; } /** * 尝试获取锁 * * @param lockKey 分布式锁的键 * @param requestId 请求标识（用于释放锁时验证） * @param expireTime 失效时间，单位毫秒 * @return */ public boolean tryLock(String lockKey, String requestId, long expireTime) { long result = jedis.setnx(lockKey, requestId); if (result == 1) { // 设置锁的过期时间，避免死锁 jedis.pexpire(lockKey, expireTime); return true; } return false; } private static final String UNLOCK_SCRIPT = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then &quot; + &quot; return redis.call(&#39;del&#39;, KEYS[1]) &quot; + &quot;else &quot; + &quot; return 0 &quot; + &quot;end&quot;; public boolean unlock(String lockKey, String requestId) { // 使用 Lua 脚本保证原子性 // 只有在锁的值与 requestId 匹配时才会删除锁，避免误删其他请求的锁 Object result = jedis.eval(UNLOCK_SCRIPT, 1, lockKey, requestId); // Lua 脚本返回 1 表示解锁成功，返回 0 表示解锁失败 return Long.valueOf(1).equals(result); } // 测试代码 public static void main(String[] args) { Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); DistributedLock lock = new DistributedLock(jedis); String lockKey = &quot;distributed_lock&quot;; String requestId = &quot;request_123&quot;; long expireTime = 5000; if (lock.tryLock(lockKey, requestId, expireTime)) { try { System.out.println(&quot;获取锁成功，执行业务逻辑...&quot;); // 模拟业务逻辑 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } finally { if (lock.unlock(lockKey, requestId)) System.out.println(&quot;释放锁成功&quot;); else System.out.println(&quot;释放锁失败&quot;); } } else { System.out.println(&quot;获取锁失败&quot;); } } } 问题：加锁操作和设置超时时间是分开的，不是原子操作。 Redis 支持通过 Lua 脚本执行多个命令，这些命令在 Redis 中是原子执行的。Lua 脚本 UNLOCK_SCRIPT： if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end KEYS[1] 是传入的锁键（lockKey） ARGV[1] 是传入的请求标识（requestId） 基于 SET 的实现使用 SET 命令的 NX（Not eXists）和 PX（毫秒级过期时间）选项，实现原子性的锁获取和过期时间设置。 NX：表示 “Only set the key if it does not already exist”（仅当键不存在时才设置）。 如果键已经存在，则 SET 命令不会执行任何操作，返回 nil。 如果键不存在，则设置键的值，并返回 OK。 PX：表示 “Set the specified expire time, in milliseconds”（设置键的过期时间，单位为毫秒）。 XX：表示 “Only set the key if it already exists”（仅当键存在时才设置）。 如果键不存在，则 SET 命令不会执行任何操作，返回 nil。 如果键存在，则设置键的值，并返回 OK。 EX：表示 “Set the specified expire time, in seconds”（设置键的过期时间，单位为秒）。 KEEPTTL：表示 “Retain the time to live associated with the key”（保留键的剩余过期时间）。 如果键已经设置了过期时间，使用 KEEPTTL 可以保留原有的过期时间。 加锁： SET lock_key lock_value NX PX 10000 解锁，使用 Lua 脚本确保解锁操作的原子性： if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then return redis.call(&quot;del&quot;, KEYS[1]) else return 0 end 需要考虑的问题： 问题一：锁过期释放了，业务还没执行完。如果业务逻辑执行时间超过了锁的过期时间（LOCK_EXPIRE_TIME），锁会自动释放，导致其他客户端可以获取锁，从而引发并发问题。 解决：锁续期（Watchdog 机制），在业务逻辑执行期间，定期（如每隔 10 秒）检查锁是否仍然持有，并延长锁的过期时间。可以使用 Redis 的 PEXPIRE 命令实现锁续期。 问题二：锁被别的线程误删。如果客户端 A 获取锁后，由于某些原因（如长时间 GC 或网络延迟）未能及时释放锁，锁过期后被客户端 B 获取；客户端 A 恢复后，可能会误删客户端 B 的锁。 解决：在设置锁时，为每个客户端生成一个唯一的标识（如 UUID），并将其作为锁的值。释放锁时，先检查锁的值是否与当前客户端的标识一致，只有一致时才删除锁。 解决锁误删问题： public boolean tryLock(String requestId) { SetParams params = SetParams.setParams().nx().px(LOCK_EXPIRE_TIME); String result = jedis.set(LOCK_KEY, requestId, params); return &quot;OK&quot;.equals(result); } public void unlock(String requestId) { // 使用 Lua 脚本保证原子性 String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;; jedis.eval(script, 1, LOCK_KEY, requestId); } 每个客户端使用唯一的 requestId 作为锁的值，避免锁的值冲突。只有当前客户端持有锁（即锁的值与 requestId 匹配）时，才允许删除锁。 测试： Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); RedisDistributedLock lock = new RedisDistributedLock(jedis); String requestId1 = &quot;request_123&quot;; String requestId2 = &quot;request_456&quot;; // 客户端 A 获取锁 if (lock.tryLock(requestId1)) { System.out.println(&quot;客户端 A 获取锁成功&quot;); // 模拟客户端 B 尝试获取锁 if (lock.tryLock(requestId2)) { System.out.println(&quot;客户端 B 获取锁成功&quot;); } else { System.out.println(&quot;客户端 B 获取锁失败&quot;); } // 客户端 A 释放锁 lock.unlock(requestId1); System.out.println(&quot;客户端 A 释放锁&quot;); // 客户端 B 再次尝试获取锁 if (lock.tryLock(requestId2)) { System.out.println(&quot;客户端 B 获取锁成功&quot;); lock.unlock(requestId2); System.out.println(&quot;客户端 B 释放锁&quot;); } else { System.out.println(&quot;客户端 B 获取锁失败&quot;); } } else { System.out.println(&quot;客户端 A 获取锁失败&quot;); } 解决锁过期+锁误删问题： import redis.clients.jedis.Jedis; import redis.clients.jedis.params.SetParams; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class RedisDistributedLockWithWatchdog { private static final String LOCK_KEY = &quot;distributed_lock&quot;; private static final int LOCK_EXPIRE_TIME = 5000; // 锁的过期时间（毫秒） private static final int WATCHDOG_INTERVAL = 4000; // 锁续期间隔（毫秒） private Jedis jedis; private ScheduledExecutorService watchdogExecutor; private String requestId; public RedisDistributedLockWithWatchdog(Jedis jedis) { this.jedis = jedis; this.watchdogExecutor = Executors.newSingleThreadScheduledExecutor(); } /** * 尝试获取锁 * * @param requestId 请求标识 * @return 是否获取成功 */ public boolean tryLock(String requestId) { this.requestId = requestId; SetParams params = SetParams.setParams().nx().px(LOCK_EXPIRE_TIME); if (&quot;OK&quot;.equals(jedis.set(LOCK_KEY, requestId, params))) { // 启动 Watchdog 定期续期 watchdogExecutor.scheduleAtFixedRate(this::renewLock, WATCHDOG_INTERVAL, WATCHDOG_INTERVAL, TimeUnit.MILLISECONDS); return true; } return false; } /** * 锁续期 */ private void renewLock() { // 使用 Lua 脚本保证原子性 String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]) else return 0 end&quot;; jedis.eval(script, 1, LOCK_KEY, requestId, String.valueOf(LOCK_EXPIRE_TIME)); } /** * 释放锁 */ public void unlock() { // 使用 Lua 脚本保证原子性 String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;; jedis.eval(script, 1, LOCK_KEY, requestId); watchdogExecutor.shutdown(); // 停止 Watchdog } } 通过一个后台线程（Watchdog）定期检查锁的状态，并在锁即将过期时延长其过期时间，从而避免锁在业务逻辑执行期间过期。 使用 ScheduledExecutorService 定期执行锁续期任务。 每隔 WATCHDOG_INTERVAL 时间，检查锁是否仍然持有，并延长锁的过期时间。 测试： Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); RedisDistributedLockWithWatchdog lock = new RedisDistributedLockWithWatchdog(jedis); String requestId = &quot;request_123&quot;; if (lock.tryLock(requestId)) { try { System.out.println(&quot;获取锁成功，执行业务逻辑...&quot;); // 模拟业务逻辑 Thread.sleep(15000); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); System.out.println(&quot;释放锁成功&quot;); } } else { System.out.println(&quot;获取锁失败&quot;); } 通过 redis&gt; TTL key_name 可以 key 的剩余过期时间（单位为秒）。当 key 不存在时，返回 -2 ；当 key 存在但没有设置剩余生存时间时，返回 -1。 参数 设置规则 推荐值 LOCK_EXPIRE_TIME 大于业务逻辑的最长执行时间，通常为 1.5 倍到 2 倍。 例如，业务逻辑最长 10 秒，设置为 15 秒到 20 秒。 WATCHDOG_INTERVAL 小于 LOCK_EXPIRE_TIME，通常为 LOCK_EXPIRE_TIME 的 1/3 到 1/2。 例如，LOCK_EXPIRE_TIME 为 30 秒，设置为 10 秒到 15 秒。 优化 使用 JedisPool 来管理 Redis 连接，避免频繁创建和销毁连接带来的性能开销，同时也能防止连接泄漏： import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; import redis.clients.jedis.params.SetParams; // Jedis 3.x 及以上版本 public class DistributedLock { private final JedisPool jedisPool; public DistributedLock(String host, int port) { JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(100); // 最大连接数 poolConfig.setMaxIdle(50); // 最大空闲连接数 poolConfig.setMinIdle(10); // 最小空闲连接数 poolConfig.setTestOnBorrow(true); // 获取连接时测试有效性 poolConfig.setTestWhileIdle(true); // 空闲时定期测试有效性 this.jedisPool = new JedisPool(poolConfig, host, port); } /** * 尝试获取锁 * * @param lockKey 分布式锁的键 * @param requestId 请求标识（用于释放锁时验证） * @param expireTime 失效时间，单位毫秒 * @return */ public boolean tryLock(String lockKey, String requestId, long expireTime) { try (Jedis jedis = jedisPool.getResource()) { SetParams params = SetParams.setParams().nx().px(expireTime); String result = jedis.set(lockKey, requestId, params); return &quot;OK&quot;.equals(result); } } private static final String UNLOCK_SCRIPT = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then &quot; + &quot; return redis.call(&#39;del&#39;, KEYS[1]) &quot; + &quot;else &quot; + &quot; return 0 &quot; + &quot;end&quot;; public boolean unlock(String lockKey, String requestId) { try (Jedis jedis = jedisPool.getResource()) { // 使用 Lua 脚本保证原子性 // 只有在锁的值与 requestId 匹配时才会删除锁，避免误删其他请求的锁 Object result = jedis.eval(UNLOCK_SCRIPT, 1, lockKey, requestId); // Lua 脚本返回 1 表示解锁成功，返回 0 表示解锁失败 return Long.valueOf(1).equals(result); } } public void close() { if (jedisPool != null &amp;&amp; !jedisPool.isClosed()) { jedisPool.close(); } } // 测试代码 public static void main(String[] args) { DistributedLock lock = new DistributedLock(&quot;localhost&quot;, 6379); try { String lockKey = &quot;distributed_lock&quot;; String requestId = &quot;request_123&quot;; long expireTime = 5000; boolean lockAcquired = lock.tryLock(lockKey, requestId, expireTime); if (lockAcquired) { System.out.println(&quot;获取锁成功，执行业务逻辑...&quot;); try { // 模拟业务逻辑 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } finally { boolean unlockSuccess = lock.unlock(lockKey, requestId); if (unlockSuccess) System.out.println(&quot;释放锁成功&quot;); else System.out.println(&quot;释放锁失败&quot;); } } else { System.out.println(&quot;获取锁失败&quot;); } } catch (Exception e) { e.printStackTrace(); } finally { // 关闭连接池 lock.close(); System.out.println(&quot;连接池已关闭&quot;); } } } 配置合理的连接池参数 maxTotal：连接池的最大连接数。根据业务并发量和 Redis 服务器的性能设置。 maxIdle：连接池中最大空闲连接数。 minIdle：连接池中最小空闲连接数。 testOnBorrow：在从连接池获取连接时，是否测试连接的有效性。 testWhileIdle：在连接空闲时，是否定期测试连接的有效性。 基于 Redlock 的实现Redlock 是 Redis 官方推荐的分布式锁算法，它的核心思想是通过多个独立的 Redis 实例来实现锁的获取和释放，从而避免单点故障问题。获取锁时，需要在大多数 Redis 实例上成功获取锁，才算真正获取锁。 Redlock 的步骤： 获取当前时间：记录获取锁的开始时间。 依次尝试获取锁： 向多个独立的 Redis 实例发送 SET 命令，尝试获取锁。 每个实例的锁设置相同的 key、value 和过期时间。 计算获取锁的时间： 计算从开始获取锁到成功获取锁所花费的时间。 如果获取锁的时间小于锁的过期时间，并且成功获取锁的实例数超过半数，则认为获取锁成功。 检查是否满足以下条件： 成功获取锁的实例数超过半数。 获取锁的时间 elapsedTime 小于锁的过期时间 expireTime。 释放锁： 向所有 Redis 实例发送 DEL 命令，释放锁。 Redlock 的实现： import redis.clients.jedis.Jedis; import redis.clients.jedis.params.SetParams; import java.util.Arrays; import java.util.List; public class RedlockDistributedLock { private static final int LOCK_EXPIRE_TIME = 30000; // 锁的过期时间（毫秒） private static final int RETRY_COUNT = 3; // 重试次数 private static final int RETRY_DELAY = 200; // 重试延迟（毫秒） private List&lt;Jedis&gt; jedisList; public RedlockDistributedLock(List&lt;Jedis&gt; jedisList) { this.jedisList = jedisList; } public boolean tryLock(String lockKey, String requestId, long expireTime) { int successCount = 0; for (int i = 0; i &lt; RETRY_COUNT; i++) { for (Jedis jedis : jedisList) { SetParams params = SetParams.setParams().nx().px(expireTime); if (&quot;OK&quot;.equals(jedis.set(lockKey, requestId, params))) { successCount++; } } if (successCount &gt; jedisList.size() / 2) { return true; } // 重试前等待（不是最佳实现，会阻塞当前线程） // 防止客户端在获取锁失败后立即重试， try { Thread.sleep(RETRY_DELAY); } catch (InterruptedException e) { e.printStackTrace(); } } return false; } private static final String UNLOCK_SCRIPT = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then &quot; + &quot; return redis.call(&#39;del&#39;, KEYS[1]) &quot; + &quot;else &quot; + &quot; return 0 &quot; + &quot;end&quot;; public void unlock(String lockKey, String requestId) { for (Jedis jedis : jedisList) { jedis.eval(UNLOCK_SCRIPT, 1, lockKey, requestId); } } // 测试 public static void main(String[] args) { List&lt;Jedis&gt; jedisList = Arrays.asList( new Jedis(&quot;localhost&quot;, 6379), new Jedis(&quot;localhost&quot;, 6380), new Jedis(&quot;localhost&quot;, 6381), new Jedis(&quot;localhost&quot;, 6382) ); RedlockDistributedLock lock = new RedlockDistributedLock(jedisList); String lockKey = &quot;distributed_lock&quot;; String requestId = &quot;request_123&quot;; long expireTime = 5000; if (lock.tryLock(lockKey, requestId, expireTime)) { try { System.out.println(&quot;获取锁成功，执行业务逻辑...&quot;); // 模拟业务逻辑 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(lockKey, requestId); System.out.println(&quot;释放锁成功&quot;); } } else { System.out.println(&quot;获取锁失败&quot;); } } } windows 启动 reids 时指定端口：redis-server.exe --port 6379 连接 redis-server 时指定端口：redis-cli.exe -h 127.0.0.1 -p 6379 比较 实现方式 优点 缺点 适用场景 SETNX 实现简单 需要单独设置过期时间，存在死锁风险 简单的分布式锁场景 SET 原子性操作，避免死锁 需要处理 Lua 脚本 高并发场景 Redlock 高可用，适合多 Redis 实例场景 实现复杂，性能较低 对可靠性要求高的场景","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"网络测速工具iPerf3的使用","slug":"网络测速工具iPerf3的使用","date":"2025-03-01T01:22:33.000Z","updated":"2025-10-26T01:45:44.197Z","comments":true,"path":"2025/03/01/网络测速工具iPerf3的使用/","link":"","permalink":"https://blog.xiongtianci.com/2025/03/01/网络测速工具iPerf3的使用/","excerpt":"","text":"环境： iperf 3.18 简介 百科：Iperf 是一个网络性能测试工具。Iperf可以测试最大 TCP 和 UDP 带宽性能，具有多种参数和UDP特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。 官方文档：https://iperf.fr/iperf-doc.php 安装 Linux windows 下载：https://iperf.fr/iperf-download.php MacOS 使用命令语法格式： iperf3 [-s|-c host] [options] 使用 iperf3 -help 查看所有的操作指令 服务器或客户端通用选项： -p, --port #：指定服务器监听的端口号或客户端连接的端口号。 -f, --format [kmgtKMGT]：指定带宽报告的单位，可选 Kbits（千比特）、Mbits（兆比特）、Gbits（吉比特）、Tbits（太比特）。 -i, --interval #：设置周期性带宽报告的间隔时间（秒）。 -I, --pidfile file：将进程 ID（PID）写入指定的文件。 -F, --file name：发送或接收指定的文件。 -A, --affinity n[,m]：设置 CPU 亲和性，将进程绑定到指定的核心 n（可选客户端绑定到核心 m，服务器绑定到核心 n）。 -B, --bind &lt;host&gt;：绑定到指定主机地址关联的网络接口。 -V, --verbose：输出更详细的信息。 -J, --json：以 JSON 格式输出结果。 --json-stream：以行分隔的 JSON 格式输出结果。 --logfile f：将输出发送到指定的日志文件。 --forceflush：强制在每个间隔时间刷新输出。 --timestamps&lt;=format&gt;：在每行输出前添加时间戳（可选 = 和格式字符串，遵循 strftime(3) 的格式）。 --rcv-timeout #：设置接收数据的空闲超时时间（默认 120000 毫秒）。 -d, --debug[=#]：输出调试信息（可选 = 和调试级别：1-4，默认是 4，输出所有信息）。 -v, --version：显示版本信息并退出。 -h, --help：显示帮助信息并退出。 备注： [KMG] 表示选项支持 K（千）、M（兆）、G（吉）后缀。 服务端服务器特定选项： -s, --server：以服务器模式运行。 -D, --daemon：以守护进程模式运行服务器。 -1, --one-off：处理一个客户端连接后退出。 --server-bitrate-limit #[KMG][/#]：设置服务器的总比特率限制（默认 0 表示无限制，可选斜杠和秒数用于平均数据速率，默认 5 秒）。 --idle-timeout #：在服务器空闲指定秒数后重启（默认无超时）。 --rsa-private-key-path：指定用于解密认证凭证的 RSA 私钥路径。 --authorized-users-path：指定包含用户凭证的配置文件路径。 --time-skew-threshold：设置服务器和客户端在认证过程中的时间偏差阈值（秒）。 --use-pkcs1-padding：使用 PKCS1 填充（需自行承担风险）。 启动服务端： #默认监听5201端口 iperf3 -s #指定监听端口 iperf3 -s -p 10086 #守护进程模式。守护进程是一种在后台运行的进程，通常不与任何终端或用户交互，适合长期运行的服务。 iperf3 -s -D #--logfile，指定日志输出 #使用 taskkill 指令关闭守护进程服务 tasklist | findstr iperf3 taskkill /PID &lt;PID&gt; /F #/T 终止指定进程及其所有子进程 #/F 强制终止进程 客户端客户端特定选项： -c, --client &lt;host&gt;[%&lt;dev&gt;]：以客户端模式运行，连接到指定主机（可选 &lt;dev&gt; 等同于 --bind-dev &lt;dev&gt;）。 -u, --udp：使用 UDP 而不是 TCP。 --connect-timeout #：设置控制连接建立的超时时间（毫秒）。 -b, --bitrate #[KMG][/#]：设置目标比特率（0 表示无限制，默认 UDP 为 1 Mbit/sec，TCP 无限制，可选斜杠和数据包数量用于突发模式）。 --pacing-timer #[KMG]：设置服务器的定时器用于数据发送节奏（微秒，默认 1000，已弃用，仅用于旧版本服务器的兼容性）。 -t, --time #：设置传输时间（秒，默认 10 秒）。 -n, --bytes #[KMG]：设置传输的字节数（替代 -t）。 -k, --blockcount #[KMG]：设置传输的块（数据包）数量（替代 -t 或 -n）。 -l, --length #[KMG]：设置读写缓冲区的长度（默认 TCP 为 128 KB，UDP 为动态或 1460）。 --cport &lt;port&gt;：绑定到指定的客户端端口（TCP 和 UDP，默认使用临时端口）。 -P, --parallel #：设置并行运行的客户端流数量。 -R, --reverse：以反向模式运行（服务器发送，客户端接收）。 --bidir：以双向模式运行（客户端和服务器同时发送和接收数据）。 -w, --window #[KMG]：设置发送/接收的套接字缓冲区大小（间接设置 TCP 窗口大小）。 -M, --set-mss #：设置 TCP/SCTP 最大段大小（MTU - 40 字节）。 -N, --no-delay：设置 TCP/SCTP 无延迟，禁用 Nagle 算法。 -4, --version4：仅使用 IPv4。 -6, --version6：仅使用 IPv6。 -S, --tos N：设置 IP 服务类型（0-255，支持十进制、八进制和十六进制，如 52、064、0x34）。 --dscp N 或 --dscp val：设置 IP DSCP 值（0-63 或符号值，支持十进制、八进制和十六进制）。 -Z, --zerocopy：使用“零拷贝”方法发送数据。 -O, --omit N：在测试前进行 N 秒的预测试，并忽略预测试的统计信息。 -T, --title str：在每行输出前添加前缀字符串。 --extra-data str：在客户端和服务器的 JSON 输出中包含额外的数据字符串。 --get-server-output：从服务器获取结果。 --udp-counters-64bit：在 UDP 测试数据包中使用 64 位计数器。 --repeating-payload：在负载中使用重复模式，而不是随机化负载（类似于 iperf2）。 --dont-fragment：设置 IPv4 的“不分片”标志。 --username：设置认证的用户名。 --rsa-public-key-path：指定用于加密认证凭证的 RSA 公钥路径。 #连接到 iperf3 服务器并进行网络性能测试 #默认进行 TCP 测试 iperf3 -c &lt;服务器IP&gt; [-p 端口号] #多链路测试。iperf3 是单线程的，这里是创建多个并发的客户端连接，从而模拟多线程的效果 iperf3 -c &lt;服务器IP&gt; [-p 端口号] -P 10 #结果看 SUM 一栏 #UDP 测试 iperf3 -c &lt;服务器IP&gt; [-p 端口号] -u -b 100M #默认模式：客户端（-c）向服务器发送数据，服务器接收数据。用于测试从客户端到服务器的上行带宽（上传速度） #客户端反向测试。服务器发送数据，客户端（-c）从服务器接收数据。用于测试从服务器到客户端的下行带宽（下载速度） iperf3 -c &lt;服务器IP&gt; [-p 端口号] -R #客户端同时测试双向流量。同时测试上行和下行带宽 iperf3 -c &lt;服务器IP&gt; [-p 端口号] --bidir 结果解析客户端会显示测试结果，包括TCP和UDP带宽、丢包率等信息。 $ iperf3 -c 192.168.31.148 -u -b 1000M Connecting to host 192.168.31.148, port 5201 [ 5] local 192.168.31.108 port 63882 connected to 192.168.31.148 port 5201 #Interval: 测试的时间间隔 #Transfer: 表示测试的时间间隔内转输的数据量 #Bitrate: 在该时间间隔内的带宽 #Total Datagrams: 在该时间间隔内发送的数据包总数 [ ID] Interval Transfer Bitrate Total Datagrams [ 5] 0.00-1.02 sec 50.6 MBytes 416 Mbits/sec 36364 [ 5] 1.02-2.02 sec 52.3 MBytes 441 Mbits/sec 37543 ... [ 5] 9.01-10.01 sec 62.5 MBytes 525 Mbits/sec 44872 - - - - - - - - - - - - - - - - - - - - - - - - - #测试报告汇总 #Jitter: 网路抖动 #Lost/Total Datagrams: 丢包数/总数据包数（丢包率） #sender: 发送端 #receiver: 接收端 [ ID] Interval Transfer Bitrate Jitter Lost/Total Datagrams [ 5] 0.00-10.01 sec 574 MBytes 481 Mbits/sec 0.000 ms 0/412333 (0%) sender [ 5] 0.00-10.14 sec 300 MBytes 248 Mbits/sec 0.017 ms 196999/412304 (48%) receiver iperf Done.","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"记录：VMware和主机在桥接模式下无法ping通的问题","slug":"记录：VMware和主机在桥接模式下无法ping通的问题","date":"2025-01-02T08:32:40.000Z","updated":"2025-10-26T02:22:16.813Z","comments":true,"path":"2025/01/02/记录：VMware和主机在桥接模式下无法ping通的问题/","link":"","permalink":"https://blog.xiongtianci.com/2025/01/02/记录：VMware和主机在桥接模式下无法ping通的问题/","excerpt":"","text":"前言桥接模式下 VMware 里面的虚拟机和主机相互无法 ping 通。 虚拟机桥接模式正常桥接至主机的物理无线网卡： 虚拟机设置中桥接模式也配置正常： 主机的无线网络适配器也勾选了 VMware Bridge Protocol： 主机网络信息： 无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : IPv4 地址 . . . . . . . . . . . . : 192.168.0.104 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.0.1 虚拟机网络配置（/etc/sysconfig/network-scripts/ifcfg-eth0）： DEVICE=eth0 TYPE=Ethernet ONBOOT=yes # 开机启动网卡 BOOTPROTO=static # 静态IP IPADDR=192.168.0.191 # 与物理机同网段 NETMASK=255.255.255.0 # 与物理机一致 GATEWAY=192.168.0.1 # 与物理机网关一致 DNS1=192.168.0.1 主机能够 ping 通除了虚拟机外的其他局域网设备；虚拟机可以上网，可以 ping 通除了主机外的其他局域网设备；主机和虚拟机无法 ping 通； 主机和虚拟机防火墙都已关闭； 问题排查检查 ARP 缓存， 发现 192.168.0.104 无法正常解析： 使用 traceroute 192.168.0.104 追踪路由， 在第一跳被转发到了 192.168.0.191 即虚拟机的ip 进入路由器后台发现虚拟机和宿主机在路由器中都是用的主机的名称、mac地址，不知道这个有没有影响： 我从下午弄到深夜，尝试了各种方法，但是这个问题依旧没有解决。这个问题先记录下来，后面看看能不能解决。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"VMware丢失了之前安装的虚拟机","slug":"VMware丢失了之前安装的虚拟机","date":"2025-01-01T06:40:16.000Z","updated":"2025-10-26T02:14:25.009Z","comments":true,"path":"2025/01/01/VMware丢失了之前安装的虚拟机/","link":"","permalink":"https://blog.xiongtianci.com/2025/01/01/VMware丢失了之前安装的虚拟机/","excerpt":"","text":"环境： Windows 10 VMware 15 Pro 前言启动 vmware 后发现之前安装的虚拟机全部不见了： 操作文件 -&gt; 扫描虚拟机 -&gt; 填写本地虚拟机系统所在目录进行扫描即可添加： 添加成功：","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"电子书下载","slug":"电子书下载","date":"2024-12-18T01:28:20.000Z","updated":"2025-10-26T01:45:44.145Z","comments":true,"path":"2024/12/18/电子书下载/","link":"","permalink":"https://blog.xiongtianci.com/2024/12/18/电子书下载/","excerpt":"","text":"网站整理推荐： Z-Library：https://z-library.sk/ 安娜档案馆：https://annas-archive.org/ 其他： 访问Z-Library电报官方频道：@zlibrary_official 推特官方频道：@Z_Lib_official Z-Library + 电报bot 1、在推特官方频道中找到官网链接（z-library点sk），注册账号；点击头像进入 Edit Profile 页面 -&gt; 选择 others 页面，在页面最下面的 Personal Telegram bot 中点击 Try it now；根据指引跳转到电报bot频道（@BotFather） 2、关注 BotFather 频道，使用 /newbot 指令创建私人bot，得到 token，将 token 复制到 zlib 中就可以了 成功连接 bot 其他 https://24hbook.com https://linux.do/t/topic/62194","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"使用Adobe Acrobat的PitStop插件批量去除水印","slug":"使用Adobe-Acrobat的PitStop插件批量去除水印","date":"2024-12-07T02:27:51.000Z","updated":"2025-10-26T01:45:44.119Z","comments":true,"path":"2024/12/07/使用Adobe-Acrobat的PitStop插件批量去除水印/","link":"","permalink":"https://blog.xiongtianci.com/2024/12/07/使用Adobe-Acrobat的PitStop插件批量去除水印/","excerpt":"","text":"版本信息： Adobe Acrobat Pro DC 2020.006.20034 PitStop Pro 20.1 (2020) 写在前面一般不是使用 Adobe 添加的水印，使用 Adobe 去除水印很麻烦。 如果页面少可以通过 Adobe 的内容编辑进行编辑：视图 -&gt; 显示/隐藏 -&gt; 导览窗格 -&gt; 内容 在左侧选中水印后按 Delete 键删除即可 如果页面多，一个个手动删除太累。本文使用 Adobe 的 Enfocus PitStop Pro 2020 插件进行批量去除水印。 安装PitStop下载安装： 地址 访问码 来源 https://cloud.189.cn/t/Yj67viuumaii 1rsy https://www.52pojie.cn/thread-1414655-1-1.html 安装后替换 PitStop Pro.dll 文件 批量去除水印PitStop 挺强大的，可以根据文字、字体、字号、颜色、对象、区域等去除水印，这里只介绍去除文字水印和图片水印。 批量去除水印都是在 PitStop 中新建对应的动作： 文字水印新建下图中的动作： 选中刚刚新建的动作并运行即可： 图片水印右下角”更多工具” -&gt; 双击”PitStop 检查” 点击”选择对象” -&gt; 选中图片水印 -&gt; 点击检查器查看图片宽度值并复制 新建下图中的动作： 选中刚刚新建的动作并运行即可：","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"记录制作网线水晶头","slug":"记录制作网线水晶头","date":"2024-08-25T23:41:52.000Z","updated":"2025-10-26T01:45:44.086Z","comments":true,"path":"2024/08/26/记录制作网线水晶头/","link":"","permalink":"https://blog.xiongtianci.com/2024/08/26/记录制作网线水晶头/","excerpt":"","text":"起因家里是开发商自带精装修，装修的各方面质量都不行，弱电箱的网线水晶头都没安装。家里一共4个网线面板口和3个电话线口，本来这次以为安装水晶头就行了，后来测试发现4个网线面包中有3个线序不对。 准备 8P网线钳。25￥ 巡线仪，由于弱电箱里面有7根网线，对应4个网线面包和3个电话线口，但是没标识哪个对应哪个，就需要这个工具了。41￥ 超五类水晶头若干。水晶头，专业术语为RJ-45连接器，共有八芯做成。5￥ 网线线序标准线序网线的接法主要有两种标准：T568A 和 T568B。这两种标准规定了不同颜色的线芯应该连接到水晶头的哪个位置。这两种接法广泛用于以太网网络中。 T568A与T568B的区别 本质上来说，T568A标准与T568B标准没有太大的区别，只是颜色与线芯排列顺序不一样， T568A线序为：绿白 绿 橙白 蓝 蓝白 橙 棕白 棕 T568B线序为：橙白 橙 绿白 蓝 蓝白 绿 棕白 棕 直通线与交叉线 直通线（Straight-through Cable）： 直通线两端使用相同的接法（T568A-T568A 或 T568B-T568B）。这种线缆常用于连接计算机到交换机、路由器等网络设备。 交叉线（Crossover Cable）： 交叉线两端使用不同的接法（T568A-T568B）。这种线缆常用于直接连接两台计算机或两台相同类型的网络设备。 现代网络设备支持自动MDI/MDIX功能，这意味着它们可以自动调整以适应直通线或交叉线，因此大多数情况下使用直通线（T568B-T568B）即可。 网络面板线序网络面板就是下面这个东西： 这里需要注意下，每个厂家的面板接线柱顺序可能是不一样的，我们需要按面板上的颜色接线。厂家画的顺序不是内部走线顺序，最终针脚触点顺序都是标准顺序（T568A/B）。 我家的面板是按照 T568B 标准接的： 开整由于弱电箱的线没有标注哪根线对应哪个面板，首先需要使用巡线仪找出哪个对应哪个。然后就是使用网线钳制作水晶头了。 制作水晶头的注意事项可以在淘宝上面顺便进去一个网线钳的详情页找到： 需要注意一点，网线的外皮也需要压进去，这样才能抗拉，防止线缆在使用过程中发生松动或断开。 接水晶头： 接完水晶头后用巡线仪的发射器和接收器分别连接到刚刚接的水晶头和网络面板上面进行网络线序校对，检查下网线接的顺序对不对。发现家里4个网络面板有3个没按照面板上的颜色顺序接。 没啥难度。收工~","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"红米AX6000官方固件解锁clash","slug":"红米AX6000官方固件解锁clash","date":"2024-08-24T01:39:19.000Z","updated":"2025-10-26T01:45:44.018Z","comments":true,"path":"2024/08/24/红米AX6000官方固件解锁clash/","link":"","permalink":"https://blog.xiongtianci.com/2024/08/24/红米AX6000官方固件解锁clash/","excerpt":"","text":"准备 红米AX6000，固件本版1.0.67 SSH连接工具 开启Telnet（windows默认未开启） 本记录适用于固件本版1.0.67，如果不是，就需要通过小米路由器官方修复工具进行降级，手动降级至1.0.67版固件。因为后续安装插件操作的前提是需要开启SSH，其他的固件版本不确定能否解锁SSH。 1、获取token进入路由器后台界面，地址：http://192.168.31.1。登录后地址栏上 stok= 后面的部分就是token。将 token 复制下来，后面需要用到。 http://192.168.31.1/cgi-bin/luci/;stok={token}/web/home#router 2、开启telnet开启开发者模式 将下面的 {token} 替换后，粘贴到浏览器中访问，更改路由器的crash分区，使其进入到开发者模式： http://192.168.31.1/cgi-bin/luci/;stok={token}/api/misystem/set_sys_time?timezone=%20%27%20%3B%20zz%3D%24%28dd%20if%3D%2Fdev%2Fzero%20bs%3D1%20count%3D2%202%3E%2Fdev%2Fnull%29%20%3B%20printf%20%27%A5%5A%25c%25c%27%20%24zz%20%24zz%20%7C%20mtd%20write%20-%20crash%20%3B%20 相当于执行zz=$(dd if=/dev/zero bs=1 count=2 2&gt;/dev/null) ; printf &#39;\\xA5\\x5A%c%c&#39; $zz $zz | mtd write - crash ;，也就是将 \\xA5\\x5A\\x00\\x00 写入crash分区 浏览器返回 &quot;code&quot;:0，表示成功： 通过浏览器重启路由器替换token后在浏览器上访问，路由器会重启，请等待重启完成： http://192.168.31.1/cgi-bin/luci/;stok={token}/api/misystem/set_sys_time?timezone=%20%27%20%3b%20reboot%20%3b%20 相当于执行 reboot 浏览器返回 {&quot;code&quot;:0}，表示执行成功。 设置Bdata永久开启telnet待路由器重启完成后，重新登录进入路由器管理后台，获取新的token。 http://192.168.31.1/cgi-bin/luci/;stok={token}/api/misystem/set_sys_time?timezone=%20%27%20%3B%20bdata%20set%20telnet_en%3D1%20%3B%20bdata%20set%20ssh_en%3D1%20%3B%20bdata%20set%20uart_en%3D1%20%3B%20bdata%20commit%20%3B%20 相当于执行 bdata set telnet_en=1 ; bdata set ssh_en=1 ; bdata set uart_en=1 ; bdata commit ; bdata set telnet_en=1: 启用telnet服务。 bdata set ssh_en=1: 启用SSH服务。 bdata set uart_en=1: 启用UART服务。 bdata commit: 提交之前的设置更改。 再次重启路由器上面设置完成（{&quot;code&quot;:0}）后再次重启路由器： http://192.168.31.1/cgi-bin/luci/;stok={token}/api/misystem/set_sys_time?timezone=%20%27%20%3b%20reboot%20%3b%20 3、开启路由器SSH使用Telnet连接路由器路由器重启完成后，windows系统中通过cmd窗口执行：telnet 192.168.31.1（端口默认23，无用户名密码），连接连接路由器。看到Are you ok的界面，就证明连接成功： 连上telnet后依次运行下面命令。 永久开启并固化SSH执行下面命令永久开启 SSH 端口： echo -e &#39;admin\\nadmin&#39; | passwd root nvram set ssh_en=1 nvram set telnet_en=1 nvram set uart_en=1 nvram set boot_wait=on nvram commit sed -i &#39;s/channel=.*/channel=&quot;debug&quot;/g&#39; /etc/init.d/dropbear /etc/init.d/dropbear restart mkdir /data/auto_ssh cd /data/auto_ssh curl -O https://fastly.jsdelivr.net/gh/lemoeo/AX6S@main/auto_ssh.sh chmod +x auto_ssh.sh uci set firewall.auto_ssh=include uci set firewall.auto_ssh.type=&#39;script&#39; uci set firewall.auto_ssh.path=&#39;/data/auto_ssh/auto_ssh.sh&#39; uci set firewall.auto_ssh.enabled=&#39;1&#39; uci commit firewall uci set system.@system[0].timezone=&#39;CST-8&#39; uci set system.@system[0].webtimezone=&#39;CST-8&#39; uci set system.@system[0].timezoneindex=&#39;2.84&#39; uci commit mtd erase crash reboot 以下是这段命令的解释，执行上面命令后不需要执行下面命令了。 修改root密码，将root密码修改为admin： echo -e &#39;admin\\nadmin&#39; | passwd root 固化SSH nvram set ssh_en=1 nvram set telnet_en=1 nvram set uart_en=1 nvram set boot_wait=on nvram commit ssh_en=1 启用 SSH；telnet_en=1 启用 Telnet uart_en=1 启用串口通信 boot_wait=on 用于在路由器启动时提供一个时间窗口，允许用户通过特定方式（如串口连接或网络）中断正常的启动流程 固化SSH之后，以后升级路由器固件SSH也会保留不会被恢复。 永久开启SSH。设置一个自动解锁 SSH 的脚本，并配置防火墙在启动时自动执行该脚本： mkdir /data/auto_ssh &amp;&amp; cd /data/auto_ssh curl -O https://cdn.jsdelivr.net/gh/lemoeo/AX6S@main/auto_ssh.sh chmod +x auto_ssh.sh uci set firewall.auto_ssh=include uci set firewall.auto_ssh.type=&#39;script&#39; uci set firewall.auto_ssh.path=&#39;/data/auto_ssh/auto_ssh.sh&#39; uci set firewall.auto_ssh.enabled=&#39;1&#39; uci commit firewall 修改时区设置 uci set system.@system[0].timezone=&#39;CST-8&#39; uci set system.@system[0].webtimezone=&#39;CST-8&#39; uci set system.@system[0].timezoneindex=&#39;2.84&#39; uci commit 关闭开发/调试模式 mtd erase crash 重启路由器 reboot 4、SSH连接设备 主机名：192.168.31.1 端口：22（默认） 用户名：root 密码：admin 需要电脑连上Redmi AX6000的WIFI 5、安装ShellClash面板通过SSH进入路由器后，依次执行下面命令。 在SSH工具中使用 Backspace 退格键可能会失效，出现 ^H 的情况。这个时候可以试下 Shift + Backspace或Ctrl + Backspace进行删除。 安装clash这一步需要路由器已连上网络。 sh -c &quot;$(curl -kfsSl https://cdn.jsdelivr.net/gh/juewuy/ShellClash@master/install.sh)&quot; &amp;&amp; source /etc/profile &amp;&gt; /dev/nul 备用安装源： export url=&#39;https://raw.fastgit.org/juewuy/ShellClash/master&#39; &amp;&amp; sh -c &quot;$(curl -kfsSl $url/install.sh)&quot; &amp;&amp; source /etc/profile &amp;&gt; /dev/null export url=&#39;https://raw.githubusercontent.com/juewuy/ShellClash/master&#39; &amp;&amp; sh -c &quot;$(curl -kfsSl $url/install.sh)&quot; &amp;&amp; source /etc/profile &amp;&gt; /dev/null export url=&#39;https://fastly.jsdelivr.net/gh/juewuy/ShellClash@master&#39; &amp;&amp; sh -c &quot;$(curl -kfsSl $url/install.sh)&quot; &amp;&amp; source /etc/profile &amp;&gt; /dev/null 下面是安装过程： root@XiaoQiang:~# sh -c &quot;$(curl -kfsSl https://cdn.jsdelivr.net/gh/juewuy/ShellClash@master/install.sh)&quot; &amp;&amp; source /etc/profile &amp;&gt; /dev/nul *********************************************** ** 欢迎使用 ** ** ShellCrash ** ** by Juewuy ** *********************************************** ----------------------------------------------- 请选择想要安装的版本： 1 公测版(推荐) 2 稳定版 3 开发版 ----------------------------------------------- 请输入相应数字 &gt; 1 最新版本：1.9.1beta13 ----------------------------------------------- 如遇问题请加TG群反馈： t.me/ShellClash 支持各种基于openwrt的路由器设备 支持Debian、Centos等标准Linux系统 ----------------------------------------------- 注意：安装ShellCrash至少需要预留约1MB的磁盘空间 检测到当前设备为小米官方系统，请选择安装位置 1 安装到 /data 目录(推荐，支持软固化功能) 2 安装到 /userdisk 目录(推荐，支持软固化功能) 3 安装到自定义目录(不推荐，不明勿用！) 0 退出安装 ----------------------------------------------- 请输入相应数字 &gt; 1 目标目录/data空间剩余：38.1M 确认安装？(1/0) &gt; 1 ----------------------------------------------- 开始从服务器获取安装文件！ ----------------------------------------------- ############################################################################################################ 100.0% ----------------------------------------------- 开始解压文件！ ----------------------------------------------- ShellCrash 已经安装成功! ----------------------------------------------- 输入 crash 命令即可管理！！！ ----------------------------------------------- root@XiaoQiang:~# crash 安装完成。 配置ShellClash输入 clash或clash 命令执行面板管理程序。 root@XiaoQiang:~# crash ----------------------------------------------- 欢迎使用ShellCrash！ 版本：1.9.1beta13 Clash服务没有运行（纯净模式），未设置开机启动！ TG频道：https://t.me/ShellClash ----------------------------------------------- ----------------------------------------------- 欢迎使用ShellCrash新手引导！ ----------------------------------------------- 请先选择你的使用环境： (你之后依然可以在设置中更改各种配置) ----------------------------------------------- 1 路由设备配置局域网透明代理 2 Linux设备仅配置本机代理 ----------------------------------------------- 请输入对应数字 &gt; 1 选项 1 全局代理： 选项 2 本机代理： ----------------------------------------------- 启用推荐的自动任务配置？这包括： ----------------------------------------------- 每隔10分钟自动保存面板配置 服务启动后自动同步ntp时间 在每周3的3点整更新订阅并重启服务 ----------------------------------------------- 是否启用？(1/0) &gt; 1 任务【运行时每10分钟自动保存面板配置】添加成功！ 任务【服务启动后自动同步ntp时间】添加成功！ 任务【在每周3的3点整更新订阅并重启服务】添加成功！ ----------------------------------------------- 检测到为小米路由设备，启用软固化可防止路由升级后丢失SSH 是否启用软固化功能？(1/0) &gt; 0 ----------------------------------------------- 是否导入配置文件？(这是运行前的最后一步) 你必须拥有一份配置文件才能运行服务！ ----------------------------------------------- 现在开始导入？(1/0) &gt; 1 ----------------------------------------------- ShellCrash配置文件管理 ----------------------------------------------- 1 在线生成配置文件 2 在线获取完配置文件 3 本地生成providers配置文件 4 本地上传完整配置文件 5 设置自动更新 6 自定义配置文件 7 更新配置文件 8 还原配置文件 ----------------------------------------------- 请输入对应数字 &gt; 2 ----------------------------------------------- 此功能可能会导致一些bug！！！ 强烈建议你使用在线生成配置文件功能！ 继续后如出现任何问题，请务必自行解决，一切提问恕不受理！ ----------------------------------------------- 我确认遇到问题可以自行解决[1/0] &gt; 1 ----------------------------------------------- 仅限导入完整的配置文件链接！！！ ----------------------------------------------- 有流媒体需求，请使用6-1在线生成配置文件功能！！！ 如不了解机制，请使用6-1在线生成配置文件功能！！！ 如遇任何问题，请使用6-1在线生成配置文件功能！！！ 此功能可能会导致部分节点无法连接或者规则覆盖不完整！！！ ----------------------------------------------- 0 返回上级菜单 ----------------------------------------------- 请输入完整链接 &gt; https://xxxvpn.xx/****************/config.yaml 输入完整链接时，右键粘贴服务商提供的配置文件链接并按回车执行命令 ----------------------------------------------- 链接地址为：https://xxxvpn.xx/****************/config.yaml 可以手动复制该链接到浏览器打开并查看数据是否正常！ ############################################### 100.0% 已成功获取配置文件！ ----------------------------------------------- 很好！现在只需要执行启动就可以愉快的使用了！ ----------------------------------------------- 立即启动服务？(1/0) &gt; 1 ----------------------------------------------- 未找到【clash】核心，正在下载！ ############################################### 100.0% 服务已启动！ 请使用 http://192.168.31.1:9999/ui 管理内置规则 ----------------------------------------------- 欢迎使用ShellCrash！ 版本：1.9.1beta13 Clash服务正在运行（Redir模式），已设置开机启动！ 当前内存占用：21224 kB，已运行：00小时00分00秒 TG频道：https://t.me/ShellClash ----------------------------------------------- 1 启动/重启服务 2 内核功能设置 3 停止内核服务 4 内核启动设置 5 配置自动任务 6 导入配置文件 7 内核进阶设置 8 其他工具 9 更新/卸载 ----------------------------------------------- 0 退出脚本 请输入对应数字 &gt; 9 ----------------------------------------------- 欢迎使用更新功能： ----------------------------------------------- 当前目录(/data/ShellCrash)剩余空间：34.5M ----------------------------------------------- 1 更新管理脚本 1.9.1beta13 &gt; 1.9.1beta13 2 切换内核文件 v1.7.1 &gt; v1.7.1 3 更新数据库文件 &gt; 20240629 4 安装本地Dashboard面板 5 安装/更新本地根证书文件 6 查看PAC自动代理配置 ----------------------------------------------- 7 切换安装源及安装版本 8 配置自动更新 9 卸载ShellCrash ----------------------------------------------- 99 鸣谢！ ----------------------------------------------- 0 返回上级菜单 ----------------------------------------------- 请输入对应数字 &gt; 4 ----------------------------------------------- 安装本地版dashboard管理面板 打开管理面板的速度更快且更稳定 ----------------------------------------------- 请选择面板安装类型： ----------------------------------------------- 1 安装Yacd面板(约1.1mb) 2 安装Yacd-Meta魔改面板(约1.5mb) 3 安装MetaXD面板(约1.5mb) 4 安装基础面板(约500kb) 5 安装Meta基础面板(约800kb) 9 卸载本地面板 0 返回上级菜单 请输入对应数字 &gt; 1 ----------------------------------------------- 请选择面板安装目录： ----------------------------------------------- 1 在/data/ShellCrash/ui目录安装 2 在/www/clash目录安装 ----------------------------------------------- 0 返回上级菜单 请输入对应数字 &gt; 1 ----------------------------------------------- 正在连接服务器获取安装文件………… ############################################### 100.0% 下载成功，正在解压文件！ ----------------------------------------------- 面板安装成功！ 参考 红米路由器AX6000解锁SSH 启用科学上网 红米AX6000刷机折腾记录 Redmi AX6000解锁SSH和科学上网教程","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://blog.xiongtianci.com/tags/路由器/"}],"author":"木浅"},{"title":"红米AX6000刷机记录","slug":"红米AX6000刷机记录","date":"2024-08-23T23:27:06.000Z","updated":"2025-10-26T01:45:43.998Z","comments":true,"path":"2024/08/24/红米AX6000刷机记录/","link":"","permalink":"https://blog.xiongtianci.com/2024/08/24/红米AX6000刷机记录/","excerpt":"","text":"先挖个坑，目前直接用 官方固件+clash 就行了，后面有需求在进行刷机。——20240824 准备本次用到： 红米AX6000，自带固件1.0.67 参考 https://www.youtube.com/watch?v=KH318DzR7lA","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://blog.xiongtianci.com/tags/路由器/"}],"author":"木浅"},{"title":"JUC学习笔记-异步编程：Future与Callable","slug":"JUC学习笔记-异步编程：Future与Callable","date":"2024-04-09T02:48:49.000Z","updated":"2025-10-26T02:16:24.693Z","comments":true,"path":"2024/04/09/JUC学习笔记-异步编程：Future与Callable/","link":"","permalink":"https://blog.xiongtianci.com/2024/04/09/JUC学习笔记-异步编程：Future与Callable/","excerpt":"","text":"Callable和Future Callable 负责 定义任务逻辑（类似 Runnable，但能返回结果和抛出异常）。 Future 负责 管理任务生命周期 和 获取计算结果。 二者结合才能完整实现 “提交任务 → 异步执行 → 获取结果” 的流程。 功能互补 职责 对方的作用 Callable 定义可返回结果的任务逻辑 需要 Future 来接收和管理它的计算结果 Future 监控任务状态、获取结果或取消任务 需要 Callable 作为实际的任务提供者 // 典型使用场景 ExecutorService executor = Executors.newCachedThreadPool(); Callable&lt;String&gt; task = () -&gt; &quot;Hello World&quot;; // 定义任务 Future&lt;String&gt; future = executor.submit(task); // 提交任务并获取Future String result = future.get(); // 通过Future获取结果 Callable接口Callable是Java 5引入的接口，与Runnable类似，但有三个关键区别： public interface Callable&lt;V&gt; { V call() throws Exception; } 可以返回结果（泛型V） 可以抛出受检异常 需要实现 call() 方法而非 run() 与 Runnable 的对比 特性 Callable Runnable 返回值 支持 不支持 异常 可以抛出受检异常 不能抛出受检异常 方法签名 V call() throws Exception void run() 使用场景 需要返回结果的异步任务 简单的异步操作 Callable的基本使用基本用法示例： // 创建Callable任务 Callable&lt;Integer&gt; task = () -&gt; { int sum = 0; for (int i = 1; i &lt;= 10; i++) { sum += i; Thread.sleep(100); // 模拟耗时操作 } return sum; }; // 使用FutureTask包装Callable FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task); // 启动线程执行任务 new Thread(futureTask).start(); try { // 获取计算结果（会阻塞直到计算完成） int result = futureTask.get(); System.out.println(&quot;1到10的和为: &quot; + result); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } 与 ExecutorService 结合使用： // 创建线程池 ExecutorService executor = Executors.newFixedThreadPool(4); // 创建Callable任务列表 List&lt;Callable&lt;Integer&gt;&gt; tasks = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { final int taskId = i; tasks.add(() -&gt; { System.out.println(&quot;任务&quot; + taskId + &quot;开始执行&quot;); Thread.sleep(1000); // 模拟耗时操作 return taskId * taskId; // 返回平方值 }); } try { // 提交所有任务并获取Future列表 List&lt;Future&lt;Integer&gt;&gt; futures = executor.invokeAll(tasks); // 处理结果 for (Future&lt;Integer&gt; future : futures) { System.out.println(&quot;任务结果: &quot; + future.get()); } } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } finally { // 关闭线程池 executor.shutdown(); } 应用场景场景1：并行计算 import java.util.concurrent.*; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class ParallelComputation { public static void main(String[] args) { List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); ExecutorService executor = Executors.newFixedThreadPool(4); try { // 并行计算每个数字的阶乘 List&lt;Future&lt;Long&gt;&gt; futures = executor.invokeAll( numbers.stream() .map(n -&gt; (Callable&lt;Long&gt;) () -&gt; factorial(n)) .collect(Collectors.toList()) ); for (int i = 0; i &lt; numbers.size(); i++) { System.out.printf(&quot;%d! = %d%n&quot;, numbers.get(i), futures.get(i).get()); } } catch (Exception e) { e.printStackTrace(); } finally { executor.shutdown(); } } private static long factorial(int n) { if (n == 0) return 1; long result = 1; for (int i = 1; i &lt;= n; i++) { result *= i; try { Thread.sleep(100); // 模拟计算耗时 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } return result; } } 场景2：超时控制 import java.util.concurrent.*; public class TimeoutExample { public static void main(String[] args) { ExecutorService executor = Executors.newSingleThreadExecutor(); Callable&lt;String&gt; task = () -&gt; { Thread.sleep(2000); // 模拟长时间运行的任务 return &quot;任务完成&quot;; }; Future&lt;String&gt; future = executor.submit(task); try { // 设置1秒超时 String result = future.get(1, TimeUnit.SECONDS); System.out.println(result); } catch (TimeoutException e) { System.out.println(&quot;任务超时，取消任务&quot;); future.cancel(true); // 尝试中断任务 } catch (Exception e) { e.printStackTrace(); } finally { executor.shutdown(); } } } 场景3：多个任务竞争（获取第一个完成的结果） import java.util.concurrent.*; import java.util.Arrays; import java.util.List; import java.util.Random; public class FirstCompletedExample { public static void main(String[] args) { ExecutorService executor = Executors.newCachedThreadPool(); List&lt;Callable&lt;String&gt;&gt; tasks = Arrays.asList( () -&gt; { Thread.sleep(new Random().nextInt(1000)); return &quot;任务1完成&quot;; }, () -&gt; { Thread.sleep(new Random().nextInt(1000)); return &quot;任务2完成&quot;; }, () -&gt; { Thread.sleep(new Random().nextInt(1000)); return &quot;任务3完成&quot;; } ); try { // 获取第一个完成的任务结果 String result = executor.invokeAny(tasks); System.out.println(&quot;第一个完成的任务: &quot; + result); } catch (Exception e) { e.printStackTrace(); } finally { executor.shutdown(); } } } Future接口Future是Java并发编程中一个非常重要的接口，它位于 java.util.concurrent 包中。Future 表示一个异步计算的结果，它提供了检查计算是否完成的方法，以及等待计算完成并检索其结果的方法。 Future接口为Java并发编程提供了基础的异步计算支持，通过它可以： 提交任务并获取未来可能的结果 查询任务状态和取消任务 实现任务的超时控制 package java.util.concurrent; public interface Future&lt;V&gt; { // 尝试取消任务的执行 boolean cancel(boolean mayInterruptIfRunning); // 判断任务是否被取消 boolean isCancelled(); // 判断任务是否完成 boolean isDone(); // 获取计算结果（阻塞直到计算完成） V get() throws InterruptedException, ExecutionException; // 获取计算结果（带超时限制） V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } isCancelled()：只有任务未启动，或者在完成之前被取消，才会返回true，表示任务已经被成功取消。其他情况都会返回false get()：方法是阻塞的，可能会影响系统响应性。使用带超时的 get() 方法避免无限期等待 Future的使用基本使用案例1：基本使用 import java.util.concurrent.*; public class FutureBasicDemo { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); // 提交Callable任务，返回Future对象 Future&lt;String&gt; future = executor.submit(() -&gt; { Thread.sleep(2000); // 模拟耗时操作 return &quot;Hello, Future!&quot;; }); System.out.println(&quot;任务已提交，可以继续做其他事情...&quot;); // 检查任务是否完成 if (!future.isDone()) { System.out.println(&quot;任务还未完成，可以继续处理其他逻辑&quot;); } // 获取结果（会阻塞直到任务完成） String result = future.get(); System.out.println(&quot;获取到结果: &quot; + result); executor.shutdown(); } } 案例2：超时控制 import java.util.concurrent.*; public class FutureTimeoutDemo { public static void main(String[] args) { ExecutorService executor = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = executor.submit(() -&gt; { Thread.sleep(3000); return &quot;Result after long processing&quot;; }); try { // 设置超时时间为2秒 String result = future.get(2, TimeUnit.SECONDS); System.out.println(&quot;结果: &quot; + result); } catch (TimeoutException e) { System.out.println(&quot;任务执行超时&quot;); future.cancel(true); // 取消任务 } catch (Exception e) { e.printStackTrace(); } finally { executor.shutdown(); } } } 案例3：任务取消 import java.util.concurrent.*; public class FutureCancelDemo { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = executor.submit(() -&gt; { Thread.sleep(5000); return &quot;This should not be reached if cancelled&quot;; }); // 模拟执行一段时间后决定取消任务 Thread.sleep(1000); // 尝试取消任务（参数true表示可以中断正在执行的任务） boolean cancelled = future.cancel(true); System.out.println(&quot;任务取消&quot; + (cancelled ? &quot;成功&quot; : &quot;失败&quot;)); // 检查任务状态 System.out.println(&quot;任务是否取消: &quot; + future.isCancelled()); System.out.println(&quot;任务是否完成: &quot; + future.isDone()); try { // 尝试获取已取消任务的结果会抛出CancellationException String result = future.get(); System.out.println(result); } catch (CancellationException e) { System.out.println(&quot;无法获取结果，任务已被取消&quot;); } executor.shutdown(); } } 应用场景场景1：并行处理多个任务 import java.util.concurrent.*; public class MultipleFuturesDemo { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newFixedThreadPool(3); // 提交多个任务 Future&lt;String&gt; future1 = executor.submit(() -&gt; { Thread.sleep(1000); return &quot;Result from Task 1&quot;; }); Future&lt;String&gt; future2 = executor.submit(() -&gt; { Thread.sleep(1500); return &quot;Result from Task 2&quot;; }); Future&lt;String&gt; future3 = executor.submit(() -&gt; { Thread.sleep(800); return &quot;Result from Task 3&quot;; }); // 获取所有结果（会按调用顺序阻塞） System.out.println(future1.get()); System.out.println(future2.get()); System.out.println(future3.get()); executor.shutdown(); } } 场景2：电商价格聚合案例 import java.util.concurrent.*; public class PriceAggregator { private ExecutorService executor = Executors.newFixedThreadPool(3); public double getFinalPrice(String product) throws Exception { // 并行获取不同平台的价格 Future&lt;Double&gt; taobaoPrice = executor.submit(() -&gt; getPriceFromTaobao(product)); Future&lt;Double&gt; jdPrice = executor.submit(() -&gt; getPriceFromJD(product)); Future&lt;Double&gt; pddPrice = executor.submit(() -&gt; getPriceFromPDD(product)); // 模拟其他处理 System.out.println(&quot;正在处理其他业务逻辑...&quot;); Thread.sleep(500); // 获取所有价格并计算最低价 double finalPrice = Math.min(taobaoPrice.get(), Math.min(jdPrice.get(), pddPrice.get())); return finalPrice; } private double getPriceFromTaobao(String product) throws InterruptedException { Thread.sleep(1000); return 199.0; // 模拟价格 } private double getPriceFromJD(String product) throws InterruptedException { Thread.sleep(1200); return 219.0; // 模拟价格 } private double getPriceFromPDD(String product) throws InterruptedException { Thread.sleep(800); return 189.0; // 模拟价格 } public static void main(String[] args) throws Exception { PriceAggregator aggregator = new PriceAggregator(); double price = aggregator.getFinalPrice(&quot;iPhone 13&quot;); System.out.println(&quot;最终价格: &quot; + price); aggregator.executor.shutdown(); } } Future实现类JUC 并发包中，Future 接口有几个重要的实现类，每个实现类都有其特定的使用场景和优势： FutureTask：最基础的 Future 实现，同时实现了 Runnable 接口 ScheduledFuture：用于定时任务的 Future 实现 ForkJoinTask：Fork/Join 框架中的 Future 实现 CompletableFuture（Java 8+）：功能最丰富的Future实现 FutureTaskFutureTask 是 Future 接口的一个实现类，特点： 同时实现了 Future 和 Runnable 接口，因此可作为任务提交给线程池 Executor 执行 只能执行一次，不能重复使用 内部基于AQS（AbstractQueuedSynchronizer）实现状态控制 示例： import java.util.concurrent.FutureTask; public class FutureTaskDemo { public static void main(String[] args) throws Exception { // 创建FutureTask FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; { int sum = 0; for (int i = 0; i &lt; 100; i++) { sum += i; Thread.sleep(10); } return sum; }); // 创建线程执行FutureTask new Thread(futureTask).start(); // 主线程可以继续做其他事情 System.out.println(&quot;主线程正在处理其他任务...&quot;); Thread.sleep(500); // 获取计算结果 if (!futureTask.isDone()) { System.out.println(&quot;计算任务还未完成，请稍候...&quot;); } int result = futureTask.get(); System.out.println(&quot;计算结果: &quot; + result); } } 案例：缓存系统实现 基于 FutureTask 实现的高并发缓存系统，解决了缓存系统中常见的”缓存击穿”问题，并提供了线程安全的缓存访问机制： import java.math.BigInteger; import java.util.Map; import java.util.concurrent.*; public class CacheSystem&lt;K, V&gt; { private final Map&lt;K, FutureTask&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private final Computable&lt;K, V&gt; computable; public CacheSystem(Computable&lt;K, V&gt; computable) { this.computable = computable; } public V get(final K key) throws InterruptedException { while (true) { FutureTask&lt;V&gt; future = cache.get(key); if (future == null) { FutureTask&lt;V&gt; newTask = new FutureTask&lt;&gt;(() -&gt; computable.compute(key)); future = cache.putIfAbsent(key, newTask); if (future == null) { future = newTask; future.run(); // 开始计算 } } try { return future.get(); } catch (CancellationException e) { cache.remove(key); } catch (ExecutionException e) { throw launderThrowable(e.getCause()); } } } private RuntimeException launderThrowable(Throwable t) { if (t instanceof RuntimeException) return (RuntimeException) t; else if (t instanceof Error) throw (Error) t; else throw new IllegalStateException(&quot;Not unchecked&quot;, t); } public interface Computable&lt;K, V&gt; { V compute(K key) throws InterruptedException; } } // 使用示例 class CacheDemo { public static void main(String[] args) { CacheSystem&lt;String, BigInteger&gt; cache = new CacheSystem&lt;&gt;(key -&gt; { // 模拟耗时计算 Thread.sleep(1000); return new BigInteger(key); }); ExecutorService executor = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 10; i++) { final String key = &quot;12345&quot;; executor.execute(() -&gt; { try { System.out.println(Thread.currentThread().getName() + &quot; 获取结果: &quot; + cache.get(key)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } executor.shutdown(); } } 工作流程： [客户端调用get(key)] | v 检查缓存是否存在 --&gt; 存在 --&gt; 返回缓存结果 | v 不存在 --&gt; 创建FutureTask --&gt; 放入缓存 --&gt; 执行计算 | v 其他线程再次请求相同key --&gt; 获取已存在的FutureTask --&gt; 等待计算结果 使用场景： // 电商系统-商品详情缓存 CacheSystem&lt;Long, ProductDetail&gt; productCache = new CacheSystem&lt;&gt;(productId -&gt; { // 从数据库获取商品详情（耗时操作） return productDao.getDetailById(productId); }); // 获取商品详情（数万QPS场景下能有效防止缓存击穿） ProductDetail detail = productCache.get(12345L); ScheduledFuture与定时任务ScheduledFuture 用于表示延迟或周期性任务的执行结果，通常与 ScheduledExecutorService 配合使用。 核心特性： 延迟/周期性任务：支持固定延迟（scheduleWithFixedDelay）或固定速率（scheduleAtFixedRate）的任务调度。 继承自 Future：提供任务取消、结果获取等基础功能。 时间控制：通过 getDelay() 方法获取剩余延迟时间。 示例： ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); ScheduledFuture&lt;?&gt; future = executor.schedule( () -&gt; System.out.println(&quot;Task executed after 1 second&quot;), 1, TimeUnit.SECONDS ); 案例：订单超时取消 import java.util.Map; import java.util.concurrent.*; public class OrderTimeoutSystem { private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); private final Map&lt;Long, ScheduledFuture&lt;?&gt;&gt; orderTasks = new ConcurrentHashMap&lt;&gt;(); public void placeOrder(long orderId) { // 提交定时任务，30分钟后检查订单状态 ScheduledFuture&lt;?&gt; future = scheduler.schedule(() -&gt; { if (!isOrderPaid(orderId)) { cancelOrder(orderId); orderTasks.remove(orderId); } }, 30, TimeUnit.MINUTES); orderTasks.put(orderId, future); } public void orderPaid(long orderId) { ScheduledFuture&lt;?&gt; future = orderTasks.get(orderId); if (future != null) { future.cancel(false); // 订单已支付，取消定时任务 orderTasks.remove(orderId); } } private boolean isOrderPaid(long orderId) { // 查询数据库或缓存 return false; } private void cancelOrder(long orderId) { System.out.println(&quot;订单超时取消: &quot; + orderId); // 实际业务中会更新订单状态等操作 } public void shutdown() { scheduler.shutdown(); } } // 使用示例 class OrderTimeoutDemo { public static void main(String[] args) throws InterruptedException { OrderTimeoutSystem system = new OrderTimeoutSystem(); // 模拟订单创建 long orderId = 10001L; system.placeOrder(orderId); System.out.println(&quot;订单创建: &quot; + orderId); // 模拟15分钟后支付 Thread.sleep(TimeUnit.MINUTES.toMillis(15)); system.orderPaid(orderId); System.out.println(&quot;订单已支付: &quot; + orderId); system.shutdown(); } } ForkJoinTask用途：支持分治（Divide-and-Conquer）任务的抽象基类，通常用于 ForkJoinPool 中处理递归或并行任务。 核心特性： 分治策略：通过 fork() 分解任务，join() 合并结果。 自动负载均衡：ForkJoinPool 使用工作窃取（Work-Stealing）算法，空闲线程从忙碌线程的队列尾部窃取任务。 两种子类： RecursiveTask：返回结果的任务。 RecursiveAction：无返回结果的任务。 示例（计算斐波那契数列）： 斐波那契数列的定义： F(0) = 0 F(1) = 1 F(n) = F(n-1) + F(n-2) （当 n &gt; 1 时）例如：0, 1, 1, 2, 3, 5, 8, 13... import java.util.concurrent.ForkJoinPool; import java.util.concurrent.RecursiveTask; class FibonacciTask extends RecursiveTask&lt;Integer&gt; { final int n; FibonacciTask(int n) { this.n = n; } protected Integer compute() { if (n &lt;= 1) return n; FibonacciTask f1 = new FibonacciTask(n - 1); f1.fork(); // 分解任务 FibonacciTask f2 = new FibonacciTask(n - 2); return f2.compute() + f1.join(); // 合并结果 } } class FibonacciTest { public static void main(String[] args) { int n = 10; // 计算斐波那契数列的第10项 ForkJoinPool pool = new ForkJoinPool(); // 创建ForkJoin线程池 FibonacciTask task = new FibonacciTask(n); int result = pool.invoke(task); // 提交任务并获取结果 System.out.println(&quot;F(&quot; + n + &quot;) = &quot; + result); // 输出结果 pool.shutdown(); // 关闭线程池 } } 分治逻辑： 将问题拆解为计算 F(n-1) 和 F(n-2) 的子任务。 fork() 提交一个子任务到线程池异步执行，compute() 同步执行另一个子任务。 join() 等待异步任务的完成并获取结果。 案例：统计大量字符串出现的频率 import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.concurrent.*; public class DataProcessor extends RecursiveTask&lt;Map&lt;String, Integer&gt;&gt; { // 任务拆分的阈值，当 数据量≤1000 时直接处理 private static final int THRESHOLD = 1000; private final List&lt;String&gt; data; // 待处理的字符串列表 public DataProcessor(List&lt;String&gt; data) { this.data = data; } /** * * @return 一个统计字符串频率的 Map */ @Override protected Map&lt;String, Integer&gt; compute() { if (data.size() &lt;= THRESHOLD) { return processDirectly(); // 数据量小，直接统计 } else { int mid = data.size() / 2; DataProcessor leftTask = new DataProcessor(data.subList(0, mid)); DataProcessor rightTask = new DataProcessor(data.subList(mid, data.size())); leftTask.fork(); // 异步提交左半部分任务 Map&lt;String, Integer&gt; rightResult = rightTask.compute(); // 同步处理右半部分 Map&lt;String, Integer&gt; leftResult = leftTask.join(); // 等待左半部分结果 // 合并左右结果 rightResult.forEach((k, v) -&gt; leftResult.merge(k, v, Integer::sum)); return leftResult; } } // 遍历列表，使用 map.merge 方法统计词频 private Map&lt;String, Integer&gt; processDirectly() { Map&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); for (String item : data) { result.merge(item, 1, Integer::sum); } return result; } } // 使用示例 class ForkJoinDemo { public static void main(String[] args) { // 模拟大数据集。生成 10_000 个随机字符串（格式为 item-0 到 item-99） List&lt;String&gt; bigData = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10_000; i++) { bigData.add(&quot;item-&quot; + ThreadLocalRandom.current().nextInt(100)); } ForkJoinPool pool = new ForkJoinPool(); DataProcessor task = new DataProcessor(bigData); Map&lt;String, Integer&gt; result = pool.invoke(task); System.out.println(&quot;处理结果大小: &quot; + result.size()); // 按词频降序排序，输出前5个高频词 result.entrySet().stream() .sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()) .limit(5) .forEach(e -&gt; System.out.println(e.getKey() + &quot;: &quot; + e.getValue())); } } CompletableFutureCompletableFuture 是 Java 8 引入的异步编程工具。 用途：支持异步任务的链式调用、组合和异常处理，是 Future 的增强版。 核心特性： 非阻塞回调：通过 thenApply、thenAccept 等方法链式处理结果。 任务组合：支持 thenCombine、allOf、anyOf 等多任务协作。 异常处理：通过 exceptionally 或 handle 方法捕获异常。 手动完成：可通过 complete() 或 completeExceptionally() 主动干预任务状态。 适用场景 并行执行多个任务（如调用多个微服务）。 异步任务编排（如 A 完成后触发 B）。 超时控制（orTimeout, completeOnTimeout）。 异常恢复（exceptionally, handle）。 常用方法： 方法 用途 supplyAsync / runAsync 创建异步任务 thenApply / thenAccept / thenRun 链式回调 thenCompose 链式嵌套 Future thenCombine / allOf / anyOf 组合多个 Future exceptionally / handle 异常处理 complete / completeExceptionally 手动控制 Future 示例： CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;) .thenApply(s -&gt; s + &quot; World&quot;) .thenAccept(System.out::println) .exceptionally(ex -&gt; { ex.printStackTrace(); return null; }); 执行异步任务1、supplyAsync - 执行有返回值的异步任务 // 异步获取用户信息 CompletableFuture&lt;String&gt; getUserInfo = CompletableFuture.supplyAsync(() -&gt; { // 模拟网络请求 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } return &quot;User: Alice, Age: 25&quot;; }); System.out.println(getUserInfo.get()); // 阻塞获取结果 默认使用 ForkJoinPool.commonPool()。 可指定自定义线程池： ExecutorService executor = Executors.newFixedThreadPool(4); CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &quot;Task&quot;, executor); 2、runAsync - 执行无返回值的异步任务 // 异步记录日志 CompletableFuture&lt;Void&gt; logTask = CompletableFuture.runAsync(() -&gt; { System.out.println(&quot;Logging operation completed at &quot; + System.currentTimeMillis()); }); logTask.join(); // 等待任务完成 链式调用（回调处理）链式调用（Chaining Calls）允许以流水线（Pipeline）的方式将多个异步操作串联起来，形成清晰的任务处理流程。 将多个操作通过方法连续调用的方式连接在一起，前一个操作的输出作为后一个操作的输入，形成”任务流水线”。 1、thenApply - 转换结果，对前一个任务的结果进行转换。 // 异步获取用户名后转为大写 CompletableFuture&lt;String&gt; upperCaseName = CompletableFuture.supplyAsync(() -&gt; &quot;alice&quot;) .thenApply(name -&gt; name.toUpperCase()); System.out.println(upperCaseName.get()); // &quot;ALICE&quot; 2、thenAccept - 消费结果，获取前一个任务的结果并进行消费（无返回值）。 // 异步查询订单后发送邮件 CompletableFuture.supplyAsync(() -&gt; &quot;Order#12345&quot;) .thenAccept(order -&gt; System.out.println(&quot;Sending confirmation for &quot; + order)); 3、thenRun - 任务完成后执行操作，前一个任务完成后执行某个操作，不关心结果。 // 数据库备份完成后通知管理员 CompletableFuture.runAsync(() -&gt; backupDatabase()) .thenRun(() -&gt; System.out.println(&quot;Notifying admin: Backup complete&quot;)); 4、thenCompose - 链式嵌套 Future，用于链式调用多个 CompletableFuture，避免回调地狱。 // 先查用户ID，再查用户详情 CompletableFuture&lt;Integer&gt; userIdFuture = CompletableFuture.supplyAsync(() -&gt; 1001); CompletableFuture&lt;String&gt; userDetailFuture = userIdFuture.thenCompose(id -&gt; CompletableFuture.supplyAsync(() -&gt; &quot;User Details for ID: &quot; + id) ); System.out.println(userDetailFuture.get()); // &quot;User Details for ID: 1001&quot; Q1：thenApply 和 thenCompose 的区别？ thenApply：接收前序结果，返回普通值 .thenApply(v -&gt; v.toUpperCase()) // 返回 String thenCompose：接收前序结果，返回新的 CompletableFuture .thenCompose(v -&gt; queryFromDB(v)) // 返回 CompletableFuture&lt;String&gt; Q2：电商订单处理链 // 1. 查询用户信息 → 2. 查询商品 → 3. 计算价格 → 4. 生成订单 CompletableFuture.supplyAsync(() -&gt; getUser(userId)) .thenApply(user -&gt; getProduct(user, productId)) .thenApply(product -&gt; calculatePrice(product)) .thenAccept(price -&gt; createOrder(price)) .exceptionally(ex -&gt; { log.error(&quot;Order failed&quot;, ex); return null; }); 组合多个Future1、thenCombine - 合并两个 Future 的结果，等待两个任务完成，并对结果进行合并。 // 并行查询商品价格和库存，然后计算总价值 CompletableFuture&lt;Double&gt; priceFuture = CompletableFuture.supplyAsync(() -&gt; 19.99); CompletableFuture&lt;Integer&gt; stockFuture = CompletableFuture.supplyAsync(() -&gt; 100); CompletableFuture&lt;BigDecimal&gt; totalValue = priceFuture.thenCombine(stockFuture, (price, stock) -&gt; new BigDecimal(String.valueOf(price)).multiply(new BigDecimal(stock)) ); System.out.println(totalValue.get().toString()); // 1999.0 2、allOf - 等待所有 Future 完成。并行执行多个任务，并在所有任务完成后触发回调。 // 批量调用多个API，全部完成后处理数据 CompletableFuture&lt;String&gt; api1 = CompletableFuture.supplyAsync(() -&gt; &quot;Data1&quot;); CompletableFuture&lt;String&gt; api2 = CompletableFuture.supplyAsync(() -&gt; &quot;Data2&quot;); CompletableFuture&lt;String&gt; api3 = CompletableFuture.supplyAsync(() -&gt; &quot;Data3&quot;); CompletableFuture&lt;Void&gt; allApis = CompletableFuture.allOf(api1, api2, api3); allApis.thenRun(() -&gt; { System.out.println(&quot;All APIs completed&quot;); // 获取各个任务的结果 try { String result1 = api1.get(); String result2 = api2.get(); String result3 = api3.get(); System.out.println(result1 + &quot;, &quot; + result2 + &quot;, &quot; + result3); } catch (Exception e) { e.printStackTrace(); } }); 3、anyOf - 任意一个 Future 完成时触发。多个任务竞争，只要有一个完成就触发回调。 // 多个服务提供相同数据，取最先返回的 CompletableFuture&lt;String&gt; serviceA = CompletableFuture.supplyAsync(() -&gt; { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return &quot;Service A Result&quot;; }); CompletableFuture&lt;String&gt; serviceB = CompletableFuture.supplyAsync(() -&gt; { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } return &quot;Service B Result&quot;; }); CompletableFuture&lt;Object&gt; fastestResult = CompletableFuture.anyOf(serviceA, serviceB); System.out.println(fastestResult.get()); // &quot;Service B Result&quot;（因为B更快） 异常处理1、exceptionally - 捕获异常并返回默认值。类似于 try-catch，在异常时提供备用值。 // 查询用户信息失败时返回默认用户 CompletableFuture&lt;String&gt; userFuture = CompletableFuture.supplyAsync(() -&gt; { if (Math.random() &gt; 0.5) { throw new RuntimeException(&quot;Failed to fetch user&quot;); } return &quot;User Data&quot;; }).exceptionally(ex -&gt; { System.err.println(&quot;Error: &quot; + ex.getMessage()); return &quot;Default User&quot;; }); System.out.println(userFuture.get()); 2、handle - 无论成功或失败都处理。无论任务成功还是失败，都会执行回调。 // 处理任务结果或异常 CompletableFuture&lt;Integer&gt; parsedFuture = CompletableFuture.supplyAsync(() -&gt; &quot;123&quot;) .handle((str, ex) -&gt; { if (ex != null) { return -1; // 解析失败返回默认值 } try { return Integer.parseInt(str); } catch (NumberFormatException e) { return -1; } }); System.out.println(parsedFuture.get()); // 123 或 -1（如果异常） 手动控制Future1、complete - 手动设置结果。强制完成任务并设置结果。 // 超时手动完成任务 CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;(); // 模拟超时控制 new Thread(() -&gt; { try { Thread.sleep(2000); future.complete(&quot;Fallback Data&quot;); } catch (InterruptedException e) { future.completeExceptionally(e); } }).start(); System.out.println(future.get()); // &quot;Fallback Data&quot;（如果超时） 2、completeExceptionally - 手动设置异常。强制任务失败并抛出异常。 // 任务验证失败时主动终止 CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;(); if (invalidInput) { future.completeExceptionally(new IllegalArgumentException(&quot;Invalid input&quot;)); } else { future.complete(&quot;Valid Result&quot;); } 对比总结 类 核心场景 是否支持链式调用 任务类型 底层机制 FutureTask 手动包装异步任务 ❌ 一次性任务 线程池或单独线程执行 ScheduledFuture 延迟/周期性任务 ❌ 单次或周期性 基于时间调度 ForkJoinTask 分治任务（递归、并行） ❌ 可分解的子任务 工作窃取线程池 CompletableFuture 异步回调、组合多任务 ✔️ 链式或组合任务 回调链 + 线程池 如何选择？ 需要延迟/周期任务 → ScheduledFuture 简单异步任务封装 → FutureTask 递归或并行计算 → ForkJoinTask 复杂异步流程（如回调、组合） → CompletableFuture","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://blog.xiongtianci.com/tags/JUC/"},{"name":"高并发","slug":"高并发","permalink":"https://blog.xiongtianci.com/tags/高并发/"}],"author":"木浅"},{"title":"JUC学习笔记-显式锁：ReentrantLock详解","slug":"JUC学习笔记-显式锁：ReentrantLock详解","date":"2024-04-03T09:13:16.000Z","updated":"2025-10-26T02:16:38.529Z","comments":true,"path":"2024/04/03/JUC学习笔记-显式锁：ReentrantLock详解/","link":"","permalink":"https://blog.xiongtianci.com/2024/04/03/JUC学习笔记-显式锁：ReentrantLock详解/","excerpt":"","text":"ReentrantLockReentrantLock 是 Java 并发工具包 (java.util.concurrent.locks) 中的一个重要类，它实现了 Lock 接口，提供了比 synchronized 更灵活、更强大的锁机制。 与synchronized的对比 特性 ReentrantLock synchronized 实现机制 JDK层面实现 JVM层面实现 锁获取方式 显式lock()/unlock() 隐式获取和释放 可中断性 支持lockInterruptibly() 不支持 公平性 可配置公平/非公平模式 完全非公平 条件变量 支持多个Condition 单个等待队列 性能 高竞争下表现更好 Java 6后优化相当 锁绑定 一个锁可绑定多个条件队列 锁与条件队列一对一绑定 核心方法： public class ReentrantLock implements Lock { // 获取锁（不可中断） public void lock(); // 尝试获取锁（立即返回） public boolean tryLock(); // 尝试获取锁（带超时） public boolean tryLock(long timeout, TimeUnit unit); // 获取锁（可中断） public void lockInterruptibly(); // 释放锁 public void unlock(); // 创建条件变量 public Condition newCondition(); } 基础使用1、锁的获取和释放必须成对出现： ReentrantLock lock = new ReentrantLock(); lock.lock(); // 必须在try块外获取锁 try { // 临界区代码 } finally { lock.unlock(); // 确保锁释放 } 锁的获取（lock()） 必须在 try 外。如果在 try 内加锁，可能锁未成功但 finally 仍会执行 unlock()。 对比 synchronized：synchronized 是 Java 内置锁，无需手动释放，因此不会存在此问题： synchronized (lockObject) { // 自动加锁/解锁 // 临界区代码 } 但 ReentrantLock 是显式锁，必须严格遵循 lock-unlock 的配对规则 2、可中断的加锁（避免死锁）： if (lock.tryLock(1, TimeUnit.SECONDS)) { // 尝试获取锁，超时放弃 try { // 临界区代码 } finally { lock.unlock(); } } else { // 处理加锁失败 } 场景案例lock()的使用账户转账案例： public class BankAccount { private final ReentrantLock lock = new ReentrantLock(); private int balance; public void transfer(BankAccount to, int amount) { // 解决死锁：按hash排序获取锁 BankAccount first = this.hashCode() &lt; to.hashCode() ? this : to; BankAccount second = first == this ? to : this; // 按顺序加锁 first.lock.lock(); // 先锁第一个账户 try { second.lock.lock(); // 再锁第二个账户 try { // 检查余额并转账 if (this.balance &gt;= amount) { this.balance -= amount; to.balance += amount; } } finally { second.lock.unlock(); // 释放第二个锁 } } finally { first.lock.unlock(); // 释放第一个锁 } } } 通过 锁排序（Lock Ordering） 避免死锁：按对象的哈希值排序，决定加锁顺序，所有线程都按 first → second 的顺序加锁，避免循环等待 如果 hashCode 相同，仍然可能死锁（但概率极低），可以用 System.identityHashCode() 替代： BankAccount first = System.identityHashCode(this) &lt; System.identityHashCode(to) ? this : to; 如果账户可能动态变化，可以用 UUID 或数据库 ID 排序： BankAccount first = this.getId().compareTo(to.getId()) &lt; 0 ? this : to; System.identityHashCode 和 hashCode 比较： 对比项 hashCode() System.identityHashCode() 是否可重写 是（可能人为导致冲突） 否（始终返回 JVM 内部标识） 冲突概率 高（如 String 哈希算法可能碰撞） 极低（依赖对象内存地址） 适用场景 需要语义相等的对象（如 HashMap） 需要唯一对象标识（如锁排序、调试） lockInterruptibly()可中断锁（死锁处理） import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.locks.ReentrantLock; public class InterruptibleLockDemo { private final ReentrantLock lock1 = new ReentrantLock(); private final ReentrantLock lock2 = new ReentrantLock(); public void threadA() { try { lock1.lockInterruptibly(); // 可中断获取锁1 try { Thread.sleep(100); // 模拟工作耗时 lock2.lockInterruptibly(); // 可中断获取锁2 try { System.out.println(&quot;ThreadA完成任务&quot;); } finally { lock2.unlock(); // 释放锁2 } } finally { lock1.unlock(); // 释放锁1 } } catch (InterruptedException e) { System.out.println(&quot;ThreadA被中断&quot;); // 响应中断 } } // threadB和threadA类似但以相反顺序获取锁 public void threadB() { try { lock2.lockInterruptibly(); // 先获取锁2 try { Thread.sleep(100); // 模拟工作耗时 lock1.lockInterruptibly(); // 再尝试获取锁1 try { System.out.println(&quot;ThreadB完成任务&quot;); } finally { lock1.unlock(); } } finally { lock2.unlock(); } } catch (InterruptedException e) { System.out.println(&quot;ThreadB被中断&quot;); } } public static void main(String[] args) { InterruptibleLockDemo demo = new InterruptibleLockDemo(); Thread t1 = new Thread(demo::threadA); Thread t2 = new Thread(demo::threadB); // threadA 先获取 lock1，再尝试获取 lock2 // threadB 先获取 lock2，再尝试获取 lock1 // 两个线程同时执行，会互相等待对方的锁，导致死锁 t1.start(); t2.start(); // 中断死锁 Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { t1.interrupt(); // 中断线程1 t2.interrupt(); // 中断线程2 timer.cancel(); // 关闭定时器 } }, 2000); // 2秒后中断线程 } } lockInterruptibly()：如果线程在等待锁时被中断，会立即抛出 InterruptedException Timer 在 2秒后 触发，无条件中断 这两个线程（无论是否真的死锁）。线程被中断后，lockInterruptibly() 会抛出 InterruptedException，释放已持有的锁，从而解除死锁 调用 timer.cancel() 停止 Timer，避免重复中断 为什么用 lockInterruptibly()？ 避免永久阻塞：普通 lock() 会无视中断请求，导致线程无法退出；lockInterruptibly() 如果线程在等待锁时被中断，会立即抛出 InterruptedException 适合需要响应中断的场景：如任务超时、系统关闭等。 公平锁公平锁（订单处理系统） import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.locks.ReentrantLock; import java.util.stream.IntStream; // 订单处理系统，使用公平锁来保证多线程环境下的订单处理顺序 public class OrderProcessingSystem { private final ReentrantLock lock = new ReentrantLock(true); // 公平锁 public void processOrder(Order order) { System.out.println(Thread.currentThread().getName() + &quot; 尝试获取锁，时间: &quot; + System.currentTimeMillis()); lock.lock(); try { System.out.println(Thread.currentThread().getName() + &quot; 处理订单: &quot; + order.getId()); // 模拟处理时间 Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 恢复中断状态 System.out.println(Thread.currentThread().getName() + &quot; 被中断，取消订单处理&quot;); } finally { lock.unlock(); } } public static void main(String[] args) { OrderProcessingSystem system = new OrderProcessingSystem(); CountDownLatch lockHeldSignal = new CountDownLatch(1); // 信号量：锁已被占用 // 先启动一个线程，长时间持有锁 new Thread(() -&gt; { system.lock.lock(); // 直接占锁，不执行订单 System.out.println(&quot;Blocking-Thread 已持有锁，迫使其他线程排队&quot;); lockHeldSignal.countDown(); // 通知主线程：锁已被占用 try { Thread.sleep(2000); // 模拟长时间持有锁 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { system.lock.unlock(); } }, &quot;Blocking-Thread&quot;).start(); // 确保锁已被占用后再启动其他线程 try { lockHeldSignal.await(); // 阻塞，直到锁被占用 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } // 此时锁已被占用，公平锁会按顺序分配 ExecutorService executor = Executors.newFixedThreadPool(10); IntStream.range(0, 10).forEach(i -&gt; { executor.submit(() -&gt; { system.processOrder(new Order(i)); }); }); executor.shutdown(); } } class Order { private final int id; public Order(int id) { this.id = id; } public int getId() { return id; } } ReentrantLock(true) 使用 公平锁（fair=true），确保线程按请求锁的顺序获取锁（避免线程饥饿）。 如果是非公平锁（默认），线程可能会插队，导致某些线程长时间等待。 ReentrantLock + Condition生产者消费者模式import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class MessageQueue&lt;T&gt; { private final ReentrantLock lock = new ReentrantLock(); private final Condition notFull = lock.newCondition(); // 队列未满条件 private final Condition notEmpty = lock.newCondition(); // 队列非空条件 private final Object[] items; // 环形队列 private int putPtr, takePtr, count; // 写入指针、读取指针、当前元素数 public MessageQueue(int capacity) { items = new Object[capacity]; } public void put(T x) throws InterruptedException { lock.lock(); try { while (count == items.length) { notFull.await(); // 队列满时等待 } items[putPtr] = x; // 写入数据 if (++putPtr == items.length) putPtr = 0; // 环形指针处理 count++; notEmpty.signal(); // 唤醒一个消费者线程 } finally { lock.unlock(); } } public T take() throws InterruptedException { lock.lock(); try { while (count == 0) { // 队列空时等待 notEmpty.await(); // 释放锁并阻塞 } @SuppressWarnings(&quot;unchecked&quot;) T x = (T) items[takePtr]; // 读取数据 if (++takePtr == items.length) takePtr = 0; // 环形指针处理 count--; notFull.signal(); // 唤醒一个生产者线程 return x; } finally { lock.unlock(); } } } class MessageQueueTest { public static void main(String[] args) throws InterruptedException { MessageQueue&lt;String&gt; queue = new MessageQueue&lt;&gt;(5); // 容量为5的队列 // 生产者线程 ExecutorService producer = Executors.newSingleThreadExecutor(); producer.submit(() -&gt; { try { for (int i = 0; i &lt; 10; i++) { queue.put(&quot;消息-&quot; + i); System.out.println(&quot;生产: 消息-&quot; + i); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); // 消费者线程 ExecutorService consumer = Executors.newSingleThreadExecutor(); consumer.submit(() -&gt; { try { for (int i = 0; i &lt; 10; i++) { String msg = queue.take(); System.out.println(&quot;消费: &quot; + msg); Thread.sleep(200); // 模拟处理耗时 } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); producer.shutdown(); consumer.shutdown(); producer.awaitTermination(10, TimeUnit.SECONDS); consumer.awaitTermination(10, TimeUnit.SECONDS); } } ReentrantLock互斥访问共享资源 保护共享变量：items（队列数组）、putPtr（写入指针）、takePtr（读取指针）、count（当前元素数量）的读写操作必须互斥。 保证 put 和 take 操作的原子性，防止并发修改导致数据不一致。 条件变量（Condition）实现精准唤醒 notFull：队列未满时唤醒生产者线程（put 方法）。 notEmpty：队列非空时唤醒消费者线程（take 方法）。 避免虚假唤醒：通过 while 循环重复检查条件（如 while (count == 0)）。 阻塞操作： 队列满时，put 方法阻塞生产者，直到有空位。 队列空时，take 方法阻塞消费者，直到有新数据。 完整工作流程生产者线程（put） sequenceDiagram participant Producer participant Lock participant notFull participant Queue Producer-&gt;&gt;Lock: lock() alt 队列已满 Producer-&gt;&gt;notFull: await() notFull--&gt;&gt;Producer: 阻塞并释放锁 else 队列未满 Producer-&gt;&gt;Queue: 写入数据 Producer-&gt;&gt;notEmpty: signal() end Producer-&gt;&gt;Lock: unlock() 消费者线程（take） sequenceDiagram participant Consumer participant Lock participant notEmpty participant Queue Consumer-&gt;&gt;Lock: lock() alt 队列为空 Consumer-&gt;&gt;notEmpty: await() notEmpty--&gt;&gt;Consumer: 阻塞并释放锁 else 队列非空 Consumer-&gt;&gt;Queue: 读取数据 Consumer-&gt;&gt;notFull: signal() end Consumer-&gt;&gt;Lock: unlock() 线程交替执行银行叫号系统 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; /** * 银行票务系统，通过 ReentrantLock 和 Condition 实现 VIP客户优先 的业务办理逻辑： * - VIP客户：优先办理，处理完成后切换回普通模式。 * - 普通客户：按顺序办理，每处理3个后切换VIP模式。 */ public class BankTicketSystem { private final ReentrantLock lock = new ReentrantLock(); // VIP客户的等待队列（当 isVipTurn=false 时阻塞） private final Condition vipCondition = lock.newCondition(); // 普通客户的等待队列（当 isVipTurn=true 时阻塞） private final Condition normalCondition = lock.newCondition(); // 当前是否优先处理VIP客户 private boolean isVipTurn = false; // VIP客户流程 public void vipCustomer(int num) throws InterruptedException { lock.lock(); try { while (!isVipTurn) { // 如果不是VIP轮次，释放锁并阻塞 vipCondition.await(); } System.out.println(&quot;VIP客户-&quot; + num + &quot;正在办理业务&quot;); Thread.sleep(500); // 模拟业务处理 isVipTurn = false; // 切换为普通模式 normalCondition.signalAll(); // 唤醒所有普通客户 } finally { lock.unlock(); } } // 普通客户流程 public void normalCustomer(int num) throws InterruptedException { lock.lock(); try { while (isVipTurn) { normalCondition.await(); } System.out.println(&quot;普通客户-&quot; + num + &quot;正在办理业务&quot;); Thread.sleep(300); // 模拟业务处理 if (num % 3 == 0) { // 每处理3个普通客户切换VIP isVipTurn = true; vipCondition.signal(); // 唤醒一个VIP客户 } } finally { lock.unlock(); } } public static void main(String[] args) { BankTicketSystem system = new BankTicketSystem(); // VIP客户线程（每隔一段时间尝试办理） new Thread(() -&gt; { for (int i = 1; i &lt;= 5; i++) { try { system.vipCustomer(i); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }).start(); // 普通客户线程（持续办理） new Thread(() -&gt; { for (int i = 1; i &lt;= 10; i++) { try { system.normalCustomer(i); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }).start(); } } signal() vs signalAll()：VIP客户唤醒一个即可，普通客户需唤醒所有（避免遗漏） 大致流程： 普通客户-1 办理 普通客户-2 办理 普通客户-3 办理 → 切换VIP模式 VIP客户-1 办理 → 切换普通模式 普通客户-4 办理 ... 交易系统订单匹配引擎/** * 订单撮合引擎 的简化实现，用于模拟金融市场中的买卖订单匹配逻辑。 * 核心功能包括： * - 订单管理：按价格优先级维护买卖订单队列。 * - 撮合引擎：持续匹配符合价格的买卖订单。 * - 线程安全：通过 ReentrantLock 和 Condition 保证并发安全。 */ public class OrderMatchingEngine { private final ReentrantLock lock = new ReentrantLock(); // 通知机制，当新订单到达时唤醒撮合线程 private final Condition orderAdded = lock.newCondition(); // 买方订单队列，按价格 降序 排列（高价优先） private final PriorityQueue&lt;Order&gt; buyOrders = new PriorityQueue&lt;&gt;( (a, b) -&gt; Double.compare(b.getPrice(), a.getPrice())); // 卖方订单队列，按价格 升序 排列（低价优先） private final PriorityQueue&lt;Order&gt; sellOrders = new PriorityQueue&lt;&gt;( Comparator.comparingDouble(Order::getPrice)); // 添加订单 public void addOrder(Order order) { lock.lock(); try { if (order.getType() == OrderType.BUY) { buyOrders.add(order); } else { sellOrders.add(order); } orderAdded.signalAll(); // 唤醒撮合线程 } finally { lock.unlock(); } } // 订单撮合逻辑 public void matchOrders() throws InterruptedException { lock.lock(); try { while (true) { // 检查是否可撮合 // 如果买方或卖方队列为空，或最高买价 &lt; 最低卖价 则无法成交 while (buyOrders.isEmpty() || sellOrders.isEmpty() || buyOrders.peek().getPrice() &lt; sellOrders.peek().getPrice()) { orderAdded.await(); // 阻塞等待新订单 } // 执行撮合 // 取出队列头部订单（最高买价和最低卖价）成交，计算成交价（买卖均价的中间价）和成交量（较小数量） Order buy = buyOrders.poll(); Order sell = sellOrders.poll(); double price = (buy.getPrice() + sell.getPrice()) / 2; // 中间价成交 // 取买卖双方数量的较小值，确保成交不超过任一方意愿 double quantity = Math.min(buy.getQuantity(), sell.getQuantity()); System.out.printf(&quot;成交: %.2f @ %.2f%n&quot;, quantity, price); // 处理剩余数量 if (buy.getQuantity() &gt; quantity) { buy.setQuantity(buy.getQuantity() - quantity); buyOrders.add(buy); // 放回剩余部分 } if (sell.getQuantity() &gt; quantity) { sell.setQuantity(sell.getQuantity() - quantity); sellOrders.add(sell); } } } finally { lock.unlock(); } } } class Order { private final OrderType type; // BUY 或 SELL private final double price; private double quantity; // 股票数量 // Constructor, Getters, Setters... } enum OrderType { BUY, SELL } PriorityQueue&lt;Order&gt; 优先队列，按价格排序，分别存储买方和卖方的未成交订单，确保高效撮合 阻塞唤醒机制 等待条件：当无法撮合时，调用 orderAdded.await() 释放锁并阻塞。 唤醒条件：addOrder 添加新订单后调用 orderAdded.signalAll()。 锁分段技术库存系统 import java.util.Arrays; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.ReentrantLock; // 分段锁（Striped Lock） 实现线程安全库存系统 // 通过 数据分片 减少锁竞争，提高并发性能 public class SegmentInventory { // 每个段包含的item数量（向上取整） private final int segmentSize; // 锁数组，每个段一个独立锁 private final ReentrantLock[] locks; // 库存数据数组，counts[itemId] 表示对应商品的库存数 private final int[] counts; /** * @param itemCount 商品总数 * @param concurrencyLevel 并发段数 */ public SegmentInventory(int itemCount, int concurrencyLevel) { // 计算每个段的大小 this.segmentSize = (itemCount + concurrencyLevel - 1) / concurrencyLevel; this.locks = new ReentrantLock[concurrencyLevel]; this.counts = new int[itemCount]; Arrays.setAll(locks, i -&gt; new ReentrantLock()); // 初始化锁数组 } // 增加库存 public void increase(int itemId) { int segment = itemId / segmentSize; // 计算所属段 locks[segment].lock(); // 获取分段锁 try { counts[itemId]++; // 修改库存 } finally { locks[segment].unlock(); // 释放锁 } } // 查询库存 public int getCount(int itemId) { int segment = itemId / segmentSize; locks[segment].lock(); try { return counts[itemId]; // 返回库存 } finally { locks[segment].unlock(); } } } class SegmentInventoryTest { public static void main(String[] args) throws InterruptedException { // 分段锁性能验证。分段锁性能优于全局锁 // testPerformance(); // 分段冲突测试。同段操作串行，不同段并发 testSegmentConflict(); } static void testPerformance() throws InterruptedException { int itemCount = 1000; int threads = 16; // 测试全局锁性能 long start1 = System.currentTimeMillis(); testWithGlobalLock(itemCount, threads); long duration1 = System.currentTimeMillis() - start1; // 测试分段锁性能 long start2 = System.currentTimeMillis(); testWithSegmentLock(itemCount, threads); long duration2 = System.currentTimeMillis() - start2; System.out.println(&quot;全局锁耗时: &quot; + duration1 + &quot;ms&quot;); System.out.println(&quot;分段锁耗时: &quot; + duration2 + &quot;ms&quot;); } static void testWithGlobalLock(int itemCount, int threads) throws InterruptedException { ReentrantLock globalLock = new ReentrantLock(); int[] counts = new int[itemCount]; ExecutorService executor = Executors.newFixedThreadPool(threads); for (int i = 0; i &lt; 10000; i++) { int itemId = i % itemCount; executor.submit(() -&gt; { globalLock.lock(); try { counts[itemId]++; } finally { globalLock.unlock(); } }); } executor.shutdown(); executor.awaitTermination(1, TimeUnit.MINUTES); } static void testWithSegmentLock(int itemCount, int threads) throws InterruptedException { SegmentInventory inventory = new SegmentInventory(itemCount, 16); // 16个分段 ExecutorService executor = Executors.newFixedThreadPool(threads); for (int i = 0; i &lt; 10000; i++) { int itemId = i % itemCount; executor.submit(() -&gt; inventory.increase(itemId)); } executor.shutdown(); executor.awaitTermination(1, TimeUnit.MINUTES); } static void testSegmentConflict() throws InterruptedException { SegmentInventory inventory = new SegmentInventory(100, 4); // 段大小=25 ExecutorService executor = Executors.newFixedThreadPool(2); // 两个线程操作同段的item（26和30属于段1） executor.submit(() -&gt; { for (int i = 0; i &lt; 1000; i++) inventory.increase(26); }); executor.submit(() -&gt; { for (int i = 0; i &lt; 1000; i++) inventory.increase(30); }); executor.shutdown(); executor.awaitTermination(1, TimeUnit.SECONDS); System.out.println(&quot;商品26库存: &quot; + inventory.getCount(26)); // 预期1000 System.out.println(&quot;商品30库存: &quot; + inventory.getCount(30)); // 预期1000 } } 操作 itemId=5 和 itemId=30 会分别锁定 段0 和 段1，互不阻塞。 操作 itemId=10 和 itemId=20 均属于 段0，会互斥阻塞。 segmentSize 计算公式：segmentSize = (itemCount + concurrencyLevel - 1) / concurrencyLevel;，通过 (itemCount + concurrencyLevel - 1) 调整分子，确保所有库存项被覆盖： 当 itemCount 不能被 concurrencyLevel 整除时，余数部分会使得分子足够大，从而让整数除法结果增加 1。 如果整除，则 + concurrencyLevel - 1 不会改变结果。 分段映射规则：int segment = itemId / segmentSize; 为什么分段映射用除法（/）而不是取模（%）？ 使用除法的目的：将连续的 itemId 分配到同一个分段，保证 局部性（Locality），减少锁切换开销。 用取模会破坏局部性，取模会导致相邻的 itemId 被分散到不同分段，增加锁竞争概率。 除法 vs 取模的对比 | 操作 | 效果 | 适用场景 || :——- | :—————————– | :————————————— || / | 按范围分片（连续ID归到同一段） | 需要局部性优化的场景（如相邻ID高频访问） || % | 哈希分片（ID均匀分散到各段） | 需要绝对均匀分布的场景 | 与全局锁比较： 场景 全局锁（synchronized） 分段锁（SegmentInventory） 操作不同段的item 串行执行 并行执行（无竞争） 操作同段的item 串行执行 串行执行（段内竞争） 锁竞争概率 高 低（与 concurrencyLevel 相关） 适用场景 低并发 高并发（如电商库存系统） 锁降级缓存系统 import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantReadWriteLock; // 基于 读写锁（ReentrantReadWriteLock） 的线程安全缓存系统 public class CacheSystem&lt;K, V&gt; { // 提供读写锁分离机制 private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); private final Lock readLock = rwl.readLock(); // 共享锁，允许多线程并发读 private final Lock writeLock = rwl.writeLock(); // 独占锁，写操作或缓存更新时使用 private Map&lt;K, V&gt; cache = new HashMap&lt;&gt;(); public V get(K key) { // 第一阶段：尝试读缓存（共享锁） readLock.lock(); try { V value = cache.get(key); if (value != null) { return value; // 缓存命中直接返回 } } finally { readLock.unlock(); } // 第二阶段：缓存未命中，加写锁 writeLock.lock(); try { // 双重检查，防止其他线程已更新 V value = cache.get(key); if (value == null) { value = loadFromDatabase(key); // 模拟数据库加载 cache.put(key, value); } // 锁降级：在释放写锁前获取读锁 readLock.lock(); return value; } finally { writeLock.unlock(); // 释放写锁，保持读锁 // 此处仍持有读锁，保护后续操作 } } private V loadFromDatabase(K key) { // 模拟数据库加载 return null; } } 关键点： 双重检查的必要性 writeLock.lock(); try { // 再次检查缓存 V value = cache.get(key); if (value == null) { value = loadFromDatabase(key); cache.put(key, value); } // ... } 目的：防止多个线程同时通过第一次检查后，重复加载数据（缓存击穿）。 效果：只有第一个拿到写锁的线程会执行加载，后续线程直接读取缓存。 锁降级（Lock Downgrading） writeLock.lock(); try { // ... 写操作 readLock.lock(); // 锁降级 } finally { writeLock.unlock(); // 释放写锁，保持读锁 } 作用： 保证在写锁释放后，其他线程无法修改数据（因为仍持有读锁）。 避免数据在返回过程中被其他写操作破坏一致性。 注意事项： 锁降级 必须 在写锁未释放前获取读锁，顺序不能颠倒。 不支持锁升级（读锁 → 写锁），会导致死锁。 Q：锁降级是否必要？ 如果去掉锁降级： writeLock.lock(); try { V value = cache.get(key); if (value == null) { value = loadFromDatabase(key); cache.put(key, value); } return value; // 直接返回，不持有读锁 } finally { writeLock.unlock(); } 在 writeLock.unlock() 和返回结果之间，其他线程可能修改数据，导致返回脏数据。 分布式锁（基于Redis+ReentrantLock）public class DistributedLock { private final ReentrantLock localLock = new ReentrantLock(); private final RedisTemplate&lt;String, String&gt; redisTemplate; private final String lockKey; private final String clientId = UUID.randomUUID().toString(); private final long expireTime = 30000; // 30秒 public boolean tryLock(long waitTime) throws InterruptedException { long start = System.currentTimeMillis(); // 先获取本地锁 if (!localLock.tryLock(waitTime, TimeUnit.MILLISECONDS)) { return false; } try { // 循环尝试获取分布式锁 do { Boolean success = redisTemplate.opsForValue().setIfAbsent( lockKey, clientId, expireTime, TimeUnit.MILLISECONDS); if (Boolean.TRUE.equals(success)) { return true; } // 检查锁是否过期 String currentValue = redisTemplate.opsForValue().get(lockKey); if (currentValue != null &amp;&amp; Long.parseLong(currentValue) &lt; System.currentTimeMillis()) { // 锁已过期，尝试抢占 String oldValue = redisTemplate.opsForValue().getAndSet( lockKey, clientId); if (oldValue != null &amp;&amp; oldValue.equals(currentValue)) { return true; } } if (System.currentTimeMillis() - start &gt; waitTime) { break; } Thread.sleep(100); // 短暂等待后重试 } while (true); return false; } finally { localLock.unlock(); } } public void unlock() { // 先检查本地锁 if (!localLock.isHeldByCurrentThread()) { throw new IllegalMonitorStateException(); } try { // 验证是当前客户端持有的锁 String value = redisTemplate.opsForValue().get(lockKey); if (clientId.equals(value)) { redisTemplate.delete(lockKey); } } finally { localLock.unlock(); } } } 常见问题与解决方案死锁预防问题代码： // 线程1 lockA.lock(); lockB.lock(); // 线程2 lockB.lock(); lockA.lock(); 解决方案 方案一 锁顺序一致性 确保所有线程以相同的顺序获取多个锁：先 from 后 to，避免死锁（需全局统一顺序） // 使用tryLock+定时回退 public boolean transfer(Account from, Account to, int amount) { long waitTime = 1000; // 1秒超时 long endTime = System.nanoTime() + waitTime * 1000000; while (true) { if (from.lock.tryLock()) { try { if (to.lock.tryLock()) { try { // 执行转账 return true; } finally { to.lock.unlock(); } } } finally { from.lock.unlock(); } } if (System.nanoTime() &gt; endTime) { return false; } Thread.sleep(100); // 短暂休眠 } } 方案二 设置锁超时 使用 tryLock(long timeout, TimeUnit unit) 方法设置获取锁的超时时间 if (lock.tryLock(1, TimeUnit.SECONDS)) { try { // 临界区代码 } finally { lock.unlock(); } } else { // 处理无法获取锁的情况 } 锁粒度过大问题代码： 使用一个锁保护过多的资源或操作，导致并发性能下降。 private final ReentrantLock lock = new ReentrantLock(); public void updateUser(User user) { lock.lock(); try { // 更新用户基本信息 updateBasicInfo(user); // 更新用户订单 updateOrders(user); // 更新用户地址 updateAddresses(user); } finally { lock.unlock(); } } 优化方案： 减小锁粒度，将一个大锁拆分为多个小锁，每个锁保护不同的资源 使用分段锁。对于集合类数据，可以使用分段锁提高并发度 private final ReentrantLock basicInfoLock = new ReentrantLock(); private final ReentrantLock ordersLock = new ReentrantLock(); private final ReentrantLock addressesLock = new ReentrantLock(); public void updateUser(User user) { basicInfoLock.lock(); try { updateBasicInfo(user); } finally { basicInfoLock.unlock(); } ordersLock.lock(); try { updateOrders(user); } finally { ordersLock.unlock(); } addressesLock.lock(); try { updateAddresses(user); } finally { addressesLock.unlock(); } } 锁泄漏问题问题代码： 忘记释放锁，导致其他线程无法获取锁，程序挂起。 public class LockLeakExample { private final Lock lock = new ReentrantLock(); public void riskyMethod() throws Exception { lock.lock(); // 获取锁 if (someCondition()) { throw new Exception(&quot;Something went wrong&quot;); // 如果抛出异常，锁永远不会被释放 } try { // 正常操作 } finally { lock.unlock(); // 只有在不抛出异常时才会执行 } } private boolean someCondition() { return Math.random() &gt; 0.5; } } 优化方案： 使用 try-finally 确保锁释放 使用 Java 7 的 try-with-resources 模式 public class LockLeakSolution { private final Lock lock = new ReentrantLock(); public void safeMethod() throws Exception { // 使用自定义的LockResource实现AutoCloseable try (LockResource lr = new LockResource(lock)) { if (someCondition()) { throw new Exception(&quot;Something went wrong&quot;); } // 正常操作 } // 自动调用close()释放锁 } private boolean someCondition() { return Math.random() &gt; 0.5; } // 辅助类实现AutoCloseable private static class LockResource implements AutoCloseable { private final Lock lock; public LockResource(Lock lock) { this.lock = lock; lock.lock(); // 在构造时获取锁 } @Override public void close() { lock.unlock(); // 在try-with-resources结束时自动释放锁 } } } 活锁问题问题代码： 线程不断重试某个操作，但始终无法取得进展。 public class LiveLockExample { private final Lock lock1 = new ReentrantLock(); private final Lock lock2 = new ReentrantLock(); public void method1() { while (true) { if (lock1.tryLock()) { try { if (lock2.tryLock()) { try { System.out.println(&quot;method1 成功&quot;); return; } finally { lock2.unlock(); } } } finally { lock1.unlock(); } } // 没有休眠，可能导致CPU高负载 } } public void method2() { while (true) { if (lock2.tryLock()) { try { if (lock1.tryLock()) { try { System.out.println(&quot;method2 成功&quot;); return; } finally { lock1.unlock(); } } } finally { lock2.unlock(); } } // 没有休眠，可能导致CPU高负载 } } } 优化方案： 引入随机退避：在重试时加入随机延迟 限制重试次数：设置最大重试次数，超过后放弃或采取其他策略 public class LiveLockSolution { private final Lock lock1 = new ReentrantLock(); private final Lock lock2 = new ReentrantLock(); private final Random random = new Random(); // 解决方案1: 引入随机退避 public void method1WithBackoff() { while (true) { if (lock1.tryLock()) { try { if (lock2.tryLock()) { try { System.out.println(&quot;method1 成功&quot;); return; } finally { lock2.unlock(); } } } finally { lock1.unlock(); } } // 随机休眠避免活锁 try { Thread.sleep(random.nextInt(50)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return; } } } // 解决方案2: 限制重试次数 public void method2WithRetryLimit() { int retryCount = 0; final int maxRetries = 10; while (retryCount &lt; maxRetries) { if (lock2.tryLock()) { try { if (lock1.tryLock()) { try { System.out.println(&quot;method2 成功&quot;); return; } finally { lock1.unlock(); } } } finally { lock2.unlock(); } } retryCount++; try { Thread.sleep(50); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return; } } System.out.println(&quot;method2 达到最大重试次数&quot;); // 执行备用方案 } } 饥饿问题问题代码： 某些线程长时间无法获取锁，一直处于等待状态。 public class StarvationExample { private final Lock lock = new ReentrantLock(); // 非公平锁 public void worker(String name) { while (true) { lock.lock(); try { System.out.println(name + &quot; 获得锁&quot;); Thread.sleep(1000); // 模拟工作 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { lock.unlock(); } } } // 多个线程竞争时，某些线程可能长时间无法获取锁 } 优化方案： 使用公平锁 限制线程持有锁的时间：避免单个线程长时间占用锁 优先级调整。适当调整线程优先级，但要注意过度使用可能导致其他问题 // 限制锁持有时间 public class TimeLimitedLockSolution { private final Lock lock = new ReentrantLock(); private static final long MAX_LOCK_HOLD_TIME_MS = 500; // 最大持有锁时间500ms public void worker(String name) { while (!Thread.currentThread().isInterrupted()) { try { // 尝试获取锁，最多等待200ms if (lock.tryLock(200, TimeUnit.MILLISECONDS)) { try { long start = System.currentTimeMillis(); System.out.println(name + &quot; 获得锁&quot;); // 模拟工作，但不超过最大持有时间 long workTime = Math.min(1000, MAX_LOCK_HOLD_TIME_MS); Thread.sleep(workTime); // 检查是否已经持有锁过长时间 if (System.currentTimeMillis() - start &gt; MAX_LOCK_HOLD_TIME_MS) { System.out.println(name + &quot; 即将超时，主动释放锁&quot;); break; // 退出当前工作循环，释放锁 } } finally { lock.unlock(); System.out.println(name + &quot; 释放锁&quot;); } } else { System.out.println(name + &quot; 等待锁超时，将重试&quot;); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } public static void main(String[] args) { TimeLimitedLockSolution example = new TimeLimitedLockSolution(); // 创建多个工作线程 for (int i = 1; i &lt;= 5; i++) { String workerName = &quot;Worker-&quot; + i; new Thread(() -&gt; example.worker(workerName)).start(); } } } // 优先级调整 public class EnhancedPrioritySolution { private final Lock lock = new ReentrantLock(true); // 使用公平锁作为基础 private static final long PRIORITY_BOOST_THRESHOLD_MS = 2000; // 等待超过2秒提升优先级 private static final long MAX_WAIT_TIME_MS = 5000; // 最大等待时间5秒 public void worker(String name, int basePriority) { if (basePriority &lt; Thread.MIN_PRIORITY || basePriority &gt; Thread.MAX_PRIORITY) { basePriority = Thread.NORM_PRIORITY; } Thread.currentThread().setPriority(basePriority); long waitStartTime = System.currentTimeMillis(); boolean priorityBoosted = false; while (!Thread.currentThread().isInterrupted()) { try { // 计算剩余等待时间 long waitedTime = System.currentTimeMillis() - waitStartTime; long remainingWaitTime = MAX_WAIT_TIME_MS - waitedTime; if (remainingWaitTime &lt;= 0) { System.out.printf(&quot;%s 等待超时(已等待%dms)，放弃本次操作%n&quot;, name, waitedTime); break; } // 动态优先级调整：等待时间超过阈值时提升优先级 if (!priorityBoosted &amp;&amp; waitedTime &gt; PRIORITY_BOOST_THRESHOLD_MS) { int newPriority = Math.min(basePriority + 1, Thread.MAX_PRIORITY); Thread.currentThread().setPriority(newPriority); priorityBoosted = true; System.out.printf(&quot;%s 已等待%dms，优先级从%d提升到%d%n&quot;, name, waitedTime, basePriority, newPriority); } // 尝试获取锁，带有超时 if (lock.tryLock(100, TimeUnit.MILLISECONDS)) { try { waitStartTime = System.currentTimeMillis(); // 重置等待时间 if (priorityBoosted) { Thread.currentThread().setPriority(basePriority); // 恢复原始优先级 priorityBoosted = false; } System.out.printf(&quot;%s (优先级:%d) 获得锁，执行工作%n&quot;, name, Thread.currentThread().getPriority()); Thread.sleep(800); // 模拟工作 } finally { lock.unlock(); System.out.printf(&quot;%s 释放锁%n&quot;, name); } } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } public static void main(String[] args) { EnhancedPrioritySolution example = new EnhancedPrioritySolution(); // 创建多个工作线程，设置不同基础优先级 for (int i = 1; i &lt;= 5; i++) { String workerName = &quot;Worker-&quot; + i; int priority = i == 3 ? Thread.MAX_PRIORITY : // 一个高优先级线程 i == 5 ? Thread.MIN_PRIORITY : // 一个低优先级线程 Thread.NORM_PRIORITY; // 其他普通优先级 new Thread(() -&gt; example.worker(workerName, priority), workerName).start(); } } } 最佳实践总结 总是使用 try-finally 释放锁，确保锁在任何情况下都能被释放 尽量减小锁的粒度，只锁定必要的资源 考虑使用更高级的同步工具，如 CountDownLatch、CyclicBarrier、Semaphore 等 避免在持有锁时调用外部方法，这可能导致死锁或性能问题 考虑使用并发集合，如 ConcurrentHashMap，而不是自己实现同步 在适当的时候使用 volatile 变量，对于简单的状态标志可能不需要完整同步 考虑无锁算法，如使用 Atomic 类（AtomicInteger, AtomicReference 等） 其他TimerTimer 是 Java 提供的一个 定时任务调度器，用于在 指定的时间 或 固定的时间间隔 执行任务。timer.schedule() 是 Timer 的核心方法，用于安排任务的执行。 Timer的基本使用Timer timer = new Timer(); // 创建一个定时器 守护线程 vs 用户线程： Timer 默认使用 用户线程（非守护线程），即使主线程结束，Timer 仍然会运行。 可以使用 Timer(true) 创建 守护线程，当所有用户线程结束时，Timer 自动终止： Timer timer = new Timer(true); // 守护线程模式 安排任务执行 Timer 提供了多个 schedule() 方法，用于不同场景的任务调度： 方法 作用 schedule(TimerTask task, long delay) 延迟 delay 毫秒后执行任务（单次执行） schedule(TimerTask task, Date time) 在指定 Date 时间执行任务（单次执行） schedule(TimerTask task, long delay, long period) 延迟 delay 毫秒后首次执行，之后每隔 period 毫秒重复执行（固定延迟） schedule(TimerTask task, Date firstTime, long period) 在 firstTime 首次执行，之后每隔 period 毫秒重复执行（固定延迟） scheduleAtFixedRate(TimerTask task, long delay, long period) 类似 schedule，但采用 固定速率（如果任务执行时间超过 period，会立即执行下一次） Timer.schedule()基本语法： // 单次任务示例 Timer timer = new Timer(); timer.schedule( new TimerTask() { // 定义任务 @Override public void run() { System.out.println(&quot;任务执行！&quot;); } }, 2000 // 延迟 2 秒执行 ); TimerTask：抽象类，表示要执行的任务（类似 Runnable） delay：延迟时间（毫秒），表示任务多久后执行 周期性任务示例 Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println(&quot;每隔1秒执行一次&quot;); } }, 0, 1000); // 立即开始，每隔 1000ms 执行 ScheduledExecutorService由于 Timer 的局限性，Java 5 引入了 ScheduledExecutorService（基于线程池），更推荐使用： ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); executor.schedule(() -&gt; { System.out.println(&quot;2秒后执行&quot;); }, 2, TimeUnit.SECONDS); 优势： 使用线程池，避免单线程阻塞问题。 支持更灵活的调度（如 scheduleAtFixedRate）。 异常不会影响其他任务。 对比 对比项 Timer ScheduledExecutorService 线程模型 单线程 线程池（可配置多个线程） 异常处理 异常会终止整个 Timer 异常不影响其他任务 灵活性 较低（仅支持简单调度） 高（支持动态调整、复杂调度） 适用场景 简单的单次或周期性任务 高并发、复杂的定时任务调度 如果只是简单的定时任务（如示例中的死锁检测），Timer 足够使用。 如果是生产环境的高并发任务，优先选择 ScheduledExecutorService。 ConditionCondition是Java并发包(java.util.concurrent.locks)中的一个接口，它提供了线程间通信的更精细控制方式，可以替代传统的Object.wait()、Object.notify()和Object.notifyAll()方法。 Condition与Lock配合使用，提供了更灵活的线程等待/通知机制。一个Lock可以创建多个Condition对象，允许线程在不同的条件下等待。 创建Condition 通过Lock对象的newCondition()方法创建： Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); 核心方法1、await() - 使当前线程等待 类似于Object.wait()，使当前线程释放锁并等待，直到被通知或中断。 condition.await(); 主要特点和作用 释放锁：调用 await() 会原子性地释放与 Condition 关联的锁 等待通知：线程进入等待状态，直到以下情况之一发生： 其他线程调用该条件的 signal() 或 signalAll() 方法 线程被中断 发生虚假唤醒（spurious wakeup） 重新获取锁：当线程被唤醒后，在从 await() 返回前会重新获取锁 典型使用模式： Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); lock.lock(); try { while (条件不满足) { // 必须用 while 而不是 if，防止虚假唤醒 condition.await(); // 条件不满足时等待 } // 执行条件满足后的操作 } finally { lock.unlock(); } 2、signal() - 唤醒一个等待线程 类似于Object.notify()，唤醒一个等待在该条件上的线程。 condition.signal(); 3、signalAll() - 唤醒所有等待线程 类似于Object.notifyAll()，唤醒所有等待在该条件上的线程。 condition.signalAll(); 4、awaitUninterruptibly() - 不可中断的等待 使当前线程等待，直到被通知，且不响应中断。 5、awaitNanos(long nanosTimeout) - 限时等待 使当前线程等待，直到被通知、中断或超时。返回剩余时间。 6、awaitUntil(Date deadline) - 绝对时间等待 使当前线程等待，直到被通知、中断或到达指定时间。 Condition vs Object监视器方法 特性 Condition Object监视器方法 前置条件 必须持有Lock 必须持有对象监视器锁 多条件支持 一个Lock可创建多个Condition 不支持 等待队列 可以有多个等待队列 只有一个等待队列 中断响应 支持可中断和不可中断等待 只支持可中断等待 超时控制 支持纳秒级超时和绝对时间等待 只支持毫秒级超时","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"JUC学习笔记-基础并发工具：Atomic包与CAS","slug":"JUC学习笔记-基础并发工具：Atomic包与CAS","date":"2024-04-02T09:13:02.000Z","updated":"2025-10-26T02:16:56.548Z","comments":true,"path":"2024/04/02/JUC学习笔记-基础并发工具：Atomic包与CAS/","link":"","permalink":"https://blog.xiongtianci.com/2024/04/02/JUC学习笔记-基础并发工具：Atomic包与CAS/","excerpt":"","text":"Atomic包与CAS概述1、什么是Atomic包 java.util.concurrent.atomic 包是Java提供的一组线程安全的原子操作类，可以在不使用锁的情况下实现线程安全操作。这些类主要分为以下几类： 基本类型：AtomicInteger、AtomicLong、AtomicBoolean 引用类型：AtomicReference、AtomicStampedReference、AtomicMarkableReference 数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray 累加器：LongAdder、DoubleAdder（Java 8+） 2、什么是CAS CAS（Compare-And-Swap）是一种无锁算法，包含三个操作数： 内存位置（V） 预期原值（A） 新值（B） CAS操作逻辑：当且仅当V的值等于A时，才会将V的值更新为B，否则不执行任何操作。无论哪种情况，都会返回V的当前值。 Atomic类和CAS的关系Java 的 java.util.concurrent.atomic 包中的所有原子类（如 AtomicInteger、AtomicReference）底层均基于 CAS 机制 实现。 Atomic类 是暴露给开发者使用的 工具。 CAS 是这些工具背后的 核心算法。 // AtomicInteger 的源码片段（JDK） public final int incrementAndGet() { return U.getAndAddInt(this, VALUE, 1) + 1; } // 最终调用的是Unsafe类的CAS操作： unsafe.compareAndSwapInt(obj, offset, expect, update); Atomic 包的 所有能力 均围绕 CAS 展开： 原子自增：AtomicInteger.getAndIncrement() → CAS 循环 条件更新：AtomicReference.compareAndSet() → 直接调用 CAS 复杂累加：LongAdder → 分段 CAS 优化 AtomicInteger counter = new AtomicInteger(0); // 底层CAS实现伪代码： int oldValue; do { oldValue = counter.get(); // 读取当前值 } while (!counter.compareAndSet(oldValue, oldValue + 1)); // CAS尝试更新 所有使用 Atomic 类的场景都隐含了 CAS 的参与： 计数器 // 高并发环境下的计数器 AtomicInteger count = new AtomicInteger(); count.incrementAndGet(); // 内部用CAS保证线程安全 状态标志 // 无锁实现状态切换 AtomicBoolean isRunning = new AtomicBoolean(true); isRunning.compareAndSet(true, false); // CAS更新 非阻塞算法 // 实现无锁栈（Treiber算法） AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;&gt;(); public void push(E item) { Node&lt;E&gt; newHead = new Node&lt;&gt;(item); Node&lt;E&gt; oldHead; do { oldHead = top.get(); newHead.next = oldHead; } while (!top.compareAndSet(oldHead, newHead)); // CAS更新栈顶 } 核心源码1、AtomicInteger实现原理 public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; // 获取Unsafe实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { // 获取value字段的内存偏移地址 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; // CAS核心方法 public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } // 原子自增 public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1; } } 2、Unsafe类的CAS操作 Atomic类底层依赖 sun.misc.Unsafe 类的CAS操作： // Unsafe类提供了多种CAS方法 // 对象字段的CAS操作 public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x); public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x); 参数说明： o: 要操作的对象 offset: 字段在对象中的偏移量(内存地址) expected: 期望的当前值 x: 要设置的新值 基础使用计数器场景 // 传统同步方式 class Counter { private int count = 0; public synchronized void increment() { count++; } } // Atomic方式 class AtomicCounter { private AtomicInteger count = new AtomicInteger(0); public void increment() { count.incrementAndGet(); } // 更灵活的操作 public void add(int delta) { count.getAndAdd(delta); } } 状态标志控制 import java.util.concurrent.atomic.AtomicBoolean; // 系统开关控制 public class FeatureToggle { private AtomicBoolean enabled = new AtomicBoolean(false); public void enable() { enabled.set(true); } public void disable() { enabled.set(false); } public boolean isEnabled() { return enabled.get(); } // 安全切换状态 public boolean toggle() { boolean prev; do { prev = enabled.get(); } while (!enabled.compareAndSet(prev, !prev)); return !prev; } } 库存扣减（电商场景） import java.util.concurrent.atomic.AtomicInteger; import java.util.stream.IntStream; public class InventorySystem { private AtomicInteger stock = new AtomicInteger(1000); // 总库存 public boolean deductStock(int quantity) { int current; do { current = stock.get(); if (current &lt; quantity) { return false; // 库存不足 } } while (!stock.compareAndSet(current, current - quantity)); // 扣减成功，处理订单逻辑 return true; } // 测试用例 public static void main(String[] args) { InventorySystem inventory = new InventorySystem(); // 模拟100个线程并发扣减 IntStream.range(0, 100).parallel().forEach(i -&gt; { if (inventory.deductStock(1)) { System.out.println(&quot;扣减成功&quot;); } }); System.out.println(&quot;剩余库存: &quot; + inventory.stock.get()); } } 序列号生成（分布式ID） import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.atomic.AtomicLong; public class SequenceGenerator { private final AtomicLong sequence = new AtomicLong(0); public long nextId() { return sequence.getAndIncrement(); } // 生成带时间戳的订单ID（格式：时间戳 + 6位序列号） public String generateOrderId() { long timestamp = System.currentTimeMillis(); long seq = nextId(); return String.format(&quot;%d%06d&quot;, timestamp, seq % 1_000_000); } } class SequenceGeneratorTest { private static final SequenceGenerator generator = new SequenceGenerator(); private static final Set&lt;String&gt; generatedIds = ConcurrentHashMap.newKeySet(); // 线程安全的Set private static final int THREAD_COUNT = 100; // 并发线程数 private static final int REQUESTS_PER_THREAD = 1000; // 每个线程生成ID的数量 public static void main(String[] args) throws InterruptedException { ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT); CountDownLatch latch = new CountDownLatch(THREAD_COUNT); long startTime = System.currentTimeMillis(); // 提交任务 for (int i = 0; i &lt; THREAD_COUNT; i++) { executor.submit(() -&gt; { try { for (int j = 0; j &lt; REQUESTS_PER_THREAD; j++) { String orderId = generator.generateOrderId(); if (!generatedIds.add(orderId)) { System.err.println(&quot;⚠️ 重复ID: &quot; + orderId); } } } finally { latch.countDown(); } }); } // 等待所有线程完成 latch.await(); executor.shutdown(); long totalTime = System.currentTimeMillis() - startTime; int totalIds = THREAD_COUNT * REQUESTS_PER_THREAD; System.out.println(&quot;测试完成！&quot;); System.out.println(&quot;生成ID总数: &quot; + totalIds); System.out.println(&quot;唯一ID数量: &quot; + generatedIds.size()); System.out.println(&quot;是否有重复: &quot; + (generatedIds.size() != totalIds ? &quot;是&quot; : &quot;否&quot;)); System.out.println(&quot;总耗时: &quot; + totalTime + &quot;ms&quot;); System.out.println(&quot;QPS: &quot; + (totalIds * 1000L / totalTime)); } } 实时报价系统 public class PriceUpdater { private AtomicReference&lt;BigDecimal&gt; currentPrice = new AtomicReference&lt;&gt;(BigDecimal.ZERO); // 多个行情源同时更新价格 public void updatePrice(BigDecimal newPrice) { BigDecimal current; do { current = currentPrice.get(); if (newPrice.compareTo(current) &lt;= 0) { return; // 新价格不比当前高，不更新 } } while (!currentPrice.compareAndSet(current, newPrice)); // 价格更新通知 notifySubscribers(newPrice); } private void notifySubscribers(BigDecimal price) { // 通知订阅者逻辑... } } CAS的局限性及解决方案ABA问题问题描述：线程1读取值为A，线程2将值改为B后又改回A，此时线程1的CAS操作仍会成功，可能导致逻辑错误。 AtomicReference&lt;Integer&gt; account = new AtomicReference&lt;&gt;(100); // 线程1 (会遭遇ABA问题) new Thread(() -&gt; { int current = account.get(); // 读取100 System.out.println(&quot;线程1读取: &quot; + current); // 模拟处理其他事情时被挂起 try { Thread.sleep(1000); } catch (InterruptedException e) {} // 尝试更新 boolean success = account.compareAndSet(current, 200); System.out.println(&quot;线程1更新结果: &quot; + success + &quot;，当前值: &quot; + account.get()); }).start(); // 线程2 (制造ABA场景) new Thread(() -&gt; { // 第一次修改：100→50 boolean success1 = account.compareAndSet(100, 50); System.out.println(&quot;线程2第一次修改: &quot; + success1 + &quot;，当前值: &quot; + account.get()); // 第二次修改：50→100 boolean success2 = account.compareAndSet(50, 100); System.out.println(&quot;线程2第二次修改: &quot; + success2 + &quot;，当前值: &quot; + account.get()); }).start(); 银行账户转账中的ABA问题： 在银行转账场景中，假设账户余额为100元： 线程A读取余额为100，准备转账50元 线程A被挂起 线程B转账50元，余额变为50 线程C存入50元，余额又变回100 线程A恢复执行，发现余额还是100，认为没有变化，执行转账操作 这样会导致账户实际上被扣款两次（线程B和线程A都扣款了50元），但余额看起来只减少了50元。 解决方案：使用 AtomicStampedReference 或 AtomicMarkableReference 添加版本号控制。 AtomicStampedReference 通过添加一个版本号（stamp）来解决ABA问题。每次修改都会递增版本号，CAS操作不仅要比较值，还要比较版本号。 import java.util.concurrent.atomic.AtomicStampedReference; // 银行账户转账ABA问题示例 public class Account { // 使用AtomicStampedReference包装余额，初始值100，初始版本号0 private AtomicStampedReference&lt;Integer&gt; balance = new AtomicStampedReference&lt;&gt;(100, 0); public boolean transfer(int amount) { int[] stamp = new int[1]; // 用于保存当前版本号的数组 int current; do { // 获取当前值和版本号 current = balance.get(stamp); if (current &lt; amount) { return false; // 余额不足，转账失败 } } while (!balance.compareAndSet( current, current - amount, // 期望值和新值 stamp[0], stamp[0] + 1)); // 期望版本号和新版本号 return true; } } 使用 get(stamp) 同时获取当前值和版本号 compareAndSet() 只有当值和版本号都匹配时才更新 AtomicStampedReference 和 AtomicMarkableReference 都是 Java 并发包中用于解决 ABA 问题 的原子引用类 特性 AtomicStampedReference AtomicMarkableReference 版本控制方式 使用 整数版本号（stamp）（每次修改递增） 使用 布尔标记（mark）（true/false） 适用场景 需要严格版本控制的场景（如银行交易） 只需知道”是否被修改过”的场景（如缓存标记） ABA 问题解决方案 通过版本号检测中间变化 通过布尔标记检测是否被修改过 典型用例 账户余额、计数器 对象状态标记、缓存失效机制 AtomicStampedReference 适用场景： 银行账户余额（防止 ABA 问题） 计数器（需要知道修改次数） 任何需要 精确版本控制 的场景 AtomicStampedReference&lt;Integer&gt; account = new AtomicStampedReference&lt;&gt;(100, 0); // 线程1：读取值和版本号 int[] stamp = new int[1]; int balance = account.get(stamp); // balance=100, stamp[0]=0 // 线程2：修改值并增加版本号 account.compareAndSet(100, 50, 0, 1); // 版本号 0→1 // 线程1尝试更新（失败，因为版本号已变） boolean success = account.compareAndSet(100, 200, stamp[0], stamp[0] + 1); // success = false（因为版本号已变为1，不匹配0） AtomicMarkableReference 适用场景： 缓存数据是否失效（true=失效，false=有效） 对象是否被锁定（true=已锁定，false=未锁定） 只需知道 “对象是否被修改过”，而不关心修改了多少次 AtomicMarkableReference&lt;String&gt; cache = new AtomicMarkableReference&lt;&gt;(&quot;data&quot;, false); // 线程1：读取值和标记 boolean[] mark = new boolean[1]; String data = cache.get(mark); // data=&quot;data&quot;, mark[0]=false // 线程2：修改值并设置标记为 true（表示已修改） cache.compareAndSet(&quot;data&quot;, &quot;newData&quot;, false, true); // 线程1尝试更新（失败，因为标记已变） boolean success = cache.compareAndSet(&quot;data&quot;, &quot;updated&quot;, mark[0], true); // success = false（因为标记已变为 true，不匹配 false） 如何选择？ 场景 推荐类 需要严格版本控制（如金融交易） AtomicStampedReference 只需知道是否被修改过（如缓存失效） AtomicMarkableReference 自旋开销问题描述：高并发场景下CAS失败率增加，线程会持续自旋，导致CPU空转。 public class Counter { private AtomicInteger count = new AtomicInteger(0); public void increment() { int oldValue; do { oldValue = count.get(); } while (!count.compareAndSet(oldValue, oldValue + 1)); } } // 高并发时可能导致大量线程自旋 解决方案： 使用 LongAdder 替代 AtomicLong（Java 8+） 引入适当的退避策略 // 高并发计数器优化 public class HitCounter { // 使用 LongAdder 作为计数器 private LongAdder count = new LongAdder(); // 增加计数 public void hit() { count.increment(); } // 获取总计数 public long getCount() { return count.sum(); } } LongAdder 采用了 分段累加（Cell 分散） 的策略： 基础值（base）：初始计数值 Cell 数组：当竞争激烈时，会创建多个 Cell，让不同线程更新不同的 Cell 最终求和：sum() 方法返回 base + 所有 Cell 的和 退避算法（Exponential Backoff） public class BackoffCounter { private AtomicInteger count = new AtomicInteger(0); // 最小退避时间(单位毫秒) private static final int MIN_DELAY = 1; // 最大退避时间(单位毫秒)，防止退避时间无限增长 private static final int MAX_DELAY = 100; public void increment() { int delay = MIN_DELAY; // 初始退避时间 while (true) { int current = count.get(); if (count.compareAndSet(current, current + 1)) { break; // CAS成功，退出循环 } // CAS失败后等待随机时间 try { Thread.sleep((long)(Math.random() * delay)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } delay = Math.min(delay * 2, MAX_DELAY); // 指数增加退避时间 } } } 指数退避算法：每次失败后，等待时间按指数增长：1, 2, 4, 8,…直到MAX_DELAY 只能保证单个变量原子性问题描述：CAS无法保证多个变量的原子更新。 解决方案： 使用AtomicReference包装多个变量 使用锁机制 // 原子更新多个变量 public class Point { private static class State { final int x; final int y; State(int x, int y) { this.x = x; this.y = y; } } // 原子状态引用 private AtomicReference&lt;State&gt; state = new AtomicReference&lt;&gt;(new State(0, 0)); // 原子更新方法 public void move(int deltaX, int deltaY) { State current; State newState; do { current = state.get(); // 获取当前状态 newState = new State( // 创建新状态 current.x + deltaX, current.y + deltaY ); } while (!state.compareAndSet(current, newState)); } public int getX() { return state.get().x; } public int getY() { return state.get().y; } } State类被设计为不可变(immutable)的，所有字段都是final的，一旦创建就不能修改 性能对比与选型建议1、Atomic vs Synchronized // 性能测试对比 public class PerformanceTest { private AtomicInteger atomicCounter = new AtomicInteger(0); private int syncCounter = 0; @Test public void testPerformance() { // Atomic测试 long atomicTime = test(() -&gt; { atomicCounter.incrementAndGet(); }); // Synchronized测试 long syncTime = test(() -&gt; { synchronized (this) { syncCounter++; } }); System.out.printf(&quot;Atomic: %dms, Synchronized: %dms%n&quot;, atomicTime, syncTime); } private long test(Runnable task) { long start = System.currentTimeMillis(); IntStream.range(0, 1_000_000) .parallel() .forEach(i -&gt; task.run()); return System.currentTimeMillis() - start; } } 2、选型建议 场景 推荐方案 理由 简单计数器 AtomicInteger/Long 实现简单，性能好 高并发统计 LongAdder 减少CAS竞争 复杂对象更新 AtomicReference 保证引用原子性 需要版本控制 AtomicStampedReference 解决ABA问题 多变量原子更新 锁机制 CAS无法直接支持","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"JUC学习步骤","slug":"JUC学习步骤","date":"2024-04-01T07:47:54.000Z","updated":"2025-10-26T02:17:14.104Z","comments":true,"path":"2024/04/01/JUC学习步骤/","link":"","permalink":"https://blog.xiongtianci.com/2024/04/01/JUC学习步骤/","excerpt":"","text":"Java JUC (java.util.concurrent) 学习路线建议学习 Java 并发工具包 (JUC) 的学习路线： 1. 基础准备 掌握 Java 基础：特别是多线程基础（Thread, Runnable） 理解并发基本概念：线程安全、竞态条件、死锁、活锁等 2. 核心组件学习顺序第一阶段：基础并发工具 Atomic 包：原子变量类 AtomicInteger, AtomicLong, AtomicBoolean AtomicReference, AtomicStampedReference 基本锁机制 synchronized 关键字复习 ReentrantLock 和 Condition 第二阶段：并发集合 ConcurrentHashMap：高并发 Map 实现 CopyOnWriteArrayList：读多写少的 List 实现 BlockingQueue 系列： ArrayBlockingQueue LinkedBlockingQueue PriorityBlockingQueue SynchronousQueue DelayQueue 第三阶段：高级同步工具 CountDownLatch：一次性栅栏 CyclicBarrier：可重复使用的栅栏 Semaphore：信号量控制 Exchanger：线程间交换数据 第四阶段：执行框架 Executor 框架 ThreadPoolExecutor ScheduledThreadPoolExecutor Executors 工厂类 Future 和 Callable CompletableFuture (Java 8+) 第五阶段：高级主题 Fork/Join 框架 Phaser (Java 7+) StampedLock (Java 8+) 系列文章第一阶段：基础并发工具 《JUC学习笔记-基础并发工具：Atomic包与CAS》 《JUC学习笔记-显式锁：ReentrantLock详解》 第二阶段：并发集合 《JUC学习笔记-并发集合：ConcurrentHashMap解析》 《JUC学习笔记-阻塞队列：BlockingQueue核心实现》 第三阶段：高级同步工具 《JUC学习笔记-线程协作：CountDownLatch与CyclicBarrier》 《JUC学习笔记-资源控制：Semaphore应用》 第四阶段：执行框架 《JUC学习笔记-线程池：Executor框架核心》 《JUC学习笔记-异步编程：Future与Callable》 《JUC学习笔记-增强Future：CompletableFuture实战》 第五阶段：高级主题 《JUC学习笔记-分治任务：Fork/Join框架》 《JUC学习笔记-锁优化：StampedLock详解》","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"JDK8中的StampedLock","slug":"JDK8中的StampedLock","date":"2024-03-11T11:09:35.000Z","updated":"2025-10-26T02:17:30.008Z","comments":true,"path":"2024/03/11/JDK8中的StampedLock/","link":"","permalink":"https://blog.xiongtianci.com/2024/03/11/JDK8中的StampedLock/","excerpt":"","text":"StampedLock是什么StampedLock 是 JDK 8 引入的一种新型锁机制，位于 java.util.concurrent.locks 包下。它是对读写锁（ReentrantReadWriteLock）的优化，提供了三种访问模式： 写锁（Write Lock）：独占锁，类似 ReentrantReadWriteLock 的写锁。 读锁（Read Lock）：共享锁，类似 ReentrantReadWriteLock 的读锁。 乐观读（Optimistic Read）：无锁机制，通过“戳记（Stamp）”验证数据是否被修改，避免完全加读锁的开销。 相比传统的 ReentrantReadWriteLock，StampedLock 在某些场景下能提供更好的性能。 特点 不可重入：StampedLock 的锁不可重入，同一个线程重复获取锁会导致死锁 不支持条件变量：不像 ReentrantLock 那样支持 Condition 票据(Stamp)机制：所有锁方法都返回一个 stamp，用于后续的解锁或验证操作 核心方法 1、写锁操作 // 获取写锁，返回 stamp long writeStamp = lock.writeLock(); try { // 写操作 } finally { // 释放写锁，需要传入正确的 stamp lock.unlockWrite(writeStamp); } 2、悲观读锁操作 // 获取读锁，返回 stamp long readStamp = lock.readLock(); try { // 读操作 } finally { // 释放读锁，需要传入正确的 stamp lock.unlockRead(readStamp); } 3、乐观读操作 // 尝试乐观读，返回 stamp long stamp = lock.tryOptimisticRead(); // 读取共享变量 int value = sharedValue; // 验证 stamp 是否仍然有效(期间没有写操作) if (!lock.validate(stamp)) { // 如果无效，升级为悲观读锁 stamp = lock.readLock(); try { value = sharedValue; } finally { lock.unlockRead(stamp); } } // 使用读取的值 为什么 JDK 8 还要推出 StampedLock？虽然已有 synchronized、ReentrantLock 和 ReentrantReadWriteLock，但它们在高并发读多写少的场景下仍存在性能瓶颈。StampedLock 的出现是为了解决以下问题： 1、读写锁（ReentrantReadWriteLock）的缺陷 读锁与写锁互斥：读锁会阻塞写锁，写锁会阻塞所有读锁，即使读操作非常频繁，写操作也可能长时间饥饿。 无乐观读机制：读锁必须加锁，即使数据未被修改，也会带来不必要的同步开销。 2、StampedLock 的优势 乐观读：通过 tryOptimisticRead() 获取一个“戳记”（Stamp），读数据时不加锁，后续通过 validate(stamp) 检查数据是否被修改。如果未被修改，直接使用；如果被修改，再升级为悲观读锁。 StampedLock lock = new StampedLock(); long stamp = lock.tryOptimisticRead(); // 乐观读（无锁） // 读取共享数据... if (!lock.validate(stamp)) { // 检查是否被修改 stamp = lock.readLock(); // 升级为悲观读锁 try { // 重新读取数据... } finally { lock.unlockRead(stamp); } } 更高的吞吐量：乐观读避免了读锁的竞争，特别适合读多写少的场景。 支持锁升级/降级：例如，可以将乐观读升级为悲观读锁或写锁。 3、对比其他锁的性能 在读远多于写的场景下，StampedLock 的吞吐量显著高于 ReentrantReadWriteLock。 但 StampedLock 不是可重入锁，且没有条件变量（Condition）支持，复杂场景需谨慎使用。 适用场景 适合读多写少的高并发场景（如缓存、监控统计）。 不适用： 需要重入锁或条件变量的场景（用 ReentrantLock）。 写操作频繁的场景（可能让乐观读失效频繁，退化为悲观锁）。 使用案例简单的读写操作class Point { private double x, y; // 点的坐标 private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) { long stamp = sl.writeLock(); // 获取写锁 try { x += deltaX; y += deltaY; } finally { sl.unlockWrite(stamp); // 释放写锁 } } double distanceFromOrigin() { long stamp = sl.tryOptimisticRead(); // 尝试乐观读 double currentX = x, currentY = y; if (!sl.validate(stamp)) { // 检查是否有写操作发生 stamp = sl.readLock(); // 获取悲观读锁 try { currentX = x; currentY = y; } finally { sl.unlockRead(stamp); // 释放读锁 } } return Math.sqrt(currentX * currentX + currentY * currentY); } } writeLock()获取独占写锁，返回一个”戳记”(stamp)用于后续解锁 tryOptimisticRead()尝试乐观读，不阻塞其他线程的写操作，返回一个戳记 validate(stamp)检查自获取戳记以来是否有写操作发生： 如果没有(返回true)，说明读取的值是有效的，可以直接使用 如果有(返回false)，则需要获取悲观读锁重新读取 如果验证失败，获取真正的读锁(readLock())，然后重新读取值 锁转换展示 StampedLock 的一个高级特性：读锁转换为写锁。 class CachedData { private Object data; private final StampedLock lock = new StampedLock(); void processCachedData() { long stamp = lock.readLock(); try { while (!isValid(data)) { long ws = lock.tryConvertToWriteLock(stamp); if (ws != 0L) { stamp = ws; data = refreshData(); // 更新缓存 break; } else { lock.unlockRead(stamp); stamp = lock.writeLock(); } } use(data); } finally { lock.unlock(stamp); } } private boolean isValid(Object data) { /*...*/ } private Object refreshData() { /*...*/ } private void use(Object data) { /*...*/ } } tryConvertToWriteLock()：尝试将现有的读锁转换为写锁，而无需先释放读锁再获取写锁，这种操作称为锁转换或锁升级。 如果转换成功，返回一个有效的写锁戳记（非零） 如果转换失败，返回0 与ReentrantReadWriteLock对比场景描述：高并发读写缓存 假设有一个全局配置缓存 configCache，多个线程频繁读取配置，偶尔有线程更新配置。 读操作频率：每秒 10,000+ 次 写操作频率：每秒 1~2 次 1、使用 ReentrantReadWriteLock 的实现 import java.util.concurrent.locks.ReentrantReadWriteLock; public class ConfigCacheWithReadWriteLock { private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(); private String configData = &quot;default&quot;; public String readConfig() { rwLock.readLock().lock(); // 加读锁（阻塞写锁） try { return configData; } finally { rwLock.readLock().unlock(); } } public void updateConfig(String newData) { rwLock.writeLock().lock(); // 加写锁（阻塞所有读锁） try { configData = newData; } finally { rwLock.writeLock().unlock(); } } } 2、使用 StampedLock 的实现 import java.util.concurrent.locks.StampedLock; public class ConfigCacheWithStampedLock { private final StampedLock stampedLock = new StampedLock(); private String configData = &quot;default&quot;; // 乐观读：无锁尝试 public String readConfig() { long stamp = stampedLock.tryOptimisticRead(); String currentData = configData; // 读取数据（无锁） if (!stampedLock.validate(stamp)) { // 检查是否被修改 stamp = stampedLock.readLock(); // 升级为悲观读锁 try { currentData = configData; // 重新读取 } finally { stampedLock.unlockRead(stamp); } } return currentData; } // 写操作：独占锁 public void updateConfig(String newData) { long stamp = stampedLock.writeLock(); try { configData = newData; } finally { stampedLock.unlockWrite(stamp); } } } 使用 JMH 进行性能测试 导入坐标： &lt;dependencies&gt; &lt;!-- JMH 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;1.36&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt; &lt;version&gt;1.36&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;finalName&gt;benchmarks&lt;/finalName&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;mainClass&gt;org.openjdk.jmh.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; JMH 测试类 import org.openjdk.jmh.annotations.*; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.RunnerException; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.util.concurrent.TimeUnit; @BenchmarkMode(Mode.Throughput) // 测试吞吐量 @OutputTimeUnit(TimeUnit.MILLISECONDS) // 输出单位：毫秒 @State(Scope.Benchmark) public class LockBenchmark { private ConfigCacheWithReadWriteLock readWriteLockCache; private ConfigCacheWithStampedLock stampedLockCache; @Setup public void setup() { readWriteLockCache = new ConfigCacheWithReadWriteLock(); stampedLockCache = new ConfigCacheWithStampedLock(); } // 测试 ReentrantReadWriteLock 的读性能 @Benchmark public String testReadWriteLockRead() { return readWriteLockCache.readConfig(); } // 测试 StampedLock 的读性能 @Benchmark public String testStampedLockRead() { return stampedLockCache.readConfig(); } // 测试 ReentrantReadWriteLock 的写性能 @Benchmark public void testReadWriteLockWrite() { readWriteLockCache.updateConfig(&quot;newValue&quot;); } // 测试 StampedLock 的写性能 @Benchmark public void testStampedLockWrite() { stampedLockCache.updateConfig(&quot;newValue&quot;); } public static void main(String[] args) throws RunnerException { Options opt = new OptionsBuilder() .include(LockBenchmark.class.getSimpleName()) .forks(1) // 使用 1 个进程 .warmupIterations(5) // 预热 5 次 .measurementIterations(10) // 正式测试 10 次 .build(); new Runner(opt).run(); } } JMH 要求基准测试类放在 src/main/java 下（而非 src/test/java），因为 JMH 会动态生成代码。 测试结果 Benchmark Mode Cnt Score Error Units testReadWriteLockRead thrpt 10 40745.041 ± 5702.837 ops/ms testReadWriteLockWrite thrpt 10 46714.948 ± 2200.964 ops/ms testStampedLockRead thrpt 10 228822.159 ± 13864.537 ops/ms testStampedLockWrite thrpt 10 53863.354 ± 3638.881 ops/ms Benchmark：测试的方法名称（不同锁实现的读写性能对比） Mode：测试模式（thrpt 表示吞吐量，单位是操作数/毫秒） Cnt：迭代次数（每个测试运行了 10 次） Score：平均吞吐量（值越大性能越好） Error：误差范围（± 后的值，表示结果的波动性） Units：单位（ops/ms 表示每毫秒完成的操作数） 结论： 读操作：StampedLock 的吞吐量是 ReentrantReadWriteLock 的 5 倍以上（因为乐观读无锁）。 写操作：两者相差不大，StampedLock 稍快（因为无读锁竞争）。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"分布式ID的几种生成方式","slug":"分布式ID的几种生成方式","date":"2024-03-01T01:21:33.000Z","updated":"2025-10-26T01:45:43.831Z","comments":true,"path":"2024/03/01/分布式ID的几种生成方式/","link":"","permalink":"https://blog.xiongtianci.com/2024/03/01/分布式ID的几种生成方式/","excerpt":"","text":"UUIDUUID (Universally Unique Identifier) 是一个 128 位的标识符，用于在分布式系统中唯一地标识信息。UUID 的标准定义见 RFC 4122。 特点： 全局唯一性：理论上在不同时间、不同机器上生成的 UUID 都不会重复 固定长度：128 位，通常表示为 32 个十六进制数字，分为 5 组显示 无需中央管理机构：可以本地生成，不需要注册 多种生成算法：UUID 有 5 个版本，每个版本使用不同的生成方法 优点： 本地生成，无网络开销，性能高。 全球唯一。 缺点： 无序（作为主键时导致B+树频繁分裂，影响插入性能）。 字符串存储占用空间大（36字节），查询效率低。 适用场景：对唯一性要求高、无需有序且非DB主键的场景。 格式：标准 UUID 表示为 32 个十六进制数字，分为 5 组，形式为：8-4-4-4-12，例如 550e8400-e29b-41d4-a716-446655440000。 UUID 的版本： 版本 1 (基于时间和 MAC 地址)：使用当前时间戳和 MAC 地址生成 版本 2 (DCE 安全 UUID)：基于版本 1，但加入了本地域标识符 版本 3 (基于名称的 MD5 哈希)：使用命名空间和名称的 MD5 哈希生成 版本 4 (随机 UUID)：使用随机或伪随机数生成 版本 5 (基于名称的 SHA-1 哈希)：类似版本 3，但使用 SHA-1 哈希 Java 中的实现在Java中，UUID（通用唯一标识符）是一个128位的值，通常表示为32个十六进制数字，由连字符分隔成5组（8-4-4-4-12格式）。 主要方法 生成随机 UUID (版本 4)： UUID uuid = UUID.randomUUID(); 从字符串创建 UUID： // 用于序列化/反序列化 UUID uuid = UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440000&quot;); 获取 UUID 的各个部分： // 获取 UUID 的高64位（前64位） long mostSigBits = uuid.getMostSignificantBits(); // 获取 UUID 的低64位（后64位） long leastSigBits = uuid.getLeastSignificantBits(); // 利用高低位重建 UUID UUID newUuid = new UUID(mostSigBits, leastSigBits); // 比较两个UUID时，先比较高64位，如果不相等就不需要比较低64位 int compare(UUID u1, UUID u2) { int cmp = Long.compare(u1.getMostSignificantBits(), u2.getMostSignificantBits()); if (cmp != 0) return cmp; return Long.compare(u1.getLeastSignificantBits(), u2.getLeastSignificantBits()); } // 基于UUID的高低位生成更短的唯一ID public String generateShortId(UUID uuid) { return Long.toHexString(uuid.getMostSignificantBits()) + Long.toHexString(uuid.getLeastSignificantBits()); } getMostSignificantBits() 和 getLeastSignificantBits() 方法分别获取UUID 128位值的高低位，为两个long值（每个long是64位） 特殊场景中直接比较 long 值比比较字符串更高效 传输两个 long 比传输 UUID 字符串更节省带宽 比较 UUID： int comparison = uuid1.compareTo(uuid2); 生成基于名称的 UUID (版本 3 或 5)： // 版本 3 (MD5) UUID uuid3 = UUID.nameUUIDFromBytes(&quot;name&quot;.getBytes()); // 版本 5 (SHA-1) - Java 标准库不直接支持，需要自己实现 import java.util.UUID; public class UUIDExample { public static void main(String[] args) { // 生成随机 UUID (版本4) UUID randomUUID = UUID.randomUUID(); // 大多数情况下这是最佳选择 System.out.println(&quot;随机 UUID: &quot; + randomUUID); // 从字符串创建 UUID UUID fromString = UUID.fromString(&quot;550e8400-e29b-41d4-a716-446655440000&quot;); System.out.println(&quot;从字符串创建的 UUID: &quot; + fromString); // 生成基于名称的 UUID (版本3) UUID nameBasedUUID = UUID.nameUUIDFromBytes(&quot;example&quot;.getBytes()); System.out.println(&quot;基于名称的 UUID: &quot; + nameBasedUUID); // 获取 UUID 的各个部分 System.out.println(&quot;Most significant bits: &quot; + randomUUID.getMostSignificantBits()); System.out.println(&quot;Least significant bits: &quot; + randomUUID.getLeastSignificantBits()); System.out.println(&quot;版本号: &quot; + randomUUID.version()); // 4 表示版本4 System.out.println(&quot;变体: &quot; + randomUUID.variant()); // 2 表示IETF变体 } } UUID 版本3和4对比 Java中的实现 特点 使用场景 版本3 UUID.randomUUID() 完全基于随机数122位随机性 (其余6位用于版本和变体信息) 安全令牌、会话ID，等 版本4 UUID.nameUUIDFromBytes() 基于命名空间和名称的 MD5 哈希相同输入总是产生相同输出 基于内容生成唯一ID (如文件内容哈希)、需要跨系统一致生成的ID，等 数据库自增序列利用数据库的自增特性： 单数据库：AUTO_INCREMENT(MySQL)或SEQUENCE(Oracle) 多数据库：设置不同步长（如DB1:1,4,7… DB2:2,5,8… DB3:3,6,9…） 优点：简单，递增有序。缺点： 强依赖DB，存在单点风险。 分库分表时需额外配置步长，扩容困难。 暴露业务数据量（如用户ID可推测注册量）。 适用场景：小型非分布式系统。 单数据库实现MySQL (AUTO_INCREMENT): CREATE TABLE items ( id BIGINT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) ); Oracle (SEQUENCE): CREATE SEQUENCE item_seq START WITH 1 INCREMENT BY 1; CREATE TABLE items ( id NUMBER PRIMARY KEY, name VARCHAR2(100) ); -- 插入时使用 INSERT INTO items (id, name) VALUES (item_seq.NEXTVAL, &#39;item1&#39;); 多数据库实现（步长设置）在分布式系统中，通过设置不同数据库实例的自增步长和初始值来避免ID冲突： DB1: 初始值=1，步长=3 → 1, 4, 7, 10... DB2: 初始值=2，步长=3 → 2, 5, 8, 11... DB3: 初始值=3，步长=3 → 3, 6, 9, 12... Java实现基于MySQL的实现-- DB1配置 SET @@auto_increment_increment=3; SET @@auto_increment_offset=1; -- DB2配置 SET @@auto_increment_increment=3; SET @@auto_increment_offset=2; -- DB3配置 SET @@auto_increment_increment=3; SET @@auto_increment_offset=3; Redis生成ID实现：利用Redis的 INCR 或 INCRBY 原子操作生成递增ID。 优点： 性能优于DB（单机可达10W+/秒）。 可生成有序ID。 缺点： 需引入Redis，增加系统复杂度。 持久化问题（AOF/RDB宕机可能导致ID重复）。 优化： 集群模式下分片生成（如每个实例预分配ID段）。 适用场景：需要高性能且允许少量ID不连续的场景。 代码实现利用Redis的原子性操作： // 使用INCR命令 Long id = redisTemplate.opsForValue().increment(&quot;global_id&quot;); Snowflake算法Snowflake 算法，雪花算法，是 Twitter 开源的分布式ID生成算法。生成后是一个 64bit 的 long 型的数值，组成部分引入了时间戳。 实现：64位ID = 1位符号位 + 41位时间戳 + 10位机器ID + 12位序列号。 优点： 本地生成，高性能（单机每秒26万+）。 趋势递增，适合作为DB主键。 缺点： 依赖系统时钟（时钟回拨会导致ID重复）。 需管理机器ID（如通过ZooKeeper）。 优化： 改进版（如美团Leaf）：解决时钟回拨问题。 缩短时间戳位数，扩展机器ID（如百度UidGenerator）。 适用场景：高并发分布式系统（如订单、日志系统）。 ID 的结构如下： +--------------------------------------------------------------------------+ | 1 Bit Unused | 41 Bit Timestamp | 10 Bit Machine ID | 12 Bit Sequence ID | +--------------------------------------------------------------------------+ 1 位未使用的 bit：最高位是符号位，始终为 0，表示正数。 41 位时间戳：表示自定义起始时间（twepoch）以来的毫秒数，可以用来排序。 10 位机器 ID：用于表示生成 ID 的机器或数据中心，确保分布式系统中不同节点生成的 ID 唯一。通常由 5 位数据中心 ID 和 5 位机器 ID 组成。 12 位序列号：表示在同一毫秒内生成的不同 ID，解决高并发场景下的冲突问题。 实现步骤 获取当前时间戳：获取当前时间与自定义起始时间的差值（单位为毫秒）。 检查时钟回拨：确保当前时间戳不小于上一次生成 ID 的时间戳。如果发生回拨，通常会抛出异常。 生成序列号： 如果在同一毫秒内生成的 ID，将序列号加 1。 如果序列号达到最大值，等待到下一毫秒。 如果是新的毫秒，序列号重置为 0。 拼接 ID：将时间戳、机器 ID 和序列号左移并按位或组合成 64 位的 ID。 Java 实现以下是 Snowflake 算法在 Java 中的完整实现代码： public class SnowflakeIdGenerator { private final long sequenceBits = 12L; private final long workerIdBits = 5L; private final long dataCenterIdBits = 5L; private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); private final long maxDataCenterId = -1L ^ (-1L &lt;&lt; dataCenterIdBits); private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); private final long workerIdShift = sequenceBits; private final long dataCenterIdShift = sequenceBits + workerIdBits; private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits; private final long twepoch = 1587708854000L; private long workerId; private long dataCenterId; private long sequence = 0L; private long lastTimestamp = -1L; public SnowflakeIdGenerator(long workerId, long dataCenterId) { if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.format(&quot;workerId can&#39;t be greater than %d or less than 0&quot;, maxWorkerId)); } if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) { throw new IllegalArgumentException(String.format(&quot;dataCenterId can&#39;t be greater than %d or less than 0&quot;, maxDataCenterId)); } this.workerId = workerId; this.dataCenterId = dataCenterId; } public synchronized long nextId() { long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) { throw new RuntimeException(String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp)); } if (lastTimestamp == timestamp) { sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) { timestamp = tilNextMillis(lastTimestamp); } } else { sequence = 0L; } lastTimestamp = timestamp; return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (dataCenterId &lt;&lt; dataCenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; } protected long timeGen() { return System.currentTimeMillis(); } protected long tilNextMillis(long lastTimestamp) { long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) { timestamp = timeGen(); } return timestamp; } public static void main(String[] args) { SnowflakeIdGenerator idGenerator = new SnowflakeIdGenerator(1, 1); for (int i = 0; i &lt; 10; i++) { System.out.println(idGenerator.nextId()); } } } LeafLeaf 是美团推出的一个分布式ID生成服务 Leaf的Leaf-segment号段模式和Leaf-snowflake模式 Leaf-segment号段模式Leaf-segment号段模式是对直接用数据库自增ID充当分布式ID的一种优化，减少对数据库的频率操作。相当于从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，业务服务将号段在本地生成1~1000的自增ID并加载到内存 依赖于数据库： CREATE TABLE `leaf_alloc` ( `biz_tag` varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;业务key&#39;, `max_id` bigint(20) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;当前已经分配了的最大id&#39;, `step` int(11) NOT NULL COMMENT &#39;初始步长，也是动态调整的最小步长&#39;, `description` varchar(256) DEFAULT NULL COMMENT &#39;业务key的描述&#39;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;数据库维护的更新时间&#39;, PRIMARY KEY (`biz_tag`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; biz_tag：针对不同业务需求，用biz_tag字段来隔离，如果以后需要扩容时，只需对biz_tag分库分表即可 max_id：当前业务号段的最大值，用于计算下一个号段 step：步长，也就是每次获取ID的数量 Leaf 在当前号段消费到某个点时，就异步的把下一个号段加载到内存中，不需要等到号段用尽的时候才去更新号段 采用双buffer Segment[] segments 存储两个号段缓存。当前号段消耗了10%时（segment.getIdle() &lt; 0.9 * segment.getStep()）会开启异步线程更新下一个号段 // com.sankuai.inf.leaf.segment.SegmentIDGenImpl#getIdFromSegmentBuffer if (!buffer.isNextReady() &amp;&amp; (segment.getIdle() &lt; 0.9 * segment.getStep()) &amp;&amp; buffer.getThreadRunning().compareAndSet(false, true)) { service.execute(new Runnable() { @Override public void run() { Segment next = buffer.getSegments()[buffer.nextPos()]; boolean updateOk = false; try { updateSegmentFromDb(buffer.getKey(), next); updateOk = true; logger.info(&quot;update segment {} from db {}&quot;, buffer.getKey(), next); } catch (Exception e) { logger.warn(buffer.getKey() + &quot; updateSegmentFromDb exception&quot;, e); } finally { if (updateOk) { buffer.wLock().lock(); buffer.setNextReady(true); buffer.getThreadRunning().set(false); buffer.wLock().unlock(); } else { buffer.getThreadRunning().set(false); } } } }); } // com.sankuai.inf.leaf.segment.model.Segment#getIdle public long getIdle() { return this.getMax() - getValue().get(); } 比对 特性 数据库自增序列 UUID Snowflake 有序性 是 否 是 分布式支持 需要特殊配置 原生支持 原生支持 性能 中等(依赖DB) 高 高 可读性 好 差 中等 扩展复杂度 高(需协调) 低 中等 依赖外部系统 是 否 部分依赖","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"C语言中的指针","slug":"C语言中的指针","date":"2024-02-02T01:24:20.000Z","updated":"2025-10-26T01:45:43.815Z","comments":true,"path":"2024/02/02/C语言中的指针/","link":"","permalink":"https://blog.xiongtianci.com/2024/02/02/C语言中的指针/","excerpt":"","text":"什么是指针？在C语言中，指针（pointer） 是一种特殊的变量，它存储的是另一个变量的内存地址。换句话说，指针”指向”内存中的某个位置。 指针的本质是内存地址。通过指针，我们可以直接访问或修改内存中的数据。 基本概念： 内存地址：计算机内存中每个字节都有一个唯一的地址 指针变量：存储内存地址的变量 间接访问：通过指针访问它所指向的值 指针的声明和初始化指针的声明 数据类型 *指针变量名; 例如： int *p; // p 是一个指向 int 类型的指针 char *c; // c 是一个指向 char 类型的指针 指针的初始化: 声明指针变量时, 可以赋初值. 注意指针的类型必须与其指向的对象的类型一致. int x; int * px = &amp;x; // 初始化 没有初始化或赋值的指针是无效的指针，引用无效指针会带来难以预料的后果。 指针运算符C语言提供了两个特殊的指针运算符： &amp;（地址运算符）：返回变量的内存地址 *（解引用运算符）：返回指针所指向地址的值 &amp;（取地址运算符）&amp; 用于获取变量的内存地址。 示例：获取变量的地址 #include &lt;stdio.h&gt; int main() { int num = 10; printf(&quot;num 的值: %d\\n&quot;, num); // 输出 10 printf(&quot;num 的地址: %p\\n&quot;, &amp;num); // 输出 num 的内存地址（如 0x7ffd...） return 0; } &amp;num 返回 num 的内存地址。 *（解引用运算符）* 用于访问指针指向的内存地址中存储的值。 示例 ：指针的基本使用 #include &lt;stdio.h&gt; int main() { int num = 10; int *p = &amp;num; // p 存储 num 的地址 printf(&quot;num 的值: %d\\n&quot;, num); // 10 printf(&quot;p 存储的地址: %p\\n&quot;, p); // 0x7ffd...（num 的地址） printf(&quot;*p 的值: %d\\n&quot;, *p); // 10（解引用 p，获取 num 的值） *p = 20; // 通过指针修改 num 的值 printf(&quot;修改后 num 的值: %d\\n&quot;, num); // 20 return 0; } *p 表示访问 p 指向的变量的值（即 num）。 修改 *p 相当于修改 num。 指针与 const 关键字的结合指针与 const 关键字的结合可以形成三种不同的指针类型，它们有不同的特性和用途： 指向常量的指针（Pointer to Constant） 常量指针（Constant Pointer） 指向常量的常量指针（Constant Pointer to Constant） 指向常量的指针（Pointer to Constant）定义 const 数据类型 *指针名; 或 数据类型 const *指针名; // 两种写法等价 特点 指针可以修改（可以指向不同的地址）。 不能通过该指针修改它所指向的数据（数据是 const 的）。 适用于保护数据不被修改，常用于函数参数传递。 示例 #include &lt;stdio.h&gt; int main() { int num = 10; const int *ptr = &amp;num; // ptr 是指向常量的指针 printf(&quot;*ptr = %d\\n&quot;, *ptr); // 输出 10 // *ptr = 20; // 错误！不能通过 ptr 修改 num num = 20; // 合法：直接修改 num printf(&quot;*ptr = %d\\n&quot;, *ptr); // 输出 20 int another_num = 30; ptr = &amp;another_num; // 合法：指针可以指向新地址 printf(&quot;*ptr = %d\\n&quot;, *ptr); // 输出 30 return 0; } 关键点： ptr 可以重新指向不同的变量（ptr = &amp;another_num）。 但不能通过 ptr 修改数据（*ptr = 20 会报错）。 常量指针（Constant Pointer）常量指针, 简称常指针: 指针本身的值不能修改. 定义 数据类型 *const 指针名; 特点 指针不能修改（始终指向同一个地址）。 可以通过该指针修改它所指向的数据（数据不是 const 的）。 适用于固定内存地址访问，如硬件寄存器操作。 示例 #include &lt;stdio.h&gt; int main() { int num = 10; int *const ptr = &amp;num; // ptr 是常量指针 printf(&quot;*ptr = %d\\n&quot;, *ptr); // 输出 10 *ptr = 20; // 合法：可以通过 ptr 修改 num printf(&quot;*ptr = %d\\n&quot;, *ptr); // 输出 20 // ptr = &amp;another_num; // 错误！ptr 不能指向新地址 return 0; } 关键点： ptr 不能重新赋值（ptr = &amp;another_num 会报错）。 但可以通过 ptr 修改数据（*ptr = 20 合法）。 指向常量的常量指针（Constant Pointer to Constant）定义 const 数据类型 *const 指针名; 特点 指针不能修改（始终指向同一个地址）。 也不能通过该指针修改它所指向的数据（数据是 const 的）。 适用于完全只读访问，如字符串常量或硬件只读寄存器。 示例 #include &lt;stdio.h&gt; int main() { int num = 10; const int *const ptr = &amp;num; // ptr 是指向常量的常量指针 printf(&quot;*ptr = %d\\n&quot;, *ptr); // 输出 10 // *ptr = 20; // 错误！不能通过 ptr 修改 num num = 20; // 合法：直接修改 num printf(&quot;*ptr = %d\\n&quot;, *ptr); // 输出 20 // ptr = &amp;another_num; // 错误！ptr 不能指向新地址 return 0; } 关键点： ptr 既不能重新赋值（ptr = &amp;another_num 报错）。 也不能通过 ptr 修改数据（*ptr = 20 报错）。 实际应用场景指向常量的指针（保护函数参数）void print_array(const int *arr, int size) { for (int i = 0; i &lt; size; i++) { printf(&quot;%d &quot;, arr[i]); // arr[i] = 0; // 错误！不能修改数据 } } 作用： 防止函数内部意外修改外部数据。 常量指针（硬件寄存器访问）volatile uint32_t *const GPIO_PORT = (uint32_t *)0x40000000; *GPIO_PORT = 0xFF; // 合法：修改寄存器值 // GPIO_PORT = 0x50000000; // 错误！指针不能修改 作用： 确保指针始终指向固定的硬件地址。 指向常量的常量指针（字符串常量）const char *const MESSAGE = &quot;Hello, World!&quot;; printf(&quot;%s\\n&quot;, MESSAGE); // MESSAGE[0] = &#39;h&#39;; // 错误！不能修改数据 // MESSAGE = &quot;New&quot;; // 错误！指针不能修改 作用： 确保字符串完全不可修改。 总结 const int *ptr（指向常量的指针）：数据不可变，指针可变。 int *const ptr（常量指针）：指针不可变，数据可变。 const int *const ptr（指向常量的常量指针）：指针和数据都不可变。 核心规则： const 在 * 左边 → 数据不可变。 const 在 * 右边 → 指针不可变。 指针算术运算指针算术运算（Pointer Arithmetic）是C语言中一项强大但需要谨慎使用的特性。它允许我们对指针进行加减运算，从而在内存中移动指针位置。 基本概念指针算术运算主要包括以下几种操作： 指针与整数的加减（+, -, +=, -=, ++, --） 指针与指针的减法（得到的是两个指针之间的距离） 指针的比较（&gt;, &lt;, &gt;=, &lt;=, ==, !=） 重要特性： 指针运算的单位是所指向类型的大小，而不是字节 对void*指针不能直接进行算术运算（因为编译器不知道类型大小） 指针与整数的运算基本运算规则int arr[5] = {10, 20, 30, 40, 50}; int *ptr = arr; // 等价于 &amp;arr[0] ptr = ptr + 1; // 现在指向arr[1] ptr += 2; // 现在指向arr[3] ptr--; // 现在指向arr[2] 内存变化（假设int占4字节）： ptr + 1 实际上是 ptr + 1*sizeof(int) = 原地址 + 4字节 ptr + n 实际上是 ptr + n*sizeof(int) 示例代码 #include &lt;stdio.h&gt; int main() { int arr[] = {10, 20, 30, 40, 50}; int *ptr = arr; printf(&quot;初始指针指向: %p, 值: %d\\n&quot;, ptr, *ptr); ptr++; printf(&quot;ptr++ 后指向: %p, 值: %d\\n&quot;, ptr, *ptr); ptr += 2; printf(&quot;ptr+=2 后指向: %p, 值: %d\\n&quot;, ptr, *ptr); ptr--; printf(&quot;ptr-- 后指向: %p, 值: %d\\n&quot;, ptr, *ptr); return 0; } 指针与指针的运算指针减法两个相同类型的指针相减，得到的是它们之间相隔的元素个数： int arr[5] = {0}; int *p1 = &amp;arr[0]; int *p2 = &amp;arr[3]; ptrdiff_t diff = p2 - p1; // 结果是3，不是字节差 注意： 结果是ptrdiff_t类型（定义在stddef.h中的有符号整数类型） 只有指向同一数组的指针相减才有意义 示例代码 #include &lt;stdio.h&gt; #include &lt;stddef.h&gt; int main() { int arr[] = {10, 20, 30, 40, 50}; int *start = &amp;arr[0]; int *end = &amp;arr[4]; ptrdiff_t distance = end - start; printf(&quot;两个指针之间的距离: %td 个元素\\n&quot;, distance); printf(&quot;实际字节差: %td 字节\\n&quot;, (char*)end - (char*)start); return 0; } 指针比较运算可以比较两个指针的大小关系（通常用于同一数组或内存块中的指针）： int arr[5] = {0}; int *p1 = &amp;arr[0]; int *p2 = &amp;arr[3]; if (p1 &lt; p2) { printf(&quot;p1在p2之前\\n&quot;); } 注意： 比较不同数组的指针结果是未定义的 比较NULL指针是允许的 不同类型指针的运算差异指针运算的步长取决于指向类型的大小： 数据类型 典型大小 ptr+1的地址增量 char 1字节 +1 int 4字节 +4 double 8字节 +8 结构体 不定 +sizeof(结构体) 示例代码 #include &lt;stdio.h&gt; int main() { char char_arr[5] = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;}; int int_arr[5] = {1,2,3,4,5}; char *cptr = char_arr; int *iptr = int_arr; printf(&quot;char指针运算:\\n&quot;); printf(&quot;cptr: %p, cptr+1: %p (差 %ld 字节)\\n&quot;, (void*)cptr, (void*)(cptr+1), (long)(cptr+1)-(long)cptr); printf(&quot;\\nint指针运算:\\n&quot;); printf(&quot;iptr: %p, iptr+1: %p (差 %ld 字节)\\n&quot;, (void*)iptr, (void*)(iptr+1), (long)(iptr+1)-(long)iptr); return 0; } 指针运算的常见应用(1) 数组遍历int arr[5] = {1,2,3,4,5}; for(int *p = arr; p &lt; arr+5; p++) { printf(&quot;%d &quot;, *p); } (2) 字符串处理char str[] = &quot;Hello&quot;; char *p = str; while(*p != &#39;\\0&#39;) { putchar(*p); p++; } (3) 动态内存管理int *arr = malloc(5 * sizeof(int)); if(arr) { for(int i=0; i&lt;5; i++) { *(arr + i) = i * 10; // 等价于arr[i] } free(arr); } (4) 多维数组访问int matrix[3][3] = {{1,2,3},{4,5,6},{7,8,9}}; int *ptr = &amp;matrix[0][0]; for(int i=0; i&lt;9; i++) { printf(&quot;%d &quot;, *(ptr + i)); } 特殊指针的运算void指针的运算void*指针不能直接进行算术运算，必须先转换为具体类型： void *vp = malloc(100); // vp++; // 错误！ char *cp = (char*)vp; cp++; // 正确 函数指针的运算函数指针的算术运算通常是未定义行为，应避免使用。 注意事项和常见错误 指针越界访问 int arr[5] = {0}; int *p = arr + 5; // 指向数组末尾之后 *p = 10; // 未定义行为！ 不同类型的指针运算 int i = 0; char *cp = (char*)&amp;i; int *ip = &amp;i; if(cp == ip) { ... } // 合法比较 // ptrdiff_t diff = cp - ip; // 非法！ 无效指针运算 int *p1, *p2; // int sum = p1 + p2; // 非法操作！ 指针运算与数组索引的等价性 int arr[5]; arr[2] = 10; // 等价于 *(arr + 2) = 10; // 这两种写法完全等价 高级应用：自定义内存管理指针运算在实现自定义内存分配器时非常有用： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define POOL_SIZE 1024 typedef struct { unsigned char data[POOL_SIZE]; unsigned char *next_free; } MemoryPool; void init_pool(MemoryPool *pool) { pool-&gt;next_free = pool-&gt;data; } void* pool_alloc(MemoryPool *pool, size_t size) { if(pool-&gt;next_free + size &gt; pool-&gt;data + POOL_SIZE) { return NULL; // 内存不足 } void *ptr = pool-&gt;next_free; pool-&gt;next_free += size; return ptr; } int main() { MemoryPool pool; init_pool(&amp;pool); int *num = pool_alloc(&amp;pool, sizeof(int)); *num = 42; double *dbl = pool_alloc(&amp;pool, sizeof(double)); *dbl = 3.14; printf(&quot;Allocated values: %d, %.2f\\n&quot;, *num, *dbl); return 0; } 总结指针算术运算的核心要点： 指针加减整数时，步长由指向类型的大小决定 只有指向同一数组/内存块的指针相减才有意义 指针比较通常用于检查指针的相对位置 void*指针需要转换后才能进行算术运算 使用指针运算时要特别注意边界检查，避免越界访问 正确使用指针算术可以写出高效灵活的代码，但不当使用也会导致难以调试的内存错误。建议： 在数组遍历时优先使用索引表示法（arr[i]） 必须使用指针运算时，添加清晰的注释 进行边界检查，避免越界访问 使用const修饰符保护不应被修改的数据 指针和数组指针与一维数组数组名本质上是一个指向数组第一个元素的常量指针。在 C 语言中，由于数组元素在内存中是连续存放的，因此使用指针可以非常方便地处理数组元素。 引用数组元素的四种方式： 数组名 + 下标; 数组名 + 指针运算; 指针 + 指针运算; 指针 + 下标（数组运算）. int arr[5] = {1, 2, 3, 4, 5}; int *p = arr; // 等价于 int *p = &amp;arr[0] // 以下两种方式等价 printf(&quot;arr[2] = %d\\n&quot;, arr[2]); printf(&quot;*(p+2) = %d\\n&quot;, *(p+2)); #include &lt;stdio.h&gt; int main() { int arr[] = {1, 2, 3, 4, 5}; printf(&quot;数组名+下标:\\n&quot;); for (int i = 0; i &lt; 5; i++) printf(&quot;%2d&quot;, arr[i]); printf(&quot;\\n\\n&quot;); printf(&quot;数组名+指针运算:\\n&quot;); for (int i = 0; i &lt; 5; i++) printf(&quot;%2d&quot;, *(arr + i)); printf(&quot;\\n\\n&quot;); printf(&quot;指针+指针运算:\\n&quot;); for (int *pa = arr; pa &lt; arr + 5; pa++) printf(&quot;%2d&quot;, *pa); printf(&quot;\\n\\n&quot;); printf(&quot;指针+下标:\\n&quot;); int *pa = arr; for (int i = 0; i &lt; 5; i++) printf(&quot;%2d&quot;, pa[i]); printf(&quot;\\n\\n&quot;); return 0; } 数组名代表数组的首地址, 当数组名出现在表达式中时, 等效于一个常指针。 int arr[] = {0, 2, 4, 8}; int *pa = arr; // OK, 数组名代表数组的首地址，即 pa=&amp;arr[0] *pa = 3; // OK，等价于 arr[0]=3 *(pa + 2) = 5; // OK，等价于 arr[2]=5 *(arr + 2) = 5; // OK，等价于 arr[2]=5 *(pa++) = 3; // OK，等价于 arr[0]=3; pa = pa+1; // *(arr++) = 3; // ERROR! a代表数组首地址，等效于常指针！ 小结: 一维数组 arr[n] 与指针 pa=arr 一维数组名 arr 是地址常量, 数组名 arr 与 &amp;arr[0] 等价; arr+i 是 arr[i] 的地址, arr[i] 与 *(arr+i) 等价; 若指针 pa 存储的是数组 arr 的首地址, 则 *(pa+i) 与 pa[i] 等价; 数组元素的下标访问方式也是按地址进行的; 指针的值可以随时改变, 即可以指向不同的元素, 通过指针访问数组的元素更加灵活; 数组名等效于常量指针, 值不能改变; pa++ 或 ++pa 合法, 但 arr++ 不合法; arr[i] &lt;=&gt; pa[i] &lt;=&gt; *(pa+i) &lt;=&gt; *(arr+i) 指针与二维数组在 C 语言中, 二维数组是按行存储的, 可以理解为由一维数组组成的数组, 其元素也是连续存放的. 二维数组名的含义 A：整个二维数组，类型是 int[2][3] A[i]：第 i 行的一维数组，类型是 int[3] A[i][j]：第 i 行第 j 列的元素 对于二维数组 A, 虽然 A、A[0] 都是数组首地址, 但二者指向的对象不同: A[0] 是一维数组名, 它指向的是行数组 A[0] 的首元素, 即 *A[0] 与 A[0][0] 等价; A 是二维数组名, 它指向的是它的首元素, 而它的元素都是一维数组（即行数组）, 因此 *A 与 A[0] 等价. 另外, 它的指针移动单位是“行”, 所以 A+i 对应的是第 i 个行数组, 即 A[i] 指针访问二维数组int arr[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }; 行指针（数组指针）int (*p)[4] = arr; // 指向包含4个int的数组的指针 p 指向第 0 行 p+1 指向第 1 行（地址增加 4×sizeof(int)） *(p+i) 获取第 i 行首地址 *(*(p+i)+j) 访问 arr[i][j] 列指针（普通指针）int *p = &amp;arr[0][0]; // 或 int *p = *arr; p 指向第一个元素 p+1 指向下一个元素 访问 arr[i][j]：*(p + i*4 + j) 指针数组int *p[3]; // 包含3个int指针的数组 for(int i=0; i&lt;3; i++) p[i] = arr[i]; // 每行首地址 访问 arr[i][j]：*(p[i] + j) 或 p[i][j] 常见操作示例遍历二维数组// 方法1：使用下标 for(int i=0; i&lt;3; i++) for(int j=0; j&lt;4; j++) printf(&quot;%d &quot;, arr[i][j]); // 方法2：使用行指针 int (*p)[4] = arr; for(int i=0; i&lt;3; i++) for(int j=0; j&lt;4; j++) printf(&quot;%d &quot;, *(*(p+i)+j)); // 方法3：使用列指针 int *q = *arr; for(int i=0; i&lt;3*4; i++) printf(&quot;%d &quot;, *(q+i)); 动态分配二维数组// 方法1：连续分配 int **arr = (int **)malloc(rows * sizeof(int *)); arr[0] = (int *)malloc(rows * cols * sizeof(int)); for(int i=1; i&lt;rows; i++) arr[i] = arr[0] + i*cols; // 方法2：非连续分配 int **arr = (int **)malloc(rows * sizeof(int *)); for(int i=0; i&lt;rows; i++) arr[i] = (int *)malloc(cols * sizeof(int)); 指针与二维数组的关系 表达式 类型 含义 arr int[3][4] 整个二维数组 arr+i int(*)[4] 指向第i行的指针 *(arr+i) int* 第i行首元素地址 *(arr+i)+j int* 第i行第j列元素地址 *(*(arr+i)+j) int 第i行第j列元素值 arr[i][j] int 第i行第j列元素值 注意事项 类型匹配：行指针 int(*)[N] 与普通指针 int* 类型不同 指针运算：arr+1 移动一行的大小，*arr+1 移动一个元素的大小 作为函数参数： void func(int arr[][4], int rows) void func(int (*arr)[4], int rows) 动态分配内存后要记得释放： // 对于连续分配 free(arr[0]); free(arr); // 对于非连续分配 for(int i=0; i&lt;rows; i++) free(arr[i]); free(arr); 指针数组和数组指针指针数组：是一个数组，其元素都是指针。 int *ptr[3]; // 包含3个int指针的数组 数组指针：是一个指针，指向一个数组。 int (*ptr)[3]; // 指向包含3个int的数组的指针 多级指针指针可以指向另一个指针，形成多级指针。 int var = 10; int *p = &amp;var; int **pp = &amp;p; // 指向指针的指针 printf(&quot;var = %d\\n&quot;, var); // 10 printf(&quot;*p = %d\\n&quot;, *p); // 10 printf(&quot;**pp = %d\\n&quot;, **pp); // 10 指针与函数指针函数指针函数是指返回值为指针类型的函数，其本质是一个函数，只是它返回的是一个地址（指针）。 语法 返回类型 *函数名(参数列表); 示例 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 指针函数：返回int指针 int* createIntArray(int size) { int *arr = (int*)malloc(size * sizeof(int)); if(arr == NULL) { return NULL; } for(int i = 0; i &lt; size; i++) { arr[i] = i + 1; } return arr; // 返回动态分配的数组指针 } int main() { int *myArray = createIntArray(5); if(myArray != NULL) { for(int i = 0; i &lt; 5; i++) { printf(&quot;%d &quot;, myArray[i]); } free(myArray); // 记得释放内存 } return 0; } 函数指针函数指针是指指向函数的指针变量，它存储的是函数的入口地址，可以通过该指针调用函数。 语法 返回类型 (*指针变量名)(参数类型列表); 示例 #include &lt;stdio.h&gt; // 普通函数 int add(int a, int b) { return a + b; } int subtract(int a, int b) { return a - b; } int main() { // 声明函数指针 int (*operation)(int, int); // 指向add函数 operation = add; printf(&quot;10 + 5 = %d\\n&quot;, operation(10, 5)); // 指向subtract函数 operation = subtract; printf(&quot;10 - 5 = %d\\n&quot;, operation(10, 5)); return 0; } 函数指针数组 #include &lt;stdio.h&gt; double add(double a, double b) { return a + b; } double sub(double a, double b) { return a - b; } double mul(double a, double b) { return a * b; } double div(double a, double b) { return a / b; } int main() { // 函数指针数组 double (*ops[4])(double, double) = {add, sub, mul, div}; char *op_names[] = {&quot;加法&quot;, &quot;减法&quot;, &quot;乘法&quot;, &quot;除法&quot;}; double x = 10.0, y = 5.0; for(int i = 0; i &lt; 4; i++) { printf(&quot;%s: %.2f %c %.2f = %.2f\\n&quot;, op_names[i], x, i == 0 ? &#39;+&#39; : i == 1 ? &#39;-&#39; : i == 2 ? &#39;*&#39; : &#39;/&#39;, y, ops[i](x, y)); } return 0; } 区别 特性 指针函数 函数指针 本质 是一个函数 是一个指针变量 声明 int* func() int (*func)() 返回值 返回指针 指向函数的地址 调用方式 直接调用：func() 通过指针调用：func_ptr() 主要用途 返回动态分配的内存或对象指针 实现回调、多态、插件架构等 内存管理 通常需要调用者管理返回的内存 不需要特殊的内存管理 void指针void指针是一种通用指针，可以指向任何数据类型。在使用前需要强制类型转换。 void * 指针名 void 类型的指针可以存储任何类型的对象的地址; 不允许直接使用 void 指针访问其目标对象; 必须通过显式类型转换, 才可以访问 void 类型指针的目标对象. int a = 10; float b = 3.14; void *p; p = &amp;a; printf(&quot;a = %d\\n&quot;, *(int *)p); p = &amp;b; printf(&quot;b = %f\\n&quot;, *(float *)p); 可以存储任何类型的地址。void * 是一种“无类型指针”，可以指向 int、char、float 等任意类型的数据： int num = 10; float f = 3.14; char c = &#39;A&#39;; void *p1 = &amp;num; // 存储 int 的地址 void *p2 = &amp;f; // 存储 float 的地址 void *p3 = &amp;c; // 存储 char 的地址 不能直接解引用。void * 不知道它指向的数据类型，所以不能直接用 * 访问数据： void *p = &amp;num; printf(&quot;%d&quot;, *p); // 错误！不能直接解引用 void 指针 必须强制类型转换后才能访问。要访问 void * 指向的数据，必须先转换为具体类型的指针： void *p = &amp;num; int *int_ptr = (int *)p; // 转换为 int * printf(&quot;%d&quot;, *int_ptr); // 正确：输出 10 动态内存分配指针常用于动态内存分配： malloc(): 分配内存 calloc(): 分配并初始化内存 realloc(): 重新分配内存 free(): 释放内存 int *arr = (int *)malloc(5 * sizeof(int)); // 分配5个int的空间 if (arr != NULL) { for (int i = 0; i &lt; 5; i++) { arr[i] = i + 1; } free(arr); // 释放内存 } 常见指针错误 未初始化的指针：使用前未初始化 野指针：指针指向已释放的内存 内存泄漏：分配的内存未释放 指针越界：访问超出分配范围的内存 空指针解引用：解引用NULL指针 指针的应用场景 动态内存管理 实现复杂数据结构（链表、树、图等） 函数参数传递（实现引用传递） 函数回调 数组和字符串操作 系统编程和硬件访问 其他指针的常见应用指针作为函数参数（按引用传递）C语言默认是值传递，但可以通过指针实现引用传递，从而在函数内部修改外部变量。 示例：交换两个变量的值 #include &lt;stdio.h&gt; // 错误示例：值传递（无法交换） void swap_wrong(int a, int b) { int temp = a; a = b; b = temp; } // 正确示例：指针传递（可以交换） void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } int main() { int x = 10, y = 20; swap_wrong(x, y); printf(&quot;x=%d, y=%d\\n&quot;, x, y); // x=10, y=20（未交换） swap(&amp;x, &amp;y); // 传递 x 和 y 的地址 printf(&quot;x=%d, y=%d\\n&quot;, x, y); // x=20, y=10（成功交换） return 0; } swap(&amp;x, &amp;y) 传递的是 x 和 y 的地址，函数内部通过 *a 和 *b 直接修改它们的值。 指针与数组数组名本质上是一个指向数组首元素的指针。 示例：指针遍历数组 #include &lt;stdio.h&gt; int main() { int arr[5] = {1, 2, 3, 4, 5}; int *p = arr; // p 指向 arr[0] for (int i = 0; i &lt; 5; i++) { printf(&quot;arr[%d] = %d\\n&quot;, i, *(p + i)); // 等价于 arr[i] } return 0; } *(p + i) 等价于 arr[i]，因为指针运算会自动计算偏移量。 动态内存分配（malloc 和 free）指针可以指向动态分配的内存，用于灵活管理数据。 示例：动态创建数组 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 提供 malloc 和 free int main() { int n = 5; int *arr = (int *)malloc(n * sizeof(int)); // 动态分配 5 个 int 的内存 if (arr == NULL) { printf(&quot;内存分配失败！\\n&quot;); return 1; } for (int i = 0; i &lt; n; i++) { arr[i] = i + 1; // 等价于 *(arr + i) = i + 1 } for (int i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, arr[i]); // 输出 1 2 3 4 5 } free(arr); // 释放内存 return 0; } malloc 动态分配内存，返回 void*，需要强制类型转换。 free 释放内存，防止内存泄漏。 常见错误未初始化的指针（野指针）int *p; // 未初始化 *p = 10; // 错误！p 指向未知内存，可能导致程序崩溃 修正方法： int num = 10; int *p = &amp;num; // 正确：p 指向 num *p = 20; // 合法 空指针解引用int *p = NULL; // p 是空指针 printf(&quot;%d&quot;, *p); // 错误！解引用空指针会导致崩溃 修正方法： if (p != NULL) { printf(&quot;%d&quot;, *p); } 总结 概念 运算符 作用 示例 取地址 &amp; 获取变量的内存地址 int *p = # 解引用 * 访问指针指向的值 int val = *p; 指针声明 * 定义指针变量 int *p; 动态内存 malloc / free 分配/释放堆内存 int *arr = malloc(5 * sizeof(int)); 指针的核心是内存地址，&amp; 取地址，* 解引用。 指针可用于函数传参、数组访问、动态内存管理。 避免野指针和空指针解引用，否则会导致程序崩溃。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"C","slug":"C","permalink":"https://blog.xiongtianci.com/tags/C/"}],"author":"木浅"},{"title":"关于Windows的一些设置","slug":"关于Windows的一些设置","date":"2024-02-01T00:56:48.000Z","updated":"2025-10-26T01:45:43.802Z","comments":true,"path":"2024/02/01/关于Windows的一些设置/","link":"","permalink":"https://blog.xiongtianci.com/2024/02/01/关于Windows的一些设置/","excerpt":"","text":"记录自己在使用 Windows 系统时的一些设置，方便后续操作 环境： Microsoft Windows 10 专业版 次要版本：21H2 查看windows版本win + R -&gt; winver mac地址cmd：getmac /v /fo list 优化设置任务栏Dism++ -&gt; 控制面板 -&gt; 系统优化 -&gt; 任务栏相关设置 资源管理器导航窗口图标管理 管理 Windows 自带: Dism++ -&gt; 控制面板 -&gt; 系统优化 -&gt; 资源管理器导航窗口图标管理 管理其他软件注册的: Windows 10 Manager -&gt; 自定义 -&gt; 设置文件资源管理器 -&gt; 此电脑管理器 我的电脑设备和驱动（各种云盘）win+R -&gt; regedit -&gt; 计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace 资源管理器左导航栏右键菜单 管理 Windows 自带: Dism++ -&gt; 控制面板 -&gt; 系统优化 -&gt; 右键菜单管理 管理其他软件注册的: Windows 10 Manager -&gt; 自定义 -&gt; 右键菜单管理 其他右键菜单”发送到”的选项是空白 shell:sendto 在这个目录下新建文件，并重命名：桌面快捷方式.desklink 壁纸地址win+R -&gt; %USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\Themes\\ TranscodedWallpaper 文件就是转码而来的壁纸文件，更改后缀为 .jpg 就能正常查看了 windows协议链接 打开个性化设置 显示设置 通知设置","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"Windows系统使用过程中的一些问题","slug":"Windows系统使用过程中的一些问题","date":"2024-01-26T07:03:10.000Z","updated":"2025-10-26T01:45:43.781Z","comments":true,"path":"2024/01/26/Windows系统使用过程中的一些问题/","link":"","permalink":"https://blog.xiongtianci.com/2024/01/26/Windows系统使用过程中的一些问题/","excerpt":"","text":"环境 Windows 10 资源管理器左侧目录有WPS网盘 进入注册表：计算机\\HKEY_USERS\\S-1-5-21-450399049-1202795166-2248467168-500\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\{7AE6DE87-C956-4B40-9C89-3D166C9841D3} 删除 {7AE6DE87-C956-4B40-9C89-3D166C9841D3} 路径说明： S-1-5-21-450399049-1202795166-2248467168-500 S-1-5-21 是固定的，表示安全主体（用户）类别 后面的 450399049-1202795166-2248467168 是这台电脑上自动生成的机器码，不同的 Windows 安装环境，每台机子都不一样。 最后一个 500 是用户ID，特别地： 500 表示 内置的 Administrator（管理员）账户。 如果是普通用户，末尾可能是 1000、1001、1002 等。 {7AE6DE87-C956-4B40-9C89-3D166C9841D3}：GUID 如果没有这个项，可以在父目录 NameSpace 里新建这个项，右面的键值填WPS网盘，然后再删除","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"Adobe Acrobat插件-Pitstop的使用","slug":"Adobe-Acrobat插件-Pitstop的使用","date":"2024-01-25T11:27:14.000Z","updated":"2025-10-26T01:45:43.764Z","comments":true,"path":"2024/01/25/Adobe-Acrobat插件-Pitstop的使用/","link":"","permalink":"https://blog.xiongtianci.com/2024/01/25/Adobe-Acrobat插件-Pitstop的使用/","excerpt":"","text":"写在前面水印样例 一般不是使用Adobe添加的水印，使用Adobe去除水印很麻烦 如果页面少可以通过Adobe的内容编辑进行编辑：视图 -&gt; 显示/隐藏 -&gt; 导览窗格 -&gt; 内容 -&gt; 在左侧选中水印后按Del键删除即可。 但是页面太多时，一个个手动删除太累。 本文就是基于这个问题出发，使用 Adobe 的Enfocus PitStop Pro 插件进行批量去除水印。 PitStop Pro 简介PitStop Pro 是用于 Adobe Acrobat Standard、Pro 和 DC 的插件，可让您编辑和记录 PDF 文档的变化。 本文主要介绍使用 PitStop Pro 批量去除 PDF 文件中的各种水印。 环境 Windows 10 Adobe Acrobat Pro 2025 Enfocus PitStop Pro 2024 批量去除水印通过动作删除通过在 PitStop 中新建动作批量去除水印 去除文字水印新建动作【按关键短语选择文本】： 运行动作即可批量删除： 去除图片水印1、点击 Adobe 右下角”更多工具” -&gt; 双击”PitStop 检查” 2、点击”选择对象” -&gt; 选中图片水印 -&gt; 点击检查器查看图片宽度值并复制 3、新建动作并运行即可 色彩动作系列RGB曲线去除水印如果内容是一整张图片，这个时候就无法选中水印的元素，这种情况下可以使用RGB曲线去除水印，但需要水印颜色与正文有色差 上面向左 是减淡 下面向右是加深慢慢调就行 固定位置相同对象在固定位置的水印，可以通过选中水印对象后进行组合，然后再将其移除： 区域水印也可以选中水印的区域范围后移除： 关于回退操作PitStop 的操作可以通过 PitStop 编辑 -&gt; 撤销xxx 进行撤销： 其他 PitStop Pro 官方文档","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"WebSocket学习笔记","slug":"WebSocket学习笔记","date":"2024-01-01T01:07:04.000Z","updated":"2025-10-26T01:45:43.746Z","comments":true,"path":"2024/01/01/WebSocket学习笔记/","link":"","permalink":"https://blog.xiongtianci.com/2024/01/01/WebSocket学习笔记/","excerpt":"","text":"简介Restful API是基于请求-响应模式的单向通信，而 WebSocket 提供全双工通信渠道，允许客户端和服务器之间进行实时双向数据传输，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。WebSocket 通信协议于 2011 年被IETF 定为标准 RFC 6455，并由 RFC 7936 补充规范。WebSocket API 也被 W3C 定为标准。 定义 基于 TCP 的独立协议WebSocket 是一种独立的应用层协议，基于 TCP 传输层实现，专为全双工实时通信设计。 HTTP 兼容的握手机制通过 HTTP/1.1 101 Switching Protocols 状态码完成握手，建立持久连接后，通信脱离 HTTP 约束，直接使用 WebSocket 协议传输数据。 双向连接的建立流程 客户端发起握手：浏览器发送带有 Upgrade: websocket 头的 HTTP 请求。 服务端确认升级：服务器验证请求后返回 101 响应，协议切换为 WebSocket。 持久化双向通道：握手成功后，TCP 连接复用，客户端与服务端可随时主动发送数据，无需重复握手。 核心优势✔ 低延迟双向通信 | ✔ 减少 HTTP 冗余开销 | ✔ 服务端主动推送 | ✔ 标准化（RFC 6455 + W3C API） 与HTTP的区别传统 HTTP HTTP 是基于请求/响应模型的，客户端发送请求，服务器返回响应，然后连接关闭（除非使用 Connection: keep-alive）。 每次请求都需要重新建立连接（或复用连接），并且请求和响应是独立的。 WebSocket WebSocket 是全双工的，客户端和服务器可以在任何时候互相发送数据。 数据传输是通过 WebSocket 帧（frames）进行的，帧可以是文本帧（UTF-8 编码）或二进制帧。 WebSocket 的连接是持久的，直到客户端或服务器主动关闭连接 Request Headers 典型的 HTTP 请求头包含以下字段： GET /path HTTP/1.1 Host: example.com Connection: keep-alive Accept: */* User-Agent: Mozilla/5.0 WebSocket 的初始握手请求头是基于 HTTP 的，但包含一些特殊的字段： GET /chat HTTP/1.1 Host: example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Sec-WebSocket-Version: 13 Upgrade: websocket：表示客户端希望升级到 WebSocket 协议。 Connection: Upgrade：表示客户端希望升级连接。 Sec-WebSocket-Key：一个随机生成的 Base64 编码字符串，用于握手验证。 Sec-WebSocket-Version：指定 WebSocket 协议的版本（通常是 13）。 Request Body 传统 HTTP 请求体 在 HTTP 请求中，请求体通常用于传输数据（如 POST 或 PUT 请求中的表单数据、JSON 数据等） { &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30 } WebSocket 请求体 WebSocket 的初始握手请求没有请求体，因为握手是通过请求头完成的。 一旦握手成功，WebSocket 会切换到二进制帧协议，后续的数据传输不再使用 HTTP 的请求体格式，而是通过 WebSocket 帧（frames）来传输数据。 WebSocket 的初始握手是基于 HTTP 的，但一旦握手成功，协议会从 HTTP 切换到 WebSocket 协议（ws:// 或 wss://）。 切换后的 WebSocket 协议不再使用 HTTP 的请求/响应模型，而是使用帧（frames）来传输数据。 Response Headers 典型的 HTTP 响应头如下： HTTP/1.1 200 OK Content-Type: text/html Content-Length: 1234 响应头包含状态码（如 200 OK）、内容类型（Content-Type）、内容长度（Content-Length）等信息。 WebSocket 的握手响应头如下： HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= 101 Switching Protocols：表示服务器同意升级到 WebSocket 协议。 Upgrade: websocket 和 Connection: Upgrade：表示连接已升级。 Sec-WebSocket-Accept：服务器根据客户端的 Sec-WebSocket-Key 计算出的值，用于验证握手。 特性 传统 HTTP WebSocket 请求头 包含方法、路径、Host 等 包含 Upgrade、Sec-WebSocket-Key 等 请求体 用于传输数据（如 JSON、表单数据） 无（握手阶段无请求体） 响应头 包含状态码、Content-Type 等 包含 101 Switching Protocols 等 响应体 包含实际数据（如 HTML、JSON） 无（握手阶段无响应体） 数据传输方式 请求/响应模型，非持久连接 全双工，持久连接，基于帧传输 协议 HTTP/HTTPS WebSocket（ws:// 或 wss://） Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。 入门案例聊天室一个 Spring Boot 集成 WebSocket 的经典案例，实现一个简单的实时聊天应用。 项目结构chat-demo/ ├── src/ │ ├── main/ │ │ ├── java/ │ │ │ └── com/ │ │ │ └── example/ │ │ │ └── chatdemo/ │ │ │ ├── config/ │ │ │ │ └── WebSocketConfig.java │ │ │ ├── controller/ │ │ │ │ └── ChatController.java │ │ │ ├── model/ │ │ │ │ └── Message.java │ │ │ └── ChatDemoApplication.java │ │ └── resources/ │ │ ├── static/ │ │ │ └── index.html │ │ └── application.yaml │ └── test/ └── pom.xml 添加依赖在pom.xml中添加WebSocket和前端相关依赖： &lt;!-- Spring Boot Starter Web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Starter WebSocket --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; WebSocket配置类创建WebSocket配置类WebSocketConfig.java： import org.springframework.context.annotation.Configuration; import org.springframework.messaging.simp.config.MessageBrokerRegistry; import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker; import org.springframework.web.socket.config.annotation.StompEndpointRegistry; import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer; @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { // 启用简单的内存消息代理，前缀为/topic的消息将发送到消息代理 config.enableSimpleBroker(&quot;/topic&quot;); // 设置应用程序目的地前缀为/app config.setApplicationDestinationPrefixes(&quot;/app&quot;); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { // 注册STOMP端点，客户端将使用它连接到WebSocket服务器 registry.addEndpoint(&quot;/ws&quot;).withSockJS(); } } @EnableWebSocketMessageBroker 启用WebSocket消息代理 消息模型创建消息模型Message.java： public class Message { private String from; private String content; @Override public String toString() { return &quot;Message{&quot; + &quot;from=&#39;&quot; + from + &#39;\\&#39;&#39; + &quot;, content=&#39;&quot; + content + &#39;\\&#39;&#39; + &#39;}&#39;; } // 构造方法、getter和setter } 控制器创建聊天控制器ChatController.java： import com.example.chatdemo.model.Message; import org.springframework.messaging.handler.annotation.MessageMapping; import org.springframework.messaging.handler.annotation.SendTo; import org.springframework.stereotype.Controller; @Controller public class ChatController { // 处理来自客户端的消息 @MessageMapping(&quot;/chat.sendMessage&quot;) @SendTo(&quot;/topic/public&quot;) public Message sendMessage(Message chatMessage) { return chatMessage; } // 处理用户加入的通知 @MessageMapping(&quot;/chat.addUser&quot;) @SendTo(&quot;/topic/public&quot;) public Message addUser(Message chatMessage) { chatMessage.setContent(&quot;用户 &quot; + chatMessage.getFrom() + &quot; 加入了聊天室!&quot;); return chatMessage; } } 1、@MessageMapping 定义消息接收端点。监听客户端发送到特定目的地的STOMP消息。类似Spring MVC 中的@RequestMapping，但专用于WebSocket消息 @MessageMapping(&quot;/chat.sendMessage&quot;) // 监听/app/chat.sendMessage public void handleMessage(Message message, SimpMessageHeaderAccessor headers) { // message: 自动从JSON反序列化的对象 // headers: 包含STOMP帧的头部信息（如sessionId） } 支持的参数类型： 参数类型 用途 @Payload Message 消息体（自动反序列化） @Header(&quot;custom&quot;) String 获取特定STOMP头 SimpMessageHeaderAccessor 完整访问消息头 Principal 认证用户信息 2、@SendTo 指定消息发送目的地。指定方法返回值的发送目的地，将返回值自动序列化（如JSON）并发送到指定主题/队列。 关键特性： 动态路径支持：可使用SpEL表达式（如@SendTo(&quot;/topic/{message.type}&quot;)） 自动广播：发送到代理（如/topic）的消息会被所有订阅该目的地的客户端接收 返回值处理：非void返回值才会触发发送 @MessageMapping(&quot;/chat.sendMessage&quot;) @SendTo(&quot;/topic/public&quot;) // 返回值发送到/topic/public public Message broadcastMessage(Message message) { return message; // 自动转为JSON发送 } 前端页面在src/main/resources/static/index.html创建前端页面： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;WebSocket 聊天演示&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/sockjs-client@1.5.0/dist/sockjs.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body { font-family: Arial, sans-serif; margin: 0; padding: 20px; } #login-container, #chat-container { max-width: 600px; margin: 0 auto; } #chat-container { display: none; } #message-container { border: 1px solid #ccc; height: 300px; overflow-y: scroll; padding: 10px; margin-bottom: 10px; } #message-form { display: flex; } #message-input { flex-grow: 1; padding: 8px; } button { padding: 8px 15px; background-color: #4CAF50; color: white; border: none; cursor: pointer; } #username-display { margin-bottom: 10px; font-weight: bold; color: #4CAF50; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;login-container&quot;&gt; &lt;h1&gt;欢迎加入聊天室&lt;/h1&gt; &lt;form id=&quot;login-form&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;username-input&quot; placeholder=&quot;请输入您的用户名&quot; required/&gt; &lt;button type=&quot;submit&quot;&gt;进入聊天室&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div id=&quot;chat-container&quot;&gt; &lt;h1&gt;Spring Boot WebSocket 聊天演示&lt;/h1&gt; &lt;div id=&quot;username-display&quot;&gt;&lt;/div&gt; &lt;div id=&quot;message-container&quot;&gt;&lt;/div&gt; &lt;form id=&quot;message-form&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;message-input&quot; placeholder=&quot;输入消息...&quot; autocomplete=&quot;off&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;发送&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; let stompClient = null; let username = null; // 登录处理 document.getElementById(&#39;login-form&#39;).addEventListener(&#39;submit&#39;, function (e) { e.preventDefault(); username = document.getElementById(&#39;username-input&#39;).value.trim(); if (username) { connect(); document.getElementById(&#39;login-container&#39;).style.display = &#39;none&#39;; document.getElementById(&#39;chat-container&#39;).style.display = &#39;block&#39;; document.getElementById(&#39;username-display&#39;).textContent = &#39;您当前的用户名: &#39; + username; } }); function connect() { const socket = new SockJS(&#39;/ws&#39;); stompClient = Stomp.over(socket); stompClient.connect({}, function (frame) { console.log(&#39;Connected: &#39; + frame); // 订阅公共频道 stompClient.subscribe(&#39;/topic/public&#39;, function (message) { showMessage(JSON.parse(message.body)); }); // 通知用户加入 stompClient.send(&quot;/app/chat.addUser&quot;, {}, JSON.stringify({from: username, content: &#39;&#39;}) ); }); } // 发送消息 document.getElementById(&#39;message-form&#39;).addEventListener(&#39;submit&#39;, function (e) { e.preventDefault(); const messageInput = document.getElementById(&#39;message-input&#39;); const messageContent = messageInput.value.trim(); if (messageContent &amp;&amp; stompClient) { const chatMessage = { from: username, content: messageContent }; stompClient.send(&quot;/app/chat.sendMessage&quot;, {}, JSON.stringify(chatMessage) ); messageInput.value = &#39;&#39;; } }); // 显示消息 function showMessage(message) { const messageContainer = document.getElementById(&#39;message-container&#39;); const messageElement = document.createElement(&#39;div&#39;); // 区分系统消息和普通消息 if (message.content.includes(&#39;加入了聊天室&#39;)) { messageElement.style.color = &#39;#888&#39;; messageElement.style.fontStyle = &#39;italic&#39;; } else if (message.from === username) { messageElement.style.color = &#39;#4CAF50&#39;; messageElement.innerHTML = `&lt;strong&gt;我:&lt;/strong&gt; ${message.content}`; } else { messageElement.innerHTML = `&lt;strong&gt;${message.from}:&lt;/strong&gt; ${message.content}`; } messageContainer.appendChild(messageElement); messageContainer.scrollTop = messageContainer.scrollHeight; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; SockJS提供了浏览器兼容性支持 STOMP协议简化了WebSocket通信 // ❌ 原始WebSocket（需要手动处理消息格式） websocket.onmessage = function(event) { const data = JSON.parse(event.data); // 需要自己解析 console.log(data); }; // ✅ STOMP（自动解析消息格式） stompClient.subscribe(&#39;/topic/public&#39;, function(message) { console.log(JSON.parse(message.body)); // STOMP已处理好消息体 }); 主应用类ChatDemoApplication.java: import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ChatDemoApplication { public static void main(String[] args) { SpringApplication.run(ChatDemoApplication.class, args); } } 运行和测试 启动Spring Boot应用 打开浏览器访问 http://localhost:8080 打开多个浏览器窗口模拟多个用户 发送消息测试实时通信功能","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"踩坑记录-Java中时间字段入库值和格式化后的值相差一秒","slug":"踩坑记录-Java中时间字段入库值和格式化后的值相差一秒","date":"2023-10-13T10:07:02.000Z","updated":"2025-10-26T02:17:53.401Z","comments":true,"path":"2023/10/13/踩坑记录-Java中时间字段入库值和格式化后的值相差一秒/","link":"","permalink":"https://blog.xiongtianci.com/2023/10/13/踩坑记录-Java中时间字段入库值和格式化后的值相差一秒/","excerpt":"","text":"先说现象，有一个时间写到本地数据库中的值和格式化后的值相差一秒。 上代码： String dateStr = &quot;2023-10-13 13:14:15:999&quot;; try { SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;); SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date date = sdf1.parse(dateStr); System.out.println(&quot;日期-带毫秒值：&quot; + sdf1.format(date)); System.out.println(&quot;日期-不带毫秒值：&quot; + sdf2.format(date)); TestBean bean = new TestBean(); bean.setTime(date); // 入库 testMapper.insert(bean); } catch (Exception e) { e.printStackTrace(); } 执行日志： 日期-带毫秒值：2023-10-13 13:14:15:999 日期-不带毫秒值：2023-10-13 13:14:15 Creating a new SqlSession SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@21ef3d1] was not registered for synchronization because synchronization is not active JDBC Connection [HikariProxyConnection@1544756118 wrapping com.mysql.cj.jdbc.ConnectionImpl@69d5f596] will not be managed by Spring ==&gt; Preparing: INSERT INTO t_test ( time ) VALUES ( ? ) ==&gt; Parameters: 2023-10-13 13:14:15.999(Timestamp) &lt;== Updates: 1 数据库中的数据： mysql&gt; select * from t_test; +----+---------------------+ | id | time | +----+---------------------+ | 1 | 2023-10-13 13:14:16 | +----+---------------------+ 此时发现，日期原始值为2023-10-13 13:14:15:999，使用yyyy-MM-dd HH:mm:ss格式进行格式化后的值为2023-10-13 13:14:15，入库的值却为2023-10-13 13:14:16 搜索：mybatis datetime 时间四舍五入","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"解决windows中Typora上万字后异常卡顿的情况","slug":"解决windows中Typora上万字后异常卡顿的情况","date":"2023-05-29T08:27:45.000Z","updated":"2025-10-26T01:45:43.713Z","comments":true,"path":"2023/05/29/解决windows中Typora上万字后异常卡顿的情况/","link":"","permalink":"https://blog.xiongtianci.com/2023/05/29/解决windows中Typora上万字后异常卡顿的情况/","excerpt":"","text":"问题 环境：Windows10 Typora 打开字数超过2w字的文件后超级卡。 解决1、打开 NVIDIA 控制面板： 2、管理3D设置 -&gt; 添加 -&gt; 选中Typora -&gt; 添加选定的程序： 3、选择 高性能NVIDIA处理器 -&gt; 应用","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://blog.xiongtianci.com/tags/Typora/"}],"author":"木浅"},{"title":"git实用命令","slug":"git实用命令","date":"2023-05-28T00:36:38.000Z","updated":"2025-10-26T01:45:43.695Z","comments":true,"path":"2023/05/28/git实用命令/","link":"","permalink":"https://blog.xiongtianci.com/2023/05/28/git实用命令/","excerpt":"","text":"git grep &lt;关键词&gt; ：搜索含有关键词的文件 git blame &lt;文件名&gt;：查看指定文件每一行的提交人和提交时间 git log -p &lt;文件名&gt;：查看指定文件的每一次提交和改动 撤销提交 教程：如何撤销 Git 操作？ 撤销提交：在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化。它不会改变过去的历史，所以是首选方式，没有任何丢失代码的风险。 语法：git revert [倒数第一个提交] [倒数第二个提交] 参数： --no-edit：执行时不打开默认编辑器，直接使用 Git 自动生成的提交信息。 --no-commit：只抵消暂存区和工作区的文件变化，不产生新的提交。 例子： # git revert HEAD 丢弃提交：让最新提交的指针回到以前某个时点，该时点之后的提交都从历史中彻底消失。 语法：git reset [last good SHA] 参数： --hard：reset 默认不改变工作区的文件（但会改变暂存区），--hard 参数可以让工作区里面的文件也回到以前的状态。 替换上一次提交：产生一个新的提交对象，替换掉上一次提交产生的提交对象。如果暂存区有发生变化的文件，会一起提交到仓库。 语法：git commit --amend -m &lt;message&gt; 撤销工作区的文件修改：将文件在工作区的修改撤销到最近一次暂存区或版本库的内容。先找暂存区，如果该文件有暂存的版本，则恢复该版本，否则恢复上一次提交的版本。 语法：git checkout -- [filename] 注意：工作区的文件变化一旦被撤销，就无法找回了。 从暂存区撤销文件 语法：git rm --cached [filename] 撤销当前分支的变化 # 新建一个 feature 分支，指向当前最新的提交 # 注意，这时依然停留在当前分支 $ git branch feature # 切换到这几次提交之前的状态 $ git reset --hard [当前分支此前的最后一次提交] # 切换到 feature 分支 $ git checkout feature 上面的操作等于是撤销当前分支的变化，将这些变化放到一个新建的分支。 问题代码定位 教程：git bisect 命令教程 git bisect： 将代码提交的历史，按照二分法不断缩小定位，直到范围缩小到某一次代码提交。 # 1.启动查错 git bisect start [终点] [起点] # 2.1.标识本次提交没有问题，并自动切换到后半段的中点 git bisect good # 2.2.标识本次提交有问题，并自动切换到后半段的中点 git bisect bad # 直到出现成功找出有问题的那一次提交为止，提示：b47892 is the first bad commit # 3.退出查错，回到最近一次的代码提交 git bisect reset","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.xiongtianci.com/tags/Git/"}],"author":"木浅"},{"title":"MySQL有关死锁的一些命令","slug":"MySQL有关死锁的一些命令","date":"2023-05-27T12:42:39.000Z","updated":"2025-10-26T01:45:43.669Z","comments":true,"path":"2023/05/27/MySQL有关死锁的一些命令/","link":"","permalink":"https://blog.xiongtianci.com/2023/05/27/MySQL有关死锁的一些命令/","excerpt":"","text":"命令5.71、查看正在进行中的事务 mysql&gt; select * from information_schema.innodb_trx\\G *************************** 1. row *************************** trx_id: 139926 trx_state: RUNNING trx_started: 2023-05-27 20:45:08 trx_requested_lock_id: NULL trx_wait_started: NULL trx_weight: 2 trx_mysql_thread_id: 347 trx_query: NULL trx_operation_state: NULL trx_tables_in_use: 0 trx_tables_locked: 1 trx_lock_structs: 2 trx_lock_memory_bytes: 1136 trx_rows_locked: 1 trx_rows_modified: 0 trx_concurrency_tickets: 0 trx_isolation_level: REPEATABLE READ trx_unique_checks: 1 trx_foreign_key_checks: 1 trx_last_foreign_key_error: NULL trx_adaptive_hash_latched: 0 trx_adaptive_hash_timeout: 0 trx_is_read_only: 0 trx_autocommit_non_locking: 0 1 row in set (0.00 sec) 2、查看正在锁的事务 mysql&gt; select * from information_schema.innodb_locks\\G *************************** 1. row *************************** lock_id: 139929:340:4:1 lock_trx_id: 139929 lock_mode: X lock_type: RECORD lock_table: `230510`.`t_order` lock_index: index_order lock_space: 340 lock_page: 4 lock_rec: 1 lock_data: supremum pseudo-record *************************** 2. row *************************** lock_id: 139926:340:4:1 lock_trx_id: 139926 lock_mode: X lock_type: RECORD lock_table: `230510`.`t_order` lock_index: index_order lock_space: 340 lock_page: 4 lock_rec: 1 lock_data: supremum pseudo-record 2 rows in set, 1 warning (0.00 sec) 3、查看等待锁的事务 mysql&gt; select * from information_schema.innodb_lock_waits\\G *************************** 1. row *************************** requesting_trx_id: 139929 requested_lock_id: 139929:340:4:1 blocking_trx_id: 139926 blocking_lock_id: 139926:340:4:1 1 row in set, 1 warning (0.00 sec) 4、查询是否锁表 mysql&gt; show open tables where in_use &gt; 0; +----------+---------+--------+-------------+ | Database | Table | In_use | Name_locked | +----------+---------+--------+-------------+ | 230510 | t_order | 1 | 0 | +----------+---------+--------+-------------+ 1 row in set (0.00 sec) 在发生死锁时，这几种方式都可以查询到和当前死锁相关的信息。 5、查看最近死锁的日志 show engine innodb status; 6、解除死锁 如果需要解除死锁，有一种最简单粗暴的方式，那就是找到进程id之后，直接干掉。 查看当前正在进行中的进程 show processlist; -- 也可以使用 select * from information_schema.innodb_trx\\G 杀掉进程对应的进程 id（进程id对应上面第一条命令的id和第二条命令的trx_mysql_thread_id）： kill &lt;id|trx_mysql_thread_id&gt;; 验证（kill后再看是否还有锁）： show open tables where in_use &gt; 0; 8.0 查看死锁select * from performance_schema.data_locks; 查看死锁等待时间select * from performance_schema.data_lock_waits; 拓展\\G的作用在MySQL中,使用\\G语句终止符可以使查询结果以列的方式显示,而不是默认的行的方式。例如，普通的查询结果显示为： mysql&gt; SELECT * FROM test; +----+-------+ | id | name | +----+-------+ | 1 | a | | 2 | b | | 3 | c | +----+-------+ 3 rows in set (0.00 sec) 使用 \\G 语句终止符后,查询结果显示为: mysql&gt; SELECT * FROM test\\G; *************************** 1. row *************************** id: 1 name: a *************************** 2. row *************************** id: 2 name: b *************************** 3. row *************************** id: 3 name: c 3 rows in set (0.00 sec) 使用 \\G 后就不能再加分号 ;，因为 \\G 在功能上等同于 ;，如果加了分号，那么就是 ;;(2 个分号)，会报SQL语法错误 No query specified： mysql&gt; select * from t_order where id=1\\G; *************************** 1. row *************************** id: 1 order_no: 1001 create_date: NULL 1 row in set (0.00 sec) ERROR: No query specified","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"木浅"},{"title":"git合并分支的几种方式","slug":"git合并分支的几种方式","date":"2023-05-25T13:54:25.000Z","updated":"2025-10-26T01:45:43.634Z","comments":true,"path":"2023/05/25/git合并分支的几种方式/","link":"","permalink":"https://blog.xiongtianci.com/2023/05/25/git合并分支的几种方式/","excerpt":"","text":"本文介绍 Git 中合并分支常见的三种方法： merge rebase cherry-pick mergegit merge Git会有很多合并策略，其中常见的是 Fast-forward、Recursive 、Ours、Theirs、Octopus。 默认Git会帮你自动挑选合适的合并策略，如果你需要强制指定，使用 git merge -s &lt;策略名字&gt; fast-forward# 语法格式 git merge &lt;commit&gt;|&lt;branch-name&gt; Fast-forward merge：快进式合并。 当当前分支与目标分支之间存在线性路径时，就会发生快进式合并。Git不需要“实际”合并这些分支，只需将接收分支（main）的指针移动到合并分支（some-feature）的指针位置上，即可集成历史记录。这有效地组合了历史记录，因为从目标分支可达的所有提交现在都可以通过当前分支访问。例如，将 some-feature 快进式合并到 main 中如下图所示，Git只需要将main分支的指向移动到fome-feature分支指向的commit节点上： Fast-forward 是 Git 在合并两个没有分叉的分支时的默认行为，如果分支已经发散，则无法进行快进式合并。当没有通往目标分支的线性路径时，Git别无选择，只能通过三方合并将它们组合在一起。三方合并使用专用提交来连接两个历史记录。命名法源于Git使用三个提交生成合并提交：两个分支尖端和它们的共同祖先。 no-ff# 语法格式 git merge --no-ff &lt;commit&gt;|&lt;branch-name&gt; [-m &lt;message&gt;] no-ff：no-fast-forward，强制禁用 Fast forward 模式。使用 --no-ff 参数后，会执行正常合并，Git会为我们在分支上生成一个新的提交节点。 为了保证版本演进的清晰，推荐采用这种做法。 实际上，当使用 --no-ff 参数进行合并时，我们的合并方式就变成了 3-way merge 了。 squashgit merge --squash Squash Merge其实很简单，它就是在 merge 分支的时候把分支上的所有 commit 合并为一个 commit 后再 merge 到目标分支 适合一个功能点被分成多次提交，如果合并到主分支的话，提交记录会显得繁琐，最终我们重点关注的应该是这个功能点的提交，而不是开发者中间做了多少开发，这时候就要用到 squash。 rebasegit rebase 变基，也是一种经常被用来做合并的方法，其与 git merge 的最大区别是，rebase 会变更历史commit节点。 merge 是一种非破坏性的操作，因此现有分支不会以任何方式被更改。这避免了所有可能出现的变基问题。但也意味着每次需要合并上游更改时，特性分支都将具有一个多余的合并提交记录。 变基的主要好处是可以获得更干净的项目历史记录。它可以消除 git 合并中不需要的合并提交节点；变基还会得到完全线性的项目历史记录。 但是，变基通过为原始分支中的每个提交创建全新的提交来重新编写项目历史记录，将会失去合并提交提供的上下文，无法看到上游的更改何时被纳入功能中。 如下图，第一张图是在 feature 分支通过 merge 合并 main 分支，会生成一个新的提交节点；第二张图在 feature 分支中通过 rebase 合并 main 分支，Git 会以 main 分支对应的 commit 节点为起点，新增三个全新的 commit 代替 feature 分支中的 commit 节点（图2中绿色所示的节点）。其原因是新的 commit 指向的 parent 变了，所以对应的SHA1值也会改变，所以没办法复用原 feature 分支中的 commit。 对于合并时候要使用 git merge 还是 git rebase 根据团队和项目习惯选择就可以。 git rebase 可以给我们带来清晰的历史记录，git merge可以保留真实的提交时间等信息，并且不容易出问题，处理冲突也比较方便。唯一有一点需要注意的是，不要对已经处于远端的多人共用分支做 rebase 操作。 个人习惯是：对于本地的分支或者确定只有一个人使用的远端分支用rebase，其余情况用merge。 交互式变基rebase 还有一个非常好用的东西叫 interactive 模式，使用方法是 git rebase -i。他的作用是在提交执行变基之前，可以实现压缩几个 commit，修改 commit 信息，抛弃某个 commit 等功能。 交互式变基在想要修改分支上某些提交时会很有用，可以执行以下 6 个动作 reword：修改提交信息； edit：修改此提交； squash：将提交融合到前一个提交中； fixup：将提交融合到前一个提交中，不保留该提交的日志消息； exec：在每个提交上运行我们想要 rebase 的命令； drop：移除该提交。 例如，使用 drop 移除一个提交： cherry-pickcherry-pick 适合用于只需要将部分代码变动（某几个提交）从一个分支转移到另一个分支的场景。 # 语法 git cherry-pick &lt;commitHashA&gt; &lt;commitHashB&gt; ... # 转移连续一系列的提交（不包括A） # 如下，转移从A到D的所有提交（A必须比D先提交） git cherry-pick A..D # 转移连续一系列的提交（包括A） git cherry-pick A^..D # 将指定分支的最新提交，转移到当前分支 git cherry-pick &lt;branch-name&gt; git cherry-pick commitHash 会将指定的提交 commitHash 应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.xiongtianci.com/tags/Git/"}],"author":"木浅"},{"title":"通过OpenAI API Key和Vercel部署个人ChatGPT Web网站","slug":"通过OpenAI-API-Key和Vercel部署个人ChatGPT-Web网站","date":"2023-05-24T12:21:27.000Z","updated":"2025-10-26T01:53:28.215Z","comments":true,"path":"2023/05/24/通过OpenAI-API-Key和Vercel部署个人ChatGPT-Web网站/","link":"","permalink":"https://blog.xiongtianci.com/2023/05/24/通过OpenAI-API-Key和Vercel部署个人ChatGPT-Web网站/","excerpt":"","text":"内容简介本文介绍如何通过 Vercel + ChatGPT-Next-Web + OpenAI API Key 部署 ChatGPT 网页。 准备工作 准备好你的 OpenAI API Key； GitHub 账号 域名（可申请免费的域名，文章后面会介绍） 自备科学上网工具 教程1. fork项目仓库 为什么需要fork这个仓库？ 在 GitHub 中将 ChatGPT-Next-Web 仓库 fork 到自己账号 2. 开启Action权限开启 Action 后可以保持你 fork 的仓库一直和上游保持同步，是最新的。 切换到 Actions，点击 I understand my workflows, go ahead and enable them按钮： 切换到 Upstream Sync，点击 Enable workflow： 会看到工作流成功启用的提醒语句： 3. 在Vercel部署网站先注册Vercel（注意：最好使用 gmail 邮箱进行注册。Vercel 屏蔽了国内邮箱和 Outlook 邮箱）。 注册成功后登录账号，进入 Vercel控制台，创建一个新项目： 选择从 GitHub 导入仓库： 关联 GitHub 账号后选择刚刚 fork 的仓库（ChatGPT-Next-Web）： 添加 Environment Variables（环境变量）： 变量1（OPENAI_API_KEY），必填。这个 Value 是你的 OpenAI API Key。没有就需要通过一些手段去创建；每个账号有5刀的免费试用额度， Name：OPENAI_API_KEY Value：sk-ohtbdhgw…… 变量2（CODE），选填。这个是设置用户访问码，不设置这任何人通过你的网站不用密码就能调用 OpenAI。值为用英文逗号分隔的自定义密码 code1,code2,code3 Name：CODE Value：code1,code2,code3 添加完变量后点击 Deploy 进行部署： 部署成功： 点击 Continue to Dashboard 跳转到仪表盘后点击 Visit 可以跳转至访问页面： 在左下角进入设置选项，输入刚刚在 Vercel 设置的访问密码： 访问成功： 4. 自定义域名由于 Vercel 在墙外，需要通过科学上网才能访问 Vercel 部署的应用。我们可以通过绑定域名，就能在大陆无需出海就能访问 ChatGPT 了。 在 Vercel 的 Project Settings 中配置自定义域名： 申请免费域名接下来介绍如何申请免费的 eu.org 域名 TODO","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://blog.xiongtianci.com/tags/AI/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://blog.xiongtianci.com/tags/ChatGPT/"}],"author":"木浅"},{"title":"GitHub的一些使用技巧","slug":"GitHub的一些使用技巧","date":"2023-05-23T11:38:27.000Z","updated":"2025-10-26T01:45:43.566Z","comments":true,"path":"2023/05/23/GitHub的一些使用技巧/","link":"","permalink":"https://blog.xiongtianci.com/2023/05/23/GitHub的一些使用技巧/","excerpt":"","text":"代码搜索文件查看技巧按下 T 键可以快速对仓库内的文件进行搜索 按 L 键快速跳转到指定行： 按 B 键，查看文件的 blame 信息： 命令面板 官方文档：传送门 Ctrl+K 其他查看first commit查看仓库的old commits时的路径类似： https://github.com/toeverything/AFFiNE/commits/master?after=48c109e1493ef856db7a65e4f73036a7f771ff4c+34 可以看到在最近一次 commit 的SHA后面有 +34 的格式，可以通过改变这个值快速定位到old commit。 比如，这个库目前有 3173 commits，可以通过下面快速访问first commit https://github.com/toeverything/AFFiNE/commits/master?after=48c109e1493ef856db7a65e4f73036a7f771ff4c+3171 官网 键盘快捷键","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.xiongtianci.com/tags/GitHub/"}],"author":"木浅"},{"title":"实现延时队列的几种方案","slug":"实现延时队列的几种方案","date":"2023-05-22T23:25:20.000Z","updated":"2025-10-26T01:45:43.588Z","comments":true,"path":"2023/05/23/实现延时队列的几种方案/","link":"","permalink":"https://blog.xiongtianci.com/2023/05/23/实现延时队列的几种方案/","excerpt":"","text":"使用关系型数据库实现TODO 使用Redis实现主要思路如下: 生产消息时,将消息的值作为 ZSET 的value,将当前时间加上delay时间作为score, zadd 添加到ZSET中。 消费消息时,使用 zrangebyscore 从ZSET中获取score在当前时间之前（0 &lt; score &lt;= 当前时间戳）的消息进行消费。可以每隔一定时间查询一次,也可以使用Redis的Keyspace Notification功能接收消息到达的通知进行消费。 如果一定时间内消息未消费,由于其score值仍然小于当前时间,所以会被重复消费,实现了消息的重试机制。 消息被成功消费后,需要从ZSET中移除,避免重复消费,使用 zrem 移除消息。 实现依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 配置： import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.connection.RedisStandaloneConfiguration; import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory; @Configuration public class RedisConfig { @Bean public RedisConnectionFactory redisConnectionFactory() { RedisStandaloneConfiguration config = new RedisStandaloneConfiguration(); config.setHostName(&quot;localhost&quot;); config.setPort(6379); return new LettuceConnectionFactory(config); } } Redisson使用MQ实现RabbitMQRabbitMQ的延时消息主要有两个解决方案： 消息的TTL + 死信Exchange RabbitMQ Delayed Message Plugin 消息的TTL+死信Exchange存活时间TTLTTL 全称为：time to live，一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。当消息没有配置消费者，消息就一直停留在队列中，停留时间超过存活时间后，消息会被自动删除。 RabbitMQ 支持两种 TTL 设置： 对消息本身设置存活时间，每条消息的存活时间可以灵活设置为不同的存活时间。 对传递的队列设置存活时间，每条传到到队列的过期时间都一致。 如果同时配置了队列的TTL和消息的TTL，将会使用较小的那个值。 当消息过期还没有被消费，此时消息会变成死信消息（dead letter），这是实现延迟队列的关键。死信消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。 消息变为死信的条件： 消息被拒绝（通过basic.reject 或者 back.nack），并且设置 requeue=false 消息的过期时间到期了 队列达到最大长度，消息被丢弃 死信交换机 DLXDLX（Dead Letter Exchanges）意思为死信交换机。死信交换机和普通交换机没什么区别，不同的是死信交换机会绑定在其他队列上，当队列的消息变成死信消息后，死信消息会发送到死信交换上。 消息变成死信消息之后，它不会立即被删除，首先它要看有没有对应的死信交换机，如果有绑定的死信交换机，消息就会从发送到对应的死信交换机上。 队列绑定死信交换机需要两个参数： x-dead-letter-exchange：绑定的死信交换机名称，必须 x-dead-letter-routing-key：死信交换机转发到死信队列的路由键，可选 死信交换机和普通交换机的区别就是死信交换机的Exchange和routingKey作为绑定参数，绑定在其他队列上。 步骤一个延时消息的流程如下图： 配置业务队列，绑定到业务交换机上 为业务队列配置死信交换机和路由key 为死信交换机配置死信队列 死信队列并不是什么特殊的队列，只不过是绑定在死信交换机上的队列。死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】。 生产者将带有TTL的消息发送给交换机，由交换机路由到队列中； 队列由于没有消费，消息一直停留在队列中，一直等到消息超时，变成死信消息； 死信消息转发到死信交换机再路由到死信队列上，最后给消费者消费。 创建死信队列坐标： &lt;!--消息队列相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 配置： spring: rabbitmq: host: localhost #rabbitmq的连接地址 port: 5672 #rabbitmq的连接端口号 virtual-host: /yolo #rabbitmq的虚拟host username: yolo #rabbitmq的用户名 password: yolo #rabbitmq的密码 配置交换机和队列的绑定： 死信队列绑定死信交换机 import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.DirectExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; @Configuration public class DelayQueueRabbitConfig { /* @@@@ 死信队列 @@@ */ /** * 死信队列 */ public static final String DLX_QUEUE = &quot;queue.dlx&quot;; /** * 死信交换机 */ public static final String DLX_EXCHANGE = &quot;exchange.dlx&quot;; /** * 死信routing-key */ public static final String DLX_ROUTING_KEY = &quot;routingKey.dlx&quot;; /** * 死信队列 * * @return */ @Bean public Queue dlxQueue() { return new Queue(DLX_QUEUE, true); } /** * 死信交换机 * * @return */ @Bean public DirectExchange dlxExchange() { return new DirectExchange(DLX_EXCHANGE, true, false); } /** * 死信队列和死信交换机绑定 * * @return */ @Bean public Binding bindingDLX() { return BindingBuilder.bind(dlxQueue()).to(dlxExchange()).with(DLX_ROUTING_KEY); } /* @@@@ 延迟队列 @@@ */ /** * 订单延迟队列 */ public static final String ORDER_QUEUE = &quot;queue.order&quot;; /** * 订单交换机 */ public static final String ORDER_EXCHANGE = &quot;exchange.order&quot;; /** * 订单routing-key */ public static final String ORDER_ROUTING_KEY = &quot;routingkey.order&quot;; /** * 订单延迟队列 * * @return */ @Bean public Queue orderQueue() { Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); // 关键参数 params.put(&quot;x-dead-letter-exchange&quot;, DLX_EXCHANGE); params.put(&quot;x-dead-letter-routing-key&quot;, DLX_ROUTING_KEY); return new Queue(ORDER_QUEUE, true, false, false, params); } /** * 订单交换机 * * @return */ @Bean public DirectExchange orderExchange() { return new DirectExchange(ORDER_EXCHANGE, true, false); } /** * 订单队列和交换机绑定 * * @return */ @Bean public Binding orderBinding() { return BindingBuilder.bind(orderQueue()).to(orderExchange()).with(ORDER_ROUTING_KEY); } } 绑定死信交换机通过添加x-dead-letter-exchange、x-dead-letter-routing-key参数指定对应的交换机和路由。 生产者import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.text.SimpleDateFormat; import java.util.Date; @RestController public class SendController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(&quot;/dlx&quot;) public String dlx(@RequestParam(&quot;msg&quot;) String msgStr) { String date = DateUtil.dateFormat(new Date()); String delayTime = &quot;5000&quot;; //单位毫秒 System.out.println(&quot;【发送消息】延迟 5 秒 发送时间 &quot; + date); rabbitTemplate.convertAndSend( DelayQueueRabbitConfig.ORDER_EXCHANGE, DelayQueueRabbitConfig.ORDER_ROUTING_KEY, msgStr, message -&gt; { // 设置过期时间 message.getMessageProperties().setExpiration(delayTime); return message; }); return &quot;ok&quot;; } } class DateUtil { public static String dateFormat(Date date) { SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;); return sdf.format(date); } } 消费者@RabbitListener(queues = DelayQueueRabbitConfig.DLX_QUEUE) public void delayPrecss(String msgStr, Channel channel, Message message) { System.out.println(&quot;【接收消息】&quot; + msgStr + &quot; 接收时间&quot; + DateUtil.dateFormat(new Date())); } 测试调用接口发送消息，可以看到，消息延迟了5秒后才被消费： 【发送消息】延迟 5 秒 发送时间 21:19:39 【接收消息】hello 接收时间21:19:44 消息时序问题队列都有 先进先出 的特点。如果队列前面的消息延迟比队列后的消息延迟更长，需要等到队列前面的消息被消费后才能消费后面的消息。 测试下： // 改造生产者 @GetMapping(&quot;/dlx&quot;) public String dlx() { dlxSend(&quot;延迟10秒&quot;, &quot;10000&quot;); dlxSend(&quot;延迟2 秒&quot;, &quot;2000&quot;); dlxSend(&quot;延迟5 秒&quot;, &quot;5000&quot;); return &quot;ok&quot;; } private void dlxSend(String msgStr, String delayTime) { System.out.println(&quot;【发送消息】&quot; + msgStr + &quot;当前时间&quot; + DateUtil.dateFormat(new Date())); rabbitTemplate.convertAndSend(DelayQueueRabbitConfig.ORDER_EXCHANGE, DelayQueueRabbitConfig.ORDER_ROUTING_KEY, msgStr, message -&gt; { message.getMessageProperties().setExpiration(delayTime); return message; }); } 控制台输出： 【发送消息】延迟10秒当前时间21:45:00 【发送消息】延迟2 秒当前时间21:45:00 【发送消息】延迟5 秒当前时间21:45:00 【接收消息】延迟10秒 接收时间21:45:10 【接收消息】延迟2 秒 接收时间21:45:10 【接收消息】延迟5 秒 接收时间21:45:10 当前面的消息没被消费时，后面的消息都不会被消费到。如上面的第二条消息延迟2秒的过期时间达到时，第一条还没被消费，第二条等待第一条被消费后立刻就能被消费了。 RabbitMQ Delayed Message PluginRabbitMQ Delayed Message Plugin是官方提供的延时消息插件，虽然使用起来比较方便，但是不是高可用的，如果节点挂了会导致消息丢失。 官网：传送门 Delayed messages are stored in a Mnesia table (also see Limitations below) with a single disk replica on the current node. They will survive a node restart. While timer(s) that triggered scheduled delivery are not persisted, it will be re-initialised during plugin activation on node start. Obviously, only having one copy of a scheduled message in a cluster means that losing that node or disabling the plugin on it will lose the messages residing on that node. 安装插件去RabbitMQ的官网下载插件rabbitmq_delayed_message_exchange，插件地址： https://www.rabbitmq.com/community-plugins.html https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases 将插件文件复制到RabbitMQ安装目录的plugins目录下： 进入RabbitMQ安装目录的sbin目录下，使用如下命令启用延迟插件： rabbitmq-plugins enable rabbitmq_delayed_message_exchange 启用插件成功，之后重新启动RabbitMQ服务，交换机会有新的类型x-delayed-message： x-delayed-message类型的交换机，支持延迟投递消息。发送消息给x-delayed-message类型的交换机： x-delayed-message类型的交换机接收消息投递后，并未将直接路由到队列中，而是存储到mnesia(一个分布式数据系统)，该系统会检测消息延迟时间。 消息达到可投递时间，消息会被投递到目标队列。 实现延迟消息配置交换机、队列以及绑定关系： import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.CustomExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; @Configuration public class XDelayedMessageConfig { /** * 队列 */ public static final String DIRECT_QUEUE = &quot;queue.delayed&quot;; /** * 延迟交换机 */ public static final String DELAYED_EXCHANGE = &quot;exchange.delayed&quot;; /** * 绑定的routing key */ public static final String ROUTING_KEY = &quot;routingKey.bind&quot;; @Bean public Queue directQueue() { return new Queue(DIRECT_QUEUE, true); } /** * 定义延迟交换机 * 交换机的类型为 x-delayed-message * * @return */ @Bean public CustomExchange delayedExchange() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;x-delayed-type&quot;, &quot;direct&quot;); return new CustomExchange(DELAYED_EXCHANGE, &quot;x-delayed-message&quot;, true, false, map); } @Bean public Binding delayOrderBinding() { return BindingBuilder.bind(directQueue()).to(delayedExchange()).with(ROUTING_KEY).noargs(); } } 生产者： @GetMapping(&quot;/delay&quot;) public String delay() { delaySend(&quot;延迟队列10 秒&quot;, 10000); delaySend(&quot;延迟队列5 秒&quot;, 5000); delaySend(&quot;延迟队列2 秒&quot;, 2000); return &quot;ok&quot;; } private void delaySend(String msgStr, Integer delayTime) { System.out.println(&quot;【发送消息】&quot; + msgStr + &quot;当前时间&quot; + DateUtil.dateFormat(new Date())); rabbitTemplate.convertAndSend(XDelayedMessageConfig.DELAYED_EXCHANGE, XDelayedMessageConfig.ROUTING_KEY, msgStr, message -&gt; { message.getMessageProperties().setDelay(delayTime); //message1.getMessageProperties().setHeader(&quot;x-delay&quot;,delayTime); return message; }); } 消费者： @RabbitListener(queues = XDelayedMessageConfig.DIRECT_QUEUE) public void delayProcess(String msgStr, Channel channel, Message message) { System.out.println(&quot;【接收消息】&quot; + msgStr + &quot; 接收时间&quot; + DateUtil.dateFormat(new Date())); } 从控制台输出的结果，可以看出RabbitMQ的 rabbitmq_delayed_message_exchange 插件可以解决消息时序问题： 【发送消息】延迟队列10 秒当前时间06:53:18 【发送消息】延迟队列5 秒当前时间06:53:18 【发送消息】延迟队列2 秒当前时间06:53:18 【接收消息】延迟队列2 秒 接收时间06:53:20 【接收消息】延迟队列5 秒 接收时间06:53:23 【接收消息】延迟队列10 秒 接收时间06:53:28 比较由于死信队列方式需要创建两个交换机（死信队列交换机+处理队列交换机）、两个队列（死信队列+处理队列），而延迟插件方式只需创建一个交换机和一个队列，所以后者使用起来更简单 RocketMQTODO 参考 RabbitMQ-dlx、RabbitMQ-ttl","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"https://blog.xiongtianci.com/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.xiongtianci.com/tags/RabbitMQ/"}],"author":"木浅"},{"title":"Zuul网关实现限流","slug":"Zuul网关实现限流","date":"2023-05-21T06:10:12.000Z","updated":"2025-10-26T01:55:00.347Z","comments":true,"path":"2023/05/21/Zuul网关实现限流/","link":"","permalink":"https://blog.xiongtianci.com/2023/05/21/Zuul网关实现限流/","excerpt":"","text":"spring-cloud-zuul-ratelimitRateLimiter是Google开源的实现了令牌桶算法的限流工具（速率限制器）。 Spring Cloud Zuul RateLimiter结合Zuul对RateLimiter进行了封装，通过实现ZuulFilter提供了服务限流功能 官网：https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit 步骤导入依赖在zuul服务引入坐标 &lt;dependency&gt; &lt;groupId&gt;com.marcosbarbero.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-zuul-ratelimit&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 配置限流策略zuul: ratelimit: enabled: true #开启限流功能 repository: redis #限流数据的存储方式 default-policy-list: # 所有服务在3秒内只能有1次请求且所有请求时间总和不得超过2秒 - limit: 1 #单位时间内请求次数限制 quota: 2 #单位时间内累计请求时间限制（秒），非必要参数 refresh-interval: 3 #单位时间（秒），默认60秒 spring: redis: host: 127.0.0.1 port: 6379 处理返回信息我们可能需要对触发限流的情况做监控、报警等，需要识别由限流导致的异常返回 推荐使用默认的 RateLimiterErrorHandler，直接写自己需要的处理就行 注意：RateLimiterErrorHandler无法捕获到限流异常信息429 TOO_MANY_REQUESTS，也就不能自定义异常返回信息 zuul触发限流后会抛出 http 429，可以针对这个错误码对response包装 也可以在全局异常处理中，判断出现的异常是否是 RateLimitExceededException import com.marcosbarbero.cloud.autoconfigure.zuul.ratelimit.support.RateLimitExceededException; import com.netflix.zuul.context.RequestContext; import com.netflix.zuul.exception.ZuulException; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.autoconfigure.web.ErrorController; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @Slf4j @RestController public class ErrorHandlerController implements ErrorController { @Override public String getErrorPath() { return &quot;/error&quot;; } @RequestMapping(&quot;/error&quot;) public ResponseEntity error() { RequestContext ctx = RequestContext.getCurrentContext(); ZuulException exception = (ZuulException) ctx.getThrowable(); if (exception != null &amp;&amp; exception.getCause() instanceof RateLimitExceededException) { // 自定义返回封装 return ResponseEntity.status(HttpStatus.BAD_GATEWAY).body(&quot;请稍后再试~&quot;); } // 其他类型的eror return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;服务异常&quot;); } } 配置zuul: #路由、重试等zuul其他配置省略 routes: #限流 ratelimit: enabled: true #开启限流功能 key-prefix: ${spring.application.name}-rate-limit #缓存key的前缀 repository: REDIS #存储类型。可选REDIS、CONSUL、JPA等，老版本还有本地内存可选 behind-proxy: true #开启则限流与业务访问是异步的，相当于rateLimitFilter先放过；默认是false policy-list: #指定服务策略 myProject1: - limit: 5 #这种配置方式相当于：10分钟内允许5个请求访问/api/test/info接口 refresh-interval: 10 type: - url_pattern=/api/test/info myProject2: - limit: 3000 refresh-interval: 1 #更常见的配置是这种，1秒允许3k个，相当于配qps限制 type: - url_pattern=/api/test2/info - limit: 300 refresh-interval: 1 #如果同一个服务有多个需要限流的url，可以这样 type: - url_pattern=/api/test2/info2","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://blog.xiongtianci.com/tags/微服务/"}],"author":"木浅"},{"title":"MySQL版本从5.5升级至5.7(win10)","slug":"MySQL版本从5-5升级至5-7-win10","date":"2022-06-23T12:00:35.000Z","updated":"2025-10-26T01:45:43.333Z","comments":true,"path":"2022/06/23/MySQL版本从5-5升级至5-7-win10/","link":"","permalink":"https://blog.xiongtianci.com/2022/06/23/MySQL版本从5-5升级至5-7-win10/","excerpt":"","text":"当前版本： 升级后的版本： 下载安装包 官网：https://dev.mysql.com/downloads/mysql/5.7.html 下载压缩包： 备份数据将mysql5.5安装目录下的 data 目录备份： 安装1、删除mysql5.5服务按键盘的 win+R—&gt;输入services.msc 后确定进入服务列表，找到现有 msql 服务并关闭服务： 在cmd中输入：mysqld -remove xxx 将 mysql5.5 服务移除。xxx为要卸载的mysql服务，可以在服务中查看，我这里为 MySQL 2、完全卸载mysql5.5我这里使用 geek 的进行卸载，这个工具可以卸载软件后自动扫描注册表并提示删除 3、配置my.ini在mysql5.7目录中创建 my.ini 文件，并配置如下信息（注意替换路径）： [client] port=3306 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录，替换成你本地的路径 basedir=D:\\Java\\MySQL\\mysql-5.7.38-winx64\\ # 设置mysql数据库的数据的存放目录，替换成你本地的路径 datadir=D:\\Java\\MySQL\\mysql-5.7.38-winx64\\data\\ #设置跳过密码直接进入mysql，需要重新mysql服务 skip-grant-tables 4、配置环境变量删除mysql原5.5版本的环境变量： 新建5.7版本的环境变量： 5、添加mysql5.7服务，并初始化启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，添加mysql5.7服务： mysqld --install mysql5.7 使用 mysqld --initialize-insecure --user=mysql 进行初始化数据文件，然后输入 net start mysql5.7 再次启动mysql： 6、更改root账户密码用下面命令进入 mysql 管理界面，因为上面在 my.ini 中设置了跳过密码，所以密码处不输入直接按下Enter： 更改 root 账户密码： # 更改root密码 mysql&gt; update mysql.user set authentication_string=password(&#39;1234&#39;) where user=&#39;root&#39; and Host = &#39;localhost&#39;; # 刷新权限 mysql&gt; flush privileges; # 退出 mysql&gt; exit 7、更新my.ini注释掉 my.ini 中的配置 skip-grant-tables： 8、迁移数据先停止服务：net stop mysql5.7 将之前备份的 5.5 版本中的数据(data)覆盖到 5.7 的 data 目录中： 重启 mysql 服务：net start mysql5.7 进入到 mysql，查看现在的版本： 完毕。 参考 https://www.cnblogs.com/appium/p/12877499.html","categories":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/categories/软件/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"木浅"},{"title":"配置CentOS6.5静态ip导致xshell连接失败","slug":"配置CentOS6-5静态ip导致xshell连接失败","date":"2022-05-15T07:15:23.000Z","updated":"2025-10-26T01:45:43.296Z","comments":true,"path":"2022/05/15/配置CentOS6-5静态ip导致xshell连接失败/","link":"","permalink":"https://blog.xiongtianci.com/2022/05/15/配置CentOS6-5静态ip导致xshell连接失败/","excerpt":"","text":"问题将CentOS6.5虚拟机配置为静态IP后，Xshell连接失败。 我本地ip： C:\\Users\\Administrator&gt;ipconfig 无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : DHCP HOST 本地链接 IPv6 地址. . . . . . . . : fe80::acf9:f5ef:1ce:3bc1%7 IPv4 地址 . . . . . . . . . . . . : 192.168.0.102 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.0.1 虚拟机配置的静态ip为 192.168.56.101，其可以正常访问外网和我本地主机： [root@Levi ~]# ping baidu.com PING baidu.com (220.181.38.251) 56(84) bytes of data. 64 bytes from 220.181.38.251: icmp_seq=1 ttl=128 time=41.1 ms [root@Levi ~]# ping 192.168.0.102 PING 192.168.0.102 (192.168.0.102) 56(84) bytes of data. 64 bytes from 192.168.0.102: icmp_seq=1 ttl=128 time=1.11 ms 虚拟机网络信息： [root@Levi ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 TYPE=Ethernet ONBOOT=yes NM_CONTROLLED=yes BOOTPROTO=static DEFROUTE=yes PEERDNS=yes PEERROUTES=yes IPV4_FAILURE_FATAL=yes IPV6INIT=no NAME=&quot;System eth0&quot; DNS1=8.8.8.8 IPADDR=192.168.56.101 NETMASK=255.255.255.0 GATEWAY=192.168.56.2 解决在我本地电脑上配置：控制面板 -&gt; 网络和共享中心 -&gt; 更改适配器设置 -&gt; 右键 VMware Network Adapter VMnet8 进入属性设置 选中 Internet 协议版本4(TCP/IPv4) 点击 属性： 默认是自动获得IP地址，勾选 使用下面的IP地址 进行自定义IP： ①配置IP地址，前三位同虚拟机系统的IP前三位相同，最后一位自定义 ②中的配置系统自动补齐 ③中的网关配置为和虚拟机系统的网关一致 配置后使用xshell重新连接虚拟机即可","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"CentOS6.5中yum源失效的解决方案","slug":"CentOS6.5中yum源失效的解决方案","date":"2022-05-15T05:11:48.000Z","updated":"2025-10-26T01:45:43.278Z","comments":true,"path":"2022/05/15/CentOS6.5中yum源失效的解决方案/","link":"","permalink":"https://blog.xiongtianci.com/2022/05/15/CentOS6.5中yum源失效的解决方案/","excerpt":"","text":"问题在 CentOS6.5 上执行 yum install gcc 报错：YumRepo Error: All mirror URLs are not using ftp, http[s] or file。出现这个的原因是因为目前官方已经停止对CentOS6的支持。并且下架了包括官方所有的CentOS6源，目前阿里、163、清华等CentOS6源已无法使用。 解决1、备份，便于进行恢复 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/ 我这里是CenOS6，其他版本可以在 https://mirrors.aliyun.com/repo/ 中找到对应的文件 # centos6 wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo 如果出现错误： [root@Levi ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo --2022-05-15 20:44:42-- https://mirrors.aliyun.com/repo/Centos-6.repo 正在解析主机 mirrors.aliyun.com... 116.162.173.85, 116.153.65.218, 116.162.173.86, ... 正在连接 mirrors.aliyun.com|116.162.173.85|:443... 已连接。 错误: 证书通用名 “*.alicdn.com” 与所要求的主机名 “mirrors.aliyun.com” 不符。 要以不安全的方式连接至 mirrors.aliyun.com，使用‘--no-check-certificate’。 使用命令： wget --no-check-certificate -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo 3、运行 yum makecache 生成缓存 [root@Levi ~]# yum makecache Loaded plugins: fastestmirror, security Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com http://mirrors.aliyun.com/centos/6/os/x86_64/repodata/repomd.xml: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 404 Not Found&quot; Trying other mirror. ... 4、替换源文件配置 非阿里云ECS用户会出现 Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’ 信息，不影响使用。用户也可自行修改相关配置: sed -i -e &#39;/mirrors.cloud.aliyuncs.com/d&#39; -e &#39;/mirrors.aliyuncs.com/d&#39; /etc/yum.repos.d/CentOS-Base.repo 替换http成https sed -i &#39;s/http/https/g&#39; /etc/yum.repos.d/CentOS-Base.repo 替换版本，$releasever 替换6.5，6.5是我用的版本 sed -i &#39;s/$releasever/6.5/g&#39; /etc/yum.repos.d/CentOS-Base.repo 替换centos为centos-vault sed -i &#39;s/centos/centos-vault/g&#39; /etc/yum.repos.d/CentOS-Base.repo 5、执行 yum clean all &amp;&amp; yum makecache [root@Levi ~]# yum clean all &amp;&amp; yum makecache Loaded plugins: fastestmirror, security Cleaning repos: base extras updates Cleaning up Everything Cleaning up list of fastest mirrors Loaded plugins: fastestmirror, security Determining fastest mirrors base | 3.7 kB 00:00 base/group_gz | 226 kB 00:00 base/filelists_db | 6.4 MB 00:01 base/primary_db | 4.7 MB 00:00 base/other_db | 2.8 MB 00:00 extras | 3.4 kB 00:00 extras/filelists_db | 38 kB 00:00 extras/prestodelta | 1.3 kB 00:00 extras/primary_db | 37 kB 00:00 extras/other_db | 51 kB 00:00 updates | 3.4 kB 00:00 updates/filelists_db | 3.5 MB 00:00 updates/prestodelta | 390 kB 00:00 updates/primary_db | 5.4 MB 00:00 updates/other_db | 74 MB 00:13 Metadata Cache Created 参考 https://wiki.centos.org/zh/About/Product https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11shelh6","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.xiongtianci.com/categories/Linux/"}],"tags":[{"name":"CentOS6.5","slug":"CentOS6-5","permalink":"https://blog.xiongtianci.com/tags/CentOS6-5/"}],"author":"木浅"},{"title":"使用驱动人生后系统开机出现选择应急系统","slug":"使用驱动人生后系统开机出现选择应急系统","date":"2022-04-24T01:03:56.000Z","updated":"2025-10-26T01:45:43.260Z","comments":true,"path":"2022/04/24/使用驱动人生后系统开机出现选择应急系统/","link":"","permalink":"https://blog.xiongtianci.com/2022/04/24/使用驱动人生后系统开机出现选择应急系统/","excerpt":"","text":"问题使用驱动人生安装驱动后，系统重启就会出现下图情况： 解决1、使用 Win+R 快捷键 -&gt; 输入 msconfig，回车 2、再弹出的窗口中，选择 引导 页签，删除 驱动人生应急启动 即可： 参考：https://zhidao.baidu.com/question/1759620719166087268.html","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"}],"author":"木浅"},{"title":"安装Nacos,初始化sql报错：index column size too large. the maximum column size is 767 bytes","slug":"安装Nacos-初始化sql报错：index-column-size-too-large-the-maximum-column-size-is-767-bytes","date":"2022-02-27T07:31:54.000Z","updated":"2025-10-26T01:45:43.243Z","comments":true,"path":"2022/02/27/安装Nacos-初始化sql报错：index-column-size-too-large-the-maximum-column-size-is-767-bytes/","link":"","permalink":"https://blog.xiongtianci.com/2022/02/27/安装Nacos-初始化sql报错：index-column-size-too-large-the-maximum-column-size-is-767-bytes/","excerpt":"","text":"问题安装 Nacos Windows，执行 conf/nacos-mysql.sql 初始化脚本时报错： Index column size too large. The maximum column size is 767 bytes 解决对脚本进行修改，添加 ROW_FORMAT=DYNAMIC： create table test (........) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC; 参考：MySQL error: The maximum column size is 767 bytes","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"木浅"},{"title":"IDEA(首次安装)的常用设置","slug":"IDEA-首次安装-的常用设置","date":"2022-02-21T01:38:11.000Z","updated":"2025-10-26T01:45:43.209Z","comments":true,"path":"2022/02/21/IDEA-首次安装-的常用设置/","link":"","permalink":"https://blog.xiongtianci.com/2022/02/21/IDEA-首次安装-的常用设置/","excerpt":"","text":"前言 本文基于 IntelliJ IDEA v2019.3.4、Windows 10 环境 进入配置页： 首次安装完，可以在欢迎页直接进入： 如果错过了欢迎页，可以通过：File -&gt; Settings...，进入配置页： 字符编码设置：UTF-8Editor -&gt; File Encodings 编辑通用设置：控制字体+帮助Editor -&gt; General 自动导包设置Editor -&gt; General -&gt; Auto Import 通用编辑外貌设置：行号+分隔线Editor -&gt; General -&gt; Appearance 通用编辑补全设置Editor -&gt; General -&gt; Code Completion 快捷键设置第一步：Keymap -&gt; Main menu -&gt; Code -&gt; Completion 第二步： 第三步： 第四步： 最后，点击 Apply 开发环境JDK设置 修改内存大小 显示内存占用情况效果： 设置： 新版开启的方式：View -&gt; Apperance -&gt; Status Bar Widgets -&gt; Memory Indicator 显示方法的注释调用方法时Editor -&gt; General -&gt; Code Completion： 鼠标移至方法上时Editor -&gt; General： 新版：File -&gt; Settings -&gt; Editor -&gt; Code Editing，勾选 Show quick documentation on hover 其他常用设置 以下设置的操作环境：IntelliJ IDEA 2022.3.3 Git的commit使用独立窗口File -&gt; Settings -&gt; Version Control -&gt; Commit -&gt; Use non-modal commit interface，取消勾选 显示Java面包屑导航File -&gt; Settings -&gt; Editor &gt; General &gt; Breadcrumbs，勾选 java Force Step Into按钮没了IDEA2022.3版本中Force Step Into按钮默认没有显示 TODO","categories":[{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"木浅"},{"title":"隐藏IDEA项目目录后面显示的文件路径地址","slug":"隐藏IDEA项目目录后面显示的文件路径地址","date":"2021-09-20T07:13:59.000Z","updated":"2025-10-26T01:45:43.192Z","comments":true,"path":"2021/09/20/隐藏IDEA项目目录后面显示的文件路径地址/","link":"","permalink":"https://blog.xiongtianci.com/2021/09/20/隐藏IDEA项目目录后面显示的文件路径地址/","excerpt":"","text":"环境：win10、IDEA 2019.3 问题IDEA左侧的Project目录中，在项目名称后面显示了项目的文件路径地址： 现在需要将其隐藏掉 解决选择：Help-&gt;Edit Custom Properties... 打开配置文件，添加以下配置： project.tree.structure.show.url=false ide.tree.horizontal.default.autoscrolling=false 保存更改后重启IDEA，就可以看见文件路径被隐藏了","categories":[{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"Cron的语法格式","slug":"Cron的语法格式","date":"2021-09-13T08:25:40.000Z","updated":"2025-10-26T01:45:43.174Z","comments":true,"path":"2021/09/13/Cron的语法格式/","link":"","permalink":"https://blog.xiongtianci.com/2021/09/13/Cron的语法格式/","excerpt":"","text":"Cron表达式 Cron表达式是一个字符串，包括6~7个时间元素，在SpringTask中可以用于指定任务的执行时间。 结构Cron的语法格式： Seconds Minutes Hours DayofMonth Month DayofWeek [Year] 秒 分 小时 日期 月份 星期 [年] 例：0/2 * * * * ?、0 15 10 ? * 6L 2020-2021 时间元素 允许值 允许的特殊字符 秒(Seconds) 0~59的整数 , - * / 分(Minutes) 0~59的整数 , - * / 小时(Hours) 0~23的整数 , - * / 日期(DayofMonth) 1~31的整数 ,- * ? / L W 月份(Month) 1~12的整数 或者 JAN-DEC , - * / 星期(DayofWeek) 1~7的整数 或者 SUN-SAT 【1=SUN】 , - * ? / L # 年(Year)【可为空】 1970~2099 , - * / 特殊字符 字符 作用 举例 , 列出枚举值 在Minutes域使用5,10，表示在5分和10分各触发一次 - 表示触发范围 在Minutes域使用5-10，表示从5分到10分钟每分钟触发一次 * 匹配任意值 在Minutes域使用*, 表示每分钟都会触发一次 / 起始时间开始触发，每隔固定时间触发一次 在Minutes域使用5/10,表示5分时触发一次，每10分钟再触发一次 ? 在DayofMonth和DayofWeek中，用于匹配任意值 在DayofMonth域使用?,表示每天都触发一次 # 在DayofMonth中，确定第几个星期几 1#3表示第三个星期日 L 表示最后 在DayofWeek中使用5L,表示在最后一个星期四触发 W 表示有效工作日(周一到周五) 在DayofMonth使用5W，如果5日是星期六，则将在最近的工作日4日触发一次 LW连用，表示在某个月最后一个工作日，即最后一个星期五","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.xiongtianci.com/tags/Spring/"},{"name":"SpringTask","slug":"SpringTask","permalink":"https://blog.xiongtianci.com/tags/SpringTask/"},{"name":"Cron","slug":"Cron","permalink":"https://blog.xiongtianci.com/tags/Cron/"}],"author":"天赐"},{"title":"使用Adobe Acrobat打开pdf文件,系统任务栏中其图标异常问题(win)","slug":"使用Adobe-Acrobat打开pdf文件-系统任务栏中其图标异常问题-win","date":"2021-08-25T03:21:23.000Z","updated":"2025-10-26T01:45:43.158Z","comments":true,"path":"2021/08/25/使用Adobe-Acrobat打开pdf文件-系统任务栏中其图标异常问题-win/","link":"","permalink":"https://blog.xiongtianci.com/2021/08/25/使用Adobe-Acrobat打开pdf文件-系统任务栏中其图标异常问题-win/","excerpt":"","text":"环境：win10参考：百度知道 问题使用 Acrobat 打开pdf文件后，Acrobat 在win系统任务栏上面显示的图标异常： 解决1.首先先关闭掉 Acrobat，然后在资源管理器打开此目录： C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs，找到 Adobe Acrobat DC，将其删除 2.找到 Acrobat 安装目录中找到启动程序并启动，就可以看到图标回复正常了","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"Adobe","slug":"Adobe","permalink":"https://blog.xiongtianci.com/tags/Adobe/"},{"name":"Acrobat","slug":"Acrobat","permalink":"https://blog.xiongtianci.com/tags/Acrobat/"}],"author":"天赐"},{"title":"解决SVN每次commit后文件属性都变为只读","slug":"解决SVN每次commit后文件属性都变为只读","date":"2021-08-20T03:06:39.000Z","updated":"2025-10-26T01:45:43.140Z","comments":true,"path":"2021/08/20/解决SVN每次commit后文件属性都变为只读/","link":"","permalink":"https://blog.xiongtianci.com/2021/08/20/解决SVN每次commit后文件属性都变为只读/","excerpt":"","text":"环境：win10、Eclipse Neno.2、TortoiseSVN 1.14.0、Subclipse 4.3.3(eclipse插件) 问题将svn中的项目的 Checkout 到本地使用eclipse开发过程中，发现每次 commit 后文件属性都变为 只读 属性，并且对刚刚提交后的文件进行编辑时就提示需要先锁定文件才能编辑 笔者在eclipse中是使用的 Subclipse 对svn进行操作 commit后编辑文件提示需要锁定： 文件属性变为只读： 解决1.在项目根目录中 鼠标右键-&gt;TortoiseSVN-&gt;Properties 2.在弹出的属性设置框中点击：New-&gt;Needs-Lock 3.选择 No locking required，点击 OK 即可解决","categories":[{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"https://blog.xiongtianci.com/tags/SVN/"},{"name":"Eclispe","slug":"Eclispe","permalink":"https://blog.xiongtianci.com/tags/Eclispe/"}],"author":"天赐"},{"title":"IDEA格式化后注释无法和代码自动对齐","slug":"IDEA格式化后注释无法和代码自动对齐","date":"2021-08-12T06:58:58.000Z","updated":"2025-10-26T01:45:43.123Z","comments":true,"path":"2021/08/12/IDEA格式化后注释无法和代码自动对齐/","link":"","permalink":"https://blog.xiongtianci.com/2021/08/12/IDEA格式化后注释无法和代码自动对齐/","excerpt":"","text":"问题使用idea对java代码进行格式化后，行注释靠在最左边没有和代码自动对齐： 解决打开设置窗口，依次选择 Code Style -&gt; Java，在右侧找到 Comment af first column 并取消其勾选状态即可解决 另外","categories":[{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"Eclipse设置护眼背景色和字体颜色并导入导出","slug":"Eclipse设置护眼背景色和字体颜色并导入导出","date":"2021-08-09T03:30:30.000Z","updated":"2025-10-26T01:45:43.089Z","comments":true,"path":"2021/08/09/Eclipse设置护眼背景色和字体颜色并导入导出/","link":"","permalink":"https://blog.xiongtianci.com/2021/08/09/Eclipse设置护眼背景色和字体颜色并导入导出/","excerpt":"","text":"环境：Windows 10、Eclipse Neon.2参考：Eclipse详细设置护眼背景色和字体颜色并导出 修改背景色打开首选项对话框：Window -&gt; Preferences 选择：General -&gt; Editors -&gt; Text Editors -&gt; Appearance color options -&gt; 点击 Background color，取消右侧 Sstem Default 的勾选状态，然后点击 Color 右侧的色块进行颜色选择 豆沙绿： 色调：85 饱和度：120 亮度：208 修改文字颜色以Java编辑器为例 在首选项对话框中依次选择：Java -&gt; Editor -&gt; Syntax Coloring -&gt; 点击右侧的Java 为了配合豆沙绿的背景色，代码颜色配色方案： 描述红(R)绿(G)蓝(U)颜色其他设置Annotations注释107147186浅蓝色Brackets符号2551280橙色Classes类名08050深绿色加粗Deprecated members 弃用的成员1232343咖啡色中划线/加粗Enums枚举1280255紫色Fields变量1280128深紫色Keyword ‘return’return关键字255085红色加粗Keyword excluding ‘return’其他关键字20746125玫瑰红加粗Method declarations方法定义25512864橙色加粗Methods方法04896深蓝Numbers数字420255蓝色Operators运算符2551280橙色Others其他781230绿色Static fields静态变量330189蓝色加粗Strings字符串13226138紫色 导出设置选择：File -&gt; Export 进行导出操作 在弹出框中，选择 General -&gt; Preferences，点击 Next 点击 Browse，输入文件名，点击 Finish，会导出一个以 .epf 结尾的配置文件 我导出的配置文件：豆沙绿配置 导入设置选择：File -&gt; Imprt 进行导入操作 在弹出框中，选择 General -&gt; Preferences，点击 Next 点击 Browse 选择之前导出的配置文件，点击 Finish 即可完成导入","categories":[{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.xiongtianci.com/tags/Eclipse/"}],"author":"天赐"},{"title":"Eclipse设置编码格式","slug":"Eclipse设置编码格式","date":"2021-08-09T02:49:13.000Z","updated":"2025-10-26T01:45:43.107Z","comments":true,"path":"2021/08/09/Eclipse设置编码格式/","link":"","permalink":"https://blog.xiongtianci.com/2021/08/09/Eclipse设置编码格式/","excerpt":"","text":"前言 环境：Windows 10、Eclipse Neon.2 eclipse每次新建一个工作空间后，都需要重新设置编码格式，否则在导入代码后很有可能会出现中文乱码的情况 步骤修改工作空间默认编码打开首选项对话框：Window -&gt; Preferences 在首选项对话框左侧导航中找到：General -&gt; Workspace设置 Text file encoding 编码为 Other: UTF-8 修改某文件类型的编码在首选项对话框左侧导航中找到：General -&gt; Content Types点击右侧中的节点，在下面 Default encoding 中输入 UTF-8(不区分大小写)，点击 Update，把每个父节点和子节点都设置一下，都设置好后点击 OK 修改项目的编码步骤：选择项目 -&gt; 右键 -&gt; Properties -&gt; Resource -&gt; 如果右侧的 Text file encoding 不是UTF-8格式，则需要设置为 UTF-8：","categories":[{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.xiongtianci.com/tags/Eclipse/"}],"author":"天赐"},{"title":"IDEA格式化代码后,方法顺序被改变","slug":"IDEA格式化代码后-方法顺序被改变","date":"2021-07-13T03:40:06.000Z","updated":"2025-10-26T01:45:43.061Z","comments":true,"path":"2021/07/13/IDEA格式化代码后-方法顺序被改变/","link":"","permalink":"https://blog.xiongtianci.com/2021/07/13/IDEA格式化代码后-方法顺序被改变/","excerpt":"","text":"问题 IDEA版本：2019.3 使用IDEA编写java代码时，使用 Ctrl+Alt+L(win) 格式化代码操作之后发现代码中的方法顺序被改变了： 格式化前： 格式化后： method01 被移动到 test01 上方 解决使用 Shift+Ctrl+Alt+L(win) 进行格式化，在弹出的选项中取消 Rearrange code 的勾选即可","categories":[{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"Eclipse在模块上右键没有gradle菜单选项","slug":"Eclipse在模块上右键没有gradle菜单选项","date":"2021-03-04T07:32:04.000Z","updated":"2025-10-26T01:45:43.045Z","comments":true,"path":"2021/03/04/Eclipse在模块上右键没有gradle菜单选项/","link":"","permalink":"https://blog.xiongtianci.com/2021/03/04/Eclipse在模块上右键没有gradle菜单选项/","excerpt":"","text":"Eclipse：Neon.2 Release (4.6.2)插件：Gradle IDE Pack 3.8.x+1.0.x 问题正常情况下，在模块上右键弹出的菜单应该会有 Gradle(STS) 选项，可以用于gradle有关操作： 但是我今天更新代码后，项目模块的右键菜单上没有了 Gradle(STS) 选项： 解决在项目模块上右键，选择：Configure-&gt;Convert to Gradle(STS) Project 即可","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.xiongtianci.com/tags/Eclipse/"}],"author":"天赐"},{"title":"Eclipse右键team显示的是git菜单,怎么切换成svn菜单?","slug":"Eclipse右键team显示的是git菜单-怎么切换成svn菜单","date":"2021-03-04T01:51:16.000Z","updated":"2025-10-26T01:45:43.028Z","comments":true,"path":"2021/03/04/Eclipse右键team显示的是git菜单-怎么切换成svn菜单/","link":"","permalink":"https://blog.xiongtianci.com/2021/03/04/Eclipse右键team显示的是git菜单-怎么切换成svn菜单/","excerpt":"","text":"问题由于这个项目我同时使用了 svn 和 git，在 Import 新的模块后，右键中 Team 下的菜单全是 git 的功能，现在需要将其改成 svn选项 解决1.先右键此模块，选择：Team -&gt; Disconnect 2.再右键此模块，选择：Team -&gt; Share Project 3.在弹出框中选择 SVN，点击 Next，点击 Finish，就完成了","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.xiongtianci.com/tags/Eclipse/"}],"author":"天赐"},{"title":"VMware中网络三种连接方式","slug":"VMware中网络三种连接方式","date":"2021-01-05T03:02:09.000Z","updated":"2025-10-26T01:45:43.011Z","comments":true,"path":"2021/01/05/VMware中网络三种连接方式/","link":"","permalink":"https://blog.xiongtianci.com/2021/01/05/VMware中网络三种连接方式/","excerpt":"","text":"VMware中网络三种连接方式1 桥接模式桥接模式(Bridged)：虚拟机是一台独立的电脑，直接连接到实际的网络上，与宿主机没有任何联系。 2 仅主机模式 这种方式下，虚拟机的网卡连接到宿主的 VMnet1 上，但系统并不为虚拟机提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。 仅主机模式(host-only)：虚拟机可以访问宿主机，宿主机无法访问虚拟机，虚拟机无法上网 3 NAT 模式 这种方式下，虚拟机的网卡连接到宿主的 VMnet8 上。此时系统的 VMWare NAT Service 服务就充当了路由器的作用，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。VMWare DHCP Service 负责为虚拟机提供 DHCP 服务。 NAT模式： 虚拟机可以访问宿主机，宿主机可以访问虚拟机 此时宿主机相当于路由器，虚拟机可以通过宿主机上网 宿主机可以配置254个虚拟机","categories":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/categories/软件/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"https://blog.xiongtianci.com/tags/VMware/"}],"author":"天赐"},{"title":"nginx停止后仍然生效(win)","slug":"nginx停止后仍然生效(win)","date":"2020-12-24T07:47:57.000Z","updated":"2025-10-26T01:45:42.992Z","comments":true,"path":"2020/12/24/nginx停止后仍然生效(win)/","link":"","permalink":"https://blog.xiongtianci.com/2020/12/24/nginx停止后仍然生效(win)/","excerpt":"","text":"问题今天在任务管理器中将nginx结束任务后，发现nginx服务无法停止 访问http://127.0.0.1/仍能看到欢迎页： 此时尝试使用命令nginx.exe -s stop停止服务发现报错： 解决由于我本地的nginx有监听8099端口，所以使用 netstat -ano | findstr &quot;8099&quot; 查看占用8099端口的进程的PID 拿到上面的PID，通过 tasklist | findstr &quot;PID&quot; 命令找到nginx进程信息 然后通过 taskkill /f /t /im nginx.exe 结束nginx进程 然后再次访问 http://127.0.0.1/ 发现nginx服务已成功停止","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[],"author":"天赐"},{"title":"Eclipse常用快捷键","slug":"Eclipse常用快捷键","date":"2020-12-03T02:51:21.000Z","updated":"2025-10-26T01:45:42.976Z","comments":true,"path":"2020/12/03/Eclipse常用快捷键/","link":"","permalink":"https://blog.xiongtianci.com/2020/12/03/Eclipse常用快捷键/","excerpt":"","text":"Ctrl 快捷键 介绍 Ctrl + D 删除当前行【常用】 Ctrl + E TODO Ctrl + G 搜索选中的元素的声明 TODO Ctrl (+Shift) + K 快速向下[向上]查找选定的内容 Ctrl + L 跳到某行 Ctrl + M 编辑窗口最大化 Ctrl + O 显示类的大纲结构(类的方法和属性) 【常用】 Ctrl + Q 上一个编辑的位置 Ctrl + R TODO Ctrl + T 显示当前类(或光标所在类)的层次结构 TODO Ctrl + 1 快速修复[补全代码、] TODO 【常用】 Ctrl + 2，释放后按L 自动补全代码 Ctrl + + 放大 Ctrl + - 缩小 Ctrl + / (取消)注释光标所在行代码 Ctrl + F6 下一个编辑器 Ctrl + F7 下一个视图 Ctrl + F8 下一个透视图 Alt 快捷键 介绍 Alt + / TODO Alt + Up/Down 上下移动选中的行 Alt + Left/Right 上一个(下一个)光标所在位置 TODO 描述 Shift 快捷键 介绍 Shift + Enter 在当前行下插入空行，光标定位到新行 Ctrl + Alt 快捷键 介绍 Ctrl + Alt + G 搜索选中的文本 Ctrl + Alt + H 快速查看被调用的层次 【常用】 Ctrl + Alt + Up/Down 向 上/下 拷贝选中的行 【常用】 Ctrl + Shift 快捷键 介绍 Ctrl + Shift + F 格式化整个文档 / 选中的代码 【常用】 Ctrl + Shift + G 查找(类、方法和属性)引用 TODO 类似 ctrl+alt+h Ctrl + Shift + L 显示快捷键帮助 Ctrl + Shift + O 导包 Ctrl + Shift + P 跳转至匹配的括号 Ctrl + Shift + R 查找Java类文件「可使用 *、? 等通配符」(含class) Ctrl + Shift + S 保存所有文件的修改操作 Ctrl + Shift + T 查找Java类文件「可使用 *、? 等通配符」(不含class) Ctrl + Shift + X/Y 将选中的内容转为大/小写 Ctrl + Shift + / (+\\) 添加(取消)块注释 Ctrl + Shift + Enter 在当前行上插入空行，光标定位到新行 Ctrl + Shift + Up/Down 上一个/下一个成员(成员对象或成员函数) Alt + Shift 快捷键 介绍 Alt + Shift + R 对 类名/属性名/方法名 重命名 Alt + Shift + T 显示重构菜单 Ctrl + Shift + Alt 快捷键 介绍 Ctrl + Shift + Alt + Debug调试 快捷键 介绍 F5 跟踪到方法中，当程序执行到某方法时，可以按【F5】键跟踪到方法中 F6 单步执行程序 F7 F8 Ctrl + R 运行至光标所在行 关键字自动补全先输入关键字，再配合自动补全快捷键(Alt + /)，即可自动生成代码 关键字 介绍 for 自动补全各式for代码 sysout 自动补全System.out.println() main 自动补全main函数 在空白区域按补全快捷键(Alt + /)，即可查看全部补全指令 其他 快捷键 介绍 F2 重命名/显示提示 F4 打开选中元素的类型继承结构 F11","categories":[{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.xiongtianci.com/tags/Eclipse/"}],"author":"天赐"},{"title":"CentOS7设置静态IP并成功上网","slug":"CentOS7设置静态IP并成功上网","date":"2020-11-08T01:19:07.000Z","updated":"2025-10-26T01:45:42.958Z","comments":true,"path":"2020/11/08/CentOS7设置静态IP并成功上网/","link":"","permalink":"https://blog.xiongtianci.com/2020/11/08/CentOS7设置静态IP并成功上网/","excerpt":"","text":"环境： VMware 15 CentOS 7.3.1611 查看网卡信息通过ip addr查看当前网卡的配置信息： 从图中可以看出, 当前设备网卡名称为： ens33 (不同设备这个可能不同)，当前主机的ip为192.168.220.134CentOS7默认网卡设备文件存放于/etc/sysconfig/network-scripts/目录中，其中名为 ifcfg-网卡名称 的文件就是设备的默认网卡，我这里的网卡名为ifcfg-ens33 配置网卡为静态IP通过cat /etc/sysconfig/network-scripts/ifcfg-ens33查看默认网卡设备配置信息： TYPE=&quot;Ethernet&quot; # 网卡类型为：以太网 PROXY_METHOD=&quot;none&quot; # 代理方式：关闭状态 BROWSER_ONLY=&quot;no&quot; # 只是浏览器：否 BOOTPROTO=&quot;dhcp&quot; # 网卡的引导协议：DHCP[中文名称: 动态主机配置协议] DEFROUTE=&quot;yes&quot; # 默认路由：是, 深入了解可以百度关键词 `默认路由` PEERDNS=&quot;yes&quot; # 是否允许DHCP获得的DNS覆盖本地的DNS PEERROUTES=&quot;yes&quot; # 是否从DHCP服务器获取用于定义接口的默认网关的信息的路由表条目 IPV4_FAILURE_FATAL=&quot;no&quot; # 是否开启IPV4致命错误检测：否 IPV6INIT=&quot;yes&quot; # IPV6是否自动初始化: 是[不会有任何影响, 现在还没用到IPV6] IPV6_AUTOCONF=&quot;yes&quot; # IPV6是否自动配置：是[不会有任何影响, 现在还没用到IPV6] IPV6_DEFROUTE=&quot;yes&quot; # IPV6是否可以为默认路由：是[不会有任何影响, 现在还没用到IPV6] IPV6_PEERDNS=&quot;yes&quot; IPV6_PEERROUTES=&quot;yes&quot; IPV6_FAILURE_FATAL=&quot;no&quot; # 是否开启IPV6致命错误检测：否 IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot; # IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略] NAME=&quot;ens33&quot; # 网卡物理设备名称 UUID=&quot;f50c1acb-829e-4c6c-a9d7-3d9c5e6ea0d5&quot; # 通用唯一识别码,每一个网卡都会有,不能重复,否则两台linux只有一台网卡可用 DEVICE=&quot;ens33&quot; # 网卡设备名称, 必须和 `NAME` 值一样 ONBOOT=&quot;no&quot; # 是否开机启动,要想网卡开机就启动或通过 `systemctl restart network`控制网卡,必须设置为 `yes` 通过vi /etc/sysconfig/network-scripts/ifcfg-ens33命令编辑 ifcfg-ens33 文件设置静态IP： 设置网卡引导协议为 静态 BOOTPROTO=&quot;static&quot; 设置网卡启动方式为 开机启动 并且可以通过系统服务管理器 systemctl 控制网卡 ONBOOT=&quot;yes&quot; 配置「IP/子网掩码/网关」 IPADDR=&quot;192.168.220.132&quot; # 指定静态IP NETMASK=&quot;255.255.255.0&quot; # 子网掩码 GATEWAY=&quot;192.168.220.2&quot; # 网关 注意：网关必须和虚机的网关地址一样，否则无法上网，网关可以在虚拟网络编辑器中找到 按住 Esc 输入 Shift + : 接着输入 wq 回车保存编辑并退出，设置完后通过service network restart命令重启网卡： 这个时候如果是使用xshell之类工具连接着，则会断开连接，因为此时主机ip已经变为修改之后的地址，需修改xshell上配置的主机地址后再进行连接 重启完成，查看此时的ip，发现修改成功： 连上外网那么现在已经成功修改成静态ip了，但是通过 ping baidu.com 发现连不上外网： 这是因为当前CentOS还解析不了域名，我们需要修改 ifcfg-ens33 文件加入DNS解析 DNS1=&quot;114.114.114.114&quot; # 114DNS DNS2=&quot;223.5.5.5&quot; # 阿里DNS 8.8.8.8 是谷歌提供的DNS服务，国内无节点，不推荐 通过service network restart重启网卡，通过cat /etc/resolv.conf命令可以看到设置的DNS解析已生效，然后再来ping百度，可以ping通： 如果还是ping不通，则可以换个DNS地址再试试 最终网卡设备配置详情表 TYPE=&quot;Ethernet&quot; BOOTPROTO=&quot;static&quot; DEFROUTE=&quot;yes&quot; PEERDNS=&quot;yes&quot; PEERROUTES=&quot;yes&quot; IPV4_FAILURE_FATAL=&quot;no&quot; IPV6INIT=&quot;yes&quot; IPV6_AUTOCONF=&quot;yes&quot; IPV6_DEFROUTE=&quot;yes&quot; IPV6_PEERDNS=&quot;yes&quot; IPV6_PEERROUTES=&quot;yes&quot; IPV6_FAILURE_FATAL=&quot;no&quot; IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot; NAME=&quot;ens33&quot; UUID=&quot;f50c1acb-829e-4c6c-a9d7-3d9c5e6ea0d5&quot; DEVICE=&quot;ens33&quot; ONBOOT=&quot;yes&quot; IPADDR=&quot;192.168.220.132&quot; NETMASK=&quot;255.255.255.0&quot; GATEWAY=&quot;192.168.220.2&quot; DNS1=&quot;114.114.114.114&quot; DNS2=&quot;223.5.5.5&quot;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.xiongtianci.com/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.xiongtianci.com/tags/CentOS7/"}],"author":"天赐"},{"title":"IDEA启动警告「OpenJDK 64-Bit Server VM warning」","slug":"IDEA启动警告「OpenJDK 64-Bit Server VM warning」","date":"2020-10-31T02:43:07.000Z","updated":"2025-10-26T01:45:42.943Z","comments":true,"path":"2020/10/31/IDEA启动警告「OpenJDK 64-Bit Server VM warning」/","link":"","permalink":"https://blog.xiongtianci.com/2020/10/31/IDEA启动警告「OpenJDK 64-Bit Server VM warning」/","excerpt":"","text":"问题IDEA启动SpingBoot项目时警告： OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended 具体如下图： 解决1.快捷键Ctrl+Alt+S；或选择IDEA左上角的菜单File -&gt; Settings： 2.搜索async，选择Async Stack Traces，将右侧面板中Instrumenting agent (requires debugger restart)前面的对勾去掉，保存设置 3.重启项目即可","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/categories/踩坑/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"黑马十次方微服务项目资源","slug":"黑马十次方微服务项目资源","date":"2020-10-30T11:00:43.000Z","updated":"2025-10-26T01:45:42.924Z","comments":true,"path":"2020/10/30/黑马十次方微服务项目资源/","link":"","permalink":"https://blog.xiongtianci.com/2020/10/30/黑马十次方微服务项目资源/","excerpt":"","text":"链接 提取码 视频 java 资料 java 解压密码：52studyit_com_20181111 后端源码：Github、Gitee","categories":[{"name":"资料","slug":"资料","permalink":"https://blog.xiongtianci.com/categories/资料/"}],"tags":[{"name":"十次方","slug":"十次方","permalink":"https://blog.xiongtianci.com/tags/十次方/"}],"author":"天赐"},{"title":"win10所有文件夹全变成只读","slug":"win10所有文件夹全变成只读","date":"2020-10-12T11:40:12.000Z","updated":"2025-10-26T01:45:42.893Z","comments":true,"path":"2020/10/12/win10所有文件夹全变成只读/","link":"","permalink":"https://blog.xiongtianci.com/2020/10/12/win10所有文件夹全变成只读/","excerpt":"","text":"系统环境：Windows 10 专业版_v1909_x64 今天突然发现自己电脑中C、D、E盘中所有文件夹的全变成了只读状态。并且无论怎么取消只读，点击确认后都会自动恢复只读： 但是所有文件夹里面的文件的属性并没有勾选只读： 网上搜索一波，有的说是文件共享的问题，又有说是权限的问题，这些都排除后问题还是没解决，一度以为电脑中了病毒 最后发现两篇文章：文章1、文章2；原来属性中的只读有3种状态： 实心小黑块■，就是我出现的情况 对勾√，这个才是正真选中了只读 空心框□ 黑色方块并不是只读，黑色对勾才是只读。黑色方块只是表明，这个文件夹以及其子文件和子文件夹中允许存在具有只读属性的文件或子文件夹，并不说明这个文件夹本身只读。 好吧，最后发现毛线问题都没有😬","categories":[{"name":"win","slug":"win","permalink":"https://blog.xiongtianci.com/categories/win/"}],"tags":[{"name":"win","slug":"win","permalink":"https://blog.xiongtianci.com/tags/win/"}],"author":"天赐"},{"title":"everything无法搜索刚插入的硬盘中的文件","slug":"everything无法搜索刚插入的硬盘中的文件","date":"2020-10-12T01:49:38.000Z","updated":"2025-10-26T01:45:42.844Z","comments":true,"path":"2020/10/12/everything无法搜索刚插入的硬盘中的文件/","link":"","permalink":"https://blog.xiongtianci.com/2020/10/12/everything无法搜索刚插入的硬盘中的文件/","excerpt":"","text":"问题在使用everything过程中，对于刚刚新增的文件或刚插入电脑的硬盘中的文件有时在everything中无法搜索到 解决 在菜单栏中选择：工具 -&gt; 选项 在选项中选择索引 -&gt; 强制重建，然后点击确定： 此时everything会开始扫描磁盘重建索引，需稍等一会： 等到窗口下方出现...个对象就说明索引重建完成，再进行搜索就会发现有结果了","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"Everything","slug":"Everything","permalink":"https://blog.xiongtianci.com/tags/Everything/"}],"author":"天赐"},{"title":"安装完svn后在bin目录中没有svn.exe文件","slug":"安装完svn后在bin目录中没有svn-exe文件","date":"2020-10-10T08:07:24.000Z","updated":"2025-10-26T01:45:42.807Z","comments":true,"path":"2020/10/10/安装完svn后在bin目录中没有svn-exe文件/","link":"","permalink":"https://blog.xiongtianci.com/2020/10/10/安装完svn后在bin目录中没有svn-exe文件/","excerpt":"","text":"问题安装完TortoiseSVN后在bin目录中没有找到svn.exe文件 解决这是由于SVN在安装过程中默认不安装command line client tools，这时我们需要将其安装到本地 双击执行TortoiseSVN的安装包 选择第一项Modify 选择：TortoiseSVN -&gt; command line client tools -&gt; Will beinstall on local hard drive 点击Next重新安装即可解决","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/categories/踩坑/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"https://blog.xiongtianci.com/tags/SVN/"}],"author":"天赐"},{"title":"Eclipse中Console无法显示全部日志问题","slug":"Eclipse中Console控制台无法显示全部日志问题","date":"2020-09-21T09:42:32.000Z","updated":"2025-10-26T01:45:42.789Z","comments":true,"path":"2020/09/21/Eclipse中Console控制台无法显示全部日志问题/","link":"","permalink":"https://blog.xiongtianci.com/2020/09/21/Eclipse中Console控制台无法显示全部日志问题/","excerpt":"","text":"问题EclipseConsole控制台日志输出量大时，后面的日志会覆盖掉之前打印的日志，无法查看所有日志信息 解决 在Eclipse上面菜单中选择：Window -&gt; Preferences 选择：Run/Debug -&gt; Console 取消Limit console output的勾选状态","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.xiongtianci.com/tags/Eclipse/"}],"author":"天赐"},{"title":"电脑连接手机热点无法访问github","slug":"电脑连接手机热点无法访问github","date":"2020-08-17T09:41:45.000Z","updated":"2025-10-26T01:45:42.773Z","comments":true,"path":"2020/08/17/电脑连接手机热点无法访问github/","link":"","permalink":"https://blog.xiongtianci.com/2020/08/17/电脑连接手机热点无法访问github/","excerpt":"","text":"问题电脑连接手机热点后无法访问github.com，ping一下发现请求超时： 解决 使用ip解析类网站获取ip地址，如下面使用站长之家Dns检测github.com的ip地址： 选择一个ip地址设置到hosts文件中，格式如下： # Windows中hosts位置：C:\\Windows\\System32\\drivers\\etc 140.82.112.4 www.github.com 140.82.112.4 github.com 使用ipconfig/flushdns命令刷新DNS解析缓存 以上，即可解决此类问题","categories":[],"tags":[],"author":"天赐"},{"title":"使用Xftp6上传文件显示状态错误","slug":"使用Xftp6上传文件显示状态错误","date":"2020-07-01T04:58:27.000Z","updated":"2025-10-26T01:45:42.755Z","comments":true,"path":"2020/07/01/使用Xftp6上传文件显示状态错误/","link":"","permalink":"https://blog.xiongtianci.com/2020/07/01/使用Xftp6上传文件显示状态错误/","excerpt":"","text":"问题在使用Xftp6上传文件到VMware中的CentOS6.5中时一直失败： 网上说法是目录权限的问题 解决通过chmod命令修改目录权限。比如我现在需要将jdk安装包上传到CentOS下/usr/local/java目录下，现在就需要将/usr/local/java目录权限进行修改 # 进入上一级目录 cd /usr/local # 修改java目录权限 chmod 777 java/ 再次进行上传，成功","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/categories/踩坑/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xiongtianci.com/tags/CentOS/"},{"name":"Xftp6","slug":"Xftp6","permalink":"https://blog.xiongtianci.com/tags/Xftp6/"}],"author":"天赐"},{"title":"使用VMware15安装Linux(CentOS6.5)","slug":"使用VMware15安装Linux-CentOS6-5","date":"2020-07-01T02:40:20.000Z","updated":"2025-10-26T01:45:42.742Z","comments":true,"path":"2020/07/01/使用VMware15安装Linux-CentOS6-5/","link":"","permalink":"https://blog.xiongtianci.com/2020/07/01/使用VMware15安装Linux-CentOS6-5/","excerpt":"","text":"环境 Window10_1909_x64VMware_15.5.2CentOS_6.5_x86 步骤1、在VMware菜单中选择文件 -&gt; 新建虚拟机： 2、配置类型，选择典型： 3、选择稍后安装操作系统创建空白硬盘： 4、选择安装Linux系统和CentOS 6 版本： 5、选择虚拟机安装位置（自定义） 6、指定磁盘容量（默认） 7、硬件配置 配置完成后点击选项卡下方关闭按钮，然后选择完成： 8、启动虚拟机 9、选择安装项 按Enter键选择第一项 扩展：不同的选择解释 Install or upgrade an existing system：安装或升级现有系统（默认项），采用CentOS的图形安装程序 Install system with basic video driver：使用基本驱动安装程序。如果显卡等驱动不能成功安装时，可以使用此项 Rescue installed system：救援安装的系统。如果不能正常启动时，使用此项 Boot frome local drive：从本地驱动器启动 Memory test：内存测试 10、跳过检查 使用Tab键选择Skip，Enter回车确认 检查安装盘是否完整。一般不用检查，如果点击OK，比较耗时 11、欢迎界面 12、选择语言环境，选择简体中文 13、选择键盘类型（默认） 14、选择存储设备 选择基本存储设备（默认） 扩展：存储设备解释 基本存储设备：作为安装空间的默认选择，适合哪些不知道应该选择哪个存储设备的用户 指定的存储设备：需要用户将系统安装指定到特定的存储设备上，可以是本地某个设备，当然也可以是SAN(存储局域网)。通过允许用户添加FCoE/iSCSI/zFCP磁盘，并且能够过滤掉安装程序应该忽略的设备 15、格式化硬盘 选择是，忽略所有数据 16、设置网络（默认） 17、设置时区（默认） 默认选择亚洲/上海 18、设置密码 Linux中根账号为root，因为是在虚拟机中安装用于自己操作学习，密码设置简单易记比较好，这里设置的是123456 密码设置要求 至少六位数 脆弱密码警告并非强制 19、磁盘分区配置 19.1、选择安装类型 可选使用所有空间 扩展：各种配置解释 使用所有空间（Use All Space ）：删除您硬盘上的所有分区（这包括如Windows的NTFS分区VFAT或其他操作系统创建的分区） 替换现有的Linux系统（Replace Existing Linux System）：以消除先前的Linux安装创建的分区。 这不会删除其他分区（如VFAT或FAT32分区），你可能对您的硬盘驱动器 缩小现有系统（Shrink Current System）：调整当前分区 使用剩余空间（Use Free Space）：保留您当前的数据和分区并安装在未使用的存储驱动器上。注意：必须保证有足够的可用空间 创建自定义布局（Create Custom Layout）： 手动存储设备进行分区并创建自定义布局 19.2、格式化，选择将修改写入磁盘 20、选择系统安装类型 选择Basic Server 扩展：各类型解释 Desktop：基本的桌面系统，包括常用的桌面软件，如文档查看工具 Minimal Desktop：基本的桌面系统，包含的软件更少 Minimal：基本的系统，不含有任何可选的软件包 Basic Server：安装的基本系统的平台支持，不包含桌面 Database Server：基本系统平台，加上MySQL和PostgreSQL数据库，无桌面 Web Server：基本系统平台，加上PHP，Web server，还有MySQL和PostgreSQL数据库的客户端，无桌面 Virtual Host：基本系统加虚拟平台 Software Development Workstation：包含软件包较多，基本系统，虚拟化平台，桌面环境，开发工具 21、安装 安装开始 安装中 安装完成，点击重新引导重启系统 22、登录 输入用户名回车输入密码回车(注意Linux中输入的密码是看不见的) 登录成功 至此，VMware安装CentOS大功告成 ★,°:.☆(￣▽￣)/$:.°★","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.xiongtianci.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xiongtianci.com/tags/CentOS/"},{"name":"VMware","slug":"VMware","permalink":"https://blog.xiongtianci.com/tags/VMware/"}],"author":"天赐"},{"title":"如何设置win10的视觉效果","slug":"如何设置win10的视觉效果","date":"2020-06-29T02:21:56.000Z","updated":"2025-10-26T01:54:50.758Z","comments":true,"path":"2020/06/29/如何设置win10的视觉效果/","link":"","permalink":"https://blog.xiongtianci.com/2020/06/29/如何设置win10的视觉效果/","excerpt":"","text":"1、在此电脑上右键，选择属性： 2、依次选择：高级系统设置 -&gt; 高级 -&gt; 在性能下点击设置： 3、在视觉效果选项卡下进行设置：","categories":[{"name":"操作","slug":"操作","permalink":"https://blog.xiongtianci.com/categories/操作/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"}],"author":"天赐"},{"title":"隐藏win10资源管理器中显示的「DVD驱动器」","slug":"隐藏win10资源管理器中显示的「DVD驱动器」","date":"2020-06-16T06:38:24.000Z","updated":"2025-10-26T01:45:42.722Z","comments":true,"path":"2020/06/16/隐藏win10资源管理器中显示的「DVD驱动器」/","link":"","permalink":"https://blog.xiongtianci.com/2020/06/16/隐藏win10资源管理器中显示的「DVD驱动器」/","excerpt":"","text":"问题在win10中安装Microsoft系列软件后可能在资源管理器中显示一个DVD 驱动器： 解决1、在桌面左下角win徽标上右键选择计算机管理： 2、依次选择设备管理器 -&gt; DVD/CD-ROM驱动器 -&gt; Microsoft虚拟DVD-ROM，在Microsoft虚拟DVD-ROM上右键选择卸载设备： 3、确认卸载： 4、重新打开资源管理器即可解决","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win","slug":"win","permalink":"https://blog.xiongtianci.com/tags/win/"}],"author":"天赐"},{"title":"关闭win10安全警告「你要允许来自未知发布者的此应用对你的设备进行更改」","slug":"关闭win10安全警告「你要允许来自未知发布者的此应用对你的设备进行更改」","date":"2020-06-13T04:10:43.000Z","updated":"2025-10-26T01:45:42.687Z","comments":true,"path":"2020/06/13/关闭win10安全警告「你要允许来自未知发布者的此应用对你的设备进行更改」/","link":"","permalink":"https://blog.xiongtianci.com/2020/06/13/关闭win10安全警告「你要允许来自未知发布者的此应用对你的设备进行更改」/","excerpt":"","text":"问题win10在安装软件时弹出安全警告你要允许来自未知发布者的此应用对你的设备进行更改?： 解决在此电脑上右键选择属性： 选择安全和维护： 选择更改用户账户控制设置： 将左侧蓝色小块拉至最下面的从不通知，点击确定： 选择是即可关闭安全警告：","categories":[],"tags":[],"author":"天赐"},{"title":"远程桌面连接出错「用户账户限制会阻止你登录...」","slug":"远程桌面连接出错「用户账户限制会阻止你登录-」","date":"2020-06-13T02:37:48.000Z","updated":"2025-10-26T01:45:42.705Z","comments":true,"path":"2020/06/13/远程桌面连接出错「用户账户限制会阻止你登录-」/","link":"","permalink":"https://blog.xiongtianci.com/2020/06/13/远程桌面连接出错「用户账户限制会阻止你登录-」/","excerpt":"","text":"问题在win10中使用远程桌面连接时出现用户账户限制(例如，时间限制)会阻止你登录...的错误问题： 这是由于远程系统的用户密码为空，且默认只允许空白密码的本地账户进行控制台登录 解决在远程系统中使用win徽标+R输入secpol.msc回车： 在弹出窗口的左侧依次选择本地策略 -&gt; 安全选项，在右侧选中帐户: 使用空白密码的本地帐户只允许进行控制台登录双击进行编辑： 选择已禁用，点击确认即可解决问题","categories":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/categories/win10/"}],"tags":[{"name":"系统","slug":"系统","permalink":"https://blog.xiongtianci.com/tags/系统/"}],"author":"天赐"},{"title":"VMware安装win10填过的坑","slug":"VMware安装win10填过的坑","date":"2020-05-03T23:49:46.000Z","updated":"2025-10-26T01:45:42.670Z","comments":true,"path":"2020/05/04/VMware安装win10填过的坑/","link":"","permalink":"https://blog.xiongtianci.com/2020/05/04/VMware安装win10填过的坑/","excerpt":"","text":"环境： 本地系统：Windows10_1909_x64VMware：15.5.2 1.使用VMware12安装问题：使用VMware12安装win10会出现错误页面Your PC ran into a problem and needs to restart.We&#39;ll restart for you，错误代码KMODE EXCEPTION NOT HANDLED，然后不断地重启报错。 网上的说法是VMware12对此版win10的显卡不支持，换用VMware14/15进行安装 2.此主机不支持64位…问题：新建虚拟机过程中报错此主机不支持64位客户机操作系统，此系统无法运行。： 忽略它点击下一步新建好虚拟机后，在开启此虚拟机时就会报如下错误： 原因：Windows10开启Hyper-V后与VMware Workstation冲突导致无法运行和新建虚拟机。但是本地电脑程序和功能中并没有开启Hyper-V： 解决： 1、在本地电脑桌面左下角win徽标上右键 -&gt; Windows PowerShell(管理员)(A) 2、输入命令bcdedit /set hypervisorlaunchtype off回车 3、重启电脑 PS：如果要重新开启Hyper-V，只需执行bcdedit /set hypervisorlaunchtype auto命令并重启电脑即可 3.出现Boot Manager问题：点击开启此虚拟机后在运行界面出现Boot Manager： 解决：要重新新建虚拟机，在新建虚拟机向导页面中选择Windows版本时需选择Windows 10而不能选择Windows 10 x64： 参考：1.Stop code: KMODE EXCEPTION NOT HANDLED、2.vmware 和 hyper-v不兼容、3.VMware14 虚拟机装win10 系统出现 BootManager","categories":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/categories/软件/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"https://blog.xiongtianci.com/tags/VMware/"}],"author":"天赐"},{"title":"Google涂鸦游戏-Coding for Carrots","slug":"Google涂鸦游戏-Coding for Carrots","date":"2020-04-27T11:26:54.000Z","updated":"2025-10-26T01:45:42.652Z","comments":true,"path":"2020/04/27/Google涂鸦游戏-Coding for Carrots/","link":"","permalink":"https://blog.xiongtianci.com/2020/04/27/Google涂鸦游戏-Coding for Carrots/","excerpt":"","text":"今天（2020.04.27）的谷歌涂鸦： Doodle名称: Stay and Play at Home with Popular Past Google Doodles: Coding (2017)展示日期: 2020.04.27展示地区：全球所有国家Doodle的关键字: 风靡一时的 Google 涂鸦游戏Doodle图像的链接: http://www.google.com/logos/doodles/2020/stay-and-play-at-home-with-popular-past-google-doodles-coding-2017-6753651837108765-law.gif 点击进去是庆祝《Kids Coding（少儿编程）》问世 50 周年的编程游戏，挺有趣的 游戏入口：https://www.google.com/doodles/celebrating-50-years-of-kids-coding 这个游戏总共有6关，每关需选择下方模块让下兔子吃掉全部的胡萝卜，其中用到模块的个数最少为最优方案。1~4挺简单的，5关稍作尝试也可以选出最优方案，第6关实际上挺难的。最后2关，都是只需要6个模块就能通关。 以下是第5、6关的解决方案。解决方案不止一种，以下仅供参考： 第5关 第6关","categories":[],"tags":[],"author":"天赐"},{"title":"Chrome播放视频时只有声音没有画面","slug":"Chrome播放视频时只有声音没有画面","date":"2020-04-19T09:43:04.000Z","updated":"2025-10-26T01:45:42.634Z","comments":true,"path":"2020/04/19/Chrome播放视频时只有声音没有画面/","link":"","permalink":"https://blog.xiongtianci.com/2020/04/19/Chrome播放视频时只有声音没有画面/","excerpt":"","text":"问题win7下Chrome在线播放视频时只有声音，没有画面 解决打开Chrome，点击右上角菜单，选择设置 -&gt; 高级 -&gt; 系统，取消使用硬件加速模式（如果可用）： 重启Chrome即可 另如果Chrome所有页面全部黑屏，原因应该是因为显卡驱动没有支持新版本Chrome的GPU加速，此时需要通过命令行关闭Chrome浏览器的GPU加速 1、找到Chrome安装目录，默认是在C:\\Program Files (x86)\\Google\\Chrome\\Application目录下打开黑窗口 2、输入命令：chrome.exe -disable-gpu可暂时关闭GPU加速打开Chrome 3、然后在Chrome菜单中选择设置 -&gt; 高级 -&gt; 系统，取消使用硬件加速模式（如果可用）4、重启Chrome即可","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/categories/踩坑/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.xiongtianci.com/tags/Chrome/"},{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"}],"author":"天赐"},{"title":"安装VMware时警告此产品安装程序不支持降级","slug":"安装VMware时警告此产品安装程序不支持降级","date":"2020-04-18T06:22:22.000Z","updated":"2025-10-26T01:45:42.618Z","comments":true,"path":"2020/04/18/安装VMware时警告此产品安装程序不支持降级/","link":"","permalink":"https://blog.xiongtianci.com/2020/04/18/安装VMware时警告此产品安装程序不支持降级/","excerpt":"","text":"问题在卸载VMware15后重新安装VMware12时报错： 解决下载Windows Installer Clean Up： 链接 解压密码 Windows Installer Clean Up xiongtianci.com 以管理员身份进行安装，默认安装路径为C:\\Program Files (x86)\\Windows Installer Clean Up，以管理员身份运行msicuu.exe 选中带VMware字样的的程序，然后点击Remove： 最后重启电脑，再安装VMware时就不会警告了","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/categories/踩坑/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"},{"name":"VMware","slug":"VMware","permalink":"https://blog.xiongtianci.com/tags/VMware/"}],"author":"天赐"},{"title":"win10关机时提示需要结束程序","slug":"win10关机时提示需要结束程序","date":"2020-04-13T00:41:04.000Z","updated":"2025-10-26T01:45:42.600Z","comments":true,"path":"2020/04/13/win10关机时提示需要结束程序/","link":"","permalink":"https://blog.xiongtianci.com/2020/04/13/win10关机时提示需要结束程序/","excerpt":"","text":"问题win10系统关机时被提示需要结束程序： 解决1、按下win徽标+R，输入gpedit.msc回车 2、选择计算机配置 -&gt; 管理模块 -&gt; 系统 -&gt; 关机选项 3、右键关闭会阻止或取消关机的应用程序的自动终止功能，选择编辑 4、选择已禁用，然后点击确定即可","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"}],"author":"天赐"},{"title":"IDEA2019.3在Plugins中搜索不到translation","slug":"IDEA2019-3在Plugins中搜索不到translation","date":"2020-04-05T07:44:56.000Z","updated":"2025-10-26T01:45:42.584Z","comments":true,"path":"2020/04/05/IDEA2019-3在Plugins中搜索不到translation/","link":"","permalink":"https://blog.xiongtianci.com/2020/04/05/IDEA2019-3在Plugins中搜索不到translation/","excerpt":"","text":"问题今天安装了IDEA2019.03版本，在安装插件时搜索不到插件： 解决点击右上角的齿轮选择HTTP Proxy Settings... 勾选上第二项Auto-detect proxy settings 点击OK，然后关闭IDEA设置页后重新打开设置页搜索Translation即可","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"禁用win10自动更新","slug":"禁用win10自动更新","date":"2020-04-04T01:49:12.000Z","updated":"2025-10-26T01:45:42.566Z","comments":true,"path":"2020/04/04/禁用win10自动更新/","link":"","permalink":"https://blog.xiongtianci.com/2020/04/04/禁用win10自动更新/","excerpt":"","text":"本方法还在测试中，不确定是否适用于不同品牌的电脑 电脑：Dell Inspiron系统：Window10_x64_1909测试时间：2020.04.04 下载工具： 链接 提取码 关闭或禁用windows自动更新工具 win10 下载后右键以管理员身份打开： 点击关闭Windows更新，然后重启电脑即可生效","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"}],"author":"天赐"},{"title":"Git修改已提交的commit注释","slug":"Git修改已提交的commit注释","date":"2019-11-12T01:34:11.000Z","updated":"2025-10-26T01:45:42.549Z","comments":true,"path":"2019/11/12/Git修改已提交的commit注释/","link":"","permalink":"https://blog.xiongtianci.com/2019/11/12/Git修改已提交的commit注释/","excerpt":"","text":"1、修改commit注释1.1、修改最后一次commit注释通过git log查看提交历史信息： 输入命令： git commit --amend 进入修改注释界面： 第一行就是最后一次commit的注释信息，按i键进行编辑状态，修改注释信息后按Esc后再按:wq保存并退出 再次通过git log查看，注释信息由add test.txt修改为新增test.txt： 1.2、修改多次commit注释命令： # n：需要修改的最近n此commit git rebase -i HEAD~n 比如我想要修改最近3次注释信息就使用git rebase -i HEAD~3，显示下面内容： 这上面一行就是一次commit历史，按照提交的顺序进行排序，最下面的一行为最后一次commit 按i进行编辑，需要修改那个注释，就将其前面的pick修改为edit： 上面为修改第1行和第3行的注释信息 然后按Esc后再按:wq保存并退出 此时输入一下命令编辑第1条commit注释： git commit --amend 编辑注释信息(按i进入编辑状态，按Esc和:wq保存并退出)，此时分支变为master|REBASE-i 1/3；再输入下面信息进行保存： git rebase --continue 此时分支变为master|REBASE-i 3/3，现在只修改完第1条commit 再通过git commit --amend和git rebase --continue修改第3条后分支状态变回master并提示Successfully rebased and updated refs/heads/master.说明已修改完成 2、提交到远程仓库# 强制更新到远程仓库 git push -f remote branch","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.xiongtianci.com/tags/Git/"}],"author":"天赐"},{"title":"解决IDEA中安装CodeGlance插件后不起作用问题","slug":"解决IDEA中安装CodeGlance插件后不起作用问题","date":"2019-11-11T13:44:20.000Z","updated":"2025-10-26T01:45:42.532Z","comments":true,"path":"2019/11/11/解决IDEA中安装CodeGlance插件后不起作用问题/","link":"","permalink":"https://blog.xiongtianci.com/2019/11/11/解决IDEA中安装CodeGlance插件后不起作用问题/","excerpt":"","text":"问题IDEA安装CodeGlance插件后不起作用 解决一、查看IDEA中是否已安装了CodeGlance Ctrl+Alt+S -&gt; Plugins -&gt; 搜索CodeGlance 二、Settings -&gt; 搜索CodeGlance -&gt; 取消勾选Disabled -&gt; 点击OK","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"},{"name":"CodeGlance","slug":"CodeGlance","permalink":"https://blog.xiongtianci.com/tags/CodeGlance/"}],"author":"天赐"},{"title":"Linux中使用vim编辑文件时报错E325:ATTETION","slug":"Linux中使用vim编辑文件时报错E325-ATTETION","date":"2019-11-09T05:34:22.000Z","updated":"2025-10-26T01:45:42.515Z","comments":true,"path":"2019/11/09/Linux中使用vim编辑文件时报错E325-ATTETION/","link":"","permalink":"https://blog.xiongtianci.com/2019/11/09/Linux中使用vim编辑文件时报错E325-ATTETION/","excerpt":"","text":"在CentOS下使用vim编辑文件时出现E325：ATTENTION的警告。 这是由于在编辑该文件的时候异常退出了，因为vim在编辑文件时会创建一个交换文件swap file以保证文件的安全性。 删除这个swp文件即可去除警告 # 查看此目录下全部文件，找到swp文件 ls -a # 删除此swp文件即可 rm -rf 文件.swp","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"天赐"},{"title":"查看IDEA中已安装的plugin插件","slug":"查看IDEA中已安装的plugin插件","date":"2019-11-03T07:40:04.000Z","updated":"2025-10-26T01:45:42.498Z","comments":true,"path":"2019/11/03/查看IDEA中已安装的plugin插件/","link":"","permalink":"https://blog.xiongtianci.com/2019/11/03/查看IDEA中已安装的plugin插件/","excerpt":"","text":"Settings -&gt; Plugins -&gt; 在Show下拉框中选中Custom：","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"使用git.io设置GitHub项目的短链接","slug":"使用git-io设置GitHub项目的短链接","date":"2019-11-02T12:27:07.000Z","updated":"2025-10-26T01:45:42.447Z","comments":true,"path":"2019/11/02/使用git-io设置GitHub项目的短链接/","link":"","permalink":"https://blog.xiongtianci.com/2019/11/02/使用git-io设置GitHub项目的短链接/","excerpt":"","text":"工具： 在桌面或目录中右键 -&gt; Git Bash Here 输入命令： # url为github项目地址 # code为短链码 curl -i https://git.io -F url=&quot;https://github.com/tiancixiong&quot; -F &quot;code=tianci&quot; 访问地址：https://git.io/tianci 一个url只能对应一个code，如果你想多个code，那就在url上加参数： curl -i https://git.io -F url=&quot;https://github.com/tiancixiong?v=1&quot; -F &quot;code=xiong&quot; 访问地址：https://git.io/xiong 如果出现&quot;XXX&quot; already is表明此短链已被抢先注册：","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"天赐"},{"title":"启动项目报错：The Tomcat connector configured to listen on port 8080 failed to start.","slug":"启动项目报错：The-Tomcat-connector-configured-to-listen-on-port-8080-failed-to-start","date":"2019-11-02T09:37:36.000Z","updated":"2025-10-26T01:45:42.481Z","comments":true,"path":"2019/11/02/启动项目报错：The-Tomcat-connector-configured-to-listen-on-port-8080-failed-to-start/","link":"","permalink":"https://blog.xiongtianci.com/2019/11/02/启动项目报错：The-Tomcat-connector-configured-to-listen-on-port-8080-failed-to-start/","excerpt":"","text":"启动SpringBoot项目，报错： org.apache.catalina.LifecycleException: Failed to start component [Connector[HTTP/1.1-8080]] .... Caused by: org.apache.catalina.LifecycleException: Protocol handler start failed .... Caused by: java.net.BindException: Address already in use: bind .... 错误描述： The Tomcat connector configured to listen on port 8080 failed to start. The port may already be in use or the connector may be misconfigured. 意思就是说8080端口一直被占用着，从而无法启动项目。此时很懵啊，因为本地并没有其他项目跑着… 解决： cmd打开黑窗口，输入下面指令显示所有端口和PID进程ID netstat -ano 找到8080端口对应的PID，通过tasklist指令找到对应的进程 tasklist | findstr &quot;7676&quot; 通过杀死此进程 taskkill /f /t /im java.exe 转载：https://blog.csdn.net/q343509740/article/details/80821409","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"天赐"},{"title":"使用Postman测试上传图片接口报错：the request was rejected because no multipart boundary was found","slug":"使用Postman测试上传图片接口报错：the-request-was-rejected-because-no-multipart-boundary-was-found","date":"2019-11-02T08:54:56.000Z","updated":"2025-10-26T01:45:42.463Z","comments":true,"path":"2019/11/02/使用Postman测试上传图片接口报错：the-request-was-rejected-because-no-multipart-boundary-was-found/","link":"","permalink":"https://blog.xiongtianci.com/2019/11/02/使用Postman测试上传图片接口报错：the-request-was-rejected-because-no-multipart-boundary-was-found/","excerpt":"","text":"问题使用Postman测试上传接口，如下： 请求，报错： org.apache.tomcat.util.http.fileupload.FileUploadException: the request was rejected because no multipart boundary was found at org.apache.tomcat.util.http.fileupload.FileUploadBase$FileItemIteratorImpl.&lt;init&gt;(FileUploadBase.java:831) ~[tomcat-embed-core-8.5.29.jar:8.5.29] at org.apache.tomcat.util.http.fileupload.FileUploadBase.getItemIterator(FileUploadBase.java:256) ~[tomcat-embed-core-8.5.29.jar:8.5.29] at org.apache.tomcat.util.http.fileupload.FileUploadBase.parseRequest(FileUploadBase.java:280) ~[tomcat-embed-core-8.5.29.jar:8.5.29] at org.apache.catalina.connector.Request.parseParts(Request.java:2868) ~[tomcat-embed-core-8.5.29.jar:8.5.29] ... 解决出现这个的原因是因为Postman会自动加上Content-Type:multipart/form-data这对请求头信息，不需要我们手动添加，将其删除即可：","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"天赐"},{"title":"解决IDEA中Vue项目出现红色波浪线问题","slug":"解决IDEA中Vue项目出现红色波浪线问题","date":"2019-11-01T12:56:20.000Z","updated":"2025-10-26T01:45:42.429Z","comments":true,"path":"2019/11/01/解决IDEA中Vue项目出现红色波浪线问题/","link":"","permalink":"https://blog.xiongtianci.com/2019/11/01/解决IDEA中Vue项目出现红色波浪线问题/","excerpt":"","text":"File -&gt; Settings… -&gt; Languages &amp; Frameworks -&gt; JavaScript -&gt; 选择ECMAScript6 -&gt; 点击OK","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"天赐"},{"title":"有趣的网站","slug":"有趣的网站","date":"2019-09-16T13:06:29.000Z","updated":"2025-10-26T01:45:42.412Z","comments":true,"path":"2019/09/16/有趣的网站/","link":"","permalink":"https://blog.xiongtianci.com/2019/09/16/有趣的网站/","excerpt":"","text":"分享一些有趣的网站持续更新中…. 小游戏 Chrome街机游戏(小恐龙) 就是进去后会是下面内容（一般Chrome浏览器在未连接互联网状态也会呈现），按空格键开始，按&uarr;键(或空格)进行跳，&darr;键进行蹲 Silk – Interactive Generative Art 可以随手画出对称的炫酷图案 Free online PDF Extractor 可以将PDF文件中的图片提取出来，PDF文件大小不能超过14M wikiHow 里面包含大量高质量的指导手册 AnywhereAnything 这个网站收录了非常多的精品网站 临时接受短信的手机号 十分钟邮箱、24小时邮箱 转换格式大全","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[],"author":"天赐"},{"title":"关闭QQ弹出的腾讯网迷你版","slug":"关闭QQ弹出的腾讯网迷你版","date":"2019-08-31T02:24:07.000Z","updated":"2025-10-26T01:45:42.395Z","comments":true,"path":"2019/08/31/关闭QQ弹出的腾讯网迷你版/","link":"","permalink":"https://blog.xiongtianci.com/2019/08/31/关闭QQ弹出的腾讯网迷你版/","excerpt":"","text":"前言每次打开PC端QQ后都会自动弹出腾讯网迷你版新闻： 下面是关闭的操作方法 操作打开PC端QQ，点击QQ主面板右下角的 主菜单 按钮，选择 设置 打开系统设置面板： 在系统设置面板中选择 权限设置 下的 资讯提醒，然后取消勾选 登录后显示“腾讯网迷你版” 即可","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"}],"author":"天赐"},{"title":"关于int和Integer之间的装箱机制问题","slug":"关于int和Integer之间的装箱机制问题","date":"2019-08-02T02:20:26.000Z","updated":"2025-10-26T01:45:42.378Z","comments":true,"path":"2019/08/02/关于int和Integer之间的装箱机制问题/","link":"","permalink":"https://blog.xiongtianci.com/2019/08/02/关于int和Integer之间的装箱机制问题/","excerpt":"","text":"装箱/拆箱机制Integer是int的包装类就是，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型 包装类型 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean public class AutoUnboxingTest { public static void main(String[] args) { int a = 1; Integer b = a; // int 类型的1自动装箱成 Integer 类型 Integer c = new Integer(1); System.out.println(b == a); // true -&gt; b自动拆箱成 int 类型再和c比较 System.out.println(c == b); // false-&gt; 两个引用没有指向同一对象 } } 装箱本质 Integer.valueOf()先看个例题： public class Test01 { public static void main(String[] args) { Integer i1 = 100, i2 = 100, i3 = 150, i4 = 150; System.out.println(i1 == i2); // true System.out.println(i3 == i4); // false } } i1、i2、i3、i4都是Integer对象引用，==比较的是引用而不是值 当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，下面我们来看看 valueOf 方法 // 源码 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } IntegerCache是Integer的内部类 /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 从上面可看出，在范围 -128 &le; i &le;127 之内的数值不会使用new创建新的Integer对象，直接引用常量池中的Integer对象；而超出这个范围将使用new创建新的Integer对象","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"面试","slug":"面试","permalink":"https://blog.xiongtianci.com/categories/面试/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.xiongtianci.com/tags/JavaSE/"}],"author":"天赐"},{"title":"IDEA中修改项目包结构后导包报错","slug":"IDEA中修改项目包结构后导包报错","date":"2019-07-28T12:44:32.000Z","updated":"2025-10-26T01:45:42.360Z","comments":true,"path":"2019/07/28/IDEA中修改项目包结构后导包报错/","link":"","permalink":"https://blog.xiongtianci.com/2019/07/28/IDEA中修改项目包结构后导包报错/","excerpt":"","text":"问题IDEA中修改项目的包结构后import导包无法正常引入 解决清除缓存： File -&gt; Invalidate Caches/Restart… -&gt; Invalidate and Restart","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"有趣的代码注释","slug":"有趣的代码注释","date":"2019-07-25T03:41:36.000Z","updated":"2025-10-26T01:45:42.344Z","comments":true,"path":"2019/07/25/有趣的代码注释/","link":"","permalink":"https://blog.xiongtianci.com/2019/07/25/有趣的代码注释/","excerpt":"","text":"作者：Blankj原链：https://github.com/Blankj/awesome-comment 神器的代码注释 写在前面的话：一时兴起就收集了以下神注释，希望能为广大ITer带来快乐，缓解你们工作中的压力，下面开车，先自爆头像，下文会给出制作链接。 /*** * 瓦瓦 十 * 十齱龠己 亅瓦車己 * 乙龍龠毋日丶 丶乙己毋毋丶 * 十龠馬鬼車瓦 己十瓦毋毋 * 鬼馬龠馬龠十 己己毋車毋瓦 * 毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己 * 乙龠龍龍鬼龍瓦 十瓦毋乙瓦龠瓦亅 * 馬齱龍馬鬼十丶日己己己毋車乙丶 * 己齱馬鬼車十十毋日乙己己乙乙 * 車馬齱齱日乙毋瓦己乙瓦日亅 * 亅車齺龖瓦乙車龖龍乙乙十 * 日龠龠十亅車龍毋十十 * 日毋己亅 己己十亅亅 * 丶己十十乙 丶丶丶丶丶 * 亅己十龍龖瓦 丶 丶 乙十 * 亅己十龠龖毋 丶丶 丶己鬼鬼瓦亅 * 十日十十日亅丶亅丶 丶十日毋鬼馬馬車乙 * 十日乙十亅亅亅丶 十乙己毋鬼鬼鬼龍齺馬乙 * 丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十 * 乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶 * 亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅 * 十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車 * 亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車 * 亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼 * 丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼 * 亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼 * 亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦 * 丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日 * 十乙己日十 丶己鬼龍齱齺齱龍馬馬馬車毋己 * 丶十己乙亅丶 亅瓦馬龠龍龠龠馬毋瓦乙 * 丶十十乙亅十 亅己瓦車馬龠鬼車瓦乙 * 丶十乙十十丶 丶丶亅十瓦鬼車瓦己 * 丶亅亅丶 亅日瓦日 * 丶 */ 就不卖关子了，图片转字符可以上这个传送门，白底的话会按空格补全，否则都为字符。 前面的传送门貌似出了点问题，下面再补上个新的传送门，也是很好用的，可以选择质量。 这不，下面的两只doge和一头滑稽就是产自于它，have fun，快去制作专属的字符注释吧。 再补上一个好玩的网站Ascii World，由于这网站的图形太多了，我就不贴上来了。 /*** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \\ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│&quot; &#39;│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ /*** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\\ = /O * ____/`---&#39;\\____ * . &#39; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| &#39;&#39;\\---/&#39;&#39; | | * \\ .-\\__ `-` ___/-. / * ___`. .&#39; /--.--\\ `. . __ * .&quot;&quot; &#39;&lt; `.___\\_&lt;|&gt;_/___.&#39; &gt;&#39;&quot;&quot;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-&#39;====== * `=---=&#39; * * ............................................. * 佛祖保佑 永无BUG */ /*** * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ */ /*** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\\ = /O * ___/`---&#39;\\____ * . &#39; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| &#39;&#39;\\---/&#39;&#39; | | * \\ .-\\__ `-` ___/-. / * ___`. .&#39; /--.--\\ `. . __ * .&quot;&quot; &#39;&lt; `.___\\_&lt;|&gt;_/___.&#39; &gt;&#39;&quot;&quot;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-&#39;====== * `=---=&#39; * ............................................. * 佛曰：bug泛滥，我已瘫痪！ */ /*** * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ */ /*** * .::::. * .::::::::. * ::::::::::: * ..:::::::::::&#39; * &#39;::::::::::::&#39; * .:::::::::: * &#39;::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::&#39; .:::. * ::::&#39; &#39;:::::&#39; .::::::::. * .::::&#39; :::: .:::::::&#39;::::. * .:::&#39; ::::: .:::::::::&#39; &#39;:::::. * .::&#39; :::::.:::::::::&#39; &#39;:::::. * .::&#39; ::::::::::::::&#39; ``::::. * ...::: ::::::::::::&#39; ``::. * ```` &#39;:. &#39;:::::::::&#39; ::::.. * &#39;.:::::&#39; &#39;:&#39;````.. */ /*** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! */ /*** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ &gt; &lt; │ * │ │ * │ ... ⌒ ... │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! */ /*** * ┌─┐ ┌─┐ + + * ┌──┘ ┴───────┘ ┴──┐++ * │ │ * │ ─── │++ + + + * ███████───███████ │+ * │ │+ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ + + * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ + + + + * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ + + + + * 神兽保佑 * 代码无BUG! */ /*** * ___====-_ _-====___ * _--^^^#####// \\\\#####^^^--_ * _-^##########// ( ) \\\\##########^-_ * -############// |\\^^/| \\\\############- * _/############// (@::@) \\\\############\\_ * /#############(( \\\\// ))#############\\ * -###############\\\\ (oo) //###############- * -#################\\\\ / VV \\ //#################- * -###################\\\\/ \\//###################- * _#/|##########/\\######( /\\ )######/\\##########|\\#_ * |/ |#/\\#/\\#/\\/ \\#/\\##\\ | | /##/\\#/ \\/\\#/\\#/\\#| \\| * ` |/ V V ` V \\#\\| | | |/#/ V &#39; V V \\| &#39; * ` ` ` ` / | | | | \\ &#39; &#39; &#39; &#39; * ( | | | | ) * __\\ | | | | /__ * (vvv(VVV)(VVV)vvv) * 神兽保佑 * 代码无BUG! */ /*** * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \\_|// |||\\\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \\/ ||| \\\\ _/~~- * __---~~~.==~||\\=_ -_--~/_-~|- |\\\\ \\\\ _/~ * _-~~ .=~ | \\\\-_ &#39;-~7 /- / || \\ / * .~ .~ | \\\\ -_ / /- / || \\ / * / ____ / | \\\\ ~-_/ /|- _/ .|| \\ / * |~~ ~~|--~~~~--_ \\ ~==-/ | \\~--===~~ .\\ * &#39; ~-| /| |-~\\~~ __--~~ * |-~~-_/ | | ~\\_ _-~ /\\ * / \\ \\__ \\/~ \\__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-&gt;/~ &#39;.|||&#39; -_| ~~-/ , . _|| * -_ ~\\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \\--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\\ * 神兽保佑 * 代码无BUG! */ /*** _ * _._ _..._ .-&#39;, _.._(`)) * &#39;-. ` &#39; /-._.-&#39; &#39;,/ * ) \\ &#39;. * / _ _ | \\ * | a a / | * \\ .-. ; * &#39;-(&#39;&#39; ).-&#39; ,&#39; ; * &#39;-; | .&#39; * \\ \\ / * | 7 .__ _.-\\ \\ * | | | ``/ /` / * /,_| | /,_/ / * /,_/ &#39;`-&#39; */ /*** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-&quot; &quot;-. | * * | / \\ | * * | _ | | _ | * * | ( \\ |, .-. .-. ,| / ) | * * | &gt; &quot;=._ | )(__/ \\__)( | _.=&quot; &lt; | * * | (_/&quot;=._&quot;=._ |/ /\\ \\| _.=&quot;_.=&quot;\\_) | * * | &quot;=._&quot;(_ ^^ _)&quot;_.=&quot; | * * | &quot;=\\__|IIIIII|__/=&quot; | * * | _.=&quot;| \\IIIIII/ |&quot;=._ | * * | _ _.=&quot;_.=&quot;\\ /&quot;=._&quot;=._ _ | * * | ( \\_.=&quot;_.=&quot; `--------` &quot;=._&quot;=._/ ) | * * | &gt; _.=&quot; &quot;=._ &lt; | * * | (_/ \\_) | * * | | * * &#39;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&#39; * * * * LASCIATE OGNI SPERANZA, VOI CH&#39;ENTRATE * ************************************************************** */ /*** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * 又看源码，看你妹妹呀！ */ /*** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ */ /*** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 */ /*** * d*##$. * zP&quot;&quot;&quot;&quot;&quot;$e. $&quot; $o * 4$ &#39;$ $&quot; $ * &#39;$ &#39;$ J$ $F * &#39;b $k $&gt; $ * $k $r J$ d$ * &#39;$ $ $&quot; $~ * &#39;$ &quot;$ &#39;$E $ * $ $L $&quot; $F ... * $. 4B $ $$$*&quot;&quot;&quot;*b * &#39;$ $. $$ $$ $F * &quot;$ R$ $F $&quot; $ * $k ?$ u* dF .$ * ^$. $$&quot; z$ u$$$$e * #$b $E.dW@e$&quot; ?$ * #$ .o$$# d$$$$c ?F * $ .d$$#&quot; . zo$&gt; #$r .uF * $L .u$*&quot; $&amp;$$$k .$$d$$F * $$&quot; &quot;&quot;^&quot;$$$P&quot;$P9$ * JP .o$$$$u:$P $$ * $ ..ue$&quot; &quot;&quot; $&quot; * d$ $F $ * $$ ....udE 4B * #$ &quot;&quot;&quot;&quot;` $r @$ * ^$L &#39;$ $F * RN 4N $ * *$b d$ * $$k $F * $$b $F * $&quot;&quot; $F * &#39;$ $ * $L $ * &#39;$ $ * $ $ */ /*** * ,----------------, ,---------, * ,-----------------------, ,&quot; ,&quot;| * ,&quot; ,&quot;| ,&quot; ,&quot; | * +-----------------------+ | ,&quot; ,&quot; | * | .-----------------. | | +---------+ | * | | | | | | -==----&#39;| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\\&gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ,&quot; * | `-----------------&#39; |,&quot; .;&#39;| |(((( | ,&quot; * +-----------------------+ ;; | | |,&quot; * /_)______________(_/ //&#39; | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \\,&quot;----------- * / ==ooooooooooooooo==.o. ooo= // ,`\\--{)B ,&quot; * /_==__==========__==_ooo__ooo=_/&#39; /___________,&quot; * */ 以上为魔性图 以下为神注释 /*** * 这个公司没有年终奖的,兄弟别指望了,也别来了,我准备辞职了 * 另外这个项目有很多*Bug* 你坚持不了多久的,拜拜! */ /*** * 1只羊 == one sheep * 2只羊 == two sheeps * 3只羊 == three sheeps * 4只羊 == four sheeps * 5只羊 == five sheeps * 6只羊 == six sheeps * 7只羊 == seven sheeps * 8只羊 == eight sheeps * 9只羊 == nine sheeps * 10只羊 == ten sheeps * 11只羊 == eleven sheeps * 12只羊 == twelve sheeps * 13只羊 == thirteen sheeps * 14只羊 == fourteen sheeps * 15只羊 == fifteen sheeps * 16只羊 == sixteen sheeps * 17只羊 == seventeen sheeps * 18只羊 == eighteen sheeps * 19只羊 == nineteen sheeps * 20只羊 == twenty sheeps * 21只羊 == twenty one sheeps * 22只羊 == twenty two sheeps * 23只羊 == twenty three sheeps * 24只羊 == twenty four sheeps * 25只羊 == twenty five sheeps * 26只羊 == twenty six sheeps * 27只羊 == twenty seven sheeps * 28只羊 == twenty eight sheeps * 29只羊 == twenty nine sheeps * 30只羊 == thirty sheeps * 现在瞌睡了吧，好了，不要再改下面的代码了，睡觉咯~~ */ /*** * You may think you know what the following code does. * But you dont. Trust me. * Fiddle with it, and youll spend many a sleepless * night cursing the moment you thought youd be clever * enough to &quot;optimize&quot; the code below. * Now close this file and go play with something else. */ /*** * 你可能会认为你读得懂以下的代码。但是你不会懂的，相信我吧。 * 要是你尝试玩弄这段代码的话，你将会在无尽的通宵中不断地咒骂自己为什么会认为自己聪明到可以优化这段代码。 * 现在请关闭这个文件去玩点别的吧。 */ /*** * somedev1 - 6/7/02 Adding temporary tracking of Login screen * somedev2 - 5/22/07 Temporary my ass */ /*** * 一些修改1 - 2002/6/7 增加临时的跟踪登录界面 * 一些修改2 - 2007/5/22 我临时的犯傻 */ /*** * 程序员1（于2010年6月7日）：在这个坑临时加入一些调料 * 程序员2（于2011年5月22日）：临你个屁啊 * 程序员3（于2012年7月23日）：楼上都是狗屎，鉴定完毕 * 程序员4（于2013年8月2日）：fuck 楼上，三年了，这坑还在！！！ * 程序员5（于2014年8月21日）：哈哈哈，这坑居然坑了这么多人，幸好我也不用填了，系统终止运行了，you&#39;re died */ /*** * For the brave souls who get this far: You are the chosen ones, * the valiant knights of programming who toil away, without rest, * fixing our most awful code. To you, true saviors, kings of men, * I say this: never gonna give you up, never gonna let you down, * never gonna run around and desert you. Never gonna make you cry, * never gonna say goodbye. Never gonna tell a lie and hurt you. */ /*** * 致终于来到这里的勇敢的人： * 你是被上帝选中的人，是英勇的、不敌辛苦的、不眠不休的来修改我们这最棘手的代码的编程骑士。 * 你，我们的救世主，人中之龙，我要对你说：永远不要放弃，永远不要对自己失望，永远不要逃走，辜负了自己， * 永远不要哭啼，永远不要说再见，永远不要说谎来伤害自己。 */ /*** * Dear maintainer: * * Once you are done trying to &#39;optimize&#39; this routine, * and have realized what a terrible mistake that was, * please increment the following counter as a warning * to the next guy: * * total_hours_wasted_here = 42 */ /*** * 亲爱的维护者： * * 如果你尝试了对这段程序进行&#39;优化&#39; * 下面这个计数器的个数用来对后来人进行警告 * * 浪费在这里的总时间 = 42h */ Exception up = new Exception(&quot;Something is really wrong.&quot;); throw up; //ha ha /*** * When I wrote this, only God and I understood what I was doing * Now, God only knows */ /*** * 写这段代码的时候，只有上帝和我知道它是干嘛的 * 现在，只有上帝知道 */ stop(); // Hammertime! // Autogenerated, do not edit. All changes will be undone. // sometimes I believe compiler ignores all my comments // 有时候我相信编译器忽略了我所有的注释 /*** * I dedicate all this code, all my work, to my wife, Darlene, who will * have to support me and our three children and the dog once it gets * released into the public. */ // drunk, fix later // 有点晕了，以后再修改 // Magic. Do not touch. // 麻鸡。勿动。 #define TRUE FALSE// Happy debugging suckers // I&#39;m sorry. return 1; # returns 1 /*** * Always returns true. */ public boolean isAvailable() { return false; } &lt;!-- Here be dragons --&gt; &lt;!-- 前方高能 --&gt; double penetration; // ouch // 自行了解，不方便解释 /////////////////////////////////////// this is a well commented line // To understand recursion, see the bottom of this file At the bottom of the file: // To understand recursion, see the top of this file // 想要明白递归须看文件末尾 到了文末 // 想要明白递归须看文件顶部 /* Please work */ long long ago; /* in a galaxy far far away */ // 很久很久以前 在一个遥远的银河中（出自星球大战） // This code sucks, you know it and I know it. // Move on and call me an idiot later. // 你我都知道这代码很烂 // 先不要骂我2B了，请先继续往下看 // I am not sure why this works but it fixes the problem. // 虽然我不知道为什么这样管用，但它却是修复了问题 // If this comment is removed the program will blow up // 如果删了此处注释程序就炸了 // This function has been here since 1987. DON&#39;T FXXKING TOUCH IT // 这函数1987年就这在了，别他娘动它 // if i ever see this again i&#39;m going to start bringing guns to work // 如果要是再让我看见这样的代码，也许我会带着一把枪来上班 // no comments for you // it was hard to write // so it should be hard to read // 难写的代码，肯定很难读。因此，我没有注释留给你。 // I will give you two of my seventy-two virgins if you can fix this. // 要是你能修正这个问题的话，我会在我的七十二个处女中挑两个送你 // I am not responsible of this code. // They made me write it, against my will. // 下面的代码，我不负责。因为是他们逼我写的，违背了我的意愿。 /* You are not expected to understand this */ /* 你绝不会明白的 */ // I have to find a better job // 看来我需要找份更好的工作了 /*** * 这个类是Object的子类 */ 如果有更好地可以留言或者到传送门提issue，如果看到这能带给你快乐的话，那就点个稀饭吧，谢谢大佬们赏脸，愿所有的程序都永无Bug。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://blog.xiongtianci.com/tags/转载/"},{"name":"注释","slug":"注释","permalink":"https://blog.xiongtianci.com/tags/注释/"}],"author":"天赐"},{"title":"解决.gitignore过滤规则不起作用问题","slug":"解决.gitignore过滤规则不起作用问题","date":"2019-07-22T02:56:37.000Z","updated":"2025-10-26T01:45:42.326Z","comments":true,"path":"2019/07/22/解决.gitignore过滤规则不起作用问题/","link":"","permalink":"https://blog.xiongtianci.com/2019/07/22/解决.gitignore过滤规则不起作用问题/","excerpt":"","text":"问题在Git使用.gitignore进行过滤时不起作用 解决# 从索引中移除所有文件，但不会删除工作区的文件 git rm -r --cached . # 重新add git add -A 如果出现：use -f to force removal，则使用git rm -rf --cached .","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"},{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"},{"name":"Git","slug":"Git","permalink":"https://blog.xiongtianci.com/tags/Git/"}],"author":"天赐"},{"title":"解决IDEA中@Autowired抛红问题","slug":"解决IDEA中-Autowired抛红问题","date":"2019-07-16T09:42:03.000Z","updated":"2025-10-26T01:45:42.311Z","comments":true,"path":"2019/07/16/解决IDEA中-Autowired抛红问题/","link":"","permalink":"https://blog.xiongtianci.com/2019/07/16/解决IDEA中-Autowired抛红问题/","excerpt":"","text":"问题在IDEA中通过@Autowired注入时在变量名下方一直有红色的标记线进行提示 解决 在IDEA中：File -&gt; Settings 打开设置页面 搜索inspections -&gt; 搜索autowiring -&gt; Autowiring for Bean Class -&gt; 将Error修改为Warning -&gt; 点击OK","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"}],"author":"天赐"},{"title":"win10永久数字权利激活工具","slug":"win10永久数字权利激活工具","date":"2019-07-06T02:16:02.000Z","updated":"2025-10-26T01:45:42.292Z","comments":true,"path":"2019/07/06/win10永久数字权利激活工具/","link":"","permalink":"https://blog.xiongtianci.com/2019/07/06/win10永久数字权利激活工具/","excerpt":"","text":"前言win10查看激活到期时间：win徽标+R -&gt; 输入slmgr.vbs -xpr回车，等待几秒会出现显示win到期时间的弹框 操作1、查看永久激活前电脑过期时间： 2、下载激活工具 链接 解压密码 win10永久激活工具 xiongtianci.com 3、打开DigitalLicense.exe激活软件，软件会自动识别你的系统，如果没有识别成功就在界面上部分右键-&gt;选择密钥，然后选择你系统对应的版本即可 4、点击激活，控制台日志中出现成功地激活了产品字样就表示激活成功 5、查看激活到期时间，显示计算机已永久激活","categories":[{"name":"资源","slug":"资源","permalink":"https://blog.xiongtianci.com/categories/资源/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"},{"name":"激活","slug":"激活","permalink":"https://blog.xiongtianci.com/tags/激活/"}],"author":"天赐"},{"title":"win10日语输入法输入罗马字母n无法打出假名","slug":"win10日语输入法输入罗马字母n无法打出假名","date":"2019-07-03T06:27:05.000Z","updated":"2025-10-26T01:45:42.276Z","comments":true,"path":"2019/07/03/win10日语输入法输入罗马字母n无法打出假名/","link":"","permalink":"https://blog.xiongtianci.com/2019/07/03/win10日语输入法输入罗马字母n无法打出假名/","excerpt":"","text":"问题使用win10输入法输入罗马字母n时，打出的结果为： 解决连续按两下n就可以打出ん或ン了另：在有些情况输入一个n后直接输入打下一个假名，ん或ン也会随之显示出来","categories":[{"name":"日语","slug":"日语","permalink":"https://blog.xiongtianci.com/categories/日语/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"},{"name":"日语","slug":"日语","permalink":"https://blog.xiongtianci.com/tags/日语/"}],"author":"天赐"},{"title":"win10日语输入法罗马音与假名不对应","slug":"win10日语输入法罗马音与假名不对应","date":"2019-07-03T03:15:29.000Z","updated":"2025-10-26T01:44:38.866Z","comments":true,"path":"2019/07/03/win10日语输入法罗马音与假名不对应/","link":"","permalink":"https://blog.xiongtianci.com/2019/07/03/win10日语输入法罗马音与假名不对应/","excerpt":"","text":"问题win10中使用日语输入法时，输入罗马音a，打出的却是ち，输入其他罗马音也是这种情况出现这种情况是因为你无意中输入方式设置成了假名输入，我们需要改成罗马字输入 解决在win10任务栏中的日语图标上：右键 -&gt; Input Method -&gt; 勾选Romaji Input 参考 https://zhidao.baidu.com/question/151047919.html","categories":[{"name":"日语","slug":"日语","permalink":"https://blog.xiongtianci.com/categories/日语/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"},{"name":"日语","slug":"日语","permalink":"https://blog.xiongtianci.com/tags/日语/"}],"author":"天赐"},{"title":"重置MySQL自增id","slug":"重置MySQL自增id","date":"2019-07-01T06:36:42.000Z","updated":"2025-10-26T01:45:42.258Z","comments":true,"path":"2019/07/01/重置MySQL自增id/","link":"","permalink":"https://blog.xiongtianci.com/2019/07/01/重置MySQL自增id/","excerpt":"","text":"方法一# 删除所有数据 delete from user; # 重置自增序列 alter table user auto_increment=1; 方法二# 删除user表后重建表 truncate table user;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"Notepad++正则的使用","slug":"Notepad++正则的使用","date":"2019-06-26T01:13:07.000Z","updated":"2025-10-26T01:45:42.241Z","comments":true,"path":"2019/06/26/Notepad++正则的使用/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/26/Notepad++正则的使用/","excerpt":"","text":"操作Notepad++正则Notepad++使用正则替换的操作：Ctrl+H -&gt; 勾选正则表达式 -&gt; 输入查找目标和替换为 -&gt; 全部替换 比如现在需求是要删除文本中的空行，可能一行也可能是多行： 使用正则\\n[\\s| ]*\\r替换为空即可： 结果： 正则汇总 正则 描述 \\n[\\s&#124; ]*\\r 匹配空白行(n行) ^ 匹配每行开头 $ 匹配每行结尾","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"正则","slug":"正则","permalink":"https://blog.xiongtianci.com/tags/正则/"},{"name":"Notepad++","slug":"Notepad","permalink":"https://blog.xiongtianci.com/tags/Notepad/"}],"author":"天赐"},{"title":"CSS :hover选择器的使用","slug":"CSS-hover选择器的使用","date":"2019-06-24T08:49:29.000Z","updated":"2025-10-26T01:44:38.849Z","comments":true,"path":"2019/06/24/CSS-hover选择器的使用/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/24/CSS-hover选择器的使用/","excerpt":"","text":"定义:hover 选择器，用于选择鼠标指针浮动在上面的元素 :hover选择器适用于所有元素 用法用法一a:hover { background-color: yellow; } 效果：当鼠标悬浮在a元素上时，a的背景颜色设置为黄色 用法二使用 a 控制其他块的样式 子元素使用 a 控制 a 的子元素 b ： a:hover b { background-color:blue; } 兄弟元素使用 a 控制 a 的兄弟元素 c(同级元素) a:hover + c { background-color:blue; } 就近元素使用 a 控制 a 的就近元素 d a:hover ~ d { background-color:blue; } 总结:hover用于选择鼠标悬停其上时的元素 空格：控制子元素 +：控制同级(兄弟)元素 ~：控制就近元素","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/tags/笔记/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.xiongtianci.com/tags/CSS/"},{"name":"选择器","slug":"选择器","permalink":"https://blog.xiongtianci.com/tags/选择器/"}],"author":"天赐"},{"title":"LeanCloud域名更换-恢复Sakura主题Valine评论","slug":"LeanCloud域名更换-恢复Sakura主题Valine评论","date":"2019-06-21T09:32:56.000Z","updated":"2025-10-26T01:44:38.821Z","comments":true,"path":"2019/06/21/LeanCloud域名更换-恢复Sakura主题Valine评论/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/21/LeanCloud域名更换-恢复Sakura主题Valine评论/","excerpt":"","text":"LeanCloud域名更换使用Valine评论插件注册过LeanCloud的小伙伴们从昨天起应该都收到过一封邮件和一条短信，告知了LeanCloud对域名进行更换： 从而导致好多小伙伴们的Valine评论插件报错Code -1: Request has been terminated： Code -1: Request has been terminated Possible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc. Valine插件作者在今天下午解决了这个问题： 恢复Valine评论博主的Hexo主题是Sakura下面是博主恢复Valine评论的记录： 1、打开文件/themes/sakura/layout/_partial/footer.ejs 2、搜索`unpkg.com/valine@1.3.4/dist/Valine.min.js，将此路径替换为unpkg.com/valine@1.3.7/dist/Valine.min.js` 3、将&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;删除或注释掉即可","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.xiongtianci.com/tags/Hexo/"},{"name":"Valine","slug":"Valine","permalink":"https://blog.xiongtianci.com/tags/Valine/"}],"author":"天赐"},{"title":"Octotree访问私有仓库：Error: Private repository","slug":"Octotree访问私有仓库：Error-Private-repository","date":"2019-06-18T07:52:34.000Z","updated":"2025-10-26T01:44:38.803Z","comments":true,"path":"2019/06/18/Octotree访问私有仓库：Error-Private-repository/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/18/Octotree访问私有仓库：Error-Private-repository/","excerpt":"","text":"问题在GitHub私有仓库中使用Octotree时出现下面情况： 这个是因为我们需要在GitHub中给Octotree设置一个访问令牌 解决在GitHub中：Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token 创建令牌 设置名称Octotree browser extension（任意）： 勾选权限范围： 点击Generate token创建令牌： 点击复制按钮复制令牌token（注意：这个token值只会显示一次） 在Octotree中点击设置按钮： 将你刚刚复制的token粘贴到GitHub access token文本框中，点击Apply settings，刷新页面即可： 注意事项 Octotree将令牌token存储在浏览器缓存中，如果将浏览器存储令牌token的缓存清除后，Octotree将会失去私有仓库的访问权限，需重新设置令牌token。https://github.com/ovity/octotree/issues/717","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"google扩展","slug":"google扩展","permalink":"https://blog.xiongtianci.com/tags/google扩展/"},{"name":"Octotree","slug":"Octotree","permalink":"https://blog.xiongtianci.com/tags/Octotree/"}],"author":"天赐"},{"title":"电影资源网址-珍藏","slug":"电影资源网址-珍藏","date":"2019-06-15T13:55:43.000Z","updated":"2025-10-26T01:44:38.786Z","comments":true,"path":"2019/06/15/电影资源网址-珍藏/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/15/电影资源网址-珍藏/","excerpt":"","text":"影视讯息 豆瓣电影 IMDb 烂番茄 Box Office Mojo 实时票房 Box Office Mojo 1905 时光网 MTC 天涯小筑 电影DVD光盘资源分享网 台湾电影资料站 雅虎电影 电影海报 推荐 在线之家 田鸡影院 风车动漫 新电影熟肉 BD影视 电影天堂 人人影视 电影FM 第一时间电影 盘盘搜 泡饭影视 悟空视频 高清电台 19影视 BTtwo 飘花资源网 6V电影网 ED2000 高清MP4 悠悠MP4 爱下电影 蓝鲸电影 沙发电影网 音范丝 电影港 嘎嘎影视 无极论坛 帝国出品 片源网 影视看看 中国高清网 电影蜜蜂 生肉 海盗湾 Zooqle TorrentGalaxy RARBG kat片源 eztv美剧 lime Monova 俄站 美剧 Orange字幕组 美剧天堂 爱美剧 电影首发站美剧 美剧鸟 美剧汇 字幕组 磁力站 天天美剧 美剧-一站搜 看美剧 鱼子酱 电波字幕组 冰冰字幕组 玄字幕组 Fantopia字幕组 大家字幕组 动漫 密柑计划 9ANIME *生肉 萌番组 D站 简单动漫 漫猫动漫 喵搜 科学上网 动漫花园 韩剧 嘟嘟韩剧网 韩剧网 韩迷字幕组 韩国综艺 住在韩国 日剧 neets搜索站-日剧 诸神字幕组-日剧 字幕组-日剧 NO视频 隐社导航 心动日剧 日剧网 花译工坊 追新番 日菁字幕组 第六感 东京不够热 综艺 综艺巴士 纪录片 老纪录 纪录片天地 wiki 科学上网 纪录片之家 纪录片-诸神字幕组 搜索常用 neets搜索站 网盘搜索 盘多多 一网打尽 番茄搜搜 史莱姆导航 探索云盘搜索 胖次 盘搜搜 盘窝窝 百度网盘搜索 网盘搜搜 去转盘网 凌风云搜索 盘优搜 搜搜云盘 搜云盘 58搜索 百度网盘搜索 坑搜网 搜盘侠 BT搜索 磁力聚合搜索神器 BT部落天堂 磁力猫 磁力鼠 万磁搜 BT之家 流弊网) 蓝光电影网 磁力站 查片源 torrentdownload Diggbt kikiBT 种子磁力 一站搜 小不点搜索 科学上网 Torrent Kitty 外挂字幕库 字幕库 opensubtitles 伪射手 R3字幕 台湾精研社R3官字幕 字幕天堂 科学上网 SUBHD 其他 V电影，国内优质短片分享平台，实时分享国内外各类短片，V电影专注于短片领域，收录的国内外优质短片作品近万部，被媒体称为中国版的VIMEO 放映TV，网页简洁美观，动态酷炫，主页以大搜索框属人耳目，放映TV分类详细，每部影片的导演、主演、类型和上映时间具有详细数据，并采用的豆瓣和IMDB的双重评分记录，每部影片至多有8家以内的主流视频网站云点播功能。 某柠檬 参考 常用各类电影资源网址","categories":[{"name":"电影","slug":"电影","permalink":"https://blog.xiongtianci.com/categories/电影/"},{"name":"资源","slug":"资源","permalink":"https://blog.xiongtianci.com/categories/资源/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://blog.xiongtianci.com/tags/电影/"}],"author":"天赐"},{"title":"Typora锚点-页内跳转","slug":"Typora锚点-页内跳转","date":"2019-06-13T06:54:02.000Z","updated":"2025-10-26T01:44:38.752Z","comments":true,"path":"2019/06/13/Typora锚点-页内跳转/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/13/Typora锚点-页内跳转/","excerpt":"","text":"锚点锚点：通俗简单地说，比如一篇很长的文章，你想按分段精确来看，那就可以用到锚点了。 锚点的用法有两种，但性质同样，都是通过链接标签&lt;a&gt;&lt;/a&gt;以及其href属性实现的：一种是：页内跳转一种是：跳到其他页面的某个指定区域 要想使用锚点必须在路径href值中使用# # 的作用#代表网页中的一个位置 其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。href中#后面的值要跟name或id一致，","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.xiongtianci.com/tags/Typora/"}],"author":"天赐"},{"title":"打造个性超赞博客Hexo+Next+GitHub Pages的超深度优化","slug":"打造个性超赞博客Hexo-NexT-GitHub-Pages的超深度优化","date":"2019-06-13T02:11:45.000Z","updated":"2025-10-26T01:44:38.770Z","comments":true,"path":"2019/06/13/打造个性超赞博客Hexo-NexT-GitHub-Pages的超深度优化/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/13/打造个性超赞博客Hexo-NexT-GitHub-Pages的超深度优化/","excerpt":"","text":"作者：reuixiy 原文：https://io-oi.me/tech/hexo-next-optimization/ theme-next：https://github.com/xiongtianci-tc/hexo-theme-next PS：此博文是博主在使用hexo建站时看过的最详细的一篇，由于原作者reuixiy在半个月前将博客主题进行了重构，故将此博文转载并附上我原先fork的主题地址，以便日后食用~ 侵权立删 必读 写在前面本文主要内容是 NexT 主题的个性化定制和一些细节的优化。搭建的过程，已有的优化，Markdown 的使用，都直接贴出大佬的文章链接。 首先肯定是感谢各位大佬的文章，我一个小白，没学 HTML，没学 CSS，没学 JavaScript，连 C 也还没学会……如果你是一个和我一样的小白，且对本博客感觉还蛮满意，恭喜你！看完这篇文章，你自己也可以拥有一个这样的博客啦！ 给小白（像我一样，也许还有完美主义和强迫症😂）却想搭建个性化博客提供参考，是我写这篇文章的主要目的，所以如果本文有幸被大佬读到，文中的不足还请大佬见谅。 本文参考的文章都会直接给出原文链接或者以注脚的形式标记出处，但 Google 参考了实在太多太多了，有些我当时没做记录，如有遗漏，欢迎指出。另外，有一些优化的很好的博客，有很多很酷的功能，我当时没收藏，后来非常后悔，提醒大家如果看到很赞的博客，一定要马上收藏。 重要的定义了解定义，防止懵逼和大脑混乱。这两个文件名字都叫_config.yml，容易乱。 1）站点配置文件，位于站点文件夹根目录内~/blog/_config.yml 2）主题配置文件，位于主题文件夹根目录内~/blog/themes/next/_config.yml 我操作的环境留这个，是因为有时我 Google 教程，发现按流程走，却达不到应有的效果。故当按照这篇的某流程却达不到预期效果，可以考虑考虑这个，然后自己灵活点去 Google 解决方案。 # [2017.12.13 更新] /* 调试浏览器 */ Google Chrome Version 62.0.3202.94 (Official Build) (64-bit) /* 版本信息 */ root@kali:~/blog# hexo version (node:6675) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated. hexo: 3.4.1 hexo-cli: 1.0.4 os: Linux 4.13.0-kali1-amd64 linux x64 http_parser: 2.7.0 node: 8.3.0 v8: 6.0.286.52 uv: 1.13.1 zlib: 1.2.11 ares: 1.10.1-DEV modules: 57 openssl: 1.0.2l icu: 59.1 unicode: 9.0 cldr: 31.0.1 tz: 2017b /* 依赖包 */ root@kali:~/blog# cat package.json { &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.4.1&quot; }, &quot;dependencies&quot;: { &quot;gulp&quot;: &quot;^3.9.1&quot;, /* 压缩代码 */ &quot;gulp-htmlclean&quot;: &quot;^2.7.15&quot;, /* 压缩代码 */ &quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;, /* 压缩代码 */ &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;, /* 压缩代码 */ &quot;hexo&quot;: &quot;^3.4.1&quot;, /* 默认安装 */ &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, /* Git 部署工具 */ &quot;hexo-filter-github-emojis&quot;: &quot;^1.4.3&quot;, /* emoji 支持 */ &quot;hexo-footnotes&quot;: &quot;^1.0.1&quot;, /* 注脚 */ &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, /* 默认安装 */ &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, /* 默认安装 */ &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;, /* RSS */ &quot;hexo-generator-index-pin-top&quot;: &quot;^0.2.2&quot;, /* 替代默认安装的，支持文章置顶 */ &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;, /* 本地搜索 */ &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;, /* 生成 sitemap.xml，利于 SEO */ &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, /* 默认安装 */ &quot;hexo-renderer-ejs&quot;: &quot;^0.3.0&quot;, /* 默认安装 */ &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;, /* 默认安装 */ &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, /* 默认安装 */ &quot;hexo-server&quot;: &quot;^0.2.0&quot;, /* 默认安装 */ &quot;hexo-tag-aplayer&quot;: &quot;^2.0.5&quot;, /* 音乐播放插件，支持歌词 */ &quot;hexo-tag-dplayer&quot;: &quot;^0.2.1&quot;, /* 视频播放插件，支持弹幕 */ &quot;hexo-wordcount&quot;: &quot;^3.0.2&quot; /* 字数统计 */ } } /* 主题NexT版本 */ version: 5.1.3 /* 优化主题NexT的设计版式 */ scheme: Muse 开始 搭建博客终于进入正文了！但是这个我却不打算写，因为看到了一些很好的文章，这里直接给出这些文章的链接🌚～ 在本地安装 Hexo直接参考 Hexo 官方文档，毕竟是官方文档。安装好 Hexo 后，先任意目录新建个文件夹，名字可以为 blog，然后进入这个文件夹，输入命令： # 所在目录：~/blog/ hexo init 等一会，如果出现橙色的 WARN 没关系，只要不出现红色的 ERROR 就行。好了后，输入命令： # 所在目录：~/blog/ hexo g &amp;&amp; hexo s 然后点开 http://localhost:4000/ ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！距离成功只差下一步——部署博客到 GitHub Pages 了～ 部署博客到 GitHub PagesGitHub Pages 是开源协作社区 GitHub 的一个服务，将博客部署到它上面再合适不过了。 问题 解答 为什么要部署到 GitHub Pages 上？ 首先免费，其次省心，最后可以学习使用 GitHub。 GitHub Pages 有容量限制吗？ 有，由 What is GitHub Pages? 可知：大小限制为 1GB，一个月 100GB 流量。 超出限制的容量怎么办？ 讲真，如果图片音乐视频等大文件都放在七牛云 KODO、阿里云 OSS 或其它云存储上，那么压根不用担心，因为我的博客现在[2017.11.17]也才用了 6.73MB 😅，所以无需担心。 国内访问速度行不行，有必要同时部署在 Coding 上吗？ 个人感觉完全没必要，自己不用梯子时，感觉访问速度可以，毕竟站点的大文件都是放在了云存储上。 我可以用自己的域名吗？ 可以，并且原生支持 https，教程见这篇文章。 注册 GitHub 帐号和创建 Repository 请查看这篇文章，之后在站点文件夹根目录，安装 Git 部署插件（以后安装插件都先到这个目录），输入下面命令回车： # 所在目录：~/blog/ npm install hexo-deployer-git --save 然后，打开站点文件夹根目录下的站点配置文件，编辑： # 文件位置：~/blog/_config.yml # URL url: https://reuixiy.github.io/ . . .省略…… . . # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: - type: + type: git + repository: https://github.com/reuixiy/reuixiy.github.io.git + branch: master 将其中的reuixiy改成你的 GitHub 注册的帐号名就行，然后执行下面的命令： # 所在目录：~/blog/ hexo clean &amp;&amp; hexo g &amp;&amp; hexo 输入你的 GitHub 的用户名和密码，成功后复制https://帐号名.github.io/到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！ 当然，如果你不想每次都输入用户名和密码，不想每次更新时，在 GitHub 上显示invalid-email-address，可以按上面所提的那篇文章操作。 更新提示（可以最后看）更新会有不确定因素，即讨厌又麻烦，但是不更新又怎么能享受新功能呢😑… 其它更新1）npm 更新全局安装的包： npm update -g 2）npm 更新站点文件夹根目录下安装的依赖包： # 所在目录：~/blog/ npm update 3）更新 npm 它自己： npm install npm -g 4）更新 Node.js 到最新版： npm install n -g n latest 更新主题进入主题文件夹根目录，然后git pull，发现报错，怎么解决呢？可以先浏览这篇文章，然后参考我的操作。 先到主题文件夹根目录： # 所在目录：~/blog/themes/next/ git pull 会发现报错，由于我们更改了相关文件，更新不成功，所以要将本地的所有修改先暂时存储起来： # 所在目录：~/blog/themes/next/ git stash 然后再试一下： # 所在目录：~/blog/themes/next/ git pull 可以了吧，接下来还原暂时存储的内容（即保存我们的所有修改）： # 所在目录：~/blog/themes/next/ git stash pop 如果报CONFLICT，是因为 Git 无法确定一些改动，所以要我们手动解决文件中冲突的部分，这个比较麻烦，可以参考我下面的流程。 首先打开报CONFLICT的文件，Ctrl + F 搜索&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes，查看从此处到=======之间保存的代码，回忆一下自己当时更改了什么，是为了达到什么功能。 然后查看=======到&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream之间更新的代码，与下面保存的代码进行对比（也请浏览下所标出代码前后的代码）： 如果改动较大，可能是主题增加了新功能，建议保留更新的代码，然后更改一下，达到自己想要在保存的代码中实现的功能，最后删除保存的代码。 如果改动较小，建议还是保留更新的代码，然后更改一下，最后删除保存的代码。 注意：要是自己不确定，一定记得将&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream到&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes之间的代码另存备份，然后进行调试，直到最后确定没有问题。 最后： # 所在目录：~/blog/themes/next/ root@kali:~/blog/themes/next# git pull error: Pulling is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use &#39;git add/rm &lt;file&gt;&#39; hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. 哇，又报错了😂😂😂，咋办？ 先查看： # 所在目录：~/blog/themes/next/ root@kali:~/blog/themes/next# git status On branch master Your branch is up to date with &#39;origin/master&#39;. Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: layout/_custom/header.swig modified: layout/_custom/sidebar.swig modified: layout/_layout.swig modified: layout/category.swig modified: layout/tag.swig modified: source/css/_common/components/post/post-meta.styl modified: source/css/_common/components/post/post-nav.styl modified: source/css/_common/scaffolding/base.styl modified: source/css/_custom/custom.styl deleted: source/images/avatar.gif modified: source/lib/Han/dist/han.min.css Unmerged paths: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: _config.yml both modified: languages/zh-Hans.yml both modified: layout/_macro/post-copyright.swig both modified: layout/_macro/post.swig both modified: layout/_macro/sidebar.swig both modified: layout/_partials/footer.swig both modified: layout/page.swig both modified: source/css/_variables/base.styl Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) layout/_macro/passage-end-tag.swig source/js/src/love.js 看下面Unmerged paths，说git reset HEAD &lt;file&gt;...来取消修改（大概），git add &lt;file&gt;...来 mark 决定（大概），我们当然要保存这些文件的更改，所以： # 所在目录：~/blog/themes/next/ root@kali:~/blog/themes/next# git add _config.yml languages/zh-Hans.yml layout/_macro/post-copyright.swig layout/_macro/post.swig layout/_macro/sidebar.swig layout/_partials/footer.swig layout/page.swig source/css/_variables/base.styl layout/_macro/passage-end-tag.swig source/js/src/love.js 顺便把新加的passage-end-tag.swig和love.js也加进去，最后再来试一下吧： # 所在目录：~/blog/themes/next/ root@kali:~/blog/themes/next# git pull Already up to date. 哇，成功更新主题！ 注意：更新有风险，一定要谨慎处理文件中冲突的部分！另，如果更新 NexT 主题后，配置文件有些新功能不会配置，可以查看 Releases（最新版）页面，去里面找说明。 优化 基本功能配置通过上面的折腾，你应该能够在自己的 GitHub Pages 上看到自己的博客了，接下来就是配置和增加功能，如阅读统计、加上评论和安装插件啥的，还有就是添加一些博客的基本信息，这些配置建议在写文章之前先折腾好。 基本功能配置大部分就是改两个文件，都叫_config.yml，文章的开头位置已告诉大家。我觉得与其将两个文件中的每点都分开来解释，倒不如直接将这两个文件贴出来，然后通过注释的方式告诉大家配置的方法，所以下面我会贴出这两个文件，怎么配置看注释就好了😄～ 选择主题不过还有一件事要先说一说，就是选择合适自己的主题，这是搭建好博客后最重要的一件事。默认的主题功能少，而且不太好看（个人感觉），而一些主题则有很多功能，也比较美观。 我选择的是 NexT（最新版），简洁且功能不少，也是在 GitHub 上被 Star 最多[2017.11.17]的一个 Hexo 主题。第二多的是 hexo-theme-yilia，第三多的是 hexo-theme-material（还有一个很棒的 Material Design 风格主题 hexo-theme-material-indigo），还有一个我感觉比较有特色的，叫 Cactus Dark，这几个我感觉都不错，可以点开链接看看长啥样。要是我上面说的还是没有合你胃口的😅，咋办？去 Hexo Themes 慢慢找。 至于换主题，很简单，我拿 NexT 主题举个栗子。首先在这个主题的 GitHub 页面的右上方复制链接，如下图： 然后： # 所在目录：~/blog/themes/ git clone https://github.com/theme-next/hexo-theme-next.git next 再在站点配置文件中修改成如下即可： # 文件位置：~/blog/_config.yml ## Themes: https://hexo.io/themes/ theme: next 站点配置文件请先查看 Hexo 官方文档，再查看下面我贴出的，如果这样后你还是对有些地方比较懵，可以自行 Google。如果你的文件中没有相关内容，请勿直接添加，且所有的:都为英文字符，它后面都有一个空格。 # [2017.11.14 更新] 文件位置：~/blog/_config.yml # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: reuixiy subtitle: Viva La Vida description: 易 象 辞 author: reuixiy language: zh-CN timezone: # URL url: https://reuixiy.github.io/ root: / # 博客文章的 URL 结构，请务必写文章之前就想好！ # 详细参数请查看：https://hexo.io/docs/permalinks.html # 当然最好不要参考我的，我的太不利于 SEO 了，除非…… permalink: :category/:year/:month/:day/:title.html permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true # 代码高亮设置 highlight: enable: true line_number: true # 代码自动高亮 auto_detect: true tab_replace: # 关于代码高亮的更多知识，可以查看本文 6.5.2 节 # Home page setting # path: Root path for your blogs index page. (default = &#39;&#39;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator: path: &#39;&#39; per_page: 10 order_by: -date # Category &amp; Tag default_category: uncategorized # URL 中的分类和标签「翻译」成英文 # 见：https://github.com/hexojs/hexo/issues/1162 category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination # 这个我有点懵，上面不是有啊…… per_page: 10 pagination_dir: page ## 修改归档页面、某一分类页面、某一标签页面的显示篇数 ## 参考：http://theme-next.iissnan.com/faqs.html#setting-page-size archive_generator: per_page: 0 yearly: false monthly: false daily: false category_generator: per_page: 0 tag_generator: per_page: 0 # Extensions ## Plugins: https://hexo.io/plugins/ # RSS，要先进入站点文件夹根目录安装插件 # npm install hexo-generator-feed --save 即可 # 无需更多配置 # 参数说明查看 README：https://github.com/hexojs/hexo-generator-feed feed: type: atom path: atom.xml # 文章数，0 为全部 limit: 0 hub: # 是否包含文章内容 content: true # emoji 支持，教程见本文 6.3 节 githubEmojis: enable: true idName: github-emoji unicode: false styles: localEmojis: ## Themes: https://hexo.io/themes/ # 主题配置 theme: next # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: https://github.com/reuixiy/reuixiy.github.io.git branch: master 主题配置文件如果你的主题不是 NexT，那么请另 Google。建议先查看 NexT 官方文档（最新版），写得很好，多逗留会没坏处。由于文件过长，为了保证文章阅读效果，我把文件放在了 GitHub。另外，我把我没有配置的差不多都删了，有问题可以多 Google。如果里面有些设置你还想进一步自定义，比如进一步自定义页脚文字的顺序，折腾完本文第 5 节你就会了😉。 动态背景 在主题配置文件中，靠后面，改canvas_nest: true，想要更改颜色和数量？修改文件： # 文件位置 ~/blog/themes/next/source/lib/canvas-nest/canvas-nest.min.js 怎么修改？参考 README。 注脚 在 Hexo 插件搜索footnotes，发现目前有两种插件，右边的可以实现鼠标放在上面悬浮显示注释的功能，但是亲测有一个 Bug，有时对页面宽度有影响，强迫症难以忍受。我安装的是左边的，先进入站点文件夹根目录，然后： # 所在目录：~/blog/ npm install hexo-footnotes --save 安装后按 README 的介绍的语法书写，应该就可以了。注意：注脚的内容一定要放在 Markdown 文档的最后面，否则可能会有错误。 优化 网页样式布局发现页面有大量留白？颜色不合自己口味？那就 F12 开始吧，大换装开始！空白区？颜色？背景？圆角矩形？阴影？透明度？超链接样式？侧栏头像圆形并旋转？文章标题前面的竖线和颜色？只需按下 F12，改到自己想要的样式，然后 Copy 到custom.styl文件即可。感觉这是 NexT 主题非常棒的设计，因为这让我们能够很方便自定义博客的样式。怎么知道要修改这个文件呢？强烈推荐阅读这篇文章。 怎么更改？浏览器按 F12 即可，建议用 Google Chrome 浏览器（有梯子的直接去 Google 下载😂），或者火狐浏览器。如果你按下 F12 后简直特么一脸懵逼，那么别急，硬着头皮慢慢折腾吧哈哈哈嗝～ bb - for - bb不管你信不信，其实博主就是这样直接折腾过来的，我之前没学过 HTML 和 CSS，所以当时按下 F12 真是一脸懵逼。我一开始是 Google（关键字：Hexo NexT 自定义）到上面那篇文章，一点进去，卧槽！侧栏终于不是清一色的默认黑色，激动！这位大佬怎么改的啊？这篇文章一定有吧😍！？然后看下去，果然有！然后眼睛先盯着贴的custom.styl，久久看着少数的注释，Copy 一段到自己的custom.styl，保存，然后hexo clean、hexo g、hexo s（当时我还不知道可以hexo s后可以直接本地调试😭），再去浏览器刷新自己的本地调试页面，看看效果。效果是有了，但是不是我想要的效果啊……于是去百度其中一行 CSS 代码，再回去慢慢删改调试……博主由懵逼到熟悉花了不少时间，但是我写这篇文章就是为了减少像我这样的小白折腾的时间，所以下面详细说明下按下 F12 后怎么快速由懵逼到熟悉！ 快速由懵逼到熟悉首先按下 F12 后的操作流程图，就是这篇文章中的三步骤，点小箭头定位元素，调试 CSS 代码，最后 Copy 到custom.styl。然后懵逼的地方，应该有下面两点： 按下 F12 后弹出的界面是什么鬼？！ 界面中的{}前面的和里面的英文是什么鬼？！ 第一点：弹出的界面是为调试设计的，如果你知道调试的是啥，也许就自然了解弹出的界面，所以我不多说，不过还是给一份 Google 官方的资料——Chrome 开发者工具。第二点：{}前面的是 HTML 的元素名，{}里面的是这个元素的 CSS 样式。 社交要先有自己原则，一段代码要先声明变量，一个数学问题有前提，一篇论文要先定义名词，到这里我们也必须要先了解一些 HTML 和 CSS 的基本语法知识了，才能继续折腾下去。建议先浏览下这篇文章，但没必要记住里面的每一个语法知识，因为这样的记忆是不够深刻也并不高效的，只要浏览下留个印象（为了能找准元素）就行，而记忆是要在实践中记忆的。 bb - for - fun实践？对！就是打开自己的本地调试页面，然后用你挑剔的眼光看看，哪里让你不爽，就按 F12，定位元素，最后调试，直到改到自己满意。这不是与一开始说的三步骤一样吗，为啥现在又说一遍？不不不，想想如果你点开一个俄文网站，然后我给你个这页面上的一个俄文链接的中文翻译，让你找到这个俄文链接并点开，你会不会懵逼呢……一样的，如果我没有让先你浏览 HTML 和 CSS 的基本语法知识，那么对网页中出现的东东大脑压根就「翻译」不成 HTML 和 CSS 代码（反之一样）。对 HTML 和 CSS 的语法定义不明，就可能会找不准元素，而找不准元素不仅可能达不到预期效果，还可能会产生一些新的 bugs，所以要先浏览上面那篇文章。这也是我这个小白走过的坑中，最大的一个了，花费了我不少时间在无意义的搜索上，想达到一个效果，但是不知道输入什么搜索关键字……最后，要熟练还是要多折腾……喵？！多折腾，说好的快速呢！？快速是要有对比的，我填了定义不明这个大坑，你按我说的操作，与我的慢折腾经历相比，你的折腾当然是快速。诡辩？好吧说实话也算是谎言，不过是个善意的谎言，只为给你一种神奇的能量——Hope，这种谎言在生活中很常见，但我的缺少一个目的——钱。 附上我的 custom.styl由于文件过长，为了保证文章阅读效果，我把文件放在了 GitHub。请先找对元素，不然可能会制造出新 bug，建议大家修改一个，就加个注释，方便以后调试修改。注意：一定是先 F12 找到要自定义的元素，调试成自己喜欢的值，然后再复制到custom.styl，而不是直接复制我给出的，我给出的仅供参考。 修改字体优化了这么多，但还有一个最影响博客形象和阅读体验的项没有优化，瓦特？字体！文章字体大小可以编辑： # 文件位置：~/blog/themes/next/source/css/_variables/base.styl $font-size-base = 16px 如果你是一个和我一样对字体一脸懵逼的人，推荐阅读： Web 中文字体排版指南 Web 字体的选择和运用 如何优雅的选择默认字体（font-family） 中文字体网页开发指南 在 Web 内容中使用系统字体 首先对于汉字来说，因为其字体库太大，通常都是调用本地中文字体库。然而，不同设备有不同默认中文字体和中文字体库，想要尽可能在不同设备上有较好的显示效果，就要在调用不同设备的本地字体库中显示效果较好的中文字体。下面附上我的供大家参考： # 文件位置：~/blog/themes/next/source/css/_variables/base.styl // Font families. $font-family-chinese = -apple-system, BlinkMacSystemFont, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;STHeiti&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Droid Sans Fallback&quot;, &quot;Microsoft YaHei&quot; $font-family-base = $font-family-chinese, sans-serif $font-family-base = get_font_family(&#39;global&#39;), $font-family-chinese, sans-serif if get_font_family(&#39;global&#39;) $font-family-logo = $font-family-base $font-family-logo = get_font_family(&#39;logo&#39;), $font-family-base if get_font_family(&#39;logo&#39;) $font-family-headings = $font-family-base $font-family-headings = get_font_family(&#39;headings&#39;), $font-family-base if get_font_family(&#39;headings&#39;) $font-family-posts = $font-family-base $font-family-posts = get_font_family(&#39;posts&#39;), $font-family-base if get_font_family(&#39;posts&#39;) $font-family-monospace = $font-family-chinese, monospace $font-family-monospace = Menlo, Monaco, Consolas, get_font_family(&#39;codes&#39;), $font-family-chinese, monospace if get_font_family(&#39;codes&#39;) 注意：要想 NexT 主题的简体中文字体配置生效，站点配置文件中的 language 必须为 zh-CN。然后对于英文字体，因为其字体库很小，所以想要个性化就简单多了。首先去 Google Fonts 找自己喜欢的英文字体，然后编辑主题配置文件，可以查看一下 NexT 官方文档（最新版）。下面附上我的供大家参考： # 文件位置：~/blog/themes/next/_config.yml font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) # 亲测这个可用，如果不可用，自己搜索 [Google 字体 国内镜像]，找个能用的就行 host: https://fonts.loli.net # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: Roboto Slab # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: Roboto Mono size: 注意：本博客的字体最新设置方法请看我的这篇文章。 进阶 高级功能配置这些功能的配置，大部分都要修改 NexT 主题的一些文件，所以git pull升级主题的时候，会比较麻烦，解决方法见本文 2.3.2 节。 大佬的文章更多如外挂一样的功能配置，就直接贴大佬的文章了，哪些功能自己喜欢，按照大佬的教程来配置就行。不过也有坑，比如有些功能（超链接样式、侧栏头像圆形并旋转）可以直接通过在custom.styl添加 CSS 代码实现，无需更改其它文件。 Hexo 高阶教程 NexT 主题优化 Hexo 的 NexT 主题个性化教程：打造炫酷网站 Hexo 搭建博客的个性化设置 第一篇文章内有 NexT 主题的文件目录说明，这对自己自定义博客有很大帮助。此外，大佬的博客可不仅仅有一篇文章，多在上面逗留会，也许会有甜品。 更改上一篇，下一篇的顺序进入一篇文章，在文章底部，有上下篇的链接（&lt; &gt;），但是点 &gt; 发现进入的是页面中的的上面那篇文章，与操作习惯不符，别扭。 我猜这是从时间角度设计的，&gt; 英语叫 next，而 next 是更新的。不过别扭就改成习惯的好了，从空间位置角度设计。[^1] 方法就是修改文件： # 文件位置：~/blog/themes/next/layout/_macro/post.swig {% if not is_index and (post.prev or post.next) %} - {% if post.next %} + {% if post.prev %} - + - {{ post.next.title }} + {{ post.prev.title }} {% endif %} &lt;/div&gt; &lt;span class=&quot;post-nav-divider&quot;&gt;&lt;/span&gt; &lt;div class=&quot;post-nav-prev post-nav-item&quot;&gt; - {% if post.prev %} + {% if post.next %} - + - {{ post.prev.title }} + {{ post.next.title }} {% endif %} &lt;/div&gt; &lt;/div&gt; {% endif %} 自己改单词请注意：是 prev 不是 perv，之前自己搞错了，然后盯着电脑屏幕尴尬半天，不停想特么老子哪里错了，怎么特么就是达不到效果！？？？ 移动端显示 back-to-top 按钮和侧栏今天更新一下 NexT 主题，发现已经添加这功能，前提是主题的设计模版是 Muse 或 Mist，然后可以直接在主题配置文件中配置： # 文件位置：~/blog/themes/next/_config.yml # Enable sidebar on narrow view onmobile: true 如果你发现你的主题配置文件_config.yml中没有这段内容，可以尝试按本文 2.3.1 节的方法更新主题。 博客推广及谷歌搜索优化（必读）想自己写的文章被别人看到？希望得到别人的评论肯定？渴望用自己写的文章照亮他人，给整个文明光能？那么这个就不可或缺了。你能看到这篇文章，很大程度上也是因为这个😏。 博客推广博客推广第一步，手动推广。你可以多浏览别人的博客并留下你的爪印（博客地址），比如评论；你可以去 README.md 中提到的这个 issue 留下你的爪印；你可以去 Issues（最新版）页面试着回答下大家的问题并留下你的爪印。 搜索引擎博客推广第二步，SEO（Search Engine Optimization）。搜索引擎是互联网上寻找资源的重要手段，而要让别人能够在搜索结果中看到自己的博客文章链接，就必须让搜索引擎收录，怎么操作呢？ 直接参考这篇文章，学会使用站长工具抓取自己的网页，然后请求搜索引擎收录。博主也是刚接触不久，不太懂，但推荐提交次数尽量多，而且每天尽量都提交一次。我没有弄百度的，只弄了 Google 的，但是前几天百度hexo next 优化（其它关键字没试），发现第一页就有自己文章，而且文章图片也在上面，很显眼，让我非常惊喜😆！ 看到链接是 SegmentFault 的，恍然大悟，原来是这个大佬推荐的，不仅帮我把此文推到了掘金，还有 SegmentFault，在此再次感谢大佬！这也给了一个启示，除了直接向搜索引擎提交自己的链接，还可以通过这种途径优化博客的 SEO。 间接影响另外，SEO 固然重要，但不要小看另一种影响，相比搜索引擎，这种可以称之为间接影响。这篇文章是一篇技术性的文章，而技术人员经常会用 Google，所以对这篇文章的浏览量，搜索引擎的功劳较大。但是，如果是其他的文章，比如一首诗，那么直接通过 Google 访问的读者几乎没有，那读者哪来？从其它文章上的读者「流」过来的。因为读者浏览着的不是一篇文章，而是一个博客。 而想让博客上的几乎不可能被 Google 的一首诗被浏览，就要这样间接拉读者了，可以称之「引流」。首先对博客上的每篇文章来说，肯定是读者花在自己博客的时间越长，被读到的可能性越大。这就意味着你要尽可能把用户留在自己的博客上，怎么留？ 博客要装饰好 文章质量要高 读者的第二印象是博客的界面，如果界面够特别，也许马上就被加入了书签。第三印象是文章内容，这其实更加重要，如果文章质量很高，那么读者肯定不会让这么好的一篇文章消失在自己的记忆中，即使界面不咋地。第一印象？加载速度，试想点开半天还是空白，那么肯定马上关了。 如果做到上面三点，那么就算好不容易「骗」到一个 Google 浏览量，但是这个读者马上被博客和文章惊呆了，看完文章后，这读者心里美滋滋，认为这么好的文章（博客）必须分享啊（如上面的大佬推荐🌚），于是可能马上来了一大批满怀期待的读者，然后这批读者又……这时文章的读者数（博客的访问量）就不是简单的加法了～ 知识平台直接或间接因为 Google 这样的搜索引擎而来的读者，绝大部分都是技术人员，而他们只希望尽快解决自己的技术问题，这也是他们的目的，这就意味着博客上的一首诗还是很难被欣赏。而要想照亮他人，他人必须要能懂自己的文章，这样也才可能有更强的交互——评论。所以为了不浪费自己的光能，能把自己的光能完完整整地贡献给文明，那就必须也让一首诗也有评论，怎么做呢？让读者的类型多样化，不限于技术人员。还好现在大部分读者也不用搜索引擎了，谁在吞食搜索引擎的用户？移动端。智能手机的迅速普及导致搜索引擎已经不是人们获取知识的主要途径，大部分人已经将手机 APP 上的知识平台作为自己获取知识的主要途径，比如：知乎、简书、微信订阅号……所以，你还可以将自己的文章发布在这些知识平台上的相应分类上，然后留个博客链接，吸引更多类型的读者😄～ 谷歌分析你怎么知道自己推广的效果？你怎么知道有没有人看了自己的博客？哪篇文章最受欢迎？此时有没有人正浏览着自己的博客？自己的文章有没有被引用？这时最常用的就是强大免费的 Google Analytics，推荐博客建好后，就立即使用。 如何使用？请务必自备梯子查看 Google 官方的教程，开始使用后一定要按照里面的设置，先添加多份 view（数据视图）。 ATTENTION：虽然有个复制 view 选项，但由 Google Analytics（分析）帮助中的具体复制内容再加上我的实践，发现（用我这个外行人的话来说）：复制 view 时只会复制它的相关配置，不会复制数据！所以请使用后立即按照官方教程中的方式添加 view！ 我们写文章，会在本地调试，这时 Google Analytics 也是会收集数据的，会影响数据分析，所以必须添加一个 filter（过滤器）。 ATTENTION：由 Google Analytics（分析）的工作原理可知，filter 是在数据处理时生效的（如上图），也就是说添加 filter 后只能过滤添加它之后的数据，而无法过滤添加它之前的数据（处理后），而 view 是利用处理后的数据生成的，所以要想去除自己在本地调试时的影响（在 view 中看不到自己在本地调试时的访问），请添加 view 之后就立即添加 filter！ 时间轴页面的年份分隔在 Archives（归档）页面，文章之间有年份分隔，而某一个 category 和 tag 的时间轴页面却没有。怎么办呢？修改两个文件，加代码即可😌～ category加到哪？要加两个位置： # 文件位置：~/blog/themes/next/layout/category.swig {% for post in page.posts %} 位置A {{ post_template.render(post) }} {% endfor %} . . .（省略好多行） . . 位置B（没错最后面） 加什么？绿色的自己看着加： # 文件位置：~/blog/themes/next/layout/category.swig # https://github.com/reuixiy/blog-files/blob/master/category.swig {% for post in page.posts %} + + {# Show year #} + {% set year %} + {% set post.year = date(post.date, 'YYYY') %} + + {% if post.year !== year %} + {% set year = post.year %} + + {{ year }} + + {% endif %} + {# endshow #} + {{ post_template.render(post) }} {% endfor %} . . .（省略好多行） . . +{% block script_extra %} + {% if theme.use_motion %} + + $('.archive-year').velocity('transition.slideLeftIn'); + + {% endif %} +{% endblock %} tag文件位置：~/blog/themes/next/layout/tag.swig，修改内容与 category 的完全一样。 说明两段代码直接 Copy 同目录下的 archive.swig 文件里面的，而且 tag.swig 和 category.swig 好像都预留了位置似的，代码小白的我折腾了半天，才改好😭😭😭，不知道写代码的大佬怎么想的w(ﾟДﾟ)w～ 文章底部加上评分小星星淘宝买东西，作为消费者的我们，看评价很重要。现在作为博主，写了一篇文章，很期待读者的反馈。而与淘宝一样，确认收货后，相比评论，更愿意五星好评。那么博客文章怎么加上呢？首先打开主题配置文件： # 文件位置：~/blog/themes/next/_config.yml # Star rating support to each article. # To get your ID visit https://widgetpack.com rating: enable: true id: color: f79533 先去注释中的网站，首页点 Rating，然后注册个帐号，填一下自己博客的信息，左上角有个 ID，填进主题配置文件中就行，color改成自己喜欢的即可。另： 1）可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device(cookie)，免登录，毕竟 Socials 里面的选项几乎都被墙，不适合国内网络环境。2）建议在侧栏 &gt; Site &gt; Setting 中勾选 Private 选项。3）上面两步勾选后别忘了点击页面右下方的 SAVE SETTING 绿色按钮保存。 如果感觉上下留白太多，咋整？浏览器 F12 找元素，调成自己喜欢的值，然后 Copy 到custom.styl即可，参考本文 4.2 节。经过上面的配置，默认最下面只会显示 5 颗小星星，简洁但不明了😂，怎么加上文字说明呢？编辑下面这个文件，Ctrl + F 搜索rating，找到这段，对比我给出的，在绿色这行所示的位置，加上自己想要的说明和样式即可。 # 文件位置：~/blog/themes/next/layout/_macro/post.swig {% if theme.rating.enable %} + (&gt;看完记得五星好评哦亲&lt;) {% endif %} 侧栏加入已运行的时间我们都有自己的生日，都知道自己的岁数，那为什么不给博客加上，让读者知道博客的年纪呢？操作很简单，而且不是精确到年而是精确到秒，233333～ 首先要加入下面代码：[^2] # 文件位置：~/blog/themes/next/layout/_custom/sidebar.swig &lt;div id=&quot;days&quot;&gt;&lt;/div&gt; &lt;script&gt; function show_date_time(){ window.setTimeout(&quot;show_date_time()&quot;, 1000); BirthDay=new Date(&quot;05/27/2017 15:13:14&quot;); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById(&#39;days&#39;).innerHTML=&quot;已运行 &quot;+daysold+&quot; 天 &quot;+hrsold+&quot; 小时 &quot;+minsold+&quot; 分 &quot;+seconds+&quot; 秒&quot;; } function setzero(i) { if (i&lt;10) { i=&quot;0&quot; + i }; return i; } show_date_time(); &lt;/script&gt; 上面Date的值记得改为你自己的，且按上面格式，然后修改： # 文件位置：~/blog/themes/next/layout/_macro/sidebar.swig {% if theme.links %} {{ theme.links_title }}&nbsp; {% for name, link in theme.links %} {{ name }} {% endfor %} + {% include '../_custom/sidebar.swig' %} {% endif %} - {% include '../_custom/sidebar.swig' %} 这样就可以了！当然，要是不喜欢颜色，感觉不好看，就可以在上文所提的custom.styl加入： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的侧栏时间样式 #days { display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px; } 里面的值 F12 调成自己喜欢的，然后更改即可。要是不想放在侧栏，想放在页脚，自己应该能折腾了吧😄～ 添加 TopX 页面博客已有的分类，如 categories 和 tags，都是基于博主的，那么有没有一种分类是基于读者的呢？有，一种是搜索，另一种就是这里的文章阅读量排行榜。前提是在主题配置文件中配置了 leancloud_visitors，配置方法见本文 3.3 节中我的主题配置文件中的教程链接。首先新建页面： # 所在目录：~/blog/ hexo new page &quot;top&quot; 然后在主题配置文件中加上菜单 top 和它的 icon： # 文件位置：~/blog/themes/next/_config.yml menu: top: /top/ || signal 接着在语言翻译文件中加上菜单 top： # 文件位置：~/blog/themes/next/languages/zh_Hans.yml menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 top: TopX /* 可以不为 TopX，随便取 */ 注意：如果你的站点配置文件中的 languages 写的不是 zh-CN，那么这里请更改相应语言配置文件。最后，编辑第一步新建页面生成的文件：[^3] # 文件位置：~/blog/source/top/index.md --- title: TopX /* 可以不为 TopX，随便取 */ comments: false keywords: top,文章阅读量排行榜 description: 博客文章阅读量排行榜 --- &lt;div id=&quot;top&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script&gt;AV.initialize(&quot;app_id&quot;, &quot;app_key&quot;);&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var time=0 var title=&quot;&quot; var url=&quot;&quot; var query = new AV.Query(&#39;Counter&#39;); query.notEqualTo(&#39;id&#39;,0); query.descending(&#39;time&#39;); query.limit(1000); query.find().then(function (todo) { for (var i=0;i&lt;1000;i++){ var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content=&quot;&lt;a href=&#39;&quot;+&quot;https://reuixiy.github.io&quot;+url+&quot;&#39;&gt;&quot;+title+&quot;&lt;/a&gt;&quot;+&quot;&lt;br /&gt;&quot;+&quot;&lt;font color=&#39;#555&#39;&gt;&quot;+&quot;阅读次数：&quot;+time+&quot;&lt;/font&gt;&quot;+&quot;&lt;br /&gt;&lt;br /&gt;&quot;; document.getElementById(&quot;top&quot;).innerHTML+=content } }, function (error) { console.log(&quot;error&quot;); }); &lt;/script&gt; &lt;style&gt;.post-description { display: none; }&lt;/style&gt; 必须将里面的里面的app_id和app_key替换为你的主题配置文件中的值，必须替换里面博客的链接，1000是显示文章的数量，其它可以自己看情况更改。最后，修改样式可以在custom.styl中加入自定义代码，参考本文 4.2 节。Okay！完成了！不过还有几点需要注意： 1）如果在设置 &gt; 安全中心中，没有将http://localhost:4000加入 Web 安全域名，那么本地调试将看不到，可以先将之加入，调试完后删除。2）如果你发现文章标题显示不对，这是由于更改过文章标题导致的，在存储 &gt; Counter 双击title修改即可。 另外，应该也可以按类似的方式，利用 JS 代码，将评分（rating）高╱多的文章，评论多的文章，也加入这个页面，不过现在博客的阅读量还不多，我暂时没折腾（其实也不太会）。如果你实现了，麻烦告诉我哦😘～ 注意：如果你的博客使用了 Valine 评论系统，那么可能会有代码冲突问题，解决方法见这篇文章。 利用 gulp 压缩代码右键查看网页源代码发现有大量留白，咋整？利用 gulp。首先任意目录全局安装：[^4] npm install gulp@3.9.1 -g 然后到站点文件夹根目录： # 所在目录：~/blog/ npm install gulp@3.9.1 gulp-minify-css gulp-htmlmin gulp-htmlclean --save 接着在站点文件夹根目录新建 gulpfile.js： # 文件位置：~/blog/gulpfile.js var gulp = require(&#39;gulp&#39;); var minifycss = require(&#39;gulp-minify-css&#39;); var htmlmin = require(&#39;gulp-htmlmin&#39;); var htmlclean = require(&#39;gulp-htmlclean&#39;); gulp.task(&#39;minify-css&#39;, function() { return gulp.src(&#39;./public/**/*.css&#39;) .pipe(minifycss()) .pipe(gulp.dest(&#39;./public&#39;)) }); gulp.task(&#39;minify-html&#39;, function() { return gulp.src(&#39;./public/**/*.html&#39;) .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true })) .pipe(gulp.dest(&#39;./public&#39;)) }); gulp.task(&#39;default&#39;, [&#39;minify-html&#39;, &#39;minify-css&#39;]); 最后部署到 GitHub Pages 上查看效果： # 所在目录：~/blog/ hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 我没有压缩 JavaScript，因为我发现会报错，实际也并不需要，因为大部分 JavaScript 都已压缩过。这里的这段代码执行 gulp 后也不支持hexo s本地调试，记得在哪看过解决方法，需要的自己 Google。另外，可能会产生一些奇怪的 bugs，没看到最好，要是看到了的话就自己解决吧～（逃…… 让页脚的心跳动起来世界上有一种伟大的力量，它的名字无人不晓，就是——❤～ 首先编辑主题配置文件： # 文件位置：~/blog/themes/next/_config.yml footer: - icon: user + icon: heart 然后编辑： # 文件位置：~/blog/themes/next/layout/_partials/footer.swig - &lt;span class=&quot;with-love&quot;&gt; + &lt;span class=&quot;with-love&quot; id=&quot;heart&quot;&gt; 接着编辑custom.styl，加入： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义页脚跳动的心样式 @keyframes heartAnimate { 0%,100%{transform:scale(1);} 10%,30%{transform:scale(0.9);} 20%,40%,60%,80%{transform:scale(1.1);} 50%,70%{transform:scale(1.1);} } #heart { animation: heartAnimate 1.33s ease-in-out infinite; } .with-love { color: rgb(255, 113, 168); } color的值可以改成你自己喜欢的，灵感来自 DIYgod 大佬的博客，CSS 代码参考这篇文章。 注意：最新版本的主题已支持，无需添加代码，直接设置animated即可。 页脚加上微信二维码主题默认的微信订阅个人感觉不美观，看到很多网站都是在页脚有个微信的 LOGO，然后鼠标移动到上面便会显示二维码，这样感觉很棒。 首先编辑文件，在文件最后加上下面代码： # 文件位置：~/blog/themes/next/layout/_partials/footer.swig &lt;div class=&quot;weixin-box&quot;&gt; &lt;div class=&quot;weixin-menu&quot;&gt; &lt;div class=&quot;weixin-hover&quot;&gt; &lt;div class=&quot;weixin-description&quot;&gt;微信扫一扫，订阅本博客&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 然后编辑custom.styl，加入： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的页脚微信订阅号样式 .weixin-box { position: absolute; bottom: 43px; left: 10px; border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35); } .weixin-menu { position: relative; height: 24px; width: 24px; cursor: pointer; background: url(https://微信的logo.svg); background-size: 24px 24px; } .weixin-hover { position: absolute; bottom: 0px; left: 0px; height: 0px; width: 0px; border-radius: 3px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background: url(https://二维码.svg); background-color: #fff; background-repeat: no-repeat; background-size: 150px 150px; transition: all 0.35s ease-in-out; z-index: 1024; opacity: 0; } .weixin-menu:hover .weixin-hover { bottom: 24px; left: 24px; height: 170px; width: 150px; opacity: 1; } .weixin-description { opacity: 0; position: absolute; bottom: 3%; left: 5%; right: 5%; font-size: 12px; transition: all 0.35s cubic-bezier(1, 0, 0, 1); } .weixin-menu:hover .weixin-description { opacity: 1; } 图片务必用矢量图 SVG 格式，否则手机上显示效果很差，其它的自己看情况更改。微信 LOGO 的图片我准备好了，点击下载 wechat.svg (1.6KB)。微信订阅号的二维码怎么弄成 SVG 格式呢，安利个网站，下载 SVG 格式的就行。最后，我参考了这个代码。 更改标签云（tagcloud）的颜色如果你和我一样个性化了博客的整体布局颜色，那么默认的标签云页面可能看起来很丑，怎么更改？修改下文件： # 文件位置：~/blog/themes/next/layout/page.swig {{ tagcloud({min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'}) }} 修改对应参数值即可，参数说明见 Hexo 官方文档，颜色可以参考这个网站，自己去纠结…… 点击侧栏头像回到博客首页不知道为什么，我看到侧栏头像的第一反应是点击，然后心理预期会跳到博客首页，可惜也仅是预期，那么开始动手吧～首先要在主题配置文件中配置好，比如我把头像avatar.gif放在~/blog/source/uploads/下，则： # 文件位置：~/blog/themes/next/_config.yml # Sidebar Avatar # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif -#avatar: /images/avatar.gif +avatar: /uploads/avatar.gif 然后编辑文件： # 文件位置：~/blog/themes/next/layout/_macro/sidebar.swig + &lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;{{ url_for( theme.avatar | default(theme.images + '/avatar.gif') ) }}&quot; alt=&quot;{{ theme.author }}&quot; /&gt; + &lt;/a&gt; 文章摘要图片俗话说：「图文并茂」，现实中用笔书写文章实现起来比较困难，但在博客上可以很轻松实现😎。首先，文章摘要（excerpt）是指每篇文章（post）在页面（page）上显示的那部分内容，也就是 [Read More] 之前的文章内容。由于它会展示在页面，因此在每篇文章的文章摘要中加一张图片，页面看起来就很美观。但是有时候可能会出现一个问题：你想从文章中选一张图片作为文章摘要图片，而这张图片由于写作要求，必须添加在文章的末尾，这样点 [Read More] 查看文章时，这张图片就会重复出现了。咋办？ 前提是在主题配置文件中： # 文件位置：~/blog/themes/next/_config.yml excerpt_description: false auto_excerpt: enable: false 首先加代码： # 文件位置：~/blog/themes/next/layout/_macro/post.swig {% if is_index %} {% if post.description and theme.excerpt_description %} {{ post.description }} {{ __('post.read_more') }} &raquo; {% elif post.excerpt %} {{ post.excerpt }} + + {% if post.image %} + + + + {% endif %} + &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;{{ url_for(post.path) }}{% if theme.scroll_to_more %}#{{ __('post.more') }}{% endif %}&quot; rel=&quot;contents&quot;&gt; {{ __('post.read_more') }} &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; 为了防止有的图片宽度不够导致风格不够统一，页面不美观，需要在custom.styl中加入： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的文章摘要图片样式 img.img-topic { width: 100%; } 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： image: url url即图片的链接地址～ 参考： issue：https://github.com/iissnan/hexo-theme-next/issues/1190 文章：http://wellliu.com/2016/12/30/【转】Blog摘要配图/ 文章置顶由于博客的首页可能是被浏览最多的页面，所以首页的前几篇文章被阅读的可能性比较大。可以利用这个特点，通过将自己认为重要的文章放在首页，从而让重要的文章被阅读的可能性增大😄。但是，默认的排序只有一个维度——时间，两种选择——正序和倒序，这就造成自己的得意之作被埋没了，怎么办呢，如何实现文章的置顶？ NexT 主题以前有过这个功能，然而由于一些 bugs（issue）被去掉了。不过在这个丰富的 issue 中，我自己摸索出了一种解决方法，参考了 issue 中的那篇文章。 首先移除默认安装的插件： # 所在目录：~/blog/ npm uninstall hexo-generator-index --save 然后安装新插件： # 所在目录：~/blog/ npm install hexo-generator-index-pin-top --save 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以---分隔的区域）加上一行： top: true 然后就行了。如果你置顶了多篇，怎么控制顺序呢？设置top的值（大的在前面），比如： # Post a.md title: a top: 1 # Post b.md title: b top: 10 那么文章 b 便会显示在文章 a 的前面。可是，没有任何标记啊，读者怎么知道文章置顶了😂～还好 NexT 原有的置顶功能有考虑到这个，且置顶的样式没有被移除，所以可以直接利用，编辑文件： # 文件位置：~/blog/node_modules/hexo-generator-index-pin-top/lib/generator.js &#39;use strict&#39;; var pagination = require(&#39;hexo-pagination&#39;); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.sticky &amp;&amp; b.sticky) { // 两篇文章sticky都有定义 if(a.sticky == b.sticky) return b.date - a.date; // 若sticky值一样则按照文章日期降序排 else return b.sticky - a.sticky; // 否则按照sticky值降序排 } else if(a.sticky &amp;&amp; !b.sticky) { // 以下是只有一篇文章sticky有定义，那么将有sticky的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.sticky &amp;&amp; b.sticky) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || &#39;page&#39;; return pagination(&#39;&#39;, posts, { perPage: config.index_generator.per_page, layout: [&#39;index&#39;, &#39;archive&#39;], format: paginationDir + &#39;/%d/&#39;, data: { __index: true } }); }; 也就是将插件的top全部替换为 NexT 原有的sticky，然后将Front-matter中的top替换为sticky，就能调用 NexT 主题原有的置顶样式了。 最后可以自定义一下样式： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的文章置顶样式 .post-sticky-flag { font-size: inherit; float: left; color: rgb(0, 0, 0); cursor: help; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .post-sticky-flag:hover { color: #07b39b; } 已发现的 bug：新安装的插件无法实现站点配置文件中order_by: date，即文章按时间从旧到新排列的配置，也就意味着文章只能按默认的时间从新到旧排列。 背景图片1）CSS # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 背景图片 body::before { background-image: url(https://背景图.jpg); background-repeat: no-repeat; background-size: cover; background-position: 50% 50%; content: &quot; &quot;; position: fixed; width: 100%; height: 100%; top: 0; left: 0; z-index: -2; } 2）jquery-backstretch # 文件位置：~/blog/themes/next/layout/_layout.swig + &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js&quot;&gt;&lt;/script&gt; + &lt;script&gt; + $(&quot;body&quot;).backstretch(&quot;https://背景图.jpg&quot;); + &lt;/script&gt; &lt;/body&gt; 加入到文件最后面&lt;/body&gt;前面即可。你可以浏览器按 F12 查看我的页面，就可以在&lt;/body&gt;前发现。幻灯片等更多用法请自行查看 GitHub 上的 README。 动态效果可以在主题配置文件_config.yml里的motion中配置，但是如果你和我一样更改了博客的背景色，可能不能达到很好的效果，怎么办呢？参考这里，修改下面两个文件的相应内容。 ~/blog/themes/next/source/css/_common/components/post/post.styl ~/blog/themes/next/source/js/src/motion.js 相关╱热门╱推荐文章https://io-oi.me/tech/related-popular-recommended-posts.html MathJax 的静态显示（svg）https://io-oi.me/tech/hexo-mathjax-svg.html 加速 Hexo 博客https://io-oi.me/tech/speed-up-hexo.html 往归档页面加入 12 生肖https://io-oi.me/tech/add-chinese-zodiac-to-next.html 进阶 写出优雅文章博客搭好了，只能说有个漂亮的外壳，内容丰富且颜值高的文章才是真正的精华。文章内容只能靠自己，不过这里教你几招提高文章颜值的方法。写文章前请先查看 Hexo 官方文档之写作，写得很棒！ 文章的模版文件如果你是在站点文件夹根目录用hexo new post &lt;title&gt;新建的文章，那么其实它就是将文章的模版文件post.md「复制」了一份到~/blog/source/_posts/下，所以这也意味着： 你可以直接通过在~/blog/source/_posts/下新建.md结尾的文件来写新的文章。 你可以通过自定义文章的模版文件，从而每次命令行新建的文章都会有你自定义的内容。 注意：如果自己直接新建文件，一定要记得加上文件最上方的参数，即下面的相关内容，还有编码请用 UTF-8。 关于文件最上方的参数，参见 Hexo 官方文档的 Front-matter 和页面变量，下面是我的总结： /* ！！！！！！！！！！ ** 每一项的 : 后面均有一个空格 ** 且 : 为英文符号 ** ！！！！！！！！！！ */ title: /* 文章标题，可以为中文 */ date: /* 建立日期，如果自己手动添加，请按固定格式 ** 就算不写，页面每篇文章顶部的发表于……也能显示 ** 只要在主题配置文件中，配置了 created_at 就行 ** 那为什么还要自己加上？ ** 自定义文章发布的时间 */ updated: /* 更新日期，其它与上面的建立日期类似 ** 不过在页面每篇文章顶部，是更新于…… ** 在主题配置文件中，是 updated_at */ permalink: /* 若站点配置文件下的 permalink 配置了 title ** 则可以替换文章 URL 里面的 title（文章标题） */ categories: /* 分类，支持多级，比如： - technology - computer - computer-aided-art 则为 technology/computer/computer-aided-art （不适用于 layout: page） */ tags: /* 标签 ** 多个可以这样写 [标签1,标签2,标签3] ** （不适用于 layout: page） */ description: /* 文章的描述，在每篇文章标题下方显示 ** 并且作为网页的 description 元数据 ** 如果不写，则自动取 &lt;!-- more --&gt; ** 之前的文字作为网页的 description 元数据 */ keywords: /* 关键字，并且作为网页的 keywords 元数据 ** 如果不写，则自动取 tags 里的项 ** 作为网页的 keywords 元数据 */ comments: /* 是否开启评论 ** 默认值是 true ** 要关闭写 false */ layout: /* 页面布局，默认值是 post，默认值可以在 ** 站点配置文件中修改 default_layout ** 另：404 页面可能用到，将其值改为 false */ type: /* categories，目录页面 ** tags，标签页面 ** picture，用来生成 group-pictures ** quote？ ** https://io-oi.me/tech/test.html */ photos: /* Gallery support，用来支持画廊╱相册，用法如下： - photo_url_1 - photo_url_2 - photo_url_3 https://io-oi.me/tech/test.html */ link: /* 文章的外部链接 ** https://io-oi.me/tech/test.html */ image: /* 自定义的文章摘要图片，只在页面展示，文章内消失 ** 此项只有参考本文 5.14 节配置好，否则请勿添加！ */ sticky: /* 文章置顶 ** 此项只有参考本文 5.15 节配置好，否则请勿添加！ */ password: /* 文章密码，此项只有参考教程： ** http://shenzekun.cn/hexo的next主题个性化配置教程.html ** 第 24 节，配置好，否则请勿添加！ ** 发现还是有 bug 的，就是右键在新标签中打开 ** 然后无论是否输入密码，都能看到内容 */ 灵活利用 permalink，如果你是一个和我一样希望文章 URL 中不会出现中文的人。 使用 Markdown（必读）用 Hexo 写文章是直接用 Markdown 写的，而不是像 WordPress 有一个类似 Word 一样的文字编辑器，所以第一次用会感觉有点难，但你熟练之后，就会觉得文字编辑器都是辣鸡🌚… Markdown 简介Markdown 的目标是实现「易读易写」。 不过最需要强调的便是它的可读性。一份使用 Markdown 格式撰写的文件应该可以直接以纯文字发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大灵感来源其实是纯文字的电子邮件格式。 因此 Markdown 的语法全由标点符号所组成，并经过严谨慎选，是为了让它们看起来就像所要表达的意思。像是在文字两旁加上星号，看起来就像强调。Markdown 的清单看起来，嗯，就是清单。假如你有使用过电子邮件，区块引言看起来就真的像是引用一段文字。[^5] Markdown 教程这是写文章必须掌握的技能哦，一开始可能比较懵，因为大脑没有相关概念，无法将 Markdown 语法「翻译」成相应样式，不过多写几篇就好啦🙊。 Markdown 语法说明 Markdown 教程 我个人的总结1）文章内标题请从二级标题（##）开始！2）英语单词、数字左右看情况加上空格！3）Markdwon 文档写完一段回车后务必再回车一次空一行！ 如何使用 emoji在这个表情横行的时代，使用 emoji 似乎已经是日常。之前一直搜索相关插件，安装了很多，但都失败了。后来发现，直接 Copy &amp; Paste 就能用😆，可以去这个网站 Copy。但是有个缺点，就是不同系统，不同浏览器，渲染的效果不同，有些甚至不能显示。为什么呢？因为这种方法 Copy 的是 Unicode，因此显示时有上面这个缺点，但是我们也可以直接调用图片，保证显示效果一致。另：无论主题配置文件中的 fancybox 的值是 true 还是 false，对下面这种方法都没太大影响✌。 首先安装插件： # 所在目录：~/blog/ npm install hexo-filter-github-emojis --save 然后在站点配置文件的适当位置中加入： # 文件位置：~/blog/_config.yml githubEmojis: enable: true - className: github-emoji + idName: github-emoji unicode: false styles: localEmojis: 没错，加入的是idName这行而非className这行，为什么我要这样写？因为要编辑文件： Ctrl + F 搜索class，全部替换为id。 Ctrl + F 搜索title，更改相关代码，如下： # 文件位置：~/blog/node_modules/hexo-filter-github-emojis/index.js var codepoints = emojis[emojiName].codepoints if (options.unicode &amp;&amp; codepoints) { codepoints = codepoints.map(function (code) { return &#39;&amp;#x&#39; + code + &#39;;&#39; }).join(&#39;&#39;) return &#39;&lt;span id=&quot;&#39; + options.idName + &#39;&quot; &#39; + styles + - &#39; title=&quot;&#39; + emojiName + - &#39;&quot; data-src=&quot;&#39; + emojis[emojiName].src + + &#39; data-src=&quot;&#39; + emojis[emojiName].src + &#39;&quot;&gt;&#39; + codepoints + &#39;&lt;/span&gt;&#39; } else { return &#39;&lt;img id=&quot;&#39; + options.idName + &#39;&quot; &#39; + styles + - &#39; title=&quot;&#39; + emojiName + &#39;&quot; alt=&quot;&#39; + emojiName + &#39;&quot; src=&quot;&#39; + + &#39; alt=&quot;&#39; + emojiName + &#39;&quot; src=&quot;&#39; + emojis[emojiName].src + &#39;&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;&#39; } 由于 NexT 主题的相关样式会干扰 emoji 图片的显示效果，所以要在custom.styl中加代码： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl /* 里面的 color 值请改为你博客的！ */ // 自定义emoji样式 img#github-emoji { margin: 0px; padding: 0px; display: inline !important; vertical-align: text-bottom; border: none; cursor: text; box-shadow: none; } // 文章超链接样式（为emoji特设） .post-body a { color: rgb(80, 115, 184); border-bottom: none; text-decoration: underline; } .post-body a:hover { color: rgb(161, 102, 171); border-bottom: none; text-decoration: underline; } // 标签云页面超链接样式（为emoji特设） .tag-cloud a { color: rgb(80, 115, 184); border-bottom: 1px solid rgb(80, 115, 184); text-decoration: none; } .tag-cloud a:hover { color: rgb(161, 102, 171); border-bottom: 1px solid rgb(161, 102, 171); text-decoration: none; } // 文章元数据中categories的样式（为emoji特设） a.categories { color: rgb(80, 115, 184); border-bottom: none; text-decoration: underline; } a.categories:hover { color: rgb(161, 102, 171); border-bottom: none; text-decoration: underline; } // tabs标签（为emoji特设） .post-body .tabs ul.nav-tabs li.tab a { text-decoration: none; } // 图片下方标题设置（为emoji特设） a.fancybox{ text-decoration: none !important; } // 按钮样式（为emoji特设） .btn { color: #fff !important; text-decoration: none !important; border: 2px solid #222 !important; } .btn:hover { color: #222 !important; } 然后直接去 Emoji Cheat Sheet 点一下自己想要的表情复制，再粘贴到自己的文章中即可👻～而且用途不止于 emoji，手机里的各种表情包，传到自己的云存储，然后按照插件 README 中的写法： &lt;img id=&quot;github-emoji&quot; src=&quot;https://表情包.gif&quot; height=&quot;30&quot; width=&quot;30&quot; /&gt; 改下 URL，看情况改下 height 和 width 的值即可啦，GIF 也可以哦～当然，还有萌即正义的颜文字 (ﾉ*･ω･)ﾉ～ 问题 解答 调用的是哪里的 emoji 图片？ 由这个插件的 README 可知，调用 GitHub 的 API，写法也是按照 GitHub 的😉～ 为什么要将插件源码里的class改为id？ 按下 F12 可看到，开启 fancyBox 后，NexT 会为默认的图片标签（img）加上一个fancybox的class，里面有一个样式：display: block !important;，因为我们要让 emoji 显示在文字之间（display: inline;），但是由于默认的class已经加了!important，所以必须用样式规则的应用优先权高于class的id。 为什么要删除插件源码里的title？ 因为开启 fancyBox 后，NexT 会将图片的title显示在图片下方，显然不满足 emoji 的显示要求。 为什么要修改.post-body a的样式？ 因为开启 fancyBox 后，NexT 会将图片标签包裹在一个a标签内，而a标签是有下划线的，emoji 下面竟然有根线？显然不满足要求。 加进custom.styl的其它一大堆代码是什么鬼？ 补 bugs😑… 插入音乐和视频音乐的话，网易云音乐的外链很好用，不仅有可以单曲，还能有歌单，有兴趣的自己去网易云音乐找首歌尝试。但是有一些音乐因为版权原因放不了，还有就是不完全支持 https，导致小绿锁不见了。要解决这些缺点，就需要安装插件👽。 音乐1）直接用 HTML 的标签，写法如下： &lt;audio src=&quot;https://什么什么什么.mp3&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt; 2）用插件，有显示歌词功能，也美观。首先在站点文件夹根目录安装插件： # 所在目录：~/blog/ npm install hexo-tag-aplayer --save 然后文章中的写法： {% aplayer \"歌曲名\" \"歌手名\" \"https://什么什么什么.mp3\" \"https://封面图.jpg\" \"lrc:https://歌词.lrc\" %} 另外可以支持歌单： {% aplayerlist %} { \"autoplay\": false, \"showlrc\": 3, \"mutex\": true, \"music\": [ { \"title\": \"歌曲名\", \"author\": \"歌手名\", \"url\": \"https://什么什么什么.mp3\", \"pic\": \"https://封面图.jpg\", \"lrc\": \"https://歌词.lrc\" }, { \"title\": \"歌曲名\", \"author\": \"歌手名\", \"url\": \"https://什么什么什么.mp3\", \"pic\": \"https://封面图.jpg\", \"lrc\": \"https://歌词.lrc\" } ] } {% endaplayerlist %} 里面的详细参数见 README 和这插件的「母亲」Aplayer 的官方文档。关于 LRC歌词，可以用工具下载网易云音乐的歌词，另发现暂时不支持offset参数。当然，如果那歌词很操蛋，有错误（比如字母大小写和标点符号乱加）或者时间完全对不上，然后你也和我一样是个完美主义者，那接下来就是令人窒息的操作了，一句一句自己查看修改…… 什么，你想把网易云的几百首歌手动同步到博客😨？慢慢慢，有一种非常简单的方法，此这种方法也支持单曲，将参数里的playlist更改为song即可，非常建议食用！更多功能请仔细阅读 README。 视频1）直接用 HTML 的标签，写法如下： &lt;video poster=&quot;https://封面图.jpg&quot; src=&quot;https://什么什么什么.mp4&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 2）用插件，可支持弹幕，首先在站点文件夹根目录安装插件： # 所在目录：~/blog/ npm install hexo-tag-dplayer --save 然后文章中的写法： {% dplayer \"url=https://什么什么什么.mp4\" \"https://封面图.jpg\" \"api=https://api.prprpr.me/dplayer/\" \"id=\" \"loop=false\" %} 要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字😂生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。 当然，这个插件的功能还有很多，可以去 README 和这插件的「母亲」Dplayer 的官方文档看看。 好玩的写作样式用一些特殊的样式，可以增加文章的可读性。不过也不是越多越好，没必要写一篇文章就把下面的样式全部用一遍，这样只会适得其反，从下面的样式中选几个自己觉得比较好的、经常会用的就行。而且写博客重点是文章的文字内容，而不是这些样式，样式只是为了让文章更美观，更适合阅读。这和我们用 Markdown 写文章是一样的道理，用 Markdown 而不是直接写 HTML 代码，就是为了将更多时间花在文字上🐒。 主题自带样式 代码块高亮先看效果： # Java # 代码来自这：https://highlightjs.org/static/demo/ /** * @author John Smith &lt;john.smith@example.com&gt; */ package l2f.gameserver.model; public abstract class L2Char extends L2Object { public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) { _ai = null; log(&quot;Should not be called&quot;); if (1 &gt; 5) { // wtf!? return; } } } 这里指的是```代码块，而不是行内代码块（`代码`），它的用法如下： ```[language] [title] [url] [link-text] 代码 ``` [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加[]了，要这样写：[] [] [url] [link text]。 首先关于代码块颜色高亮，高亮的模式可以在主题配置文件中设置： # Code Highlight theme # Available value: # normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal 要颜色正确高亮，代码语言的名称肯定要写对，各种支持语言的名称可以查看这篇文章。当然，如果你和我一样懒，可以在站点配置文件_config.yml中设置自动高亮： # 文件位置：~/blog/_config.yml highlight: enable: true line_number: true # 代码自动高亮 - auto_detect: false + auto_detect: true 咦？发现了什么没有😳，红色-和绿色+的样式哪来的？哈哈哈，原来这也是一种语言，叫diff，所以你只需在 [language] 这写diff，然后在相应代码前面加上-和+就行了。 当然，要是你不满意顶部的文字样式，也可以自己在custom.styl自定义： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 文章```代码块顶部样式 .highlight figcaption { margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9; } .highlight figcaption a { color: rgb(80, 115, 184); } 参考了 Hexo 官方文档的标签插件页面，这个页面还有更多的 Hexo 标签插件（Tag Plugins）的用法，请自行查看。 主题自带样式 各种标签https://theme-next.org/docs/tag-plugins/ 自定义样式 数字块由于是自定义的样式，故要自己将 CSS 代码加到custom.styl中。为什么可以自定义呢？如果你是一个和我一样的小白，可以点击这里了解了解 CSS 中id和class的知识。 需加入custom.styl的代码： # 文件位置：~/blog/themes/next/source/css/_custom/custom.styl // 自定义的数字块 span#inline-toc { display: inline-block; border-radius: 80% 100% 90% 20%; background-color: rgb(227, 242, 253); color: #555; padding: 0.05em 0.4em; margin: 2px 5px 2px 0px; line-height: 1.5; } 使用： &lt;span id=&quot;inline-toc&quot;&gt;1.&lt;/span&gt; 参考：https://qianling.pw/style/#TOC数字块 结尾其实写这篇文章时，犯了一个很大的错误，把定制（customization）写成了优化（optimization），本文的内容都是个性化的定制，而非优化🌚… 然后毕竟只是小白，本文如有错误，欢迎评论指出～也欢迎你把这篇文章加入收藏夹，毕竟 NexT 主题一直在更新，会有一些新的功能和配置，这篇文章自然也会一直保持更新😄～ 不知道这篇文章有木有照亮你呢？为修改这篇文章博主光通宵就来了两次，如果你觉得这篇文章很赞，欢迎分享本文给更多像我一样的小白看到！感谢😘φ(≧ω≦*)♪～ 最后如果引用本文的内容，麻烦留个本文的链接，因为如果读者或我自己发现文章有错误，我会在这里更正，留个本文的链接，防止我暂时的疏漏耽误了他人宝贵的时间。 [^1]: https://github.com/ahonn/hexo-theme-even/issues/69↑[^2]: http://lovekernel.com/2017/hexo博客构建笔记/↑[^3]: http://lovekernel.com/2017/hexo博客构建笔记/↑[^4]: https://leaferx.online/2017/06/16/use-gulp-to-minimize/↑[^5]: http://markdown.tw/↑","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"转载","slug":"转载","permalink":"https://blog.xiongtianci.com/categories/转载/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.xiongtianci.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://blog.xiongtianci.com/tags/博客/"},{"name":"Pages","slug":"Pages","permalink":"https://blog.xiongtianci.com/tags/Pages/"}],"author":"天赐"},{"title":"git push报错：The current branch master has no upstream branch","slug":"git-push报错：The-current-branch-master-has-no-upstream-branch","date":"2019-06-12T06:22:18.000Z","updated":"2025-10-26T01:44:38.700Z","comments":true,"path":"2019/06/12/git-push报错：The-current-branch-master-has-no-upstream-branch/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/12/git-push报错：The-current-branch-master-has-no-upstream-branch/","excerpt":"","text":"问题进行git push操作时报错：fatal: The current branch master has no upstream branch. 原因：没有将本地的分支与远程仓库的分支进行关联通过git branch查看本地分支只有master 通过git branch -a查看远程分支，有master和remotes/origin/master两个 这时由于远程仓库太多，且分支较多。在默认情况下，git push时一般会上传到origin下的master分支上，然而当repository和branch过多，而又没有设置关联时，git就会产生疑问，因为它无法判断你的push目标 解决方式一使用git push --set-upstream origin master命令 方式二使用git push -u origin master命令","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"},{"name":"Git","slug":"Git","permalink":"https://blog.xiongtianci.com/tags/Git/"}],"author":"天赐"},{"title":"hexo常用命令汇总","slug":"hexo常用命令汇总","date":"2019-06-12T01:32:47.000Z","updated":"2025-10-26T01:44:38.734Z","comments":true,"path":"2019/06/12/hexo常用命令汇总/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/12/hexo常用命令汇总/","excerpt":"","text":"# 新建文章 hexo n # 清除缓存 hexo clean # 生成静态页面+部署 hexo d -g # 等同：hexo g &amp;&amp; hexo d # 生成静态网页 hexo g # 部署 hexo d # 启动服务器预览 hexo s 建站# 安装hexo npm install hexo -g # 升级hexo npm update hexo -g # hexo初始化 hexo init # 查看node.js版本号 node -v # 查看npm版本号 npm -v # 查看git版本号 git --version # 查看hexo版本号 hexo -v 插件安装和卸载# 安装插件 npm install hexo-xxx-xxx --save # 卸载插件 npm uninstall hexo-xxx-xxx --save 指令简写 指令 简写 描述 hexo new hexo n 新建文章 hexo generate hexo g 生成静态文件 hexo deploy hexo d 部署 hexo server hexo s 启动服务预览 hexo publish hexo p 发表草稿 注: hexo clean 没有简写, git --version 没有简写 init# 新建一个网站 $ hexo init [folder] 如果没有设置folder，Hexo默认在当前文件夹建立网站 new# 新建一篇文章,文章名称和标题为 [title],文章采用 [layout] 布局 $ hexo new [layout] &lt;title&gt; 会在目录source/_posts下生成 [title].md 文件，[title].md文件的顶部会使用---分割区域，也称作Front matter区如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替（一般默认是post）。如果标题包含空格的话，请使用引号括起来。 # eg $ hexo new &quot;post title with whitespace&quot; generate# 生成静态文件 $ hexo generate $ hexo g 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将/blog/source/下面的.md后缀的文件编译为.html后缀的文件,存放在/blog/public/路径下 publish# 发表草稿 $ hexo publish [layout] &lt;filename&gt; hexo publish [layout] &lt;title&gt; 通过 publish 命令将草稿移动到 source/_posts 文件夹如:$ hexo publish [layout] &lt;title&gt;，草稿默认是不会显示在页面中的，可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true来预览草稿。 server# 启动服务器（常用于调试） $ hexo server $ hexo s 默认情况下，访问网址为： http://localhost:4000/。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。 选项 描述 eg -p, --port 重设端口 hexo s -p 5000 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 -i 自定义IP hexo s -i 192.168.1.1 deploy# 部署网站,将本地数据部署到远端服务器(如github、coding) $ hexo deploy $ hexo d 参数 描述 -g, --generate 部署之前预先生成静态文件 render# 渲染文件 $ hexo render &lt;file1&gt; [file2] ... 参数 描述 -o, --output 设置输出路径 migrate$ hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean# 清除缓存,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 $ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list# 列出网站资料 $ hexo list &lt;type&gt; version# 显示 Hexo 版本 $ hexo version 选项安全模式$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式$ hexo --silent 隐藏终端信息。 自定义配置文件的路径$ hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD$ hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。 参考 hexo官方文档 hexo常用命令笔记","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.xiongtianci.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://blog.xiongtianci.com/tags/博客/"}],"author":"天赐"},{"title":"git常用命名汇总","slug":"git常用命名汇总","date":"2019-06-12T01:24:41.000Z","updated":"2025-10-26T01:44:38.718Z","comments":true,"path":"2019/06/12/git常用命名汇总/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/12/git常用命名汇总/","excerpt":"","text":"常用将本地项目初始化# git init # 给项目添加远程仓库 git remote add origin git@github.xxx.git # 本地分支和远程分支建立联系(使用git branch -vv 可以查看本地分支和远程分支的关联关系) git branch --set-upstream-to=origin/远程分支 本地分支 # 首次提交,推送到master并关联此分支 git push -u origin master 合并分支# 合并指定分支到当前分支 git merge [branch-name] # 查看分支的合并情况 # 简略信息 git log --graph --pretty=oneline --abbrev-commit # 详细信息 git log --graph 查看# 查看工作目录和暂存区的状态 git status # 查看工作区与暂存区的差异 git diff # 查看某个文件的工作区与暂存区的差异 git diff file.txt # 查看日志，一个压缩后的每一条提交记录只占一行的输出 git log --pretty=oneline # 查看命令历史 git reflog # ----分支 # 查看git本地分支 git branch # 查看git远程分支 git branch -r # 查看所有本地分支和远程分支，远程分支为红色 git branch -a # 查看每个本地分支的最后一次提交 git branch -v # 查看本地分支和远程分支联系 git branch -vv # 切换git分支 git checkout branch-name # 创建分支 git branch branch-name # 新建并切换git分支 git checkout -b branch-name # 删除git分支 git branch -d branch-name # 强制删除git分支 git branch -D branch-name # 删除git远程分支 git push origin -d branch-name # 本地分支和远程分支建立联系 git branch --set-upstream-to=origin/远程分支 本地分支 # 查看git 配置 git config -l # 把远程分支迁到本地分支 git checkout develop origin/develop # 把远程分支迁到本地顺便切换到该分支 git checkout -b develop origin/develop # 修改远程仓库地址 git remote set-url origin git@github.xxx.git # 本地分支回滚到指定版本 git reset --hard &lt;commit ID号&gt; # 强制推送到远程分支 git push -f origin &lt;branch name&gt; 版本回退# 回退到上一个版本 HEAD表示当前版本 git reset --hard HEAD^ git reset --hard HEAD~1 # 回退到指定版本(版本号可以只写前几位,一般写前4位即可) git reset --hard 56db0ffa425e86bd999683e6b9903e1196290def # 放弃工作区某个文件的修改 git checkout -- file # 把暂存区某个文件的修改撤销掉 git reset HEAD &lt;file&gt; 删除commit记录何时需要删除Git提交的历史记录 当历史记录中出现过密码等敏感信息在历史记录中, 需要删除历史记录时 当项目因历史记录过多, 导致历史记录占用了大量内存时, 比如Github仓库个人总容量时1GB不够用时 当你想要一个全新的项目的时候, 并且想保持项目代码不变 # 1. 创建全新的孤立分支 latest_branch git checkout --orphan latest_branch # 2. 暂存所有文件 git add -A # 3. 提交所有文件的修改到latest_branch git commit -am &quot;del all history&quot; # 4. 删除原来的master分支 git branch -D master # 5. 修改latest_branch分支名为master git branch -m master # 6. 强制更新远程服务器的master分支, 至此清空git所有历史 git push -f origin master 修改commit注释# 修改最近一次 git commit --amend git commit --amend -m &quot;an updated commit message&quot; # 修改最近多次 # pick -&gt; edit git rebase -i HEAD~n # 编辑注释信息 git commit --amend # 保存 git rebase --continue 修改完后通过git push -f remote branch强制更新到远程仓库 新建代码库# 在当前目录新建一个Git代码库 git init # 新建一个目录，将其初始化为Git代码库 git init [project-name] # 下载一个项目和它的整个代码历史 git clone [url] git initgit init命令将当前目录转为git仓库它会在当前目录下生成一个.git子目录，在其中写入git的配置和项目的快照 # 在当前目录新建一个Git代码库 git init # 新建一个目录，将其初始化为Git代码库 git init [project-name] git clonegit clone命令用于克隆远程分支 # 下载一个项目和它的整个代码历史 git clone [url] # 将alpha目录（必须是git代码仓库），克隆到delta目录 # bare参数表示delta目录只有仓库区，没有工作区和暂存区，即delta目录中就是.git目录的内容 git clone alpha delta --bare 配置# 显示当前的Git配置 git config --list # 编辑Git配置文件 git config -e [--global] # 设置提交代码时的用户信息 git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email address]&quot; git configGit的设置文件为.gitconfig，它可以在用户主目录下，也可以在项目目录下 # 显示当前的Git配置 git config --list git config -l # 编辑Git配置文件 git config -e [--global] # 设置提交代码时的用户信息 # 参数 # 1.系统级别：--system # 2.用户全局：--global # 3.单独一个项目：--local git config --global user.name &quot;xxxx&quot; #用户名 git config --global user.email &quot;xxxx@xxx.com&quot; #邮箱 git config --global core.editor vim #编辑器 git config --global alias.st status #按这种方法，配置别名 增加/删除文件# 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 git add . # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] git addgit add命令用于将变化的文件，从工作区提交到暂存区。它的作用就是告诉 Git，下一次哪些变化需要保存到仓库区。用户可以使用git status命令查看目前的暂存区放置了哪些文件。 # 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 # 会把当前目录中所有有改动的文件（不包括.gitignore中要忽略的文件）都添加到git缓冲区以待提交 git add . # 会把当前目录中所有有改动的文件（包括.gitignore中要忽略的文件）都添加到git缓冲区以待提交 git add * #&lt;不推荐&gt; 参数-u参数表示只添加暂存区已有的文件（包括删除操作），但不添加新增的文件。 git add -u -A或者--all参数表示追踪所有操作，包括新增、修改和删除 Git 2.0 版开始，-A参数成为默认，即git add .等同于git add -A git add -A -f参数表示强制添加某个文件，不管.gitignore是否包含了这个文件。 git add -f &lt;fileName&gt; -p参数表示进入交互模式，指定哪些修改需要添加到暂存区。即使是同一个文件，也可以只提交部分变动。 # 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交 git add -p 注意，Git 2.0 版以前，git add默认不追踪删除操作。即在工作区删除一个文件后，git add命令不会将这个变化提交到暂存区，导致这个文件继续存在于历史中。Git 2.0 改变了这个行为。 git rmgit rm命令用于删除文件。 # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] git mv# 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区 git commit -m [message] # 提交暂存区的指定文件到仓库区 git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 git commit -a # 提交时显示所有diff信息 git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 git commit --amend &lt;file1&gt; &lt;file2&gt; ... git commitgit commit命令用于将暂存区中的变化提交到仓库区。-m参数用于指定 commit 信息，是必需的。如果省略-m参数，git commit会自动打开文本编辑器，要求输入。 # 提交暂存区到仓库区 git commit -m &quot;message&quot; # 提交暂存区的指定文件到仓库区 # 将工作区中指定文件的变化，先添加到暂存区，然后再将暂存区提交到仓库区 git commit [file1] [file2] ... -m [message] 参数-m-m参数用于添加提交说明如果没有指定提交说明，运行 commit 会直接打开默认的文本编辑器，让用户撰写提交说明 git commit -m &quot;message&quot; -a-a参数用于先将所有工作区的变动文件，提交到暂存区，再运行git commit。用了-a参数，就不用执行git add .命令了。 # 提交工作区自上次commit之后的变化，直接到仓库区 git commit -am &quot;message&quot; –allow-empty--allow-empty参数用于没有提交信息的 commit git commit --allow-empty –amend–amend参数用于撤销上一次 commit，然后生成一个新的 commit # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 git commit --amend &lt;file1&gt; &lt;file2&gt; ... –fixup--fixup参数的含义是，当前添加的 commit 是以前某一个 commit 的修正。以后执行互动式的git rebase的时候，这两个 commit 将会合并成一个。 # 提交说明将自动生成，即在目标 commit 的提交说明的最前面，添加&quot;fixup!&quot;这个词 git commit --fixup &lt;commit&gt; –squash--squash参数的作用与--fixup类似，表示当前添加的 commit 应该与以前某一个 commit 合并成一个，以后执行互动式的git rebase的时候，这两个 commit 将会合并成一个。 git commit --squash &lt;commit&gt; 分支# 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 列出所有本地分支和远程分支 git branch -a # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch-name] # 新建一个分支，指向指定commit git branch [branch-name] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch-name] [remote-branch] # 切换到指定分支，并更新工作区 git checkout [branch-name] # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch-name] [remote-branch] # 合并指定分支到当前分支 git merge [branch-name] # 选择一个commit，合并进当前分支 git cherry-pick [commit] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete &lt;branch-name&gt; git branch -dr &lt;remote/branch&gt; git branchgit branch是分支操作命令 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 列出所有本地分支和远程分支 git branch -a 新建一个分支直接在git branch后面跟上分支名，就表示新建该分支 # 新建一个分支，但依然停留在当前分支 git branch branch-name 新建一个分支，指向当前 commit。本质是在refs/heads/目录中生成一个文件，文件名为分支名，内容为当前 commit 的哈希值 注意：创建后，还是停留在原来分支，需要用git checkout切换到新建分支 # 切换到指定分支，并更新工作区 git checkout branch-name 使用 -b 参数，可以新建的同时切换到新分支（如果已存在同名分支，则报错） # 新建一个分支，并切换到该分支 git checkout -b NewBranch [MyBranch] 使用 -B 参数，会强制创建新的分支（如果已存在同名分支，新建分支会覆盖掉原来的分支） git checkout -b NewBranch [MyBranch] 新建一个空分支# 使用 --orphan 参数创建一个没有父级与其他分支断开的空分支 git checkout --orphan branch-name # 删除所有文件 git rm -rf . 删除分支-d参数用来删除一个分支，前提是该分支没有未合并的变动 # 删除分支 git branch -d &lt;branch-name分支名&gt; 强制删除一个分支，不管有没有未合并变化 git branch -D &lt;branch-name分支名&gt; 删除远程分支 # 删除远程分支 git push origin --delete &lt;branch-name&gt; git branch -dr &lt;remote/branch&gt; 分支改名# 新建一个分支 git checkout -b twitter-experiment feature132 # 删除原来的分支，使用新的分支，从而达到重命名操作 git branch -d feature132 另一种写法 # 为当前分支改名 git branch -m twitter-experiment # 为指定分支改名 git branch -m feature132 twitter-experiment # 如果有重名分支，强制改名 git branch -m feature132 twitter-experiment 查看 merge 情况# 显示全部合并到当前分支的分支 git branch --merged # 显示未合并到当前分支的分支 git branch --no-merged 拉取远程所有分支 Stack Overflow git branch -r | grep -v &#39;-&gt;&#39; | while read remote; do git branch --track &quot;${remote#origin/}&quot; &quot;$remote&quot;; done git fetch --all git pull --all git merge合并指定分支到当前分支 # 合并指定分支到当前分支 git merge [branch] # 合并指定分支到当前分支(生成一个新的提交记录) git merge --no-ff [branch] git cherry-pickgit cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交 # 选择一个commit，合并进当前分支 git cherry-pick [commit] Bug分支# 把未提交的修改(工作区和暂存区)储藏起来 git stash git stash save &quot;描述&quot; # 查看stash内容 git stash list # 恢复stash内容 git stash pop # 恢复指定stash内容 git stash apply stash@{0} # 删除stash内容 git stash drop 标签# 列出所有tag git tag # 新建一个tag在当前commit git tag [tag] # 新建一个tag在指定commit git tag [tag] [commit] # 新建带有说明的标签；通过 git show [tag] 查看 # -a 指定标签名；-m 指定说明文字 git tag -a [tag] -m [说明] [commit] # 删除标签(删除本地) git tag -d [tag] # 删除标签(删除远程,先删除本地) git push origin :refs/tags/[tag] # 查看tag信息 git show [tag] # 提交指定tag到远程 git push [remote] [tag] # 提交所有tag到远程 git push [remote] --tags # 新建一个分支，指向某个tag git checkout -b [branch] [tag] git taggit tag命令用于为 commit 打标签Tag 分两种：普通tag和注解tag只有annotated tag(注解tag) 才会产生 object git tag tmp # 生成.git/refs/tags/tmp git tag -a release git tag -a [VERSION] -m &quot;released [VERSION]&quot; 上面代码表示为当前commit打上一个带注解的标签，标签名为release普通标签的写法 git tag 1.0.0 git push --tags git tag v0.0.1 git push origin master --tags 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 查看信息# 显示有变更的文件 git status # 显示指定文件是什么人在什么时间修改过 git blame [file] # 显示暂存区和工作区的差异 git diff # 显示暂存区和上一个commit的差异 git diff --cached [&lt;file&gt;] # 显示工作区与当前分支最新commit之间的差异 git diff HEAD # 显示两次提交之间的差异 git diff [first-branch]...[second-branch] # 显示某次提交的元数据和内容变化 git show [commit] # 显示某次提交发生变化的文件 git show --name-only [commit] # 显示某次提交时，某个文件的内容 git show [commit]:[filename] # 显示当前分支的最近几次提交 git reflog git log# 显示当前分支的版本历史 git log # 显示commit历史，以及每次commit发生变更的文件 git log --stat # 显示某个文件的版本历史，包括文件改名 git log --follow [file] git whatchanged [file] # 显示指定文件相关的每一次diff git log -p [file] # 查看提交历史[简略信息] git log [--pretty=oneline] # 输出概要日志,这条命令等同于 # git log --pretty=oneline --abbrev-commit git log --oneline # git log --graph --pretty=oneline --abbrev-commit # 通过ASCII艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签 git log --graph --oneline --decorate --all # 提供类似GUI工具的 log 展示 git log --graph --date=relative --pretty=tformat:&#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%an %ad)%Creset&#39; # 只看某一个人的提交记录 git log --author=username # 看看哪些文件改变了 git log --name-status 远程同步git remote当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origingit remote查看远程库的信息 # 下载远程仓库的所有变动 git fetch [remote] # 查看远程库详细信息 # 显示可以抓取(fetch)和推送(push)的origin的地址；如果没有推送权限，就看不到push的地址 git remote -v # 显示某个远程仓库的信息 git remote show [remote] # 增加一个新的远程仓库，并命名 git remote add [shortname] [url] # 修改远程仓库地址 git remote set-url origin git@github.xxx.git # 取回远程仓库的变化，并与本地分支合并 git pull [remote] [branch] # 上传本地指定分支到远程仓库 git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force # 推送所有分支到远程仓库 git push [remote] --all 查看版本改动git diffgit diff命令用于查看文件之间的差异 在git提交环节，存在三大部分：working tree（工作区）, index file（暂存区：stage）, commit（分支：master） # 查看工作区与暂存区的差异 git diff # 查看某个文件的工作区与暂存区的差异 git diff file.txt # 查看暂存区与当前 commit 的差异 git diff --cached # 查看两个commit的差异 git diff &lt;commitBefore&gt; &lt;commitAfter&gt; # 查看暂存区与仓库区的差异 git diff --cached # 查看工作区与上一次commit之间的差异 # 即如果执行 git commit -a，将提交的文件 git diff HEAD # 查看工作区与某个 commit 的差异 git diff &lt;commit&gt; # 显示两次提交之间的差异 git diff [first-branch]...[second-branch] # 查看工作区与当前分支上一次提交的差异，但是局限于test文件 git diff HEAD -- ./test # 查看当前分支上一次提交与上上一次提交之间的差异 git diff HEAD -- ./test # 生成patch git format-patch master --stdout &gt; mypatch.patch 比较两个分支 # 查看topic分支与master分支最新提交之间的差异 git diff topic master # 与上一条命令相同 git diff topic..master # 查看自从topic分支建立以后，master分支发生的变化 git diff topic...master 版本回退# 恢复暂存区的指定文件到工作区 git checkout [file] # 恢复某个commit的指定文件到工作区 git checkout [commit] [file] # 恢复上一个commit的所有文件到工作区 git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 git revert [commit] .gitignore# 强制添加到Git git add -f &lt;filename&gt; # 查看某文件在.gitignore对应的过滤规则 git check-ignore -v &lt;filename&gt; 其他# 生成一个可供发布的压缩包 git archive # 删除未跟踪的目录和文件【慎用】 git clean -d -f HEAD表示当前版本，也就是最新的提交。上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写100个^ 比较容易数不过来，所以写成HEAD~100。HEAD~2相当于HEAD^^ 参考 廖雪峰官方网站、阮一峰 Git 教程","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.xiongtianci.com/tags/Git/"}],"author":"天赐"},{"title":"常用正则表达式公式","slug":"常用正则表达式公式","date":"2019-06-10T10:07:34.000Z","updated":"2025-10-26T01:44:38.683Z","comments":true,"path":"2019/06/10/常用正则表达式公式/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/10/常用正则表达式公式/","excerpt":"","text":"作者：艾欢欢 链接：收藏一波：常用正则表达式公式总结 校验数字的表达式一位数字： ^[0-9]\\*$ n位的数字： ^\\d{n}$ 至少n位的数字： ^\\d{n,}$ m-n位的数字： ^\\d{m,n}$ 零和非零开头的数字： ^(0|[1-9][0-9]\\*)$ 非零开头的最多带两位小数的数字： ^([1-9][0-9]\\*)+(\\.[0-9]{1,2})?$ 带1-2位小数的正数或负数： ^(\\-)?\\d+(\\.\\d{1,2})$ 正数、负数、和小数： ^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数： ^[0-9]+(\\.[0-9]{2})?$ 有1~3位小数的正实数： ^[0-9]+(\\.[0-9]{1,3})?$ 非零的正整数： ^[1-9]\\d\\*$ 或 ^([1-9][0-9]\\*){1,3}$ 或 ^\\+?[1-9][0-9]\\*$ 非零的负整数： ^\\-[1-9][]0-9&quot;\\*$ 或 ^-[1-9]\\d\\*$ 非负整数： ^\\d+$ 或 ^[1-9]\\d\\*|0$ 非正整数： ^-[1-9]\\d\\*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数： ^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*|0?\\.0+|0$ 非正浮点数： ^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*))|0?\\.0+|0$ 正浮点数： ^[1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*$ 或 ^(([0-9]+\\.[0-9]\\*[1-9][0-9]\\*)|([0-9]\\*[1-9][0-9]\\*\\.[0-9]+)|([0-9]\\*[1-9][0-9]\\*))$ 负浮点数： ^-([1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*)$ 或 ^(-(([0-9]+\\.[0-9]\\*[1-9][0-9]\\*)|([0-9]\\*[1-9][0-9]\\*\\.[0-9]+)|([0-9]\\*[1-9][0-9]\\*)))$ 浮点数： ^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d\\*\\.\\d\\*|0\\.\\d\\*[1-9]\\d\\*|0?\\.0+|0)$ 校验字符的表达式汉字： ^[\\u4e00-\\u9fa5]{0,}$ 英文和数字： ^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符： ^.{3,20}$ 由26个英文字母组成的字符串： ^[A-Za-z]+$ 由26个大写英文字母组成的字符串： ^[A-Z]+$ 由26个小写英文字母组成的字符串： ^[a-z]+$ 由数字和26个英文字母组成的字符串： ^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串： ^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线： ^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号： ^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 禁止输入含有~的字符： [^~\\x22]+ 特殊需求表达式Email地址： ^\\w+([-+.]\\w+)\\*@\\w+([-.]\\w+)\\*\\.\\w+([-.]\\w+)\\*$ 域名： [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL： [a-zA-z]+://[^\\s]\\* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]\\*)?$ 手机号码： ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 国内电话号码(0511-4405222、021-87888822)： \\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X： (^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： ^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)： ^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)： ^(?=.\\*\\d)(?=.\\*[a-z])(?=.\\*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)： ^(?=.\\*\\d)(?=.\\*[a-z])(?=.\\*[A-Z]).{8,10}$ 日期格式： ^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)： ^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)： ^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件： ^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式： [\\u4e00-\\u9fa5] 空白行的正则表达式： \\n\\s\\*\\r (可以用来删除空白行) HTML标记的正则表达式： &lt;(\\S\\*?)[^&gt;]\\*&gt;.\\*?|&lt;.\\*? /&gt; ( 首尾空白字符的正则表达式：^\\s\\*|\\s\\*$或(^\\s\\*)|(\\s\\*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号： [1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码： [1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址： ((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"},{"name":"转载","slug":"转载","permalink":"https://blog.xiongtianci.com/categories/转载/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://blog.xiongtianci.com/tags/正则/"}],"author":"天赐"},{"title":"一千行MySQL学习笔记","slug":"一千行MySQL学习笔记","date":"2019-06-05T09:41:17.000Z","updated":"2025-10-26T01:44:38.667Z","comments":true,"path":"2019/06/05/一千行MySQL学习笔记/","link":"","permalink":"https://blog.xiongtianci.com/2019/06/05/一千行MySQL学习笔记/","excerpt":"","text":"作者：Jioby 链接： https://shockerli.net/post/1000-line-mysql-note/ Windows服务-- 启动mysql net start mysql -- 创建windows服务(注意：等号与值之间有空格) sc create mysql binpath= mysqld_bin_path 连接与断开服务器-- 连接（地址、端口可不填，默认为localhost:3306） mysql -h 地址 -P 端口 -u 用户名 -p 密码 -- 显示哪些线程正在运行 show processlist -- 显示系统变量信息 show variables 数据库操作-- 查看当前数据库 select database(); -- 显示当前时间、用户名、数据库版本 select now(), user(), version(); -- 创建库 create database [if not exists] 数据库名 数据库选项 -- 数据库选项： character set charset_name collate collation_name -- 查看已有库 show databases [like &#39;pattern&#39;] -- 查看当前库信息 show create database 数据库名 -- 修改库的选项信息 alter database 库名 选项信息 -- 删除库 drop database[ if exists] 数据库名 -- 同时删除该数据库相关的目录及其目录内容 表的操作创建-- 创建表 create [temporary] table [if not exists] [库名.]表名 (表的结构定义) [表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 temporary 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [not null | null] [default default_value] [auto_increment] [unique [key] | [primary] key] [comment &#39;string&#39;] -- 表选项 -- 字符集 charset = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 engine = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：innodb myisam memory/heap bdb merge example csv maxdb archive 不同的引擎在保存表的结构和数据时采用不同的方式 myisam表文件含义：.frm表定义，.myd表数据，.myi表索引 innodb表文件含义：.frm表定义，表空间数据和日志文件 show engines -- 显示存储引擎的状态信息 show engine 引擎名 {logs|status} -- 显示存储引擎的日志或状态信息 -- 自增起始数 auto_increment = 行数 -- 数据文件目录 data directory = &#39;目录&#39; -- 索引文件目录 index directory = &#39;目录&#39; -- 表注释 comment = &#39;string&#39; -- 分区选项 partition by ... (详细见手册) 删除-- 删除表 drop table[ if exists] 表名 ... -- 清空表数据 truncate [table] 表名 查看-- 查看所有表 show tables [like &#39;pattern&#39;] show tables from 表名 -- 查看表机构 show create table 表名 （信息更详细） desc 表名 / describe 表名 / explain 表名 / show columns from 表名 [like &#39;pattern&#39;] show table status [from db_name] [like &#39;pattern&#39;] 其他-- 复制表结构 create table 表名 like 要复制的表名 -- 复制表结构和数据 create table 表名 [as] select * from 要复制的表名 -- 检查表是否有错误 check table tbl_name [, tbl_name] ... [option] ... -- 优化表 optimize [local | no_write_to_binlog] table tbl_name [, tbl_name] ... -- 修复表 repair [local | no_write_to_binlog] table tbl_name [, tbl_name] ... [quick] [extended] [use_frm] -- 分析表 analyze [local | no_write_to_binlog] table tbl_name [, tbl_name] ... 修改-- ### 修改表 ### -- 修改表本身的选项 alter table 表名 表的选项 eg: alter table 表名 engine=myisam; -- 对表进行重命名 rename table 原表名 to 新表名 rename table 原表名 to 库名.表名 （可将表移动到另一个数据库） -- rename可以交换两个表名 -- 修改表的字段机构（13.1.2. alter table语法） alter table 表名 操作名 -- 操作名 add[ column] 字段定义 -- 增加字段 after 字段名 -- 表示增加在该字段名后面 first -- 表示增加在第一个 add primary key(字段名) -- 创建主键 add unique [索引名] (字段名)-- 创建唯一索引 add index [索引名] (字段名) -- 创建普通索引 drop[ column] 字段名 -- 删除字段 modify[ column] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) change[ column] 原字段名 新字段名 字段属性 -- 支持对字段名修改 drop primary key -- 删除主键(删除主键前需删除其auto_increment属性) drop index 索引名 -- 删除索引 drop foreign key 外键 -- 删除外键 数据操作-- 增 insert [into] 表名 [(字段列表)] values (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ replace 与 insert 完全一样，可互换 insert [into] 表名 set 字段名=值[, 字段名=值, ...] -- 删 delete from 表名[ 删除条件子句] ⚠没有条件子句，则会删除全部 -- 查 select 字段列表 from 表名 [其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段 -- 改 update 表名 set 字段名=新值[, 字段名=新值] [更新条件] 字符集编码-- mysql、数据库、表、字段均可设置编码 -- 数据编码与客户端编码不需一致 show variables like &#39;character_set_%&#39; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码 set 变量名 = 变量值 set character_set_client = gbk; set character_set_results = gbk; set character_set_connection = gbk; set names gbk; -- 相当于完成以上三个设置 -- 校对集 校对集用以排序 show character set [like &#39;pattern&#39;]/show charset [like &#39;pattern&#39;] 查看所有字符集 show collation [like &#39;pattern&#39;] 查看所有校对集 charset 字符集编码 设置字符集编码 collate 校对集编码 设置校对集编码 数据类型(列类型)数值类型1. 数值类型 -- ### a.整型 ### 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(m) m表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&#39;123&#39;，补填后为&#39;00123&#39; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。mysql没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 -- ### b.浮点型 ### 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(m, d) double(m, d) m表示总位数，d表示小数位数。 m和d的大小会决定浮点数的范围。不同于整型的固定范围。 m既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。 -- ### c.定点数 ### decimal -- 可变长度 decimal(m, d) m也表示总位数，d表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。 字符串类型2. 字符串类型 -- ### a. char/varchar ### char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 m表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 create table tb(c1 int, c2 char(30), c3 varchar(n)) charset=utf8; 问n的最大值是多少？ 答：(65535-1-2-4-30*3)/3 -- ### b. blob/text ### blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 -- ### c. binary/varbinary ### 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. 日期时间类型3. 日期时间类型 一般用整型保存时间戳，因为php可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 -- ###### datetime yyyy-mm-dd hh:mm:ss timestamp yy-mm-dd hh:mm:ss yyyymmddhhmmss yymmddhhmmss yyyymmddhhmmss yymmddhhmmss date yyyy-mm-dd yy-mm-dd yyyymmdd yymmdd yyyymmdd yymmdd time hh:mm:ss hhmmss hhmmss year yyyy yy yyyy yy 枚举和集合4. 枚举和集合 -- 枚举(enum) ---------- enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 null值的索引是null。 空字符串错误值的索引值是0。 -- 集合（set） ---------- set(val1, val2, val3...) create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) ); insert into tab values (&#39;男, 女&#39;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，set成员值的尾部空格将自动被删除。 选择类型-- php角度 1. 功能满足 2. 存储空间尽量小，处理效率更高 3. 考虑兼容问题 -- ip存储 ---------- 1. 只需存储，可用字符串 2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned 1) php函数转换 ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。 利用sprintf函数格式化字符串 sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;)); 然后用long2ip将整型转回ip字符串 2) mysql函数转换(无符号整型，unsigned) inet_aton(&#39;127.0.0.1&#39;) 将ip转为整型 inet_ntoa(2130706433) 将整型转为ip 列属性（列约束）1. primary 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); 2. unique 唯一索引（唯一约束） 使得某字段的值也不能重复。 3. null 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &#39;val&#39;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null 4. default 默认值属性 当前字段的默认值。 insert into tab values (default, &#39;val&#39;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time 5. auto_increment 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x; 6. comment 注释 例：create table tab ( id int ) comment &#39;注释内容&#39;; 7. foreign key 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 mysql中，可以对innodb引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被innodb存储引擎所支持。其他引擎是不支持的。 建表规范-- normal format, nf - 每个表保存一个实体信息 - 每个具有一个id字段作为主键 - id主键 + 原子表 -- 1nf, 第一范式 字段不能再分，就满足第一范式。 -- 2nf, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3nf, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 部分依赖指的是某个（或多个）列依赖于别的列，且和其他的列没有任何直接关系。当表的设计中有部分依赖时，我们需要将一张表拆分成多张表，这些表包括基本信息表和关系表，从而消除数据的部分依赖。这和设计模式中常说的耦合是一个原则，要尽可能实现低耦合高内聚（low in coupling and high in cohesion)。 比如下面这张学生信息表： 学生编号 学生姓名 学生性别 老师名称 老师性别 1001 李小桐 男 张三 男 1002 徐小盼 女 张三 男 SQL语句selectselect [all|distinct] select_expr from -&gt; where -&gt; group by [合计函数] -&gt; having -&gt; order by -&gt; limit a. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb; b. from 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 select * from tb1 as tt, tb2 as bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 select * from tb1, tb2; -- 向优化符提示如何选择索引 use index、ignore index、force index select * from table1 use index (key1,key2) where key1=1 and key2=2 and key3=3; select * from table1 ignore index (key3) where key1=1 and key2=2 and key3=3; c. where 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较 d. group by 子句, 分组子句 group by 字段/别名 [排序方式] 分组后会进行排序。升序：asc，降序：desc 以下[合计函数]需配合 group by 使用： count 返回不同的非null值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非null值的字符串结果。组内字符串连接。 e. having 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行where代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having sql标准要求having必须引用group by子句中的列或用于合计函数中的列。 f. order by 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：asc，降序：desc 支持多个字段的排序。 g. limit 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数 h. distinct, all 选项 distinct 去除重复记录 默认为 all, 全部记录 union将多个select查询的结果组合成一个结果集合。 select ... union [all|distinct] select ... 默认 distinct 方式，即所有返回的行都是唯一的 建议，对每个select查询加上小括号包裹。 order by 排序时，需加上 limit 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 子查询-- 子查询需用括号包裹。 -- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1; -- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 row(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 连接查询(join) 将多个表的字段进行连接，可以指定连接条件。 -- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2; -- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充 -- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; /* 导入导出 */ ------------------ select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据 load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理 -- 控制格式 fields 控制字段格式 默认：fields terminated by &#39;\\t&#39; enclosed by &#39;&#39; escaped by &#39;\\\\&#39; terminated by &#39;string&#39; -- 终止 enclosed by &#39;char&#39; -- 包裹 escaped by &#39;char&#39; -- 转义 -- 示例： select a,b,a+b into outfile &#39;/tmp/result.text&#39; fields terminated by &#39;,&#39; optionally enclosed by &#39;&quot;&#39; lines terminated by &#39;\\n&#39; from test_table; lines 控制行格式 默认：lines terminated by &#39;\\n&#39; terminated by &#39;string&#39; -- 终止 insertselect语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 insert into tbl_name set field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 insert into tbl_name values (), (), (); 可以在列值指定时，使用表达式。 insert into tbl_name values (field_value, 10+10, now()); 可以使用一个特殊值 default，表示该列使用默认值。 insert into tbl_name values (field_value, default); 可以通过一个查询的结果，作为需要插入的值。 insert into tbl_name select ...; 可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 insert into tbl_name values/set/select on duplicate key update 字段=值, …; deletedelete from tbl_name [where where_definition] [order by ...] [limit row_count] 按照条件删除。where 指定删除的最多记录数。limit 可以通过排序条件删除。order by + limit 支持多表删除，使用类似连接语法。 delete from 需要删除数据多表1，表2 using 表连接操作 条件。 /* truncate */ ------------------ truncate [table] tbl_name 清空数据 删除重建表 区别： 1，truncate 是删除表再创建，delete 是逐条删除 2，truncate 重置auto_increment的值。而delete不会 3，truncate 不知道删除了几条，而delete知道。 4，当被用于带分区的表时，truncate 会保留分区 备份与还原备份，将数据的结构与表内数据保存起来。 利用 mysqldump 指令完成。 -- 导出 mysqldump [options] db_name [tables] mysqldump [options] ---database db1 [db2 db3...] mysqldump [options] --all--database 1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(d:/a.sql) 2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(d:/a.sql) 3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(d:/a.sql) 4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(d:/a.sql) 可以-w携带where条件 -- 导入 1. 在登录mysql的情况下： source 备份文件 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 视图什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 -- 创建视图 create [or replace] [algorithm = {undefined | merge | temptable}] view view_name [(column_list)] as select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过algorithm指定。 - column_list如果存在，则数目必须等于select语句检索的列数 -- 查看结构 show create view view_name -- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 drop view [if exists] view_name ... -- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 alter view view_name [(column_list)] as select_statement -- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构 -- 视图算法(algorithm) merge 合并 将视图的查询语句，与外部查询需要先合并再执行！ temptable 临时表 将视图执行完毕后，形成临时表，再做外层查询！ undefined 未定义(默认)，指的是mysql自主去选择相应的算法。 事务(transaction)事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续sql的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 innodb 或 bdb 存储引擎，对自动提交的特性支持完成。 - innodb被称为事务安全型引擎。 -- 事务开启 start transaction; 或者 begin; 开启事务后，所有被执行的sql语句均被认作当前事务内的sql语句。 -- 事务提交 commit; -- 事务回滚 rollback; 如果部分操作发生问题，映射到事务开启前。 -- 事务的特性 1. 原子性（atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。 -- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。 -- 事务的原理 利用innodb的自动提交(autocommit)特性完成。 普通的mysql执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。 -- 注意 1. 数据定义语言（ddl）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套 -- 保存点 savepoint 保存点名称 -- 设置一个事务保存点 rollback to savepoint 保存点名称 -- 回滚到保存点 release savepoint 保存点名称 -- 删除保存点 -- innodb自动提交特性设置 set autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与start transaction不同的是， set autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而start transaction记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表表锁定只用于防止其它客户端进行不正当地读取和写入 myisam 支持表锁，innodb 支持行锁 -- 锁定 lock tables tbl_name [as alias] lock_type [, tbl_name [[AS] alias] lock_type] ... -- lock_type: READ[LOCAL]| [LOW_PRIORITY] WRITE -- 解锁 unlock tables 触发器 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。 -- 创建触发器 create trigger trigger_name trigger_time trigger_event on tbl_name for each row trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 insert：将新行插入表时激活触发程序 update：更改某一行时激活触发程序 delete：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与temporary表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用begin...end复合语句结构 -- 删除 drop trigger [schema_name.]trigger_name 可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new. -- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。 -- 字符连接函数 concat(str1,str2,...]) concat_ws(separator,str1,str2,...) -- 分支语句 if 条件 then 执行语句 elseif 条件 then 执行语句 else 执行语句 end if; -- 修改最外层语句结束符 delimiter 自定义结束符号 sql语句 自定义结束符号 delimiter ; -- 修改回原来的分号 -- 语句块包裹 begin 语句块 end -- 特殊的执行 1. 只要添加记录，就会触发程序。 2. insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update 3. replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert SQL编程--// 局部变量 ---------- -- 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 -- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量） --// 全局变量 ---------- -- 定义、赋值 set 语句可以定义并为变量赋值。 set @var = value; 也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。 还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。 select @var:=20; select @v1:=id, @v2=name from t1 limit 1; select * from tbl_name where @var:=30; select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb; -- 自定义变量名 为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。 @var=10; - 变量被定义后，在整个会话周期都有效（登录到退出） --// 控制结构 ---------- -- if语句 if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; -- case语句 case value when [compare-value] then result [when [compare-value] then result ...] [else result] end -- while循环 [begin_label:] while search_condition do statement_list end while [end_label]; - 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环 --// 内置函数 ---------- -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date(&#39;yyyy-mm-dd hh:ii:ss&#39;); -- 获取日期部分 time(&#39;yyyy-mm-dd hh:ii:ss&#39;); -- 获取时间部分 date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 流程函数 case when [condition] then result [when [condition] then result ...] [else result] end 多分支 if(expr1,expr2,expr3) 双分支。 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); --// 存储函数，自定义函数 ---------- -- 新建 create function function_name (参数列表) returns 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。 -- 删除 drop function [if exists] function_name; -- 查看 show function status like &#39;partten&#39; show create function function_name; -- 修改 alter function function_name 函数选项 --// 存储过程，自定义功能 ---------- -- 定义 存储存储过程 是一段代码（过程），存储在数据库中的sql组成。 一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。 而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。 -- 创建 create procedure sp_name (参数列表) 过程体 参数列表：不同于函数的参数列表，需要指明参数类型 in，表示输入型 out，表示输出型 inout，表示混合型 注意，没有返回值。 存储过程存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。 调用：call 过程名 -- 注意 - 没有返回值。 - 只能单独调用，不可夹杂在其他语句中 -- 参数 in|out|inout 参数名 数据类型 in 输入：在调用过程中，将数据输入到过程体内部的参数 out 输出：在调用过程中，将过程体处理完的结果返回到客户端 inout 输入输出：既可输入，也可输出 -- 语法 create procedure 过程名 (参数列表) begin 过程体 end 用户和权限管理-- root密码重置 1. 停止mysql服务 2. [linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [windows] mysqld --skip-grant-tables 3. use mysql; 4. update `user` set password=password(&quot;密码&quot;) where `user` = &quot;root&quot;; 5. flush privileges; 用户信息表：mysql.user -- 刷新权限 flush privileges; -- 增加用户 create user 用户名 identified by [password] 密码(字符串) - 必须拥有mysql数据库的全局create user权限，或拥有insert权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略password关键词。要把密码指定为由password()函数返回的混编值，需包含关键字password -- 重命名用户 rename user old_user to new_user -- 设置密码 set password = password(&#39;密码&#39;) -- 为当前用户设置密码 set password for 用户名 = password(&#39;密码&#39;) -- 为指定用户设置密码 -- 删除用户 drop user 用户名 -- 分配权限/添加用户 grant 权限列表 on 表名 to 用户名 [identified by [password] &#39;password&#39;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 grant all privileges on `pms`.* to &#39;pms&#39;@&#39;%&#39; identified by &#39;pms0817&#39;; -- 查看权限 show grants for 用户名 -- 查看当前用户权限 show grants; 或 show grants for current_user; 或 show grants for current_user(); -- 撤消权限 revoke 权限列表 on 表名 from 用户名 revoke all privileges, grant option from 用户名 -- 撤销所有权限 -- 权限层级 -- 要使用grant或revoke，您必须拥有grant option权限，并且您必须用于您正在授予或撤销的权限。 全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user grant all on *.*和 revoke all on *.*只授予和撤销全局权限。 数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host grant all on db_name.*和revoke all on db_name.*只授予和撤销数据库权限。 表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv grant all on db_name.tbl_name和revoke all on db_name.tbl_name只授予和撤销表权限。 列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用revoke时，您必须指定与被授权列相同的列。 -- 权限列表 all [privileges] -- 设置除grant option之外的所有简单权限 alter -- 允许使用alter table alter routine -- 更改或取消已存储的子程序 create -- 允许使用create table create routine -- 创建已存储的子程序 create temporary tables -- 允许使用create temporary table create user -- 允许使用create user, drop user, rename user和revoke all privileges。 create view -- 允许使用create view delete -- 允许使用delete drop -- 允许使用drop table execute -- 允许用户运行已存储的子程序 file -- 允许使用select...into outfile和load data infile index -- 允许使用create index和drop index insert -- 允许使用insert lock tables -- 允许对您拥有select权限的表使用lock tables process -- 允许使用show full processlist references -- 未被实施 reload -- 允许使用flush replication client -- 允许用户询问从属服务器或主服务器的地址 replication slave -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） select -- 允许使用select show databases -- 显示所有数据库 show view -- 允许使用show create view shutdown -- 允许使用mysqladmin shutdown super -- 允许使用change master, kill, purge master logs和set global语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 update -- 允许使用update usage -- “无权限”的同义词 grant option -- 允许授予权限 表维护-- 分析和存储表的关键字分布 analyze [local | no_write_to_binlog] table 表名 ... -- 检查一个或多个表是否有错误 check table tbl_name [, tbl_name] ... [option] ... option = {quick | fast | medium | extended | changed} -- 整理数据文件的碎片 optimize [local | no_write_to_binlog] table tbl_name [, tbl_name] ... 杂项1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准sql注释风格，要求双破折号后加一空格符（空格、tab、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\&#39; 5. cmd命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\g&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. sql对大小写不敏感 7. 清除已有语句：\\c","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"},{"name":"转载","slug":"转载","permalink":"https://blog.xiongtianci.com/categories/转载/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"npm install hexo-renderer-sass时报错","slug":"npm-install-hexo-renderer-sass时报错","date":"2019-05-20T15:37:42.000Z","updated":"2025-10-26T01:44:38.632Z","comments":true,"path":"2019/05/20/npm-install-hexo-renderer-sass时报错/","link":"","permalink":"https://blog.xiongtianci.com/2019/05/20/npm-install-hexo-renderer-sass时报错/","excerpt":"","text":"问题使用hexo搭建博客时，需安装hexo-renderer-sass： $ npm install hexo-renderer-sass 解决改用淘宝镜像： $ npm install -g cnpm --registry=https://registry.npm.taobao.org $ npm config set registry https://registry.npm.taobao.org 再次安装： $ cnpm install hexo-renderer-sass --save","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.xiongtianci.com/tags/Hexo/"}],"author":"天赐"},{"title":"重新搭建博客","slug":"重新搭建博客","date":"2019-05-20T12:49:00.000Z","updated":"2025-10-26T01:44:38.650Z","comments":true,"path":"2019/05/20/重新搭建博客/","link":"","permalink":"https://blog.xiongtianci.com/2019/05/20/重新搭建博客/","excerpt":"","text":"前言3月份初，许久没写博客（主要就是懒）的博主在莫一天心血来潮写好一篇文章后，使用hexo d部署博客文章时，发现hexo抛出各种错误。但由于当时准备面试的面试题（主要就是懒），然后就放着没管它。紧接着面试实习岗位，工作后也一直没有闲下来。最近终于抽出时间来重构博客，写下这篇文章，记录一下重构博客的过程~ 博客目录介绍. ├── .deploy ├── public ├── scaffolds ├── scripts ├── source | ├── _drafts | └── _posts ├── themes ├── _config.yml └── package.json .deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章 _posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的 关于 按钮 接下来是重头戏 _config.yml ，做个简单说明： # Hexo Configuration ## Docs: http://zespia.tw/hexo/docs/configure.html ## Source: https://github.com/tommy351/hexo/ # Site #整站的基本信息 title: 不如 #网站标题 subtitle: 码农，程序猿，未来的昏析师 #网站副标题 description: bruce sha&#39;s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到 author: bruce #网站作者，在下方显示 email: bu.ru@qq.com #联系邮箱 language: zh-CN #语言 # URL #域名和文件结构 ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: http://ibruce.info #你的域名 root: / permalink: :year/:month/:day/:title/ tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code # Writing #写文章选项 new_post_name: :title.md # File name of new posts default_layout: post #默认layout方式 auto_spacing: false # Add spaces between asian characters and western characters titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab max_open_file: 100 multi_thread: true filename_case: 0 render_drafts: false highlight: #代码高亮 enable: true #是否启用 line_number: false #是否显示行号 tab_replace: # Category &amp; Tag #分类与标签 default_category: uncategorized # default category_map: tag_map: # Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突 ## 2: Enable pagination ## 1: Disable pagination ## 0: Fully Disable archive: 1 category: 1 tag: 1 # Server #本地服务参数 ## Hexo uses Connect as a server ## You can customize the logger format as defined in ## http://www.senchalabs.org/connect/logger.html port: 4000 logger: true logger_format: # Date / Time format #日期显示格式 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: MMM D YYYY time_format: H:mm:ss # Pagination #分页设置 ## Set per_page to 0 to disable pagination per_page: 10 #每页10篇文章 pagination_dir: page # Disqus #社会化评论disqus，我使用多说，在主题中配置 disqus_shortname: # Extensions #插件，暂时未安装插件 ## Plugins: https://github.com/tommy351/hexo/wiki/Plugins ## Themes: https://github.com/tommy351/hexo/wiki/Themes ## 主题 theme: modernist # raytaylorism # pacman # modernist # light exclude_generator: # Deployment #部署 ## Docs: http://zespia.tw/hexo/docs/deploy.html deploy: type: github repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库 主题目录介绍. ├── languages #多语言 | ├── default.yml #默认语言 | └── zh-CN.yml #中文语言 ├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制 | ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制 | └── _widget #小挂件的布局，页面下方小挂件的控制 ├── source #源码 | ├── css #css源码 | | ├── _base #*.styl基础css | | ├── _partial #*.styl局部css | | ├── fonts #字体 | | ├── images #图片 | | └── style.styl #*.styl引入需要的css源码 | ├── fancybox #fancybox效果源码 | └── js #javascript源代码 ├── _config.yml #主题配置文件 └── README.md #用GitHub的都知道 如果你需要修改头部，直接修改 hexo\\themes\\modernist\\layout\\_partial\\header.ejs ，比如头上加个搜索框： &lt;div&gt; &lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\\/\\//, &#39;&#39;) %&gt;&quot;&gt; &lt;/form&gt; &lt;/div&gt; 将如上代码加入即可，您需要修改css以便这个搜索框比较美观。再如，你要修改页脚版权信息，直接编辑 hexo\\themes\\modernist\\layout\\_partial\\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。 主题安装 https://www.haomwei.com/technology/maupassant-hexo.html $ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant $ npm install hexo-renderer-pug --save $ npm install hexo-renderer-sass --save npm install hexo-renderer-pug --save安装时可能会报错，以下是解决方案：改用cnpm来安装软件 $ npm install -g cnpm –registry=https://registry.npm.taobao.org目的是直接改npm为淘宝的npm，也为防止某些依赖直接用npm来安装，导致无法顺利安装完成$ npm config set registry https://registry.npm.taobao.org 编辑Hexo目录下的 _config.yml，将theme的值改为maupassant theme: matery 功能配置# 是否启用Fancybox图片灯箱效果 # Disqus评论 shortnam disqus: # 友言评论 id uyan: # 来必力评论 data-uid livere: # 畅言评论 appid changyan: changyan_conf: ## Your changyan conf, e.g. prod_d8a508c2825ab57eeb43e7c69bba0e8b # Gitment评论相关参数 gitment: enable: false owner: repo: client_id: client_secret: # Gitalk评论相关参数 gitalk: enable: false owner: repo: client_id: client_secret: admin: # Valine评论相关参数 valine: enable: false appid: appkey: notify: false # 评论系统中的邮件提醒设置 verify: false ## Validation code. placeholder: Just so so avatar: &#39;mm&#39; pageSize: 10 guest_info: nick,mail,link # 默认使用Google搜索引擎 google_search: true # 若想使用百度搜索，将其设定为 true baidu_search: false # Swiftype 站内搜索key swiftype: # 微搜索 key tinysou: # 基于jQuery的本地搜索引擎，需要安装hexo-generator-search插件使用 self_search: false # Google Analytics 跟踪ID google_analytics: # 百度统计 跟踪ID baidu_analytics: # fancybox: true ## If you want to use fancybox please set the value to true. # 是否显示侧边栏分类数目 show_category_count: false # 是否显示文章中目录列表自动编号 toc_number: true # 是否使用分享按鈕，需要安装hexo-helper-qrcode插件使用 shareto: false # 是否使用不蒜子页面访问计数 busuanzi: false # wordcount: false ## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed. # 是否在移动设备屏幕底部显示侧边栏 widgets_on_small_screens: false ## Set to true to enable widgets on small screens. # 是否使用canvas动态背景 canvas_nest: enable: false color: ## RGB value of the color, e.g. &quot;100,99,98&quot; opacity: ## Transparency of lines, e.g. &quot;0.7&quot; zIndex: ## The z-index property of the background, e.g. &quot;-1&quot; count: ## Quantity of lines, e.g. &quot;150&quot; # 是否启用捐赠按钮 donate: enable: false github: ## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page alipay_qr: ## Path of Alipay QRcode image, e.g. /img/AliPayQR.png wechat_qr: ## Path of Wechat QRcode image, e.g. /img/WeChatQR.png btc_qr: ## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png btc_key: ## Bitcoin key, e.g. 1KuK5eK2BLsqpsFVXXSBG5wbSAwZVadt6L paypal_url: ## Paypal URL, e.g. https://www.paypal.me/tufu9441 post_copyright: enable: false ## If you want to display the copyright info after each post, please set the value to true and fill the following items on your need. author: ## Your author name, e.g. tufu9441 copyright_text: ## Your copyright text, e.g. The author owns the copyright, please indicate the source reproduced. # 自定义页面及菜单，依照已有格式填写。 # 填写后请在source目录下建立相应名称的文件夹，并包含index.md文件，以正确显示页面。 # 导航菜单中集成了FontAwesome图标字体，可以在这里选择新的图标，并按照相关说明使用。 menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: about directory: about/ icon: fa-user - page: rss directory: atom.xml icon: fa-rss # 选择和排列希望使用的侧边栏小工具 widgets: ## Six widgets in sidebar provided: search, category, tag, recent_posts, rencent_comments and links. - search - category - tag - recent_posts - recent_comments - links # 友情链接，请依照格式填写 links: - title: site-name1 url: http://www.example1.com/ - title: site-name2 url: http://www.example2.com/ - title: site-name3 url: http://www.example3.com/ # 网站历史时间线，在页面front-matter中设置layout: timeline可显示 timeline: - num: 1 word: 2014/06/12-Start - num: 2 word: 2014/11/29-XXX - num: 3 word: 2015/02/18-DDD - num: 4 word: More # Static files # 静态文件存储路径，方便设置CDN缓存 js: js css: css # Theme version # 主题版本，便于静态文件更新后刷新CDN缓存 version: 0.0.0 评论Disqus配置使用注册 https://disqus.com/ 主题特性主题目录结构-maupassant |-languages 网站图标网站Favicon：/blog/source/favicon.ico，建议的大小：32px*32px。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"生活","slug":"生活","permalink":"https://blog.xiongtianci.com/categories/生活/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.xiongtianci.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://blog.xiongtianci.com/tags/博客/"}],"author":"天赐"},{"title":"hexo d命令报错：ERROR Deployer not found: git","slug":"hexo-d命令报错：ERROR-Deployer-not-found-git","date":"2019-05-15T06:30:17.000Z","updated":"2025-10-26T01:44:38.615Z","comments":true,"path":"2019/05/15/hexo-d命令报错：ERROR-Deployer-not-found-git/","link":"","permalink":"https://blog.xiongtianci.com/2019/05/15/hexo-d命令报错：ERROR-Deployer-not-found-git/","excerpt":"","text":"问题使用hexo d或hexo deploy命令时报错： ERROR Deployer not found: git 解决安装hexo-deployer-git： npm install --save hexo-deployer-git 在_config.yml配置中将deploy的type由github改为git： deploy type: git repository: git@github.com:YOUR_ID/YOUR_ID.github.io.git branch: master 将其中的YOUR_ID改成你自己的GitHub账号","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.xiongtianci.com/tags/Hexo/"}],"author":"天赐"},{"title":"彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示","slug":"彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示","date":"2019-05-09T12:17:52.000Z","updated":"2025-10-26T01:44:38.587Z","comments":true,"path":"2019/05/09/彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示/","link":"","permalink":"https://blog.xiongtianci.com/2019/05/09/彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示/","excerpt":"","text":"前言Chrome勾选开发者模式安装插件后，每次启动都会弹出请停用以开发者模式运行的扩展程序的提示，最为一枚具有强迫症的程序员，这个绝对不能忍~~ Chrome版本：74.0.3729.131 解决方案方案一：反编译修改chrome.dll文件1.1 下载x64dbg下载地址：https://github.com/x64dbg/x64dbg/releases选择最新版本进行下载：下载好之后，解压打开release，可以点击x96dbg选择x64dbg，也可以直接选择x64文件夹中的x64dbg，如果你是32位的系统还可以选择x32dbg 1.2 反编译chrome.dll通过 右键chrome图标 –&gt; 属性 –&gt; 打开文件的所在位置 找到chrome.dll文件将chrome.dll文件拖入x64.dbg，会出现两个弹窗，其中黑色命令行弹窗不要关掉。如图：然后连续多次点击运行到用户代码按钮（我这里是连续点击6下），直至窗口标题处的模块变成chrome.dll：然后在主面板右键依次选择 搜索 –&gt; 当前模块 –&gt; 字符串：然后会打开一个搜索界面，等待模块搜索进度条100%也就是加载完毕：在搜索框输入ExtensionDeveloperModeWarning进行搜索，会搜到2条结果，双击第1个，跳转到反汇编界面，往上翻一点，找到cmp eax,2（也有可能是 cmp eax,3 ）：双击打开编辑页面，修改成cmp eax,9，然后点击确定，注意只需要点击一次确定即可，点击确定后它还是会继续弹出其它行的编辑界面，此时直接关闭对话框即可：修改完之后Ctrl+P导出修改过的dll文件（点击修补文件按钮就是导出dll文件）：然后把dll文件导出到任意其他位置，然后把原始chrome.dll文件==备份==（以免操作失误，否则只能重装Chrome），先关掉x64dbg，将刚刚导出的修补文件以chrome.dll命名然后覆盖原来的chrome.dll文件，重启Chrome，发现整个世界都清净了~~","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.xiongtianci.com/tags/Chrome/"}],"author":"天赐"},{"title":"黑马乐优商城","slug":"黑马乐优商城","date":"2019-05-07T03:50:27.000Z","updated":"2025-10-26T01:44:38.570Z","comments":true,"path":"2019/05/07/黑马乐优商城/","link":"","permalink":"https://blog.xiongtianci.com/2019/05/07/黑马乐优商城/","excerpt":"","text":"链接 提取码 视频 java 笔记 java 资料 java 本资源是博主在网上寻找乐优商城资料时，一位好人所赠 注意：找乐优商城资料的同学应该知道，乐优商城的视频有win和mac版本之分，此资源中的视频是mac版本。资料中的课件是完整的，但是与视频会有所出入 如果链接失效，可通过邮件联系获取 项目源码是博主通过学习笔记所编写，没有看视频","categories":[{"name":"资源","slug":"资源","permalink":"https://blog.xiongtianci.com/categories/资源/"}],"tags":[{"name":"黑马","slug":"黑马","permalink":"https://blog.xiongtianci.com/tags/黑马/"},{"name":"乐优商城","slug":"乐优商城","permalink":"https://blog.xiongtianci.com/tags/乐优商城/"}],"author":"天赐"},{"title":"navicat操作mysql的时候，如何输入null值？","slug":"navicat操作mysql的时候，如何输入null值？","date":"2019-05-05T03:47:07.000Z","updated":"2025-10-26T01:44:38.552Z","comments":true,"path":"2019/05/05/navicat操作mysql的时候，如何输入null值？/","link":"","permalink":"https://blog.xiongtianci.com/2019/05/05/navicat操作mysql的时候，如何输入null值？/","excerpt":"","text":"使用右键或菜单栏中的编辑可以设置NULL值","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://blog.xiongtianci.com/tags/Mysql/"},{"name":"Navicat","slug":"Navicat","permalink":"https://blog.xiongtianci.com/tags/Navicat/"}],"author":"天赐"},{"title":"POI导入Excel异常Cannot get a text value from a numeric cell","slug":"POI导入Excel异常Cannot-get-a-text-value-from-a-numeric-cell","date":"2019-04-23T09:37:03.000Z","updated":"2025-10-26T01:44:38.535Z","comments":true,"path":"2019/04/23/POI导入Excel异常Cannot-get-a-text-value-from-a-numeric-cell/","link":"","permalink":"https://blog.xiongtianci.com/2019/04/23/POI导入Excel异常Cannot-get-a-text-value-from-a-numeric-cell/","excerpt":"","text":"问题POI操作Excel时偶尔会出现Cannot get a text value from a numeric cell的异常错误 java.lang.IllegalStateException: Cannot get a text value from a numeric cell 异常原因：Excel数据cell有不同的类型，当我们试图从一个数字类型的Cell读取出一个字符串并写入数据库时，就会出现Cannot get a text value from a numeric cell的异常错误。 解决通过setCellType()设置cell类型，统一设置成String类型，然后再获取 Row row = sheet.getRow(i); for (int j = 0; j &lt; row.getPhysicalNumberOfCells(); j++) { // row.getCell(j).setCellType(Cell.CELL_TYPE_STRING); // String cellValue = row.getCell(j).getStringCellValue(); System.out.println(cellValue); }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"POI","slug":"POI","permalink":"https://blog.xiongtianci.com/tags/POI/"},{"name":"Excel","slug":"Excel","permalink":"https://blog.xiongtianci.com/tags/Excel/"}],"author":"天赐"},{"title":"电脑开机后弹窗提示下载名称是cc.png，来源是s3.amazonaws.com的文件","slug":"电脑开机后弹窗提示下载名称是cc-png，来源是s3-amazonaws-com的文件","date":"2019-04-19T01:27:45.000Z","updated":"2025-10-26T01:44:38.518Z","comments":true,"path":"2019/04/19/电脑开机后弹窗提示下载名称是cc-png，来源是s3-amazonaws-com的文件/","link":"","permalink":"https://blog.xiongtianci.com/2019/04/19/电脑开机后弹窗提示下载名称是cc-png，来源是s3-amazonaws-com的文件/","excerpt":"","text":"问题电脑开机之后会自动弹窗提示让下载一个名称是cc.png，来源是s3.amazonaws.com的文件 解决网上查询后，了解到是因为我最近下载了Adobe Premiere，而破解工具有瑕疵的原因。网上的解决方案是将Adobe Creative Cloud的默认开机启动改成禁用即可，下面是解决步骤： 1、使用快捷键Ctrl + Shift + Esc打开任务管理器2、在启动中找到Adobe Creative Cloud3、右键，将其改为禁用即可","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"cc.png","slug":"cc-png","permalink":"https://blog.xiongtianci.com/tags/cc-png/"}],"author":"天赐"},{"title":"IDEA运行SpringBoot项目控制台输出颜色高亮的日志","slug":"IDEA运行SpringBoot项目控制台输出颜色高亮的日志","date":"2019-04-16T08:43:18.000Z","updated":"2025-10-26T01:44:38.484Z","comments":true,"path":"2019/04/16/IDEA运行SpringBoot项目控制台输出颜色高亮的日志/","link":"","permalink":"https://blog.xiongtianci.com/2019/04/16/IDEA运行SpringBoot项目控制台输出颜色高亮的日志/","excerpt":"","text":"问题有时IDEA运行SpringBoot项目，控制台Console输出的日志颜色为白色的 解决配置启动类application的相关参数，添加：-Dspring.output.ansi.enabled=ALWAYS","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.xiongtianci.com/tags/SpringBoot/"}],"author":"天赐"},{"title":"win10日语输入法切换平片假名","slug":"win10日语输入法切换平片假名","date":"2019-04-16T07:45:21.000Z","updated":"2025-10-26T01:44:38.501Z","comments":true,"path":"2019/04/16/win10日语输入法切换平片假名/","link":"","permalink":"https://blog.xiongtianci.com/2019/04/16/win10日语输入法切换平片假名/","excerpt":"","text":"1.切换平假名使用Ctrl + CapsLock切换至平假名输入 2.切换片假名使用Alt + CapsLock切换至片假名输入 3.在键入时切换假名在键入时可通过F6切换成平假名、F7切换成片假名 4.切换英文输入使用Shift + CapsLock或Alt + ~切换至英文输入 5.语言切换使用win徽标键 + 空格在输入语言之间切换","categories":[{"name":"日语","slug":"日语","permalink":"https://blog.xiongtianci.com/categories/日语/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"},{"name":"日语","slug":"日语","permalink":"https://blog.xiongtianci.com/tags/日语/"}],"author":"天赐"},{"title":"Chrome历史版本下载","slug":"Chrome历史版本下载","date":"2019-04-01T02:23:02.000Z","updated":"2025-10-26T01:44:38.468Z","comments":true,"path":"2019/04/01/Chrome历史版本下载/","link":"","permalink":"https://blog.xiongtianci.com/2019/04/01/Chrome历史版本下载/","excerpt":"","text":"Chrome历史版本","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.xiongtianci.com/tags/Chrome/"}],"author":"天赐"},{"title":"使用Twitter的Snowflake设置分布式自增长ID","slug":"使用Twitter的Snowflake设置分布式自增长ID","date":"2019-03-29T06:44:44.000Z","updated":"2025-10-26T01:44:38.450Z","comments":true,"path":"2019/03/29/使用Twitter的Snowflake设置分布式自增长ID/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/29/使用Twitter的Snowflake设置分布式自增长ID/","excerpt":"","text":"十次方项目工具类IdWorker.java描述：使用Twitter的Snowflake雪花算法设置分布式自增长ID import java.lang.management.ManagementFactory; import java.net.InetAddress; import java.net.NetworkInterface; /** * &lt;p&gt;名称：IdWorker.java&lt;/p&gt; * &lt;p&gt;描述：分布式自增长ID&lt;/p&gt; * &lt;pre&gt; * Twitter的 Snowflake JAVA实现方案 * &lt;/pre&gt; * 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用： * 1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000 * 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间， * 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识）， * 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。 * 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， * 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 * &lt;p&gt; * 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加)) * * @author Polim */ public class IdWorker { // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker() { this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); } /** * @param workerId 工作机器ID * @param datacenterId 序列号 */ public IdWorker(long workerId, long datacenterId) { if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.format(&quot;worker Id can&#39;t be greater than %d or less than 0&quot;, maxWorkerId)); } if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) { throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#39;t be greater than %d or less than 0&quot;, maxDatacenterId)); } this.workerId = workerId; this.datacenterId = datacenterId; } /** * 获取下一个ID * * @return */ public synchronized long nextId() { long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) { throw new RuntimeException(String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp)); } if (lastTimestamp == timestamp) { // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) { // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); } } else { sequence = 0L; } lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; } private long tilNextMillis(final long lastTimestamp) { long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) { timestamp = this.timeGen(); } return timestamp; } private long timeGen() { return System.currentTimeMillis(); } /** * &lt;p&gt; * 获取 maxWorkerId * &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) { StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) { /* * GET jvmPid */ mpid.append(name.split(&quot;@&quot;)[0]); } /* * MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); } /** * &lt;p&gt; * 数据标识id部分 * &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) { long id = 0L; try { InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) { id = 1L; } else { byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); } } catch (Exception e) { System.out.println(&quot; getDatacenterId: &quot; + e.getMessage()); } return id; } }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Snowflake","slug":"Snowflake","permalink":"https://blog.xiongtianci.com/tags/Snowflake/"},{"name":"自增ID","slug":"自增ID","permalink":"https://blog.xiongtianci.com/tags/自增ID/"}],"author":"天赐"},{"title":"bat脚本中以管理员权限执行命令","slug":"bat脚本中以管理员权限执行命令","date":"2019-03-29T06:30:05.000Z","updated":"2025-10-26T01:44:38.415Z","comments":true,"path":"2019/03/29/bat脚本中以管理员权限执行命令/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/29/bat脚本中以管理员权限执行命令/","excerpt":"","text":"在bat脚本文件第一行加上下面命令： %1 mshta vbscript:CreateObject(“Shell.Application”).ShellExecute(“cmd.exe”,”/c %~s0 ::”,””,”runas”,1)(window.close)&amp;&amp;exit","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"bat","slug":"bat","permalink":"https://blog.xiongtianci.com/tags/bat/"},{"name":"脚本","slug":"脚本","permalink":"https://blog.xiongtianci.com/tags/脚本/"}],"author":"天赐"},{"title":"win10开机运行脚本文件","slug":"win10开机运行脚本文件","date":"2019-03-29T06:24:21.000Z","updated":"2025-10-26T01:44:38.432Z","comments":true,"path":"2019/03/29/win10开机运行脚本文件/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/29/win10开机运行脚本文件/","excerpt":"","text":"需求 有个bat脚本，希望电脑开机时自动执行此脚本 解决1、打开电脑目录：C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup2、将需要开机启动就执行的脚本放入此目录下3、重启电脑","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"},{"name":"脚本","slug":"脚本","permalink":"https://blog.xiongtianci.com/tags/脚本/"}],"author":"天赐"},{"title":"SpringMVC注解@CrossOrigin解决跨域问题","slug":"SpringMVC注解@CrossOrigin解决跨域问题","date":"2019-03-27T01:51:27.000Z","updated":"2025-10-26T01:44:38.398Z","comments":true,"path":"2019/03/27/SpringMVC注解@CrossOrigin解决跨域问题/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/27/SpringMVC注解@CrossOrigin解决跨域问题/","excerpt":"","text":"一般的，只要网站的【协议名protocol】、【主机host】、【端口号port】这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用跨域：浏览同源策略的造成，是浏览器对JavaScript施加的安全限制CORS是一种可以解决跨域问题的技术 SprinMVC通过@CrossOrigin注解解决跨域 在Spring MVC4.2之后推出了@CrossOrigin注解来解决跨域问题，而在4.2之前我们都是通过定义注册过滤器的方式来解决跨域问题的 @CrossOrigin的参数：1、origins：允许可访问的域列表；*表示可以是任何来源2、maxAge：准备响应前的缓存持续的最大时间（单位：秒） @CrossOrigin使用在Controller层：1、类上，此类中所有方法启用跨域支持 // 开启跨域支持 @CrossOrigin @RestController @RequestMapping(&quot;/user&quot;) public class UserController { } 2、方法上，仅此方法启用跨域支持 // 开启跨域支持 @CrossOrigin @RequestMapping(value = &quot;/findAll&quot;, method = RequestMethod.GET) public List&lt;User&gt; findAll(){ return userService.findAll(); } 注意1、注解失效问题：此时Controlle的方法上@RequestMapping注解中需要声明请求方式即增加method=RequestMethod.XXX 2、添加注解后session失效问题：此时对的ajax请求中需要添加xhrFields:{withCredentials:true}（每个ajax中都需要加此属性，以保证session一致） $.ajax({ type: &quot;post&quot;, url: &#39;/user/login&#39;, xhrFields: {withCredentials: true}, data: { username: username, password: password }, success: function (msg) { console.log(&#39;登录成功&#39;); }, error: function (msg) { console.log(&#39;请求报错！&#39;); } })","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://blog.xiongtianci.com/tags/SpringMVC/"},{"name":"跨域","slug":"跨域","permalink":"https://blog.xiongtianci.com/tags/跨域/"},{"name":"CrossOrigin","slug":"CrossOrigin","permalink":"https://blog.xiongtianci.com/tags/CrossOrigin/"}],"author":"天赐"},{"title":"win系统查看连接过的WIFI密码","slug":"win系统查看连接过的WIFI密码","date":"2019-03-26T10:22:36.000Z","updated":"2025-10-26T01:44:38.381Z","comments":true,"path":"2019/03/26/win系统查看连接过的WIFI密码/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/26/win系统查看连接过的WIFI密码/","excerpt":"","text":"1. win+R，输入cmd回车打开cmd窗口2. 输入下面命令显示电脑连接过的所有WIFI名：netsh wlan show profiles 在cmd中鼠标右键是粘贴 3. 输入下面命令查看WIFI密码：netsh wlan show profile name=&quot;WIFI名&quot; key=clear “WIFI名称”：使用英文状态下的双引号 在显示的内容中找到安全设置下的关键内容，即为WIFI密码","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"},{"name":"WIFI密码","slug":"WIFI密码","permalink":"https://blog.xiongtianci.com/tags/WIFI密码/"}],"author":"天赐"},{"title":"Swagger异常：java.lang.NumberFormatException: For input string: ","slug":"Swagger异常：java-lang-NumberFormatException-For-input-string","date":"2019-03-25T06:36:14.000Z","updated":"2025-10-26T01:44:38.336Z","comments":true,"path":"2019/03/25/Swagger异常：java-lang-NumberFormatException-For-input-string/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/25/Swagger异常：java-lang-NumberFormatException-For-input-string/","excerpt":"","text":"问题项目整合Swagger，访问Swagger首页时后台抛出下面异常： i.s.m.p.AbstractSerializableParameter : Illegal DefaultValue null for parameter type integerjava.lang.NumberFormatException: For input string: “” 原因好像是说swagger2本身引用的swagger-models-1.5.20.jar有bug 解决导入下面的maven坐标： &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;version&gt;1.5.21&lt;/version&gt; &lt;/dependency&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Swagger","slug":"Swagger","permalink":"https://blog.xiongtianci.com/tags/Swagger/"}],"author":"天赐"},{"title":"上传图片415异常：\"Content type 'multipart/form-data;' .... not supported\"","slug":"上传图片415异常：Content type 'multipartform-data;' ~not supported","date":"2019-03-25T02:23:04.000Z","updated":"2025-10-26T01:44:38.365Z","comments":true,"path":"2019/03/25/上传图片415异常：Content type 'multipartform-data;' ~not supported/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/25/上传图片415异常：Content type 'multipartform-data;' ~not supported/","excerpt":"","text":"问题 上传图片时报错：Content type ‘multipart/form-data;boundary=—-WebKitFormBoundarypOpfYxCGU6Q4sciA;charset=UTF-8’ not supported Controller层： @PostMapping(path = &quot;/uploadRotationImg&quot;) public ResponseEntity&lt;String&gt; uploadRotationImg(@RequestParam(&quot;photos&quot;) MultipartFile file, @RequestBody ImgRotation imgRotation) { try { // 进行上传操作 return imgRotationService.uploadRotationImg(file, imgRotation); } catch (Exception e) { // 上传失败 e.printStackTrace(); return new ResponseEntity&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); } } 解决去掉@RequestBody注解就行了 @PostMapping(path = &quot;/uploadRotationImg&quot;) public ResponseEntity&lt;String&gt; uploadRotationImg(@RequestParam(&quot;photos&quot;) MultipartFile file, ImgRotation imgRotation) { try { // 进行上传操作 return imgRotationService.uploadRotationImg(file, imgRotation); } catch (Exception e) { // 上传失败 e.printStackTrace(); return new ResponseEntity&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"415","slug":"415","permalink":"https://blog.xiongtianci.com/tags/415/"}],"author":"天赐"},{"title":"@RequestParam和@RequestBody","slug":"@RequestParam和@RequestBody","date":"2019-03-22T07:51:52.000Z","updated":"2025-10-26T01:44:37.990Z","comments":true,"path":"2019/03/22/@RequestParam和@RequestBody/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/22/@RequestParam和@RequestBody/","excerpt":"","text":"一、@RequestParam GET和POST请求传的参数会自动转换赋值到@RequestParam所注解的变量上 &lt;form action=&quot;/requestParamDemo&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 用户昵称：&lt;input type=&quot;text&quot; name=&quot;usernick&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; @RequestMapping(value = &quot;/requestParamDemo&quot;, method = RequestMethod.GET) public void requestParamDemo(@RequestParam(value = &quot;username&quot;) String userName, @RequestParam(value = &quot;usernick&quot;) String userNick) { System.out.println(&quot;username: &quot; + userName); System.out.println(&quot;usernick: &quot; + userNick); } 二、@RequestBody @RequestBody注解可以接收json格式的数据，并将其转换成对应的数据类型 // 通过ajax发送json数据 { &quot;id&quot;:1, &quot;username&quot;:&quot;jack&quot;, &quot;password&quot;:&quot;1234&quot; } @RequestMapping(value=&quot;/requestBodyDemo&quot;, method = RequestMethod.POST) public void requestBodyDemo(@RequestBody User user){ System.out.println(&quot;id: &quot; + user.getId()); System.out.println(&quot;name: &quot; + user.getName()); System.out.println(&quot;password: &quot; + user.getPassword()); }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"RequestParam","slug":"RequestParam","permalink":"https://blog.xiongtianci.com/tags/RequestParam/"},{"name":"RequestBody","slug":"RequestBody","permalink":"https://blog.xiongtianci.com/tags/RequestBody/"}],"author":"天赐"},{"title":"MySQL中datetime类型的字段与JavaBean对应的类型","slug":"MySQL中datetime类型的字段与JavaBean对应的类型","date":"2019-03-22T03:50:18.000Z","updated":"2025-10-26T01:44:38.008Z","comments":true,"path":"2019/03/22/MySQL中datetime类型的字段与JavaBean对应的类型/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/22/MySQL中datetime类型的字段与JavaBean对应的类型/","excerpt":"","text":"MySQL数据库中时间格式为datetime类型的字段： JavaBean中对应字段的类型：import com.fasterxml.jackson.annotation.JsonFormat; import org.springframework.format.annotation.DateTimeFormat; // 如果到的是sql下的包(java.sql.Date)，get操作时封装的结果为null、put/post操作时会抛415异常 import java.util.Date; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone=&quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @ApiModelProperty(&quot;创建时间，格式：yyyy-MM-dd HH:mm:ss&quot;) private Date ctime; or import com.fasterxml.jackson.annotation.JsonFormat; import org.springframework.format.annotation.DateTimeFormat; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone=&quot;GMT+8&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @ApiModelProperty(&quot;创建时间，格式：yyyy-MM-dd HH:mm:ss&quot;) private String ctime;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"},{"name":"datetime","slug":"datetime","permalink":"https://blog.xiongtianci.com/tags/datetime/"}],"author":"天赐"},{"title":"SpringBoot中MyBatis属性映射之开启驼峰命名","slug":"SpringBoot中MyBatis属性映射之开启驼峰命名","date":"2019-03-20T06:43:26.000Z","updated":"2025-10-26T01:44:37.974Z","comments":true,"path":"2019/03/20/SpringBoot中MyBatis属性映射之开启驼峰命名/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/20/SpringBoot中MyBatis属性映射之开启驼峰命名/","excerpt":"","text":"今天使用SpringBoot整合MyBatis开发时，发现从数据库中查询到的结果封装到javabean中，只要表中有下划线的字段，就会出现null值 MyBatis默认是属性名和数据库字段名一一对应的，即数据库表列：user_name实体类属性：user_name 但是java中一般使用驼峰命名数据库表列：user_name实体类属性：userName 在SpringBoot中，可以通过设置map-underscore-to-camel-case属性为true来开启驼峰功能： mybatis: configuration: map-underscore-to-camel-case: true # 开启驼峰命名","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.xiongtianci.com/tags/MyBatis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.xiongtianci.com/tags/SpringBoot/"},{"name":"驼峰命名","slug":"驼峰命名","permalink":"https://blog.xiongtianci.com/tags/驼峰命名/"}],"author":"天赐"},{"title":"原生js修改textarea的值","slug":"原生js修改textarea的值","date":"2019-03-19T07:56:17.000Z","updated":"2025-10-26T01:44:37.957Z","comments":true,"path":"2019/03/19/原生js修改textarea的值/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/19/原生js修改textarea的值/","excerpt":"","text":"// 设置textarea的值 document.getElementById(&quot;goodstext_id&quot;).value = &quot;值&quot;;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.xiongtianci.com/tags/js/"},{"name":"textarea","slug":"textarea","permalink":"https://blog.xiongtianci.com/tags/textarea/"}],"author":"天赐"},{"title":"js获取ModelAndView中的数据","slug":"js获取ModelAndView中的数据","date":"2019-03-19T07:47:05.000Z","updated":"2025-10-26T01:44:37.905Z","comments":true,"path":"2019/03/19/js获取ModelAndView中的数据/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/19/js获取ModelAndView中的数据/","excerpt":"","text":"后台封装： @GetMapping(&quot;/findById/{id}&quot;) public ModelAndView findById(@PathVariable(&quot;id&quot;) Integer id) { // 通过id查询商品 Goods dbgoods = goodsService.findById(id); // 创建ModelAndView对象 ModelAndView mv = new ModelAndView(); // 跳转到goods_editor.html页面 mv.setViewName(&quot;/goods/goods_editor&quot;); // 封装查询结果 mv.addObject(&quot;dbgoods&quot;,dbgoods); // return mv; } 前端获取： &lt;script th:inline=&quot;javascript&quot;&gt; // 需要添加 th:inline 才能访问 model 中的属性 window.onload = function () { console.log(&quot;页面加载完成&quot;); // 获取ModelAndView中的dbgoods对象 var dbgoods = [[${dbgoods}]]; // 打印 console.log(dbgoods); } &lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.xiongtianci.com/tags/js/"},{"name":"ModelAndView","slug":"ModelAndView","permalink":"https://blog.xiongtianci.com/tags/ModelAndView/"}],"author":"天赐"},{"title":"SpringBoot使用 thymeleaf+@RestController 跳转页面","slug":"SpringBoot使用-thymeleaf-RestController-跳转页面","date":"2019-03-19T02:19:37.000Z","updated":"2025-10-26T01:44:37.940Z","comments":true,"path":"2019/03/19/SpringBoot使用-thymeleaf-RestController-跳转页面/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/19/SpringBoot使用-thymeleaf-RestController-跳转页面/","excerpt":"","text":"thymeleaf推荐使用@Controller进行页面跳转如果用@RestController，则可以通过ModelAndView进行页面跳转eg /** * 跳转到goods_editor.html页面 * @return */ @GetMapping(&quot;/goodsEditor&quot;) public ModelAndView goodsEditor(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;/goods/goods_editor&quot;); return mv; }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.xiongtianci.com/tags/SpringBoot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://blog.xiongtianci.com/tags/thymeleaf/"},{"name":"RestController","slug":"RestController","permalink":"https://blog.xiongtianci.com/tags/RestController/"}],"author":"天赐"},{"title":"org.xml.sax.SAXParseException: 元素类型 \"link\" 必须由匹配的结束标记 \"</link>\" 终止","slug":"org-xml-sax-SAXParseException-元素类型link必须由匹配的结束标记link终止","date":"2019-03-19T02:02:05.000Z","updated":"2025-10-26T01:44:37.923Z","comments":true,"path":"2019/03/19/org-xml-sax-SAXParseException-元素类型link必须由匹配的结束标记link终止/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/19/org-xml-sax-SAXParseException-元素类型link必须由匹配的结束标记link终止/","excerpt":"","text":"问题SpringBoot使用thymeleaf模板引擎时报错： org.xml.sax.SAXParseException: 元素类型 “link” 必须由匹配的结束标记 “&lt;&#47;link&gt;” 终止 or org.xml.sax.SAXParseException: 元素类型 “meta” 必须由匹配的结束标记 “&lt;&#47;meta&gt;” 终止 解决解决方法是在pom.xml文件中指定具体的thymeleaf版本具体如下 &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!--添加下面两项指定thymeleaf的版本--&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.0.5&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"}],"author":"天赐"},{"title":"通过MyBatis向MySQL中插入数据时中文乱码","slug":"通过MyBatis向MySQL中插入数据时中文乱码","date":"2019-03-18T06:20:50.000Z","updated":"2025-10-26T01:44:37.889Z","comments":true,"path":"2019/03/18/通过MyBatis向MySQL中插入数据时中文乱码/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/18/通过MyBatis向MySQL中插入数据时中文乱码/","excerpt":"","text":"问题：通过MyBatis向MySQL中插入或更新操作时，中文会显示成??? 解决：在配置文件application.yml中连接数据库的地址url后面加上characterEncoding=utf8即可 spring: application: name: server # 服务名称 datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db?characterEncoding=utf8 username: root # 数据库账号 password: root # 数据库密码","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.xiongtianci.com/tags/MyBatis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"},{"name":"乱码","slug":"乱码","permalink":"https://blog.xiongtianci.com/tags/乱码/"}],"author":"天赐"},{"title":"A component required a bean of type 'com.renqijie.dao.SellerMapper' that could not be found.","slug":"A-component-required-a-bean-of-type-com-renqijie-dao-SellerMapper-that-could-not-be-found","date":"2019-03-14T09:53:11.000Z","updated":"2025-10-26T01:44:37.853Z","comments":true,"path":"2019/03/14/A-component-required-a-bean-of-type-com-renqijie-dao-SellerMapper-that-could-not-be-found/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/14/A-component-required-a-bean-of-type-com-renqijie-dao-SellerMapper-that-could-not-be-found/","excerpt":"","text":"异常：Description:A component required a bean of type ‘com.renqijie.dao.SellerMapper’ that could not be found. 原因：dao层接口SellerMapper未加注解&#64;org.apache.ibatis.annotations.Mapper","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"}],"author":"天赐"},{"title":"org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON","slug":"org-springframework-http-converter-HttpMessageNotWritableException-Could-not-write-JSON","date":"2019-03-14T03:52:15.000Z","updated":"2025-10-26T01:44:37.872Z","comments":true,"path":"2019/03/14/org-springframework-http-converter-HttpMessageNotWritableException-Could-not-write-JSON/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/14/org-springframework-http-converter-HttpMessageNotWritableException-Could-not-write-JSON/","excerpt":"","text":"记一次踩坑经历：Resolved [org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: (was java.lang.NullPointerException); nested exception is com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: com.renqijie.pojo.vo.IndexBean[&quot;images&quot;]-&gt;java.util.ArrayList[0]-&gt;com.renqijie.pojo.Image[&quot;id&quot;])] 原因：JavaBean类Image中有一个属性类型刚开始设置成int类型，生成getter/setter方法后，又将其改成了Integer类型，结果就出现了上述情况","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"}],"author":"天赐"},{"title":"小程序用户表wx_user设计","slug":"小程序用户表wx-user设计","date":"2019-03-13T02:07:05.000Z","updated":"2025-10-26T01:44:37.837Z","comments":true,"path":"2019/03/13/小程序用户表wx-user设计/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/13/小程序用户表wx-user设计/","excerpt":"","text":"CREATE TABLE `wx_user` ( `id` int(20) NOT NULL AUTO_INCREMENT, `openid` varchar(28) DEFAULT NULL COMMENT &#39;小程序用户的openid&#39;, `nickname` varchar(100) DEFAULT NULL COMMENT &#39;用户头像&#39;, `avatarurl` varchar(100) DEFAULT NULL COMMENT &#39;用户头像&#39;, `gender` tinyint(1) DEFAULT NULL COMMENT &#39;性别 0-男、1-女&#39;, `country` varchar(100) DEFAULT NULL COMMENT &#39;所在国家&#39;, `province` varchar(100) DEFAULT NULL COMMENT &#39;省份&#39;, `city` varchar(100) DEFAULT NULL COMMENT &#39;城市&#39;, `language` varchar(100) DEFAULT NULL COMMENT &#39;语种&#39;, `ctime` datetime DEFAULT NULL COMMENT &#39;创建/注册时间&#39;, `mobile` varchar(50) DEFAULT NULL COMMENT &#39;手机号码&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;小程序用户表&#39;;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://blog.xiongtianci.com/tags/小程序/"}],"author":"天赐"},{"title":"查看CentOS版本信息","slug":"查看CentOS版本信息","date":"2019-03-12T02:37:43.000Z","updated":"2025-10-26T01:44:37.819Z","comments":true,"path":"2019/03/12/查看CentOS版本信息/","link":"","permalink":"https://blog.xiongtianci.com/2019/03/12/查看CentOS版本信息/","excerpt":"","text":"指令：cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core)","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xiongtianci.com/tags/CentOS/"}],"author":"天赐"},{"title":"Java操作MongoDB之mongodb-driver","slug":"Java操作MongoDB之mongodb-driver","date":"2019-02-27T13:11:45.000Z","updated":"2025-10-26T01:44:37.803Z","comments":true,"path":"2019/02/27/Java操作MongoDB之mongodb-driver/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/27/Java操作MongoDB之mongodb-driver/","excerpt":"","text":"mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。通过一个入门的案例来了解mongodb-driver的基本使用： 1、查询全部记录1.1、创建工程mongoDemo，引入依赖&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt; &lt;version&gt;3.6.3&lt;/version&gt; &lt;/dependency&gt; 1.2、创建测试类public class MongoDemo1 { public static void main(String[] args) { // 创建连接 MongoClient client = new MongoClient(&quot;192.168.206.128&quot;); // 打开数据库spitdb MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 获取集合 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 查询记录，获取文档集 FindIterable&lt;Document&gt; documents = spit.find(); // 循环遍历 for (Document document : documents) { System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;)); System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;)); System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;)); } // 关闭连接 client.close(); } } 2、条件查询BasicDBObject对象：表示一个具体的记录，BasicDBObject实现了DBObject，是key/value的数据结构，用起来和HashMap是基本一致的。 2.1、查询userid为1013的记录public class MongoDemo1 { public static void main(String[] args) { // 创建连接 MongoClient client = new MongoClient(&quot;192.168.206.128&quot;); // 打开数据库spitdb MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 获取集合 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 构建查询条件，通过userid进行查询 BasicDBObject bson = new BasicDBObject(&quot;userid&quot;, &quot;1013&quot;); // 通过userid查询记录获取文档集 FindIterable&lt;Document&gt; documents = spit.find(bson); // 循环遍历 for (Document document : documents) { System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;)); System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;)); System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;)); } // 关闭连接 client.close(); } } 2.2、查询浏览量大于1000的记录public class MongoDemo2 { public static void main(String[] args) { // 创建连接 MongoClient client = new MongoClient(&quot;192.168.206.128&quot;); // 打开数据库spitdb MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 获取集合 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 构建查询条件，查询visits大于1000的结果 BasicDBObject bson = new BasicDBObject(&quot;visits&quot;, new BasicDBObject(&quot;$gt&quot;, 1000)); // 通过userid查询记录获取文档集 FindIterable&lt;Document&gt; documents = spit.find(bson); // 循环遍历 for (Document document : documents) { System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;)); System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;)); System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;)); } // 关闭连接 client.close(); } } 3、插入数据public class MongoDemo3 { public static void main(String[] args) { // 创建连接 MongoClient client = new MongoClient(&quot;192.168.206.128&quot;); // 打开数据库spitdb MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;); // 获取集合 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;); // 准备数据 HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;content&quot;, &quot;我要吐槽&quot;); map.put(&quot;userid&quot;, &quot;9999&quot;); map.put(&quot;visits&quot;, 123); map.put(&quot;publishtime&quot;, new Date()); // Document document = new Document(map); // 插入一条数据 spit.insertOne(document); // 关闭连接 client.close(); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://blog.xiongtianci.com/tags/MongoDB/"}],"author":"天赐"},{"title":"使用SpringCache进行缓存数据库查询","slug":"使用SpringCache进行缓存数据库查询","date":"2019-02-26T10:14:18.000Z","updated":"2025-10-26T01:44:37.724Z","comments":true,"path":"2019/02/26/使用SpringCache进行缓存数据库查询/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/26/使用SpringCache进行缓存数据库查询/","excerpt":"","text":"1、在SpringBoot的启动类上添加注解@EnableCaching，开启SpringCache缓存支持 @SpringBootApplication // 开启SpringCache缓存支持 @EnableCaching public class GatheringApplication { public static void main(String[] args) { SpringApplication.run(GatheringApplication.class, args); } } 2、在service的方法上添加对应的注解 /** * 根据ID查询 * * @param id * @return */ // 使用SpringCache进行缓存数据库查询 @Cacheable(value = &quot;gathering&quot;, key = &quot;#id&quot;) public Gathering findById(String id) { return gatheringDao.findById(id).get(); } /** * 修改 * * @param gathering */ // 修改数据库数据后需要删除redis中的缓存 @CacheEvict(value = &quot;gathering&quot;, key = &quot;#gathering.id&quot;) public void update(Gathering gathering) { gatheringDao.save(gathering); } /** * 删除 * * @param id */ // 删除数据库数据后需要删除redis中的缓存 @CacheEvict(value = &quot;gathering&quot;, key = &quot;#id&quot;) public void deleteById(String id) { gatheringDao.deleteById(id); }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://blog.xiongtianci.com/tags/缓存/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://blog.xiongtianci.com/tags/SpringCache/"}],"author":"天赐"},{"title":"MYSQL:WARN: Establishing SSL connection without server's identity verification is not recommended.","slug":"MYSQL-WARN-Establishing-SSL-connection-without-server-s-identity-verification-is-not-recommended","date":"2019-02-26T09:46:40.000Z","updated":"2025-10-26T01:44:37.650Z","comments":true,"path":"2019/02/26/MYSQL-WARN-Establishing-SSL-connection-without-server-s-identity-verification-is-not-recommended/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/26/MYSQL-WARN-Establishing-SSL-connection-without-server-s-identity-verification-is-not-recommended/","excerpt":"","text":"连接MySQL数据库时抛出警告：Tue Feb 26 17:38:27 CST 2019 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.这是Mysql数据库的SSL连接问题，提示警告不建议使用没有带服务器身份验证的SSL连接，是在MYSQL5.5.45+, 5.6.26+ and 5.7.6+版本中才有的这个问题 解决在配置文件application.yml中连接数据库的url后添加useSSL=false即可 spring datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.206.128:3306/tensquare_article?characterEncoding=utf8&amp;useSSL=false username: root password: ....","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"SpringDataRedis常用方法","slug":"SpringDataRedis常用方法","date":"2019-02-26T09:30:15.000Z","updated":"2025-10-26T01:44:37.691Z","comments":true,"path":"2019/02/26/SpringDataRedis常用方法/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/26/SpringDataRedis常用方法/","excerpt":"","text":"// 向redis里存入数据和设置缓存时间 stringRedisTemplate.opsForValue().set(&quot;test&quot;, &quot;100&quot;, 60 * 10, TimeUnit.SECONDS); // 根据key获取缓存中的val stringRedisTemplate.opsForValue().get(&quot;test&quot;); // val做-1操作 stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(-1); // val +1 stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(1); // 根据key获取过期时间 stringRedisTemplate.getExpire(&quot;test&quot;); // 根据key获取过期时间并换算成指定单位 stringRedisTemplate.getExpire(&quot;test&quot;, TimeUnit.SECONDS); // 根据key删除缓存 stringRedisTemplate.delete(&quot;test&quot;); // 检查key是否存在，返回boolean值 stringRedisTemplate.hasKey(&quot;546545&quot;); // 设置过期时间 stringRedisTemplate.expire(&quot;red_123&quot;, 1000, TimeUnit.MILLISECONDS); // 向指定key中存放set集合 stringRedisTemplate.opsForSet().add(&quot;red_123&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;); // 根据key查看集合中是否存在指定数据 stringRedisTemplate.opsForSet().isMember(&quot;red_123&quot;, &quot;1&quot;); // 根据key获取set集合 stringRedisTemplate.opsForSet().members(&quot;red_123&quot;);","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringDataRedis","slug":"SpringDataRedis","permalink":"https://blog.xiongtianci.com/tags/SpringDataRedis/"}],"author":"天赐"},{"title":"SpringBoot整合Redis进行缓存数据库查询","slug":"SpringBoot整合Redis进行缓存数据库查询","date":"2019-02-26T08:30:10.000Z","updated":"2025-10-26T01:44:37.674Z","comments":true,"path":"2019/02/26/SpringBoot整合Redis进行缓存数据库查询/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/26/SpringBoot整合Redis进行缓存数据库查询/","excerpt":"","text":"1、导入redis的启动器 &lt;!--redis启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、在yml配置文件中配置redis连接信息 spring: redis: host: 192.168.206.128 3、在service中通过RedisTemplate操作redis，使用redis进行缓存数据库查询 /** * 根据ID查询 * * @param id * @return */ public Article findById(String id) { // 从redis缓存中提取数据 Article article = (Article) redisTemplate.opsForValue().get(&quot;article_&quot; + id); // 如果缓存中没有，则从数据库中查询并放入缓存中 if(article == null){ article = articleDao.findById(id).get(); redisTemplate.opsForValue().set(&quot;article_&quot; + id, article); } // 返回从redis缓存中获得的数据 return article; } 4、对数据库进行删除或修改后删除redis中的缓存 /** * 修改 * * @param article */ public void update(Article article) { // 删除redis中的缓存 redisTemplate.delete(&quot;article_&quot; + article.getId()); // 修改操作 articleDao.save(article); } /** * 删除 * * @param id */ public void deleteById(String id) { // 删除redis缓存数据 redisTemplate.delete(&quot;article_&quot; + id); // 删除操作 articleDao.deleteById(id); } 5、缓存过期处理 // 设置缓存过期时间为1天 redisTemplate.opsForValue().set(&quot;article_&quot; + id, article, 1, TimeUnit.DAYS);","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.xiongtianci.com/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.xiongtianci.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"https://blog.xiongtianci.com/tags/缓存/"}],"author":"天赐"},{"title":"使用Spring Data JPA报错：javax.persistence.TransactionRequiredException: Executing an update/delete query","slug":"使用Spring-Data-JPA报错：javax-persistence-TransactionRequiredException-Executing-an-update-delete-query","date":"2019-02-26T06:18:54.000Z","updated":"2025-10-26T01:44:37.708Z","comments":true,"path":"2019/02/26/使用Spring-Data-JPA报错：javax-persistence-TransactionRequiredException-Executing-an-update-delete-query/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/26/使用Spring-Data-JPA报错：javax-persistence-TransactionRequiredException-Executing-an-update-delete-query/","excerpt":"","text":"Caused by: javax.persistence.TransactionRequiredException: Executing an update/delete query at org.hibernate.query.internal.AbstractProducedQuery.executeUpdate(AbstractProducedQuery.java:1496) 1、 报错原因：SpringData JPA事务导致的异常2、解决：在Service层添加注解@Transactional进行事务管理","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"},{"name":"JPA","slug":"JPA","permalink":"https://blog.xiongtianci.com/tags/JPA/"}],"author":"天赐"},{"title":"服务器重启后，Docker安装的mysql怎么重启？","slug":"服务器重启后，Docker安装的mysql怎么重启？","date":"2019-02-26T00:51:59.000Z","updated":"2025-10-26T01:44:37.741Z","comments":true,"path":"2019/02/26/服务器重启后，Docker安装的mysql怎么重启？/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/26/服务器重启后，Docker安装的mysql怎么重启？/","excerpt":"","text":"1、重启Docker [root@pinyoyougou-docker ~]# sudo systemctl start docker 2、列出Docker中创建的容器 [root@pinyoyougou-docker ~]# docker ps -a 3、启动mysql [root@pinyoyougou-docker ~]# docker restart 3815a718c8b5 4、查看是否启动成功 [root@pinyoyougou-docker ~]# docker ps","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.xiongtianci.com/tags/Docker/"}],"author":"天赐"},{"title":"IDEA开启Run Dashboard的配置","slug":"IDEA开启Run Dashboard的配置","date":"2019-02-25T01:52:08.000Z","updated":"2025-10-26T01:44:37.628Z","comments":true,"path":"2019/02/25/IDEA开启Run Dashboard的配置/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/25/IDEA开启Run Dashboard的配置/","excerpt":"","text":"效果Run Dashboard面板：IDEA升级到 2017.3.1 版本后，发现找不到Run Dashboard面板了。通过下面步骤教你找回Run Dashboard： 操作 找到.idea文件下的workspace.xml，通过Ctrl+F搜索RunDashboard 加入如下配置，重启服务，Run Dashboard就自动就弹出来了 &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot;/&gt; &lt;/set&gt; &lt;/option&gt; 最终配置如下：最终配置如下： &lt;component name=&quot;RunDashboard&quot;&gt; &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name=&quot;ruleStates&quot;&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt; &lt;option name=&quot;contentProportion&quot; value=&quot;0.20013662&quot; /&gt; &lt;/component&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"},{"name":"RunDashboard","slug":"RunDashboard","permalink":"https://blog.xiongtianci.com/tags/RunDashboard/"}],"author":"天赐"},{"title":"Java中List集合去重的几种方式","slug":"Java中List集合去重的几种方式","date":"2019-02-19T00:52:35.000Z","updated":"2025-10-26T01:44:37.603Z","comments":true,"path":"2019/02/19/Java中List集合去重的几种方式/","link":"","permalink":"https://blog.xiongtianci.com/2019/02/19/Java中List集合去重的几种方式/","excerpt":"","text":"准备数据： // 准备数据 List&lt;String&gt; list = new ArrayList(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); list.add(&quot;b&quot;); list.add(&quot;a&quot;); 1. 利用HashSet去重// 利用list中的元素创建HashSet集合，此时set中进行了去重操作 HashSet set = new HashSet(list); // 清空list集合 list.clear(); // 将去重后的元素重新添加到list中 list.addAll(set); 2. 通过List的contains()方法去重// 创建一个新的list集合，用于存储去重后的元素 List listTemp = new ArrayList(); // 遍历list集合 for (int i = 0; i &lt; list.size(); i++) { // 判断listTemp集合中是否包含list中的元素 if (!listTemp.contains(list.get(i))) { // 将未包含的元素添加进listTemp集合中 listTemp.add(list.get(i)); } } 3. 循环List进行去重// 从list中索引为0开始往后遍历 for (int i = 0; i &lt; list.size() - 1; i++) { // 从list中索引为 list.size()-1 开始往前遍历 for (int j = list.size() - 1; j &gt; i; j--) { // 进行比较 if (list.get(j).equals(list.get(i))) { // 去重 list.remove(j); } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"List","slug":"List","permalink":"https://blog.xiongtianci.com/tags/List/"}],"author":"天赐"},{"title":"关闭迅雷更新到新版本的提示","slug":"关闭迅雷更新到新版本的提示","date":"2019-01-17T00:36:39.000Z","updated":"2025-10-26T01:44:37.579Z","comments":true,"path":"2019/01/17/关闭迅雷更新到新版本的提示/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/17/关闭迅雷更新到新版本的提示/","excerpt":"","text":"每次打开迅雷都会自动检查是否是最新版本，如果不是最新版本，迅雷会一直重复弹窗弹出更新到新版本的提示： 解决方案简介：迅雷提示升级是因为每次迅雷主程序启动时都会同时启动一个叫XLLiveUD.exe的程序，这个程序会检查更新，所以如果不想让他检查更新，就只需要把他替换掉就可以了（因为如果删除它，每次迅雷启动时都会弹出一个错误对话框，提示找不到文件XLLiveUD.exe） 进入迅雷安装目录，找到XLLiveUD.exe( 可直接在迅雷安装目录中搜索这个文件 )，将其删除。这个就是自动升级的程序，但是删除之后下次开启迅雷会提示该文件丢失。 在同一个目录找到迅雷执行程序文件Thunder.exe，这个是就是迅雷桌面快捷方式指到的程序也就是迅雷开启程序。然后复制拷贝Thunder.exe副本，然后将副本文件名更改为迅雷更新执行程序名：XLLiveUD.exe 当迅雷程序调用检查更新的执行文件时，实际上相当于重复点击打开迅雷，而迅雷本身不允许重复打开。这样既不会报错也不会造成重复弹屏的问题。从而算是比较完美的解决了关闭迅雷更新到新版本提示的问题(❁´◡`❁)✲ﾟ","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"迅雷","slug":"迅雷","permalink":"https://blog.xiongtianci.com/tags/迅雷/"}],"author":"天赐"},{"title":"XMind8 破解激活教程（win系统）","slug":"XMind8-破解激活教程（win系统）","date":"2019-01-12T05:08:50.000Z","updated":"2025-10-26T01:44:37.544Z","comments":true,"path":"2019/01/12/XMind8-破解激活教程（win系统）/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/12/XMind8-破解激活教程（win系统）/","excerpt":"","text":"下载资源 链接 解压密码 XMind8+破解补丁 xiongtianci.com 破解安装好XMind8后，接下来进行破解 将破解补丁中的XMindCrack.jar拷贝到一个目录下( 注意：这个位置要是一个不会移动的位置，我就复制在XMind的安装目录下 )，如图 ： 修改XMind的配置文件打开XMind的配置文件XMind.ini，增加内容：-javaagent:刚刚XMindCrack.jar放置的位置 修改电脑的hosts文件，切断Xmind访问网络hosts文件目录：C:\\Windows\\System32\\drivers\\etc添加内容：0.0.0.0 www.xmind.net 添加序列号启动XMind，在帮助里面找到序列号，填写序列号邮箱任意，将破解补丁内序列号.txt文件中的内容复制到序列号中，点击验证出现下面内容证明激活成功了ヾ(๑╹◡╹)ﾉ”ヾ(●´∀｀●)","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"XMind","slug":"XMind","permalink":"https://blog.xiongtianci.com/tags/XMind/"}],"author":"天赐"},{"title":"连接Oracle报错 ORA-12638: 身份证明检索失败","slug":"连接Oracle报错-ORA-12638-身份证明检索失败","date":"2019-01-08T01:26:18.000Z","updated":"2025-10-26T01:44:37.529Z","comments":true,"path":"2019/01/08/连接Oracle报错-ORA-12638-身份证明检索失败/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/08/连接Oracle报错-ORA-12638-身份证明检索失败/","excerpt":"","text":"问题连接Oracle数据库时报错：ORA-12638: 身份证明检索失败 C:\\Users\\***&gt;sqlplus scott/tiger@192.168.56.103:1521/orcl SQL*Plus: Release 10.2.0.1.0 - Production on 星期二 1月 8 09:13:18 2019 Copyright (c) 1982, 2005, Oracle. All rights reserved. ERROR: ORA-12638: 身份证明检索失败 解决将oracle安装路径oracle\\product\\10.2.0\\db_1\\NETWORK\\ADMIN\\sqlnet.ora 文件修改一下把文件中的：SQLNET.AUTHENTICATION_SERVICES= (NTS)修改为：SQLNET.AUTHENTICATION_SERVICES= (BEQ,NONE) 修改前： # sqlnet.ora Network Configuration File: C:\\oracle\\product\\10.2.0\\db_1\\network\\admin\\sqlnet.ora # Generated by Oracle configuration tools. # This file is actually generated by netca. But if customers choose to # install &quot;Software Only&quot;, this file wont exist and without the native # authentication, they will not be able to connect to the database on NT. SQLNET.AUTHENTICATION_SERVICES= (NTS) NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT) 修改后： # sqlnet.ora Network Configuration File: C:\\oracle\\product\\10.2.0\\db_1\\network\\admin\\sqlnet.ora # Generated by Oracle configuration tools. # This file is actually generated by netca. But if customers choose to # install &quot;Software Only&quot;, this file wont exist and without the native # authentication, they will not be able to connect to the database on NT. SQLNET.AUTHENTICATION_SERVICES= (BEQ,NONE) NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"},{"name":"Oracle","slug":"Oracle","permalink":"https://blog.xiongtianci.com/tags/Oracle/"}],"author":"天赐"},{"title":"try和finally中都有return语句，执行哪一个return？","slug":"try和finally中都有return语句，执行哪一个return？","date":"2019-01-07T09:51:07.000Z","updated":"2025-10-26T01:44:37.455Z","comments":true,"path":"2019/01/07/try和finally中都有return语句，执行哪一个return？/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/07/try和finally中都有return语句，执行哪一个return？/","excerpt":"","text":"try 中的 return 语句调用的函数先于 finally 中调用的函数执行，也就是说 try 中的 return 语句先执行，finally 语句后执行，但try中的 return 并不是让函数马上返回结果，而是 return 语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行 finally 语句后才真正开始返回。但此时会出现两种情况：① 如果finally中也有return，则会直接返回finally中的return结果，并终止程序，函数栈中的return不会被完成② 如果finally中没有return，则在执行完finally中的代码之后，会将函数栈中保存的try return的内容返回并终止程序 注意： 1、不管有没有出现异常，finally块中代码都会执行2、当try和catch中有return时，finally仍然会执行3、finally是在try中return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"try{ return }finally{}中的return","slug":"try{return}finally{}中的return","date":"2019-01-07T08:57:57.000Z","updated":"2025-10-26T01:44:37.430Z","comments":true,"path":"2019/01/07/try{return}finally{}中的return/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/07/try{return}finally{}中的return/","excerpt":"","text":"try 中的 return 语句调用的函数先于 finally 中调用的函数执行，也就是说 return 语句先执行，finally 语句后执行，但 return 并不是让函数马上返回结果，而是 return 语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回结果，它要执行 finally 语句后才真正开始返回，，但此时finally块中的代码已经影响不了return返回的值了 public class Demo { public static void main(String[] args) { System.out.println(num()); } public static int num(){ int i = 0; try { i = 1; return i; }catch (Exception e){ }finally { i = 2; } return i; } } 打印结果：1 返回的是基本数据类型，直接返回值 public class Demo { public static void main(String[] args) { System.out.println(num().getI()); } public static Test num() { Test t = new Test(); try { t.setI(1); return t; } catch (Exception e) { } finally { t.setI(2); } return t; } } class Test{ private int i ; public int getI() { return i; } public void setI(int i) { this.i = i; } } 打印结果：2 返回的是对象的引用","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？","slug":"什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？","date":"2019-01-07T07:43:22.000Z","updated":"2025-10-26T01:44:37.483Z","comments":true,"path":"2019/01/07/什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/07/什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？/","excerpt":"","text":"一、什么是java虚拟机？java虚拟机(Java Virtual Machine 即 JVM)是执行字节码文件(.class)的虚拟机进程。java源程序(.java)被编译器编译成字节码文件(.class)。然后字节码文件，将由java虚拟机，解释成机器码(不同平台的机器码不同)。利用机器码操作硬件和操作系统 二、为什么java被称为平台无关的编程语言？因为不同的平台装有不同的JVM，它们能够将相同的.class文件，解释成不同平台所需要的机器码。正是因为有JVM的存在，java被称为平台无关的编程语言","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://blog.xiongtianci.com/tags/虚拟机/"}],"author":"天赐"},{"title":"MySQL存储引擎","slug":"MySQL存储引擎","date":"2019-01-07T06:47:36.000Z","updated":"2025-10-26T01:44:37.390Z","comments":true,"path":"2019/01/07/MySQL存储引擎/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/07/MySQL存储引擎/","excerpt":"","text":"存储引擎概述MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。例如，如果你在研究大量的临时数据，你也许需要使用内存MySQL存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。这些不同的技术以及配套的相关功能在 MySQL中被称作存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活性。 MySQL存储引擎种类 存储引擎 特点 InnoDB 5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢 MyISAM 高速引擎，拥有较高的插入，查询速度，但不支持事务 Memory 内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失 Falcon 一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者 Archive 将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作 CSV CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换)","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"如何控制多线程执行顺序","slug":"如何控制多线程执行顺序","date":"2019-01-05T03:03:06.000Z","updated":"2025-10-26T01:44:37.325Z","comments":true,"path":"2019/01/05/如何控制多线程执行顺序/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/05/如何控制多线程执行顺序/","excerpt":"","text":"现象public class Test02 { static Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;thread1&quot;); } }); static Thread thread2 = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;thread2&quot;); } }); static Thread thread3 = new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;thread3&quot;); } }); public static void main(String[] args) { thread1.start(); thread2.start(); thread3.start(); } } 上面的代码执行结果： // 线程执行顺序是随机的 thread1 thread3 thread2 原因：start()方法只是让子线程处于就绪状态，最终执行状态是不可控的 解决方案方案一：使用join控制多线程执行顺序 join()：让主线程等待子线程结束以后才能继续运行 public static void main(String[] args) throws Exception { thread1.start(); thread1.join(); // 让主线程放弃cpu执行权，让给子线程执行 thread2.start(); thread2.join(); thread3.start(); } 结果： thread1 thread2 thread3 join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll( 调用了JVM底层lock.notify_all(thread)方法来唤醒 )方法唤醒A线程，从而达到同步的目的 jion()源码： public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException(&quot;timeout value is negative&quot;); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } } 最终是调用object的wait方法 public final native void wait(long timeout) throws InterruptedException; join()的调用位于main Thread的main()中，所以这里当然就是阻塞main Thread了。所以thread1.join()调用后，main Thread会阻塞起来。 方案二：利用单线程化线程池(newSingleThreadExecutor)串行执行所有任务利用并发包里的Executors的newSingleThreadExecutor()产生一个单线程的线程池，而这个线程池的底层原理就是一个先进先出（FIFO）的队列。代码中executor.submit依次添加了123线程，按照FIFO的特性，执行顺序也就是123的执行结果，从而保证了执行顺序 static ExecutorService executorService = Executors.newSingleThreadExecutor(); public static void main(String[] args) throws Exception { executorService.submit(thread1); executorService.submit(thread2); executorService.submit(thread3); executorService.shutdown(); }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.xiongtianci.com/tags/多线程/"}],"author":"天赐"},{"title":"为什么 1000==1000 返回为false，而 100==100 会返回为true","slug":"为什么1000==1000返回为false，而100==100会返回为true","date":"2019-01-05T01:39:06.000Z","updated":"2025-10-26T01:44:37.293Z","comments":true,"path":"2019/01/05/为什么1000==1000返回为false，而100==100会返回为true/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/05/为什么1000==1000返回为false，而100==100会返回为true/","excerpt":"","text":"现象Integer a = 1000, b = 1000; System.out.println(a == b);//false Integer c = 100, d = 100; System.out.println(c == d);//true = 运算比较的不是值而是引用** 分析 其实正常情况Integer类型与int是不可能相等的，一个是对象类型（Integer ），一个是基础数据类型（int）。只是Java搞了自动装箱和拆箱机制，会将int转换成Integer，反之亦然。但是转换时正常情况下，装箱与拆箱的对象的内存地址应该是不同的，应该仍然不等才对，但是JVM让对应的-128~127的装箱对象都缓存起来了，这意味着每次装箱在这个范围的，直接从缓存取，不会new，通过这个trick让其相等 但是超出这个范围的默认还是一般原理就不相等了 当我们给一个Integer 对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf 的源代码就知道发生了什么： public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } IntegerCache 是Integer 的内部类，其代码如下所示： /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 简单的说，如果整型字面量的值在-128 ~ 127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以才会出现上面的现象","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"HashMap和HashTable的区别","slug":"HashMap和HashTable的区别","date":"2019-01-05T01:23:58.000Z","updated":"2025-10-26T01:44:37.275Z","comments":true,"path":"2019/01/05/HashMap和HashTable的区别/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/05/HashMap和HashTable的区别/","excerpt":"","text":"HashMap和HashTable的区别HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 HashMap是非线程安全的，HashTable是线程安全的HashMap的键和值都允许有null值存在，而HashTable则不行因为线程安全的问题，HashMap效率比HashTable的要高 1、HashMap几乎可以等价于HashTable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而HashTable则不行)。2、HashMap是非synchronized，而HashTable是synchronized，这意味着HashTable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。3、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。4、由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。5、HashMap不能保证随着时间的推移Map中的元素次序是不变的。 注意：1、 sychronized意味着在一次仅有一个线程能够更改HashTable。就是说任何线程要更新HashTable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新HashTable。2、Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。3、结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。 我们能否让HashMap同步？HashMap可以通过下面的语句进行同步： Map map = Collections.synchronizeMap(hashMap);","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"打印昨天的当前时刻","slug":"打印昨天的当前时刻","date":"2019-01-04T08:15:38.000Z","updated":"2025-10-26T01:44:37.248Z","comments":true,"path":"2019/01/04/打印昨天的当前时刻/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/04/打印昨天的当前时刻/","excerpt":"","text":"方式一：通过Calendar实现Calendar cal = Calendar.getInstance(); cal.add(Calendar.DATE,-1); System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(cal.getTime())); 方式二：通过Date实现// 1天的时间 = 24小时 x 60分钟 x 60秒 x 1000毫秒 单位是L Date yesterday = new Date(new Date().getTime() - 24 * 60 * 60 * 1000); System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(yesterday));","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？","slug":"怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？","date":"2019-01-04T08:05:49.000Z","updated":"2025-10-26T01:44:37.229Z","comments":true,"path":"2019/01/04/怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/04/怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？/","excerpt":"","text":"使用的函数： public String(byte bytes[], String charsetName) throws UnsupportedEncodingException { this(bytes, 0, bytes.length, charsetName); } 代码： String s1 = &quot;你好&quot;; String s2 = new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"MyBatis中 # 和 $ 的区别？","slug":"MyBatis中#和$的区别？","date":"2019-01-03T09:20:00.000Z","updated":"2025-10-26T01:44:37.150Z","comments":true,"path":"2019/01/03/MyBatis中#和$的区别？/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/03/MyBatis中#和$的区别？/","excerpt":"","text":"#相当于对数据加上双引号，$相当于直接显示数据 &#35;将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by &#35;user_id&#35;，如果传入的值是111，那么解析成sq 时的值为：order by “111”；如果传入的值是id，则解析成的sql为：order by “id” &#36;将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111，那么解析成sql 时的值为：order by user_id,；如果传入的值是id，则解析成的sql为：order by id &#35;方式能够很大程度防止sql 注入 &#36;方式无法防止sql注入 &#36;方式一般用于传入数据库对象，例如传入表名 一般能用&#35;的就别用&#36;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"SQL中limit的用法","slug":"SQL中limit的用法","date":"2019-01-03T08:01:40.000Z","updated":"2025-10-26T01:44:37.195Z","comments":true,"path":"2019/01/03/SQL中limit的用法/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/03/SQL中limit的用法/","excerpt":"","text":"语法 limit子句用于限制查询结果返回的数量，常用于分页查询 格式： SELECT * FROM tableName LIMIT [offset,] rows | rows OFFSET offset # tableName：表名 # offset：可选项，偏移量，指定了结果集的起始位置(从0开始)，为0时可省略 # rows：行数，指定了返回结果集的行数 limit rows 等同于 limit 0,rows 等同于 limit rows OFFSET 0 栗子： # 查询10条数据，第1条记录到第10条记录 select * from t_user limit 10; select * from t_user limit 0,10; # 查询8条数据，第6条记录到第13条记录 select * from t_user limit 5,8; //偏移量是从0开始的，因此将从第6行开始选择 offsetoffset 是 MySQL 中用于指定结果集偏移量的关键字。在使用 LIMIT 子句时，可以通过指定偏移量来跳过一定数量的行，从而获取结果集的不同部分。偏移量从0开始计数，因此 OFFSET 0 表示从结果集的第一行开始返回结果。 需要注意： 如果 offset 超过了表中的总记录数，就会返回空结果 offset 与 count 一起使用可以实现更灵活的分页查询。但如果 offset 过大，查询效率可能会受影响 如：SELECT * FROM table LIMIT 1000, 50;，这个语句会跳过前 1000 条数据，然后取 50 条数据，即第 1001 到 1050 条。 优化偏移量大的问题offset 过大，查询效率可能会受影响。这是因为 MySQL 在处理 LIMIT 子句时，需要扫描整个结果集并跳过指定数量的行，然后才能返回所需的行。 优化方案： id 是递增的情况： SELECT * FROM table WHERE id &gt; 1000000 LIMIT 10;，这里的 LIMIT 是限制了条数，没有采用偏移量 SELECT * FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; id 非递增： SELECT * FROM table WHERE id IN (SELECT id FROM table LIMIT 1000000, 10);，某些 MYSQL 版本不支持在 in 子句中使用 limit SELECT a.* FROM table a, (SELECT id FROM table LIMIT 1000000, 10) b WHERE a.id = b.id;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.xiongtianci.com/tags/SQL/"}],"author":"天赐"},{"title":"事务的基本要素（ACID）","slug":"事务的基本要素（ACID）","date":"2019-01-03T07:11:01.000Z","updated":"2025-10-26T01:44:37.212Z","comments":true,"path":"2019/01/03/事务的基本要素（ACID）/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/03/事务的基本要素（ACID）/","excerpt":"","text":"数据库事务(Transanction)正确执行的四个基本要素：1、原子性（Atomicity）：事务开始后所有操作，要么全部完成，要么全部不完成，不可能停滞在中间环节。事务执行过程中出错，会回滚（Rollback）到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账4、持久性（Durability）：事务完成后，该事务所对数据库所作的更改将被保存到数据库之中，不能回滚","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"https://blog.xiongtianci.com/tags/事务/"}],"author":"天赐"},{"title":"Mysql的四种隔离级别","slug":"Mysql的四种隔离级别","date":"2019-01-03T06:56:10.000Z","updated":"2025-10-26T01:44:37.178Z","comments":true,"path":"2019/01/03/Mysql的四种隔离级别/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/03/Mysql的四种隔离级别/","excerpt":"","text":"一、MySQL事务隔离级别 隔离级别 脏读 不可重复读 幻读 读未提交 是 是 是 读已提交 否 是 是 可重复读 否 否 是 串行化 否 否 否 在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。 未提交读（Read uncommitted）：在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上来说，未提交读不会比其他的级别好太多，但是缺乏其他级别的很多好处，在实际应用中一般很少使用。读已提交（Read committed）：大多数数据库系统的默认隔离级别都是读已提交（但Mysql不是）。读已提交满足隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。可重复读（Repeatable read）：可重复读解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom read）问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务中又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom row）。可重复读是MySQL的默认事务隔离级别。可串行化（Serializable）：可串行化是最高的隔离级别。它通过强制事务串行执行，避免了前面所说的幻读问题。简单来说，可串行化会在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑用该级别。 二、事务的并发问题1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 2、不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 3、幻读：系统管理员1将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员2就在这个时候插入了一条具体分数的记录，当系统管理员1操作结束后发现还有一条记录(2插入的那条)没有改过来，就好像发生了幻觉一样，这就叫幻读。 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"MySQL面试题","slug":"MySQL面试题","date":"2019-01-02T12:05:58.000Z","updated":"2025-10-26T01:44:37.132Z","comments":true,"path":"2019/01/02/MySQL面试题/","link":"","permalink":"https://blog.xiongtianci.com/2019/01/02/MySQL面试题/","excerpt":"","text":"1. 主键 超键 候选键 外键主 键： 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。 一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null） 超 键： 在关系中能唯一标识元组的属性集称为关系模式的超键 一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键 超键包含候选键和主键。 候选键： 是最小超键，即没有冗余元素的超键。 外 键： 在一个表中存在的另一个表的主键称此表的外键 2.数据库事务的四个特性及含义 数据库事务( transanction )正确执行的四个基本要素( ACID )：原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 原子性： 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性： 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性： 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 持久性： 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 3.drop,delete与truncate的区别 drop直接删掉表delete删除表中数据，可以加where字句truncate删除表中数据，再插入时自增长id又从1开始 1、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除的数据是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。 2、表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。 3、一般而言，drop &gt; truncate &gt; delete 4、应用范围。truncate 只能对 table；delete 可以是table和view 5、truncate 和 DELETE 只删除数据，而DROP则删除整个表（结构和数据）。 6、truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。 7、delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。 8、truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚 9、在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。 10、Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 11、TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 12、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 4.索引的工作原理及其种类 数据库索引：是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。 图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O($log_2n$)的复杂度内获取到相应数据。 创建索引可以大大提高系统的性能。 第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点： 第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。 唯一索引 唯一索引是不允许其中任何两行具有相同索引值的索引。 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。 如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"}],"author":"天赐"},{"title":"Google Chrome快捷键","slug":"Google-Chrome快捷键","date":"2018-12-27T06:15:42.000Z","updated":"2025-10-26T01:44:37.018Z","comments":true,"path":"2018/12/27/Google-Chrome快捷键/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/27/Google-Chrome快捷键/","excerpt":"","text":"标签页和窗口 操作 快捷键 打开新窗口 Ctrl + N 在无痕模式下打开新窗口 Ctrl + Shift + N 打开新的标签页，并跳转到该标签页 Ctrl + T 重新打开最后关闭的标签页，并跳转到该标签页 Ctrl + Shift + T 跳转到下一个打开的标签页 Ctrl + Tab 或 Ctrl + PgDn 跳转到上一个打开的标签页 Ctrl + Shift + Tab 或 Ctrl + PgUp 跳转到特定标签页 Ctrl + 1 到 Ctrl + 8 跳转到最后一个标签页 Ctrl + 9 在当前标签页中打开主页 Alt + Home 打开当前标签页浏览记录中记录的上一个页面 Alt + 向左箭头键 打开当前标签页浏览记录中记录的下一个页面 Alt + 向右箭头键 关闭当前标签页 Ctrl + W 或 Ctrl + F4 关闭所有打开的标签页和浏览器 Ctrl + Shift + W 最小化当前窗口 Alt + 空格键 + N 最大化当前窗口 Alt + 空格键 + X 关闭当前窗口 Alt + F4 退出 Google Chrome Ctrl + Shift + q Google Chrome 功能快捷键 操作 快捷键 打开 Chrome 菜单 Alt + F、Alt + E 或 F10 显示或隐藏书签栏 Ctrl + Shift + B 打开书签管理器 Ctrl + Shift + O 在新标签页中打开“历史记录”页 Ctrl + H 在新标签页中打开“下载内容”页 Ctrl + J 打开 Chrome 任务管理器 Shift + Esc 将焦点放置在 Chrome 工具栏中的第一项上 Shift + Alt + T 在地址栏、书签栏（若显示）和页面内容之间向前切换焦点 F6 在地址栏、书签栏（若显示）和页面内容之间向后切换焦点 Shift + F6 打开查找栏搜索当前网页 Ctrl + F 或 F3 跳转到与查找栏中搜索字词相匹配的下一条内容 Ctrl + G 跳转到与查找栏中搜索字词相匹配的上一条内容 Ctrl + Shift + G 打开“开发者工具” Ctrl + Shift + j 或 F12 打开“清除浏览数据”选项 Ctrl + Shift + Delete 在新标签页中打开 Chrome 帮助中心 F1 使用其他帐号登录或以访客身份浏览 Ctrl + Shift + m 打开反馈表单 Alt + Shift + i 地址栏快捷键 操作 快捷键 使用默认搜索引擎进行搜索 输入搜索字词并按 Enter 键 使用其他搜索引擎进行搜索 输入搜索引擎名称并按 Tab 键 为网站名称添加 www. 和 .com，并在当前标签页中打开该网站 输入网站名称并按 Ctrl+Enter 打开新的标签页并执行 Google 搜索 输入搜索字词并按 Alt+Enter 键 光标移至地址栏 Ctrl+L / Alt+D/F6 地址栏使用搜索 Ctrl+K / Ctrl+E 从地址栏中移除联想查询内容 按向下箭头键以突出显示相应内容，然后按 Shift+Delete 网页快捷键 操作 快捷键 打开选项以打印当前网页 Ctrl + p 打开选项以保存当前网页 Ctrl + s 重新加载当前网页 F5 或 Ctrl + r 重新加载当前网页（忽略缓存的内容） Shift + F5 或 Ctrl + Shift + r 停止加载网页 Esc 浏览下一个可点击项 Tab 浏览上一个可点击项 Shift + Tab 使用 Chrome 打开计算机中的文件 按住 Ctrl + o 键并选择文件 显示当前网页的 HTML 源代码（不可修改） Ctrl + u 将当前网页保存为书签 Ctrl + d 将所有打开的标签页以书签的形式保存在新文件夹中 Ctrl + Shift + d 开启或关闭全屏模式 F11 放大网页上的所有内容 Ctrl 和 + 缩小网页上的所有内容 Ctrl 和 - 将网页上的所有内容恢复到默认大小 Ctrl + 0 向下滚动网页，一次一个屏幕 空格键或 PgDn 向上滚动网页，一次一个屏幕 Shift + 空格键或 PgUp 转到网页顶部 首页 转到网页底部 末尾 在网页上水平滚动 按住 Shift 键并滚动鼠标滚轮 将光标移到文本字段中的上一个字词前面 Ctrl + 向左箭头键 将光标移到文本字段中的上一个字词后面 Ctrl + 向右箭头键 删除文本字段中的上一个字词 Ctrl + Backspace 将焦点移到通知上 Alt + n 在通知中允许 Alt + Shift + a 在通知中拒绝 Alt + Shift + d 在当前标签页中打开主页 Alt + Home 鼠标快捷键 操作 快捷键 在当前标签页中打开链接（仅限鼠标） 将链接拖到标签页中 在新的后台标签页中打开链接 按住 Ctrl 键的同时点击链接 打开链接，并跳转到该链接 按住 Ctrl + Shift 键的同时点击链接 打开链接，并跳转到该链接（仅使用鼠标） 将链接拖到标签栏的空白区域 在新窗口中打开链接 按住 Shift 键的同时点击链接 在新窗口中打开标签页（仅使用鼠标） 将标签页拖出标签栏 将标签页移至当前窗口（仅限鼠标） 将标签页拖到现有窗口中 将标签页移回其原始位置 拖动标签页的同时按 Esc 将当前网页保存为书签 将相应网址拖动到书签栏中 下载链接目标 按住 Alt 键的同时点击链接 显示浏览记录 右键点击“后退”箭头 返回 或“前进”箭头 下一个，或者左键点击（并按住鼠标左键 在最大化模式和窗口模式间切换 双击标签栏的空白区域 放大网页上的所有内容 按住 Ctrl 键的同时向上滚动鼠标滚轮 缩小网页上的所有内容 按住 Ctrl 键的同时向下滚动鼠标滚轮","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.xiongtianci.com/tags/Chrome/"},{"name":"快捷键","slug":"快捷键","permalink":"https://blog.xiongtianci.com/tags/快捷键/"}],"author":"天赐"},{"title":"SpringMVC 常用注解","slug":"SpringMVC-常用注解","date":"2018-12-26T10:22:15.000Z","updated":"2025-10-26T01:44:36.556Z","comments":true,"path":"2018/12/26/SpringMVC-常用注解/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/26/SpringMVC-常用注解/","excerpt":"","text":"1、@RequestMapping @RequestMapping：用于处理请求url映射，可以作用于类和方法上 value：定义request请求的映射地址(默认) method：定义地request址请求的方式，包括【GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.】默认接受get请求，如果请求方式和定义的方式不一样则请求无法成功 params：定义request请求中必须包含的参数值。 headers：定义request请求中必须包含某些指定的请求头，如：RequestMapping(value = “/something”, headers = “content-type=text/*”)说明请求中必须要包含”text/html”, “text/plain”这中类型的Content-type头，才是一个匹配的请求。 consumes：定义请求提交内容的类型。 produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 2、@RequestParam 用于Controller层，获取请求的参数。类似于：request.getParameter(“name”) 3、@RequestBody 用于Controller层，将请求中的json格式的数据转换成java对象 4、@ResponseBody 用于Controller层，将返回的对象转换成json格式","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://blog.xiongtianci.com/tags/SpringMVC/"}],"author":"天赐"},{"title":"Typora侧边栏的大纲视图折叠( win系统 )","slug":"Typora侧边栏的大纲视图折叠-win系统","date":"2018-12-26T02:11:23.000Z","updated":"2025-10-26T01:44:36.581Z","comments":true,"path":"2018/12/26/Typora侧边栏的大纲视图折叠-win系统/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/26/Typora侧边栏的大纲视图折叠-win系统/","excerpt":"","text":"效果 解决方案文件 &rArr; 偏好设置 &rArr; 勾选”侧边栏”","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.xiongtianci.com/tags/Typora/"}],"author":"天赐"},{"title":"MyBatis中通用Mapper接口以及Example的方法解析","slug":"MyBatis中通用Mapper接口以及Example的方法解析","date":"2018-12-25T03:04:39.000Z","updated":"2025-10-26T01:44:36.492Z","comments":true,"path":"2018/12/25/MyBatis中通用Mapper接口以及Example的方法解析/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/25/MyBatis中通用Mapper接口以及Example的方法解析/","excerpt":"","text":"一、通用Mapper中的方法解析 方法 功能说明 int countByExample(UserExample example) thorws SQLException 按条件计数 int deleteByPrimaryKey(Integer id) thorws SQLException 按主键删除 int deleteByExample(UserExample example) thorws SQLException 按条件查询 String/Integer insert(User record) thorws SQLException 插入数据（返回值为ID） User selectByPrimaryKey(Integer id) thorws SQLException 按主键查询 List selectByExample(UserExample example) thorws SQLException 按条件查询 List selectByExampleWithBLOGs(UserExample example) thorws SQLException 按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。 int updateByPrimaryKey(User record) thorws SQLException 按主键更新 int updateByPrimaryKeySelective(User record) thorws SQLException 按主键更新值不为null的字段 int updateByExample(User record, UserExample example) thorws SQLException 按条件更新 int updateByExampleSelective(User record, UserExample example) thorws SQLException 按条件更新值不为null的字段 ### 二、Example实例解析mybatis的逆向工程中会生成实例及实例对应的example，example用于添加条件，相当where后面的部分java import tk.mybatis.mapper.entity.Example; Example example = new Example(JavaBean.class); Example.Criteria criteria = example.createCriteria(); 方法 说明 example.setOrderByClause(“字段名 ASC”); 添加升序排列条件，DESC为降序 example.setDistinct(false) 去除重复，boolean型，true为选择不重复的记录。 criteria.andXxxIsNull 添加字段xxx为null的条件 criteria.andXxxIsNotNull 添加字段xxx不为null的条件 criteria.andXxxEqualTo(value) 添加xxx字段等于value条件 criteria.andXxxNotEqualTo(value) 添加xxx字段不等于value条件 criteria.andXxxGreaterThan(value) 添加xxx字段大于value条件 criteria.andXxxGreaterThanOrEqualTo(value) 添加xxx字段大于等于value条件 criteria.andXxxLessThan(value) 添加xxx字段小于value条件 criteria.andXxxLessThanOrEqualTo(value) 添加xxx字段小于等于value条件 criteria.andXxxIn(List&lt;？&gt;) 添加xxx字段值在List&lt;？&gt;条件 criteria.andXxxNotIn(List&lt;？&gt;) 添加xxx字段值不在List&lt;？&gt;条件 criteria.andXxxLike(“%”+value+”%”) 添加xxx字段值为value的模糊查询条件 criteria.andXxxNotLike(“%”+value+”%”) 添加xxx字段值不为value的模糊查询条件 criteria.andXxxBetween(value1,value2) 添加xxx字段值在value1和value2之间条件 criteria.andXxxNotBetween(value1,value2) 添加xxx字段值不在value1和value2之间条件 三、使用案例1.查询① selectByPrimaryKey() 按主键查询 //相当于：select * from user where id = 100; User user = UserMapper.selectByPrimaryKey(100); ② selectByExample() 和 selectByExampleWithBLOGs() //相当于：select * from user where username = &#39;wyw&#39; // and username is null order by username asc,email desc UserExample example = new UserExample(); Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(&quot;wyw&quot;); criteria.andUsernameIsNull(); example.setOrderByClause(&quot;username asc,email desc&quot;); List&lt;?&gt;list = XxxMapper.selectByExample(example); 2.插入数据①insert() //相当于：insert into user(ID,username,password,email) values //(&#39;dsfgsdfgdsfgds&#39;,&#39;jack&#39;,&#39;1234&#39;,&#39;hello@126.com&#39;); User user = new User(); user.setId(&quot;dsfgsdfgdsfgds&quot;); user.setUsername(&quot;jack&quot;); user.setPassword(&quot;1234&quot;) user.setEmail(&quot;hello@163.com&quot;); XxxMapper.insert(user); 3.更新数据①updateByPrimaryKey() //相当于：update user set username=&#39;rose&#39;, password=&#39;5678&#39;, //email=&#39;hello@163.com&#39; where id=&#39;a01&#39; User user =new User(); user.setId(&quot;a01&quot;); user.setUsername(&quot;rose&quot;); user.setPassword(&quot;5678&quot;); user.setEmail(&quot;hello@163.com&quot;); XxxMapper.updateByPrimaryKey(user); ②updateByPrimaryKeySelective() //相当于：update user set password=&#39;7890&#39; where id=&#39;a01&#39; User user = new User(); user.setId(&quot;a01&quot;); user.setPassword(&quot;7890&quot;); XxxMapper.updateByPrimaryKey(user); ③ updateByExample() 和 updateByExampleSelective() //相当于：update user set password=&#39;6666&#39; where username=&#39;jack&#39; UserExample example = new UserExample(); Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(&quot;jack&quot;); User user = new User(); user.setPassword(&quot;6666&quot;); XxxMapper.updateByPrimaryKeySelective(user,example); updateByExample()更新所有的字段，包括字段为null的也更新建议使用 updateByExampleSelective()更新想更新的字段 4.删除数据①deleteByPrimaryKey() //相当于：delete from user where id=1 XxxMapper.deleteByPrimaryKey(1); ②deleteByExample() //相当于：delete from user where username=&#39;jack&#39; UserExample example = new UserExample(); Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(&quot;jack&quot;); XxxMapper.deleteByExample(example); 5.查询数据数量①countByExample() //相当于：select count(*) from user where username=&#39;jack&#39; UserExample example = new UserExample(); Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(&quot;jack&quot;); int count = XxxMapper.countByExample(example);","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.xiongtianci.com/tags/MyBatis/"}],"author":"天赐"},{"title":"抽象类和接口有什么不同点？","slug":"抽象类和接口有什么不同点？","date":"2018-12-25T01:31:16.000Z","updated":"2025-10-26T01:44:36.507Z","comments":true,"path":"2018/12/25/抽象类和接口有什么不同点？/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/25/抽象类和接口有什么不同点？/","excerpt":"","text":"参数 抽象类 接口 默认的方法实现 它可以有默认的方法实现 接口完全是抽象的。它根本不存在方法的实 实现 子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 子类使用关键字 implements 来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常Java类的区别 除了你不能实例化抽象类之外，它和普通Java 类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有 public、protected 和 default 这些修饰符 接口方法默认修饰符是 public。你不可以使用其它修饰符 main 方法 抽象方法可以有main 方法并且我们可以运行它 接口没有main 方法，因此我们不能运行它 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口 速度 它比接口速度要快 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法 添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码 如果你往接口中添加方法，那么你必须改变实现该接口的类","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"面试题：说下原生jdbc 操作数据库流程？","slug":"面试题：说下原生jdbc-操作数据库流程？","date":"2018-12-25T00:25:40.000Z","updated":"2025-10-26T01:44:36.525Z","comments":true,"path":"2018/12/25/面试题：说下原生jdbc-操作数据库流程？/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/25/面试题：说下原生jdbc-操作数据库流程？/","excerpt":"","text":"原生的jdbc操作数据库流程：1.注册驱动程序：Class.forName(“com.mysql.jdbc.Driver”);2.使用驱动管理类来获取数据连接对象：conn = DriverManager.getConnection(…);3.获取数据库操作对象：Statement stmt = conn.createStatement();4.定义操作的SQL语句5.执行SQL：stmt.executeQuery(sql);6.处理结果集：ResultSet，如果SQL前有参数值就设置参数值setXXX()7.关闭对象，回收数据库资源（关闭结果集–&gt;关闭数据库操作对象–&gt;关闭连接） public class JDBCTest { /** * 使用JDBC连接并操作mysql数据库 */ public static void main(String[] args) { // 数据库驱动类名的字符串 String driver = &quot;com.mysql.jdbc.Driver&quot;; // 数据库连接串 String url = &quot;jdbc:mysql://127.0.0.1:3306/jdbctest&quot;; // 用户名 String username = &quot;root&quot;; // 密码 String password = &quot;1234&quot;; Connection conn = null; Statement stmt = null; ResultSet rs = null; try { // 1、加载数据库驱动（ 成功加载后，会将Driver类的实例注册到DriverManager类中） Class.forName(driver); // 2、获取数据库连接 conn = DriverManager.getConnection(url, username, password); // 3、获取数据库操作对象 stmt = conn.createStatement(); // 4、定义操作的SQL语句 String sql = &quot;select * from user where id = 100&quot;; // 5、执行数据库操作 rs = stmt.executeQuery(sql); // 6、获取并操作结果集 while (rs.next()) { System.out.println(rs.getInt(&quot;id&quot;)); System.out.println(rs.getString(&quot;name&quot;)); } } catch (Exception e) { e.printStackTrace(); } finally { // 7、关闭对象，回收数据库资源 if (rs != null) { //关闭结果集对象 try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt != null) { // 关闭数据库操作对象 try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { // 关闭数据库连接对象 try { if (!conn.isClosed()) { conn.close(); } } catch (SQLException e) { e.printStackTrace(); } } } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"JDBC","slug":"JDBC","permalink":"https://blog.xiongtianci.com/tags/JDBC/"}],"author":"天赐"},{"title":"跨域问题&cors解决跨域","slug":"跨域问题-cors解决跨域","date":"2018-12-21T00:42:19.000Z","updated":"2025-10-26T01:44:36.473Z","comments":true,"path":"2018/12/21/跨域问题-cors解决跨域/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/21/跨域问题-cors解决跨域/","excerpt":"","text":"跨域问题 跨域：浏览器对于javascript的同源策略的限制 。 以下情况都属于跨域：| 跨域原因说明 | 示例 || ——— | ————————————- || 域名不同 | www.jd.com 与 www.taobao.com || 域名相同，端口不同 | www.jd.com:8080 与 www.jd.com:8081 || 二级域名不同 | item.jd.com 与 miaosha.jd.com | 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 为什么有跨域问题？跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是与当前页域名相同的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 解决跨域问题的方案目前比较常用的跨域解决方案有3种： Jsonp最早的解决方案，利用script标签可以跨域的原理实现。限制： 需要服务的支持 只能发起GET请求 nginx反向代理思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式缺点：需要在nginx进行额外配置，语义不清晰 CORS规范化的跨域请求解决方案，安全可靠。优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 cors解决跨域1.什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 2.原理有点复杂浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 2.1.简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：Origin.Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： Access-Control-Allow-Origin: http://manage.leyou.com Access-Control-Allow-Credentials: true Content-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名） Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 有关cookie： 要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 2.2.特殊请求不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： OPTIONS /cors HTTP/1.1 Origin: http://manage.leyou.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.leyou.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://manage.leyou.com Access-Control-Allow-Credentials: true Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Max-Age: 1728000 Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 3.实现非常简单虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在leyou-gateway中编写一个配置类，并且注册CorsFilter： import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; @Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(&quot;http://manage.leyou.com&quot;); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(&quot;OPTIONS&quot;); config.addAllowedMethod(&quot;HEAD&quot;); config.addAllowedMethod(&quot;GET&quot;); config.addAllowedMethod(&quot;PUT&quot;); config.addAllowedMethod(&quot;POST&quot;); config.addAllowedMethod(&quot;DELETE&quot;); config.addAllowedMethod(&quot;PATCH&quot;); // 4）允许的头信息 config.addAllowedHeader(&quot;*&quot;); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(&quot;/**&quot;, config); //3.返回新的CorsFilter. return new CorsFilter(configSource); } } 结构：","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"跨域","slug":"跨域","permalink":"https://blog.xiongtianci.com/tags/跨域/"}],"author":"天赐"},{"title":"CollectionUtils工具类使用指南","slug":"CollectionUtils工具类使用指南","date":"2018-12-20T12:58:08.000Z","updated":"2025-10-26T01:44:36.326Z","comments":true,"path":"2018/12/20/CollectionUtils工具类使用指南/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/20/CollectionUtils工具类使用指南/","excerpt":"","text":"CollectionUtils提供很多对集合的操作方法，常用的方法如下： //并集 Collection&lt;String&gt; union = CollectionUtils.union(a, b); //交集 Collection&lt;String&gt; intersection = CollectionUtils.intersection(a, b); //交集的补集 Collection&lt;String&gt; disjunction = CollectionUtils.disjunction(a, b); //集合相减 Collection&lt;String&gt; subtract = CollectionUtils.subtract(a, b); //判断集合是否为空 Boolean boolean = CollectionUtils.isEmpty(Collection&lt;?&gt; collection); //判断集合是否不为空 Boolean boolean = CollectionUtils.isNotEmpty(Collection&lt;?&gt; collection); 并集@Test public void testUnion(){ String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; }; String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; }; List&lt;String&gt; listA = Arrays.asList(arrayA); List&lt;String&gt; listB = Arrays.asList(arrayB); //2个数组取并集 System.out.println(ArrayUtils.toString(CollectionUtils.union(listA, listB))); //[A, B, C, D, E, F, G, H, K] } 交集@Test public void testIntersection(){ String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; }; String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; }; List&lt;String&gt; listA = Arrays.asList(arrayA); List&lt;String&gt; listB = Arrays.asList(arrayB); //2个数组取交集 System.out.println(ArrayUtils.toString(CollectionUtils.intersection(listA, listB))); //[B, D, F] } 交集的补集（析取）@Test public void testDisjunction(){ String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; }; String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; }; List&lt;String&gt; listA = Arrays.asList(arrayA); List&lt;String&gt; listB = Arrays.asList(arrayB); //2个数组取交集 的补集 System.out.println(ArrayUtils.toString(CollectionUtils.disjunction(listA, listB))); //[A, C, E, G, H, K] } 差集（扣除）@Test public void testSubtract(){ String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; }; String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; }; List&lt;String&gt; listA = Arrays.asList(arrayA); List&lt;String&gt; listB = Arrays.asList(arrayB); //arrayA扣除arrayB System.out.println(ArrayUtils.toString(CollectionUtils.subtract(listA, listB))); //[A, C, E] } 集合是否为空@Test public void testIsEmpty(){ class Person{} class Girl extends Person{} List&lt;Integer&gt; first = new ArrayList&lt;&gt;(); List&lt;Integer&gt; second = null; List&lt;Person&gt; boy = new ArrayList&lt;&gt;(); //每个男孩心里都装着一个女孩 boy.add(new Girl()); //判断集合是否为空 System.out.println(CollectionUtils.isEmpty(first)); //true System.out.println(CollectionUtils.isEmpty(second)); //true System.out.println(CollectionUtils.isEmpty(boy)); //false //判断集合是否不为空 System.out.println(CollectionUtils.isNotEmpty(first)); //false System.out.println(CollectionUtils.isNotEmpty(second)); //false System.out.println(CollectionUtils.isNotEmpty(boy)); //true } 集合是否相等@Test public void testIsEqual(){ class Person{} class Girl extends Person{ } List&lt;Integer&gt; first = new ArrayList&lt;&gt;(); List&lt;Integer&gt; second = new ArrayList&lt;&gt;(); first.add(1); first.add(2); second.add(2); second.add(1); Girl goldGirl = new Girl(); List&lt;Person&gt; boy1 = new ArrayList&lt;&gt;(); //每个男孩心里都装着一个女孩 boy1.add(new Girl()); List&lt;Person&gt; boy2 = new ArrayList&lt;&gt;(); //每个男孩心里都装着一个女孩 boy2.add(new Girl()); //比较两集合值 System.out.println(CollectionUtils.isEqualCollection(first,second)); //true System.out.println(CollectionUtils.isEqualCollection(first,boy1)); //false System.out.println(CollectionUtils.isEqualCollection(boy1,boy2)); //false List&lt;Person&gt; boy3 = new ArrayList&lt;&gt;(); //每个男孩心里都装着一个女孩 boy3.add(goldGirl); List&lt;Person&gt; boy4 = new ArrayList&lt;&gt;(); boy4.add(goldGirl); System.out.println(CollectionUtils.isEqualCollection(boy3,boy4)); //true } 不可修改的集合我们对c进行操作，s也同样获得了和c相同的内容，这样就可以避免其他人员修改这个s对象。有时候需要对它进行保护，避免返回结果被人修改。 @Test public void testUnmodifiableCollection(){ Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); Collection&lt;String&gt; s = CollectionUtils.unmodifiableCollection(c); c.add(&quot;boy&quot;); c.add(&quot;love&quot;); c.add(&quot;girl&quot;); //! s.add(&quot;have a error&quot;); System.out.println(s); } Collections.unmodifiableCollection可以得到一个集合的镜像，它的返回结果是不可直接被改变，否则会提示错误 java.lang.UnsupportedOperationException at org.apache.commons.collections.collection.UnmodifiableCollection.add(UnmodifiableCollection.java:75)","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://blog.xiongtianci.com/tags/工具类/"},{"name":"CollectionUtils","slug":"CollectionUtils","permalink":"https://blog.xiongtianci.com/tags/CollectionUtils/"}],"author":"天赐"},{"title":"通用Mapper的select(T t)的使用","slug":"通用Mapper的select(T t)的使用","date":"2018-12-20T12:35:14.000Z","updated":"2025-10-26T01:44:36.457Z","comments":true,"path":"2018/12/20/通用Mapper的select(T t)的使用/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/20/通用Mapper的select(T t)的使用/","excerpt":"","text":"通用mapper类： public interface CategoryMapper extends Mapper&lt;Category&gt; { } 使用select(T t) public List&lt;Category&gt; queryCategoryListByParentId(Long pid) { // select(T t) 将对象c中的非空字段当作查询的条件参数 Category record = new Category(); record.setParentId(pid); return this.categoryMapper.select(record); } select(T t) 将实例对象t中的非空字段作为条件参数上面实例转换的sql语句：select * from category c where c.pid = #{pid}","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Mapper","slug":"Mapper","permalink":"https://blog.xiongtianci.com/tags/Mapper/"}],"author":"天赐"},{"title":"使用nginx进行反向代理","slug":"使用nginx进行反向代理","date":"2018-12-20T09:17:17.000Z","updated":"2025-10-26T01:44:36.440Z","comments":true,"path":"2018/12/20/使用nginx进行反向代理/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/20/使用nginx进行反向代理/","excerpt":"","text":"什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器(代理服务器)代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图： 安装和使用安装安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！ 下载nginx：http://nginx.org/en/download.html 我们在本地安装一台nginx： 解压后，目录结构： conf：配置目录 contrib：第三方依赖 html：默认的静态资源目录，类似于tomcat的webapps logs：日志目录 nginx.exe：启动程序。可双击运行，但不建议这么做。 反向代理配置示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： #user nobody; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server { listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / { proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; } } server { listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / { proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; } } } 使用nginx可以通过命令行来启动，操作命令： 启动：start nginx.exe 停止：nginx.exe -s stop 重新加载：nginx.exe -s reload 启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程： 测试启动nginx，然后用域名访问后台管理系统：现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问 http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口： http://127.0.0.1:80本机的nginx一直监听 80 端口，因此捕获这个请求 nginx中配置了反向代理规则，将 manage.leyou.com 代理到 127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.xiongtianci.com/tags/Nginx/"},{"name":"反向代理","slug":"反向代理","permalink":"https://blog.xiongtianci.com/tags/反向代理/"}],"author":"天赐"},{"title":"win10使用Switchhost显示无修改权限","slug":"win10使用Switchhost显示无修改权限","date":"2018-12-20T08:41:06.000Z","updated":"2025-10-26T01:44:36.425Z","comments":true,"path":"2018/12/20/win10使用Switchhost显示无修改权限/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/20/win10使用Switchhost显示无修改权限/","excerpt":"","text":"现象使用Switchhost!操作电脑hosts文件时，显示无修改权限，即使使用管理员身份运行Switchhost!也是如此 解决方案 找到hosts文件 路径：C:\\Windows\\System32\\drivers\\etc 右键hosts，点击属性 取消常规中只读的勾选 选择安全 点击编辑，赋予Users 完全权限","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"}],"author":"天赐"},{"title":"IDEA报错：Lombok Requires Annotation Processing","slug":"IDEA报错：Lombok Requires Annotation Processing","date":"2018-12-20T08:17:49.000Z","updated":"2025-10-26T01:44:36.366Z","comments":true,"path":"2018/12/20/IDEA报错：Lombok Requires Annotation Processing/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/20/IDEA报错：Lombok Requires Annotation Processing/","excerpt":"","text":"现象Lombok安装完成之后，启动项目时出现 Lombok Requires Annotation Processing 的错误提示 16:08 Lombok Requires Annotation Processing Annotation processing seems to be disabled for the project &quot;leyou&quot;. For the plugin to function correctly, please enable it under &quot;Settings &gt; Build &gt; Compiler &gt; Annotation Processors&quot; 解决方案依次点 File &rarr; Settings &rarr; Build, Execution, Deploymen &rarr; Annotation Processors 打开编辑页面，勾上 Enable annotation processing 前面的选框，保存重启IDEA即可解决","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"},{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"}],"author":"天赐"},{"title":"Java中clone()与new的区别？","slug":"Java中clone()与new的区别？","date":"2018-12-20T03:27:48.000Z","updated":"2025-10-26T01:44:36.398Z","comments":true,"path":"2018/12/20/Java中clone()与new的区别？/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/20/Java中clone()与new的区别？/","excerpt":"","text":"为什么要使用clone()？在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A 中已经包含了一些有效值，此时可能会需要一个和A 完全相同新对象B，并且此后对B 任何改动都不会影响到A 中的值，也就是说，A 与B 是两个独立的对象，但B 的初始值是由A 对象确定的。在Java 语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现clone()方法是其中最简单，也是最高效的手段 clone()与new的区别 clone()不会调用构造方法；new会调用构造方法 clone()更快。clone()能快速创建一个已有对象的副本，即创建对象并且将已有对象中所有属性值克隆；new只能在JVM中申请一个空的内存区域，对象的属性值要通过构造方法赋值","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"基本数据类型与String之间的转换","slug":"基本数据类型与String之间的转换","date":"2018-12-19T13:12:35.000Z","updated":"2025-10-26T01:44:36.309Z","comments":true,"path":"2018/12/19/基本数据类型与String之间的转换/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/19/基本数据类型与String之间的转换/","excerpt":"","text":"字符串转基本数据类型调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型。 基本数据类型转字符串一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String类中的valueOf()方法返回相应字符串","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"为何short s1=1;是对的，而float f=3.4;是错的？","slug":"为何short s1=1;是对的，而float f=3.4;是错的？","date":"2018-12-19T12:42:28.000Z","updated":"2025-10-26T01:44:36.292Z","comments":true,"path":"2018/12/19/为何short s1=1;是对的，而float f=3.4;是错的？/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/19/为何short s1=1;是对的，而float f=3.4;是错的？/","excerpt":"","text":"在Java中，没小数点的默认是int ,有小数点的默认是 double 编译器可以自动向上转型，如 int 转成 long 系统自动转换没有问题，因为后者精度更高 ；但如果是向下转型，就需要强制类型转换 short类型变量的初始化语句，只要不超过short范围( -215 ~ 215-1 )的就可以直接初始化，所以short s1 = 1;是对的；而对于小数，默认情况下：float f=3.4;中的小数3.4此时为double类型。此时，等式float f=3.4;左边为float类型，等式右边为double类型，将涉及到强制类型转换，所以float f=3.4;这个写法是错误的，","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"ES6语法指南","slug":"ES6语法指南","date":"2018-12-18T08:10:28.000Z","updated":"2025-10-26T01:44:36.276Z","comments":true,"path":"2018/12/18/ES6语法指南/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/18/ES6语法指南/","excerpt":"","text":"作者：阮一峰 链接：http://es6.ruanyifeng.com/ ES6 语法指南后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： for(var i = 0; i &lt; 5; i++){ console.log(i); } console.log(&quot;循环外：&quot; + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： for(let i = 0; i &lt; 5; i++){ console.log(i); } console.log(&quot;循环外：&quot; + i) 结果： const const声明的变量是常量，不能被修改 3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 3.3.解构表达式 数组解构 比如有一个数组： let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值 // 然后打印 console.log(x,y,z); 结果： 对象解构 例如有个person对象： const person = { name:&quot;jack&quot;, age:21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } 我们可以这么做： // 解构表达式获取值 const {name,age,language} = person; // 打印 console.log(name); console.log(age); console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： function add(a , b) { // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b; } // 传一个参数 console.log(add(10)); 现在可以这么写： function add(a , b = 1) { return a + b; } // 传一个参数 console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： var print = function (obj) { console.log(obj); } // 简写为： var print2 = obj =&gt; console.log(obj); 多个参数： // 两个参数的情况： var sum = function (a , b) { return a + b; } // 简写为： var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 var sum3 = (a,b) =&gt; { return a + b; } 对象的函数属性简写 比如一个Person对象，里面有eat方法： let person = { name: &quot;jack&quot;, // 以前： eat: function (food) { console.log(this.name + &quot;在吃&quot; + food); }, // 箭头函数版： eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food),// 这里拿不到this // 简写版： eat3(food){ console.log(this.name + &quot;在吃&quot; + food); } } 箭头函数结合解构表达式 比如有一个函数： const person = { name:&quot;jack&quot;, age:21, language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;] } function hello(person) { console.log(&quot;hello,&quot; + person.name) } 如果用箭头函数和解构表达式 var hi = ({name}) =&gt; console.log(&quot;hello,&quot; + name); 3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 let arr = [&#39;1&#39;,&#39;20&#39;,&#39;-5&#39;,&#39;3&#39;]; console.log(arr) arr = arr.map(s =&gt; parseInt(s)); console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： const arr = [1,20,-5,3] 没有初始值： 指定初始值： 3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： const promise = new Promise(function(resolve, reject) { // ... 执行异步操作 if (/* 异步操作成功 */){ resolve(value);// 调用resolve，代表Promise将返回成功的结果 } else { reject(error);// 调用reject，代表Promise会返回失败结果 } }); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： promise.then(function(value){ // 异步执行成功后的回调 }); 如果想要处理promise异步执行失败的事件，还可以跟上catch： promise.then(function(value){ // 异步执行成功后的回调 }).catch(function(error){ // 异步执行失败后的回调 }) 示例： const p = new Promise(function (resolve, reject) { // 这里我们用定时任务模拟异步 setTimeout(() =&gt; { const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) { resolve(&quot;成功！num:&quot; + num) } else { reject(&quot;出错了！num:&quot; + num) } }, 300) }) // 调用promise p.then(function (msg) { console.log(msg); }).catch(function (msg) { console.log(msg); }) 结果： 3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： // Set构造函数可以接收一个数组或空 let set = new Set(); set.add(1);// [1] // 接收数组 let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： set.add(1);// 添加 set.clear();// 清空 set.delete(2);// 删除指定元素 set.has(2); // 判断是否存在 set.keys();// 返回所有key set.values();// 返回所有值 set.entries();// 返回键值对集合 // 因为set没有键值对，所有其keys、values、entries方法返回值一样的。 set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： // map接收一个数组，数组中的元素是键值对数组 const map = new Map([ [&#39;key1&#39;,&#39;value1&#39;], [&#39;key2&#39;,&#39;value2&#39;], ]) // 或者接收一个set const set = new Set([ [&#39;key1&#39;,&#39;value1&#39;], [&#39;key2&#39;,&#39;value2&#39;], ]) const map2 = new Map(set) // 或者其它map const map3 = new Map(map); 方法： 3.8.模块化3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： const util = { sum(a,b){ return a + b; } } 我可以使用export将这个对象导出： const util = { sum(a,b){ return a + b; } } export util; 当然，也可以简写为： export const util = { sum(a,b){ return a + b; } } export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： var name = &quot;jack&quot; var age = 21 export {name,age} 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： // 无需声明对象的名字 export default { sum(a,b){ return a + b; } } 这样，当使用者导入时，可以任意起名字 3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： // 导入util import util from &#39;hello.js&#39; // 调用util中的属性 util.sum(1,2) 要批量导入前面导出的name和age： import {name, age} from &#39;user.js&#39; console.log(name + &quot; , 今年&quot;+ age +&quot;岁了&quot;) 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"},{"name":"转载","slug":"转载","permalink":"https://blog.xiongtianci.com/categories/转载/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://blog.xiongtianci.com/tags/ES6/"}],"author":"天赐"},{"title":"IntellijIDEA使用时的小技巧","slug":"Intellij IDEA使用时的小技巧","date":"2018-12-17T10:24:16.000Z","updated":"2025-10-26T01:44:36.255Z","comments":true,"path":"2018/12/17/Intellij IDEA使用时的小技巧/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/17/Intellij IDEA使用时的小技巧/","excerpt":"","text":"使用Inject language编写JSON字符串如果你使用IDEA在编写JSON字符串的时候，然后要一个一个\\去转义双引号的话，就实在太不应该了，又烦又容易出错。在IDEA可以使用Inject language帮我们自动转义双引号 在双引号内 Alt+回车，选择Inject language or reference，然后回车 输入 json，在列表中选择 json组件，回车 选择完后，在双引号内Alt+回车，选择Edit JSON Fragment，回车 此时将弹出编辑JSON文件的视图了 可以看到IDEA确实帮我们自动转义双引号了。如果要退出编辑JSON信息的视图，只需要使用Ctrl+F4快捷键即可。 Structure展示一个类的所有方法或者使用Ctrl+F12弹框查看当前类的所有方法","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"自定义百度云分享密码","slug":"自定义百度云分享密码","date":"2018-12-14T01:13:35.000Z","updated":"2025-10-26T01:44:36.230Z","comments":true,"path":"2018/12/14/自定义百度云分享密码/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/14/自定义百度云分享密码/","excerpt":"","text":"第一步打开百度云盘网页版 第二步找到需要分享的资源，点击分享之后看见下面内容： 别动，重点的在后面 第三步按下F12，进入开发者模式，点击 consle 进入控制台，如下图： 第四步在控制台中输入下面代码，按下回车 avascript:require([“function-widget-1:share/util/shareFriend/createLinkShare.js”]).prototype.makePrivatePassword=function(){return prompt(“请输入自定义的密码”,”1234”)} 第五步关闭开发者模式，点击“创建链接”，输入你想要自定义的密码，回车确定即可","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"百度网盘","slug":"百度网盘","permalink":"https://blog.xiongtianci.com/tags/百度网盘/"}],"author":"天赐"},{"title":"微信小程序笔记","slug":"微信小程序笔记","date":"2018-12-11T13:15:58.000Z","updated":"2025-10-26T01:44:36.213Z","comments":true,"path":"2018/12/11/微信小程序笔记/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/11/微信小程序笔记/","excerpt":"","text":"微信小程序账号与工具在线文档：https://mp.weixin.qq.com/debug/wxadoc/dev/ 小程序开发者账号注册微信公众平台：https://mp.weixin.qq.com/ 小程序开发者账号注册：https://mp.weixin.qq.com/wxopen/waregister?action=step1 微信开发者工具微信开发者工具：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html 小程序在线Demo二维码体验小程序官方源码：https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip 微信小程序文件结构主体文件结构主体部分由三个文件组成，必须放在项目的根目录，如下： 文件 必填 作用 app.js 是 小程序逻辑 app.json 是 小程序公共设置 app.wxss 否 小程序公共样式表 页面文件结构页面由四个文件组成，分别是： 文件类型 必填 作用 js 是 页面逻辑 ( 微信小程序没有window和document对象 ) wxml 是 页面结构 ( XML语法，不是HTML语法 ) wxss 否 页面样式表 ( 拓展了rpx尺寸单位，微信专属响应式像素 ) json 否 页面配置 ( 不能写注释，否则编译报错 ) WXML 结构_基础 (标签、组件)组件文档：https://mp.weixin.qq.com/debug/wxadoc/dev/component/ 常用布局标签(组件)&lt;view&gt;&lt;/view&gt; 相当于 &lt;div&gt;&lt;/div&gt; &lt;text&gt;&lt;/text&gt; 相当于 &lt;span&gt;&lt;/span&gt; &lt;image&gt;&lt;/image&gt; 相当于 &lt;img /&gt; &lt;navigator&gt;&lt;/navigator&gt; 相当于 &lt;a&gt;&lt;/a&gt; &lt;block&gt;&lt;/block&gt; 区块标签，不会渲染到页面 注意：image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高 常用表单标签(组件)&lt;button&gt;&lt;/button&gt; &lt;input type=&quot;text&quot; /&gt; &lt;checkbox /&gt; &lt;radio/&gt; 轮播图组件&lt;swiper indicator-dots=&quot;是否显示面板指示点&quot; autoplay=&quot;是否自动切换&quot; interval=&quot;自动切换时间间隔&quot; duration=&quot;滑动动画时长&quot;&gt; &lt;swiper-item&gt; &lt;image src=&quot;图片路径1&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&quot;图片路径2&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; 探索：实现无缝轮播怎么办？ WXSS 样式WXSS (WeiXin Style Sheets) 是一套样式语言。 WXSS文档： https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html WXSS 新增特性与 CSS 相比，WXSS 扩展以下2个特性： 尺寸单位 rpx ( responsive pixel 响应式像素) 样式导入 @import “样式表路径”; 尺寸单位 rpx ( responsive pixel 响应式像素) : 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 JSON 配置配置文档：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html app.json 配置项列表 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口表现 tabBar Object 否 设置底部 tab 的表现 networkTimeout Object 否 设置网络超时时间 debug Boolean 否 设置是否开启 debug 模式 如：app.json { &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;: { &quot;navigationBarTitleText&quot;: &quot;小程序标题&quot; }, &quot;tabBar&quot;: { &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; }, { &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;Tab栏&quot; }] }, &quot;networkTimeout&quot;: { &quot;request&quot;: 10000, &quot;downloadFile&quot;: 10000 }, &quot;debug&quot;: true } window 配置 用于设置小程序的状态栏、导航条、标题、窗口背景色。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉背景字体、loading 图的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数。 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px window 配置图示 window 配置注意事项 !! 注意：页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个关键词。 如：/pages/message/message.json { &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;内页标题修改&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot; } tabBar 配置如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 属性说明： 属性 类型 必填 默认值 描述 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black/white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top，设置成top是无图标 其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 tabBar 配置图示 tabBar 配置注意事项 当设置 position 为 top 时，将不会显示 icon。 tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 icon 大小限制为40kb，建议尺寸为 81px * 81px。 JS 行为(逻辑)微信小程序生命周期函数Page({ /** 页面的初始数据 */ data: { }, /** 生命周期函数--监听页面加载 */ onLoad: function (options) { console.log(options); }, /** 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** 生命周期函数--监听页面显示 */ onShow: function () { }, /** 生命周期函数--监听页面隐藏 */ onHide: function () { }, /** 生命周期函数--监听页面卸载 */ onUnload: function () { } }) 页面相关事件处理函数 /** 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { }, /** 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /** 用户点击右上角分享 */ onShareAppMessage: function () { } 注意事项 微信小程序没有BOM和DOM概念，所以不能使用window对象和document对象。 WXML 高级(指令、事件)数据绑定 &#123;&#123; &#125;&#125;&lt;!--wxml--&gt; &lt;view&gt; {{message}} &lt;/view&gt; // page.js Page({ data: { message: &#39;Hello MINA!&#39; } }) 特别注意 花括号和引号之间不能有空格。 不要直接写 checked=”false”，其计算结果是一个字符串，转成 boolean 类型后代表真值。 &lt;checkbox checked=&quot;false&quot;&gt; &lt;/checkbox&gt; 其计算结果是一个字符串，转成 boolean 类型后变成了 true &lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt; 正确写法 列表渲染 wx:for&lt;!--wxml--&gt; &lt;view wx:for=&quot;{{array}}&quot;&gt; {{item}} &lt;/view&gt; // page.js Page({ data: { array: [1, 2, 3, 4, 5] } }) wx:key主要功能：提高列表渲染时排序的效率。 wx:key 的值以两种形式提供： 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 条件渲染 wx:if wx:else wx:elif&lt;!--wxml--&gt; &lt;view wx:if=&quot;{{length >= 80}}&quot;&gt; 优秀 &lt;/view&gt; &lt;view wx:elif=&quot;{{length >= 60}}&quot;&gt; 良好 &lt;/view&gt; &lt;view wx:else&gt; 加油 &lt;/view&gt; // page.js Page({ data: { length: &#39;95&#39; } }) wx:if 与 hidden 区别 wx:if 是否渲染， hidden 是否隐藏。 一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。 因此，如果需要频繁切换的情景下，用 hidden 更好。 事件 事件对象可以获取额外信息，如 id, dataset(自定义属性集合), touches(触摸点坐标)。 事件绑定和冒泡 冒泡事件 bind事件类型 如 bindtap bindlongpress 非冒泡事件 catch事件类型 如 catchtap catchlongpress 常用事件类型 类型 触发条件 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 &lt;!--wxml--&gt; &lt;view data-index=&quot;自定义属性&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt; // page.js Page({ tapHandle: function(event) { console.log(event) } }) 事件传参注意小程序绑定事件只能写函数名称，不能通过括号方式传参。 &lt;!--wxml--&gt; &lt;view bindtap=&quot;tapHandle(520)&quot;&gt; 点我触发事件 &lt;/view&gt; 错误，事件不能触发 &lt;view data-index=&quot;520&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt; // page.js Page({ tapHandle: function(event) { console.log( event.target.dataset.index ); // 输出标签自定义属性上的index值 } }) WXS 脚本WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，功能类似&lt;script&gt;标签，主要用于在视图层定义函数(比较少用)。 注意 wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。 wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。 wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。 wxs 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 &lt;!--wxml--&gt; &lt;wxs module=&quot;foo&quot;&gt; var sum = function(a,b){ return a+b; }; // 这里可以导出一个对象，这个对象可以直接在界面上使用 module.exports.sum = sum; &lt;/wxs&gt; &lt;view&gt; {{foo.sum(1,2)}} &lt;/view&gt; 微信开发者工具常用快捷键 快捷键 说明 Shift + Alt + F 格式化代码 Ctrl + P 跳到文件 Ctrl + E 跳到最近文件 Ctrl + Shift + P 上传扫码预览 Ctrl + Shift + I 显示/隐藏调试器","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.xiongtianci.com/tags/微信小程序/"}],"author":"天赐"},{"title":"Hystrix状态","slug":"Hystrix状态","date":"2018-12-07T00:12:05.000Z","updated":"2025-10-26T01:44:36.196Z","comments":true,"path":"2018/12/07/Hystrix状态/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/07/Hystrix状态/","excerpt":"","text":"@SpringCloudApplication 相当于：@EnableCircuitBreaker、@EnableDiscoveryClilent、@SpringBootApplication 熔断器状态的相关配置@HystrixProperty相关配置在抽象类：package com.netflix.hystrix.HystrixCommandProperties 中 熔断器开启或者关闭的条件： 1、 当满足一定的阀值的时候（默认10秒内超过20个请求次数） 2、 当失败率达到一定的时候（默认10秒内超过50%的请求失败） 3、 到达以上阀值，断路器将会开启 4、 当开启的时候，所有请求都不会进行转发 5、 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。 // 开启服务降级 @HystrixCommand( // 熔断器状态相关配置 commandProperties = { // 当请求次数达到10次时才能开启熔断 @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), // 状态变换的时间，由开启 --&gt; 半开 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;20000&quot;), // 失败请求/所有请求=60% --&gt; 开启熔断器 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;) } )","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://blog.xiongtianci.com/tags/SpringCloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.xiongtianci.com/tags/Hystrix/"}],"author":"天赐"},{"title":"HashSet如何去重？","slug":"HashSet如何去重","date":"2018-12-06T02:37:51.000Z","updated":"2025-10-26T01:44:36.178Z","comments":true,"path":"2018/12/06/HashSet如何去重/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/06/HashSet如何去重/","excerpt":"","text":"&lt; !– more –&gt;HashSet存储元素的原理：往hashSet添加元素的时候，首先会调用元素的 hashCode 方法得到元素的哈希码值，然后把哈希码值经过运算算出该元素存在哈希表中的位置。有两种情况： 情况1：如果算出的位置目前还没有存在任何的元素，那么该元素可以直接添加到哈希表中。 情况2： 如果算出的位置目前已经存在其他的元素，那么还会调用元素的 equals 方法再与这个位置上的元素比较一次。如果 equals 方法返回的是true，那么该元素被视为重复元素，不允许添加。如果equals方法返回的是false，那么该元素也可以被添加。 先看个最简单的构造方法* Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() { map = new HashMap&lt;&gt;(); } 很明显，HashSet底层是Hashmap存储的。借大神的话 HashSet 就是HashMap的马甲 —–someone 再看看add方法// Dummy value to associate with an Object in the backing Map private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); /** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) { return map.put(e, PRESENT)==null; } add方法的参数： map：map是一个HashMap的实例 e：我们要存储的值，是HashMap的key PRESENT：固定值( Object PRESENT = new Object(); )，空的obj对象 Set偷偷的用了HashMap的 put 方法，然而HashMap并没有去重的功能呀，那么Set是如何做到去重的呢？ 从add方法中可以看到，E是我们要存储的值，而到了HashMap里面却变成了Key，PRESENT就是个空对象。 在HashMap中Key的HashCode是决定底层数组的下标，进一步使用 equals 进行遍历对象链表中的Key进而覆盖原来的Value。 那么对于HashSet，如果 e 已经存在（先HashCode相同定位到链表，然后equals比较定位到具体的Node），那么覆盖oldValue（value其实就是个傀儡，没啥用），Key不变；如果不存在，就添加一个新的节点（即加了一个新的Key）。 HashMap的返回值是oldValue，oldValue==null说明节点之前不存在；反之说明节点存在，虽然返回false但实际上还是对底层数据进行了改变（即旧的空对象变成了新的空对象）。 总而言之，HashSet确定相同的方式其实就是HashCode相同（才能找到同一链表），然后equals的返回值（才能比较具体节点进行覆盖）。 重点看key（敲黑板）HashMap中的put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 这里边有两个看点： HashMap中key存储是hash后的值，对于String类型的相同值的hash值是一致的（其他接触类型类似，自定义对象类型需要重写hashcode方法与equel方法）。换句话说相同的值在hashMap中的存储位置是一样的。 基于上一点来看看怎么存储重复值的。如下代码对于hashMap中已经存在的key，key不变，新value覆盖就value。对于HashSet而言新旧value都是PRESENT对象，所以set在存储的时候就不会重复。 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } 所以hashset中存储的值输出的顺序和存储的先后顺序不一致，这是因为hashset是按照值的hash顺序进行输出。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"HashSet","slug":"HashSet","permalink":"https://blog.xiongtianci.com/tags/HashSet/"}],"author":"天赐"},{"title":"IDEA常用快捷键","slug":"IDEA常用快捷键","date":"2018-12-04T07:45:52.000Z","updated":"2025-10-26T01:44:36.161Z","comments":true,"path":"2018/12/04/IDEA常用快捷键/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/04/IDEA常用快捷键/","excerpt":"","text":"Ctrl+Alt+D –&gt; 查看当前类的实现类 ctrl+l –&gt; 重写方法","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"IDEA创建SpringBoot开启找回RunDashboard","slug":"IDEA创建SpringBoot开启找回RunDashboard","date":"2018-12-04T06:32:05.000Z","updated":"2025-10-26T01:44:36.127Z","comments":true,"path":"2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/","link":"","permalink":"https://blog.xiongtianci.com/2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/","excerpt":"","text":"Run Dashboard 面板Run Dashboard：微服务项目的开发过程中，工程会非常多，经常要启动很多个服务，才能完成一项测试。启动的多了，容易给开发者带来错乱的感觉，很不方便管理。IDEA开发工具推荐了一个很好用的功能–Run Dashboard。他是 Run 的升级版 我们可以对比一下这个是Run Dashboard的窗口 普通的Run窗口： 显然如果启动多个端口Run Dashboard窗口显得更好管理。一般有时候创建springboot项目的时候右下角可以提示你打开Run Dashboard，但是如果不提醒就需要自己配置了。 配置方法方式一新建项目或者通过 open 打开项目时，可能会弹出提示 “Multiple Spring Boot run configurations were detected. Run Dashboard allows to manage multiple run configurations at once.” 见下图： 点击 Show run configurations in Run Dashboard ，Run Dashboard 面板重新在底部区域展示了出来。 如没有此提示，请选择方式二或方式三 方式二打开Run Dashboard：View –&gt; Tool Windows –&gt; Run Dashboard 方式三如果上述的方式都没有打开 Run Dashboard 面板，可以在工程目录下找 .idea 文件夹下的 workspace.xml文件，通过修改此文件可达到打开 Run Dashboard 面板的目的 找到当前项目中 .idea 文件下的 workspace.xml 文件，双击打开 接下来找到 &lt;component name=&quot;RunDashboard&quot;&gt; 加入如下配置： &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; 这样 Run Dashboard 自动就弹出来了 最终配置如下： &lt;component name=&quot;RunDashboard&quot;&gt; &lt;option name=&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name=&quot;ruleStates&quot;&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt; &lt;/component&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"}],"author":"天赐"},{"title":"Java线程状态","slug":"Java线程状态","date":"2018-11-30T09:23:50.000Z","updated":"2025-10-26T01:44:36.093Z","comments":true,"path":"2018/11/30/Java线程状态/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/30/Java线程状态/","excerpt":"","text":"Java线程状态网上流传了很久的线程具备5种状态，这样是不贴切JDK中描述的，JDK中描述线程状态只有6种，而网络流传的5种状态就是进程的五态模型。那张广为流传的来自网络的图如下： 很明显这是操作系统中进程的5种状态，在很多操作系统书中也由介绍分别为new，ready，running，waiting，terminated。不幸的是，有很多的书上常常把这些进程状态，线程状态与Java线程状态混在一起谈。 进程与线程的区分总图： 很多人觉得在JVM线程中应该有，Running运行状态。对JAVA而言，Runnable包含了就绪与运行，那为什么JAVA不区分开呢？这跟CPU分配的时间片有关，而且JAVA进行的是抢占式轮转调度，由于我们的JVM线程是服务于监控，线程又是切换的如此之快，那么区分ready与running又没有多大意义了。再者，我们都知道现在使用的很多JVM底层都将线程映射到操作系统上了，JVM本身没有做什么调度，因为虚拟机看到的都是底层的映射与封装，故而将ready与running映射来也没有太大意义，不如统一为Runnable 总之还是有些乱的，我们不妨就拿Windows系统为例，用的就是“进程”和“线程”这两种较为标准的叫法，这时一个进程下至少有一个线程，线程是CPU调度的基本单位，进程不参与CPU调度，CPU根本不知道进程的存在。 为了避免混乱，下面说的线程状态，只是站在JVM层面上 我们先来看下，这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 初始(NEW)：新创建了一个线程对象，但还没有调用 start() 方法。 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running） 阻塞(BLOCKED)：表示线程阻塞于锁 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断） 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回 终止(TERMINATED)：表示该线程已经执行完毕 1. NEW(新建)状态 概念：线程对象创建了，但是还没有启动之前，就是新建状态 实现 Runnable接口 或继承 Thread 可以得到一个线程类，new一个实例出来，线程就进入了初始状态。 这里强调两点： 线程对象创建之后，还未开启( 调用start()方法 )时候，就处于NEW的状态 开启线程，指的是调用start方法，并不是run方法，run方法仅仅作为一个普通方法存在 线程对象调用 run() 方法不开启线程，仅是对象调用方法。线程对象调用 start() 方法开启线程，并让jvm调用 run() 方法在开启的线程中执行 当我们执行 new Thread(target) 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 Runnable (可运行)状态。 在我们研究线程状态时，采用Thread中的getState()方法进行研究 通过代码演示： public class MyThread extends Thread{ @Override public void run() { // 线程执行的代码 } } /** * 研究新建线程状态 * 新建状态：至今还未启动的线程处于这一状态 */ public class ThreadStateTest1 { public static void main(String[] args) { // 创建线程对象 MyThread myThread = new MyThread(); // 线程默认名：Thread-0 Thread-1... System.out.println(myThread.getName()); System.out.println(&quot;线程创建之后处于：&quot; + myThread.getState()); myThread.run(); System.out.println(&quot;线程run之后处于：&quot; + myThread.getState()); myThread.start(); System.out.println(&quot;线程start之后处于：&quot; + myThread.getState()); } } // 输出： // 线程创建之后处于：NEW // 线程run之后处于：NEW // 线程start之后处于：RUNNABLE 当我们执行 new Thread(target) 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 Runnable (可运行)状态。所以说 当业务需要频繁创建线城市，最好使用线程池，提高效率减轻JVM的压力。当然如果大量线程进行频繁上下文切换，此时多线程的效率会大打折扣。 2. RUNNABLE(可运行)状态 可运行状态：一个在JVM中执行的线程处于这个状态中，等待JVM调度，德能在执行，也可能在等待 注：这里的等待指的是等待调度，等待的是系统资源，如IO、CPU时间片，与 sleep、lock 的等待有着本质差别。 接下来使用代码演示一个最简单的可运行状态： public class MyThread extends Thread { @Override public void run() { System.out.println(&quot;线程开始执行&quot;); System.out.println(&quot;线程开始执行具体的任务&quot;); // 假设这个任务使用5秒钟 long beiginTime = System.currentTimeMillis(); while (System.currentTimeMillis()-beiginTime &lt; 5000){ // 假设做了5秒钟的任务 } System.out.println(&quot;线程执行完毕&quot;); } } /** * 可运行状态 * 当线程有资格运行，调用了start方法，线程首先进入可运行状态 * 这种可运行状态不一定被线程调度运行 * 简单来说，调用start方法之后，该线程处于可运行状态，但未运行 * 此时存放在&quot;可运行池&quot;中 * 线程在运行的过程中，自然该线程也是处于可运行状态 * * JDK中处于可运行状态的线程，有两种，一种是正在JVM中运行， * 另一种是可能正在等待操作系统其它资源，比如处理器 */ public class Demo { public static void main(String[] args) { // 创建线程对象 MyThread myThread = new MyThread(); System.out.println(&quot;创建完成之后：&quot; + myThread.getState()); // 开启线程 myThread.start(); System.out.println(&quot;开启线程之后：&quot; + myThread.getState()); } } 3. BLOCHED(阻塞)状态我们还是使用代码来解析一下锁阻塞状态： public class ThreadA extends Thread { private Object obj; public ThreadA(String name,Object obj){ super(name); this.obj = obj; } @Override public void run() { // 同步代码块 synchronized (obj){ System.out.println(&quot;线程A开始执行&quot;); System.out.println(&quot;线程A真正开始执行代码了&quot;); long beginTime = System.currentTimeMillis(); // 模拟5秒钟的任务 while(System.currentTimeMillis()-beginTime &lt; 5000){ } System.out.println(&quot;线程A执行完毕&quot;); } } } public class ThreadB extends Thread{ private Object obj; public ThreadB(String name,Object obj){ super(name); this.obj = obj; } @Override public void run() { // 同步代码块 synchronized (obj){ System.out.println(&quot;线程B开始执行&quot;); System.out.println(&quot;线程B真正开始执行代码了&quot;); long beginTime = System.currentTimeMillis(); // 模拟5秒钟的任务 while(System.currentTimeMillis()-beginTime &lt; 5000){ } System.out.println(&quot;线程B执行完毕&quot;); } } } /** * 线程状态之阻塞状态BLOCKED * JDK：锁阻塞并且正在等待监视器锁的某一线程状态 * 处于受阻状态的某一线程正在等待监视器锁，以便进入一个同步代码块/同步方 * 还有就是 调用Object.wart方法之后，再次进入同步中时 * */ public class BlockedDemo { public static void main(String[] args) throws InterruptedException { // 创建一个锁对象 Object obj = new Object(); // 创建线程A、B ThreadA a = new ThreadA(&quot;线程A&quot;, obj); ThreadB b = new ThreadB(&quot;线程B&quot;, obj); // 开启线程 a.start(); b.start(); // Thread.sleep(3000); System.out.println(&quot;线程A的状态是：&quot; + a.getState()); System.out.println(&quot;线程B的状态是：&quot; + b.getState()); // Thread.sleep(3000); System.out.println(&quot;线程A的状态是：&quot; + a.getState()); System.out.println(&quot;线程B的状态是：&quot; + b.getState()); } } 在这里我们只是对之前分析的情况一进行了阐释 4. Timed Waiting(计时等待)状态 带指定的等待时间的等待线程所处的状态。一个线程处于这一状态是因为用一个指定的正的等待时间（为参数）调用了一下方法中的其一： Thread.sleep 带时限（timeout）的 Object.wait 带时限（timeout）的 Thread.join LockSupport.parkNanos LockSupport.parkUntil Timed Waiting 在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 注：sleep的使用时区别去其他方法的。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting（计时等待），那么我们通过一个案例加深对该状态的一个理解： 实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串 代码： /** * 限时等待 */ public class MyThread extends Thread { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;mt的线程状态： &quot; + myThread.getState()); } } // 实现一个计算器，0-99计数，在每个数字之间暂停1秒，每个10个数字输出一个字符串 @Override public void run() { for (int i = 0; i &lt; 99; i++) { if (i%10 == 0){ System.out.println(&quot;oewewowllskd &quot; + i); } System.out.println(i); try { Thread.sleep(1000); System.out.println(&quot; 休息了1秒&quot;); } catch (Exception e) { e.printStackTrace(); } } } } 通过案例可以发西咸，sleep方法的使用还是很简单的。我们需要记住下面几点： 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 为了让其他线程有机会执行，可以将Thread.sleep() 的调用放线程run()之内，这样才能保证该线程执行过程中会睡眠 sleep 与锁无关，线程睡眠到期自动苏醒，并返回到 Runnable（可运行）状态 小提示：sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep() 方法不能保证该线程睡眠到期后就开始立刻执行 5. WAITING(无限等待)状态Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 一个线程进入 WAITING 状态是因为调用了以下方法： 不带时限的 Object.wait 方法 不带时限的 Thread.join 方法 LockSupport.park 然后会等其他线程执行一个特别的动作，比如： 一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 或 Object.notifyAll() 一个调用了 Thread.join 方法的线程会等待指定的线程结束 代码演示： /** * 无限等待 * Object中的wait方法完成 * 使用当前线程 进入无限等待状态，直到其他线程有唤醒 notify 或 notifyAll 才能被唤醒 * * 线程间通信 两个线程执行不同的操作 关联的 * 两个线程 使用同样的锁 只能使用锁对象调用wait方法或者notify方法 */ public class WaitingTest { private static Object obj = new Object(); public static void main(String[] args) throws InterruptedException { // 使用匿名函数创建线程 Thread t1 = new Thread() { @Override public void run() { synchronized (obj){ System.out.println(&quot;获取到锁，调用wait方法，当前线程进入无线等待状态。。。等待着别的线程来唤醒&quot;); try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;唤醒了这个线程，就不再是线程等待了，线程执行完毕&quot;); } } }; // 开启线程t1 t1.start(); // 使用匿名内部内方式创建一个新的线程，用来唤醒t1线程 new Thread(){ @Override public void run() { // 获取到锁 synchronized (obj){ try { // 3秒钟后执行唤醒操作 Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;获取到锁 执行 唤醒操作&quot;); // 唤醒操作 obj.notify(); } } }.start(); // 4秒后查看线程t1状态 Thread.sleep(4000); System.out.println(&quot;查看t1的线程状态&quot; + t1.getState()); } } 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 方法或 Object.notifyAll() 方法 其实 waiting 状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司了你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作一完成某些任务。 6. TEMINATED(终止)状态线程因如下两个原因之一将被终止： run() 方法正常退出而自然死亡 一个没有捕获的异常终止了 run() 方法而意外死亡 线程的方法1. wait(), notify(), notifyAll()等方法介绍在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait() 的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify() 是唤醒单个线程，而 notifyAll() 是唤醒所有的线程。 Object类中关于等待/唤醒的API详细信息如下：notify() – 唤醒在此对象监视器上等待的单个线程。notifyAll() – 唤醒在此对象监视器上等待的所有线程。wait() – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout, int nanos) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"Java线程","slug":"Java线程","permalink":"https://blog.xiongtianci.com/tags/Java线程/"}],"author":"天赐"},{"title":"Flex布局","slug":"Flex布局","date":"2018-11-30T09:12:44.000Z","updated":"2025-10-26T01:44:36.076Z","comments":true,"path":"2018/11/30/Flex布局/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/30/Flex布局/","excerpt":"","text":"Flex 布局教程：语法篇 作者： 阮一峰链接： http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 网页布局（layout）是 CSS 的一个重点应用 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的 Flex 写法。网友JailBreak 为本文的所有示例制作了 Demo，也可以参考。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 .box{ display: flex; } 行内元素也可以使用 Flex 布局。 .box{ display: inline-flex; } Webkit 内核的浏览器，必须加上-webkit前缀。 .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性 (紫色大盒子) *以下6个属性设置在容器上。 flex-direction √ flex-wrap √ flex-flow justify-content √ align-items √ align-content 3.1 flex-direction属性 **flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性 **默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } 3.4 justify-content属性 **justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性 **align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性 (橙色小盒子) *以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性 **flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"},{"name":"装载","slug":"装载","permalink":"https://blog.xiongtianci.com/categories/装载/"}],"tags":[{"name":"Flex","slug":"Flex","permalink":"https://blog.xiongtianci.com/tags/Flex/"}],"author":"天赐"},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2018-11-30T08:19:55.000Z","updated":"2025-10-26T01:44:36.110Z","comments":true,"path":"2018/11/30/Linux常用命令/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/30/Linux常用命令/","excerpt":"","text":"1 Linux介绍1.1 Linux的版本Linux的版本分为两种：内核版本和发行版本 Linux内核版本：Linux内核运维开发小组。 源码在一定程度上不是开源的 Linux发行版本：由各大互联网/软件公司定制。 外围的样式功能的源码完全开源 一个内核版本是有多种多样的发行版本： Ubuntu：以强大的桌面应用为主，吸收不少Windows用户 因为桌面应用会在一定程度上大量占用系统资源，开发。 服务器部署上，不会优先选择Ubuntu CentOS：对服务器性能进行了一定程度的优化，性能比较高，比较稳定 服务器操作系统的优选CentOS 1.2 Linux目录介绍 /：Linux系统根目录 /etc：(etcetera) 系统配置文件存放的目录，不建议在此目录下存放可执行文件。 重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。 注：/etc/X11存放与 x windows 有关的设置（防火墙文件，网络设置文件，JDK环境配置文件，mysql） home:存放所有普通用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /root： 系统管理员root(超级用户)的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下 每一个用户都有家目录，超级管理员root家目录 /root Linux命令行模式中相当于Windows的桌面 /usr：(unix shared resources)：应用程序存放目录，比较重要的目录/usr/local本地系统管理员软件安装目录（安装系统级的应用） /usr/bin 存放应用程序 /usr/share 存放共享数据 /usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local:存放软件升级包 /usr/share/doc: 系统说明文件存放目录 /usr/share/man: 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间。​ Jdk,tomcat,mysql,redis,nginx /opt：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里 以上建议并不是强制性约束 2 常用命令【重点】# 指令格式 [root@study ~]$ command [-options] parameter1 parameter2 ... 指令 选项 参数1 参数2 # 说明 1.一行指令中第一个输入的部分绝对是 &quot;指令(command)&quot; 或 &quot;可可执行文件案(例如批次脚本,script)&quot; 2.command 为指令的名称，例如变换工作目录的指令为 cd 等 3.中刮号&quot;[]&quot;并不存在于实际的指令中，而加入选项设置时，通常选项前会带&quot;-&quot;号，例如 -h；有时候会使用选项的完整全名，则选项前带有&quot;--&quot;符号，例如&quot;--help&quot; 4.parameter1 parameter2 为依附在选项后面的参数，或者是 command 的参数 5.指令、选项、参数等，这几个中间以空格来区分，不论空几格shell都视为一格。所以空格是很重要的特殊字符 6.按下[Enter]按键后，该指令就立即执行。[Enter]按键代表着一行指令的开始启动 7.指令太长的时候，可以使用反斜线&quot;\\&quot; 来跳脱[Enter]符号，使指令连续到下一行 Linux命令中参数，一般都是无序的。特殊情况下除外注意：Linux中的命令严格区分大小写的！如 cd 和 CD 并不同 2.1 磁盘管理命令ls 列出目录内容 ls（list）功能：列出目录内容 格式： ls [参数] [文件或目录] # 参数 -a或--all 查询所有文件和文件夹，包含隐藏。注意隐藏文件、特殊目录、. 和 .. -l 查询详细列表 ls -l--&gt;简写：ll -h 友好展示信息 ll -h (d目录，-普通文件, l链接) -t 用文件和目录的更改时间排序。 -r 反向排序 --help 在线帮助 常用： ls -l --&gt; 此命令非常常用，提供简化版命令 ll ls -al ll /home/ --&gt; 显示指定目录下的内容 eg: 需求：展示某个目录下的内容 ls 目录名 所在位置：/root 想要查看:/etc目录下的内容 命令：ll -h /etc cd 切换目录 cd(change directory) 功能：切换目录 语法： # 格式 cd [目录] # 常用 cd /目录名 ，任意目录切换到指定目录中 /目录名--&gt;Linux的绝对路径 windows绝对路径--&gt;c:/xxxx/xxx.jpg?raw=true cd ../ ，向上一层目录 cd ~ ，切换到当前用户 家目录。root用户家目录 /root cd / ，切换到Linux的 根目录 cd - ，切换到上一次访问的目录。 只能两个目录相互切换 cd .. ，上一级目录 cd ，缺省当前用户目录 Linux绝对： eg：cd /etc/x1 先切换到 /目录，然后在 /目录 中找到子目录 etc，在 etc 中找 子目录x1 特点：在任意目录都可以随意切换 Linux相对： eg：cd x1/x2 在当前目录中寻找子目录x1, 在x1中寻找子目录x2 特点：必须确定 当前目录 下有子目录x1 pwd 显示当前的所在目录 pwd(print working directory) 功能：显示工作目录(当前的所在目录)。返回绝对路径 mkdir 创建目录 mkdir（make directoriy）功能： 创建目录 语法： # 格式 mkdir -p 文件夹名称 # 参数 -p 父目录不存在情况下先生成父目录 （parents） -v 显示命令执行过程中的详细信息 注意：使用mkdir创建带后缀的文件时，创建的是目录，不是文件（创建文件使用touch命令） eg: # 1 需要在/root/t1目录下创建一个t2目录 位置：/root 命令：相对路径：mkdir t1/t2 绝对：mkdir /root/t1/t2 # 2 需要在/root/t3目录下创建一个t4目录 位置：/root 条件：t3和t4都不存在 命令：mkdir -p t3/t4 rmdir 删除空目录 rmdir(remove directory) 功能：删除空目录 指令快捷键 历史输入使用上、下箭头可以找出上一条指令和下一条指令 Tab代码补全使用tab键可以快速输入指令比如：我要输入shutdown指令，这时，我们可以只输入shut然后按下tab键，即可自动把shutdown补全 注意：使用两下Tab补全时，如果匹配的结果有多个，这时候将会把所有匹配的结果展示出来。当结果很多时将会出现以下结果： 按y之后会列出所有匹配的结果，但因为129个比较多，而在电脑中无法一次全显示出来，所以先显示一部分：（More代表还有更多，这时按回车就可以向下滚动，按下Ctrl+C将会退出） 2.2 文件浏览(管理)命令 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号 more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页 head 只看头几行 tail 只看尾巴几行 od 以二进制的方式读取文件内容 直接浏览文件内容cat 查看文件全部内容 cat： Concatenate(连续)的简写，快捷查看当前文件的内容 cat适合查看少量信息的文件 语法： # 格式 cat [-AbEnTv] 文件名 # 参数： -A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已 -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号 -E ：将结尾的断行字符 $ 显示出来 -n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同 -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 nl 添加行号打印nl 可以将输出的文件内容自动的加上行号 # 格式 nl [-bnw] 文件名 # 选项与参数： -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号（类似 cat -n） -b t ：如果有空行，空的那一行不要列出行号（默认值） -n ：列出行号表示的方法，主要有三种： -n ln ：行号在屏幕的最左方显示 -n rn ：行号在自己字段的最右方显示，且不加 0 -n rz ：行号在自己字段的最右方显示，且加 0 -w ：行号字段的占用的字符数 可翻页浏览more 一页一页翻动 more：分页显示文件内容，还支持直接跳转行等功能 语法： more 文件名 操作： 空格键(space) ：向下翻一页 Enter ：向下翻一行 /字串 ：代表在这个显示的内容当中，向下搜寻“字串”这个关键字 :f ：立刻显示出文件名以及目前显示的行数 q ：代表立刻离开 more ，不再显示该文件内容 b 或 Ctrl+B ：代表往回翻页，不过这动作只对文件有用，对管线无用 less 一页一页翻动 less：分页显示文件内容，操作更详细 语法： # 格式 less -mN 文件名 # 参数 -m 显示类似more命令的百分比 -N 显示每行的行号 操作： 空格键 向下滚动一屏 或 Ctrl+F b 返回上一屏 或 Ctrl+B q 退出less d 前进半页 u 后退半页 Enter (或方向键向下)前进一行 y (或方向键向上)后退一行 v 进入vim编辑器 /字符串 向下搜索 ?字符串 向上搜索 n 重复前一个搜寻(与 / 或 ? 有关) N 反向的重复前一个搜寻(与 / 或 ? 有关) g 跳到文件第一行 G 跳到文件最后一行 左右方向键 相当于水平滚动条 特点： 适用于大量数据的查看 数据撷取head 取出前面几行显示一个文件的前几行内容 # 格式 head [-n number] 文件名 # 选项与参数： -n ：后面接数字，代表显示几行的意思 tail 取出后面几行 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件 语法： # 格式 tail [-n number] [文件] # 参数 -n : 后面接数字，代表显示几行的意思 -f : 循环读取，通过Ctrl+C结束循环 eg： &amp; 表示后台运行，否则占用终端 Ctrl + C 退出 2.3 文件操作命令文件 隐藏文件 Linux中以 点. 开头的是隐藏文件，使用ls命令是查看不到的，需使用ls -a 目录与文件的区别 当我们使用ls命令列出目录中的所有子目录和文件时，如何区分哪些是文件哪些是目录？可以通过详细信息中第一列的信息来区分：以 d 开头的是目录，以 - 开头的是文件 touch创建文件 功能：创建文件 语法： touch 绝对路径/相对路径 cp 复制 cp（copy）：复制文件或者复制目录 复制文件： 语法： cp 需要复制的文件 复制的位置 注意：cp可以进行重命名操作： cp demo1.java t1/ddd.java 当将一个 文件位置 以不同名字复制到当前文件时，意思是复制并重命名；即 将demo1.java复制到t1目录中，并重命名成ddd.java eg： 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中 位置：/root 命令：cp Demo1.java t1 cp /root/Demo1.java /root/t1 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中，改名为ddd.java 位置：/root 命令：cp Demo1.java t1/ddd.java 复制目录： 语法： # 格式 cp -r 需要复制的目录 复制的位置 # 参数 -r或--recursive 递归处理，将指定目录下的文件与子目录一并处理 复制目录必须使用-r eg： 需求：把/root/t5目录 复制到 /root/t1目录中 位置：/root 命令：cp -r t5 t1 cp -r /root/t5 /root/t1 cp ./abc ./xxx #无法复制目录 cp -r ./abc ./xxx #复制目录必须使用 -r参数 mv 移动、更名 mv(move) 功能： 移动 或 更名 现有的文件或目录 移动文件： 语法： # 格式 mv -f 需要移动的文件 移动的位置 # 参数 -f或--force 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录，不进行询问 eg： 需求：把/root/t5 目录 移动到 /root/t3目录中 位置：/root 命令：mv t5 t3 需求：把/root/t5 目录 移动到 /root/t3目录中 不询问，直接覆盖 位置：/root 已知：/root/t3目录中 已经有一个t5目录了 命令：mv -f t5 t3 文件更名： 格式： mv 需要移动的文件 新名字 ## 必须是在同一目录中进行此操作 eg： 文件/目录更名操作： 需求：把/root/Demo1.java 改名为 hehe.java 位置：/root 命令：mv Demo1.java hehe.java rm 删除 rm(remove) 功能：删除文件或目录 删除文件： 语法： rm 文件名 删除目录： 语法： # 格式 rm -rf 目录名 # 参数 -f或--force 强制删除文件或目录，不进行询问 -r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。删除目录必须使用-r 注意： rm -rf * 删除 当前目录 下所有内容 rm –rf /* 删除Linux系统 根目录 下所有内容 eg： 需求：删除/root/t5 目录， 位置：/root 已知：t5目录下有子目录或者文件 命令：rm -rf t5 find 查找 find功能：查找文件或目录 语法： find 目录名 -name &#39;需要查找的字符串&#39; -name 指定字符串作为寻找文件或目录的范本样式 * 表示0~多个任意字符 eg：find t1 -name &#39;*.txt&#39; eg: 需求：查找/root目录下 所有以ins开头的文件或者目录 位置：/root 命令：find /root -name &#39;ins*&#39; 2.4 文档编辑命令Windows是有记事本Linux也有类似的记事本功能 VIM编辑器 VI 编辑 操作： 输入 vi 文件名 进入 “命令(一般)模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 vim 命令 操作： 输入 vim 文件名 或 vi 文件名 进入 “一般模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 一般(命令)模式: 可以浏览文件内容，可以进行文本快捷操作（单行复制，多行复制，单行删除，多行删除…） 按 i/a/o 可以切换到 插入模式按 : 可以切换到 底行模式 插入模式： 可以编辑文件内容。 按 ESC 可以切回 一般模式 底行模式： 可以进行强制退出不保存操作 q! 可以进行保存并退出操作 wq 2.5 grep* 、 管道|、重定向输出&gt;&gt;grep 正则表达式 grep：正则表达式，进行字符串搜索工作 用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活 语法： # 格式 grep -i 需要搜索的字符串 搜索的文件 # 参数 -i 忽略大小写查找数据 符合规则，就会返回符合规则的行 管道 管道命令： 可以连接多个Linux命令，其作用是将一个命令的输出用在另一个命令的输入 格式： 命令1 | 命令2 | 命令3…… eg： 需求：查询当前目录中，所有带ins关键字的行数据 位置：/root 思考：查询当前目录内容 ll 查询字符串，返回字符串所在行 grep 命令：ll | grep ins 需求：分页显示ls的help信息 命令：ls --help | more 重定向输出&gt; &gt;&gt; 重定向输出 &gt; 定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空 &gt;&gt; 将输出内容追加到目标文件中。如果文件不存在，就创建文件；如果文件存在，则将新的内容追加到那个文件的末尾，该文件中的原有内容不受影响 格式： 注意： 使用： 将一个文件夹的内容保存到文本文件中去，也就是将ls命令打印出来的内容都写到文本中去可以这样： # a.txt文件中就是ls命令打印出来的内容了 ls -al &gt;&gt; a.txt 2.6 压缩 / 解压gzip# 格式 gzip [-cdtv#] 文件名 # 选项与参数： -c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理； -d ：解压缩的参数； -t ：可以用来检验一个压缩文件的一致性～看看文件有无错误； -v ：可以显示出原文件/压缩文件的压缩比等信息； -# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6 # 例子 gzip -v services #压缩 gzip -d services.gz #解压 zcat services.gz #查看压缩文件的内容 使用 gzip 进行压缩时，在默认的状态下原本的文件会被压缩成为 .gz 的文件名，原始文件就不再存在了；与 gzip 相反， gzip -d 会将原本的 .gz 删除 bzip2# 格式 bzip2 [-cdkzv#] 文件名 # 选项与参数： -c ：将压缩的过程产生的数据输出到屏幕上！ -d ：解压缩的参数 -k ：保留原始文件，而不会删除原始的文件喔！ -z ：压缩的参数 （默认值，可以不加） -v ：可以显示出原文件/压缩文件的压缩比等信息； -# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！ # 例子 bzip2 -v services #压缩 bzip2 -d services.bz2 #解压 bzcat services.bz2 #查看压缩文件的内容 bzip2 的压缩率比 gzip 要好些。不过，对于大容量文件来说，bzip2 的压缩时间会比 gzip 要更久一些 xz# 格式 xz [-dtlkc#] 文件名 # 选项与参数： -d ：就是解压缩啊！ -t ：测试压缩文件的完整性，看有没有错误 -l ：列出压缩文件的相关信息 -k ：保留原本的文件不删除～ -c ：同样的，就是将数据由屏幕上输出的意思！ -v ：可以显示出原文件/压缩文件的压缩比等信息； -# ：同样的，也有较佳的压缩比的意思！ # 例子 xz -v services #压缩 xz -d services.xz #解压 xzcat services.xz #查看压缩文件的内容 压缩率从高到低：xz &gt; bzip2 &gt; gzip压缩时间从长到短：xz &gt; bzip2 &gt; gzip tar 打包打包：将多个文件或目录包成一个大文件 Linux常见压缩包： .tar 打包，大小不会进行压缩​ .tar.gz 打包并压缩文件大小 # 格式 tar [-j|-z] [cv] [-f 创建的档名] filename... #打包与压缩 tar [-j|-z] [tv] [-f 创建的档名] #察看档名 tar [-j|-z] [xv] [-f 创建的档名] [-C 目录] #解压缩 # 选项与参数： -c ：创建打包文件，可搭配 -v 来察看过程中被打包的档名(filename) -t ：查看打包文件的内容含有哪些档名，重点在察看『档名』就是了； -x ：解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开 特别留意的是， -c, -t, -x 不可同时出现在一串命令列中。 -z ：通过 gzip 的支持进行压缩/解压缩：此时档名最好为 *.tar.gz -j ：通过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2 -J ：通过 xz 的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串命令行中 -v ：在压缩/解压缩的过程中，将正在处理的档名显示出来！ -f filename：-f 后面要立刻接要被处理的档名！建议 -f 单独写一个选项罗！ -C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。 tar 并不会主动的产生创建的文件名，如果不加 [-z|-j|-J] 的话，文件名最好取为 .tar 即可 压缩：(参数顺序不变) # 格式 tar -zcvf 压缩包名字.tar.gz 需要压缩的内容 # 选项与参数： -z 是否需要用 gzip 压缩 -c 建立一个压缩文件的参数指令（create）--压缩 -v 压缩的过程中显示文件（verbose） -f 使用档案名称，在 f 之后要立即接档名（file） eg： 例如：tar -zcvf hehe.tar.gz * 将当前目录下所有内容进行打包压缩，文件名hehe.tar.gz 解压：(参数顺序不变) # 解压到当前目录 tar -zxvf 需要解压的压缩包名称 解压到当前目录 # 解压到指定目录 tar -zxvf 需要解压的压缩包名称 -C 指定压缩路径 解压到指定目录中 # 参数 -z 是否需要用 gzip 压缩 -x 解开一个压缩文件的参数指令（extract）--解压 -v 压缩的过程中显示文件（verbose） -f 使用档名，在 f 之后要立即接档名（file） eg： # 把 /root/t5/abc.tar.gz 解压到 /root/t5/t5 目录中 tar -zxvf /root/t5/abc.tar.gz -C /root/t5/t5 tar -zxvf hehe.tar.gz -C t5 2.7 系统命令系统服务服务，是指常期运行，常驻内存中的进程，比如，apache、mysql、ssh等 服务与端口每个服务软件一般在运行时都会对应一个端口。查看监听的端口： ss –lntp 防火墙及防火墙设置CentOS 7.0默认使用的是firewall作为防火墙，使用iptables必须重新设置一下 查看防火墙状态： firewall-cmd --state # running 防火墙处于开启状态 # not running 防火墙处于关闭状态 直接关闭防火墙停止firewall： systemctl stop firewalld.service 禁止firewall开机启动： systemctl disable firewalld.service 查看系统进程：ps -ef需求：查看进程中 和 vim相关的进程 命令：ps -ef|grep -i vim -e 此参数的效果和指定&quot;A&quot;参数相同，显示所有程序 -f 显示UID,PPIP,C与STIME栏位 强制杀死某个进程：kill -9 pid号需求：查看进程 和 vim相关的进程有哪些，并将vim进程杀死 命令：ps -ef|grep -i vim Kill -9 pid号 -l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称 kill 9 表示强制终止 查看网络配置：ifconfig 显示网络设备 测试和目标的连通性：ping 主机名或ip地址 测试与目标主机的连通性 会持续不断一直测试，直到ctrl+c Linux centos重启命令：reboot Linux centos关机命令：halt 关机# 格式 shutdown [-krhc] [时间] [警告讯息] 选项与参数： -k：不要真的关机，只是发送警告讯息出去！ -r：在将系统的服务停掉之后就重新开机（常用） -h：将系统的服务停掉后，立即关机（常用） -c：取消已经在进行的 shutdown 指令内容。 时间：指定系统关机的时间 特殊： shutdown -h now #立刻关机，其中 now 相当于时间为 0 的状态 shutdown -h 20:25 #系统在今天的20:25关机，若在21:25才下达此指令，则隔天才关机 shutdown -h +10 #系统再过十分钟后自动关机 shutdown -r now #系统立刻重新开机 shutdown -r +30 &#39;The system will reboot&#39; #再过三十分钟系统会重新开机，并显示后面的讯息给所有在线上的使用者 shutdown -k now &#39;This system will reboot&#39; #仅发出警告信件的参数！系统并不会关机啦！吓唬人！ 其他关机或重启的命令 reboot #直接重启系统 poweroff #系统关机，所以没有提供额外的电力，屏幕空白 halt #系统停止，屏幕可能会保留系统已经停止的讯息 其实上面这些命令都是调用了 systemctl 这个指令，这个指令跟关机有关的语法如下： systemctl [指令] 指令： halt 进入系统停止的模式，屏幕可能会保留已有些讯息，这与你的电源管理模式有关 poweroff 进入系统关机模式，直接关机没有提供电力 reboot 直接重新开机 suspend 进入休眠模式 2.8 其他命令su - #切换root账号 基础命令# 显示日期与时间 date [+%Y/%m/%d] # 显示日历 cal [month] [year] # eg: cal 2021、cal 12 2021 # 简单好用的计算机 运算符号：+(加)、-(减)、*(乘)、/(除)、%(余)、^(指数) bc # bc默认仅输出整数，如果要输出小数，需使用下面命令指定小数点位数 scale=number # eg: # 1/100 #0 # scale=3 # 1/100 #.010 # 退出bc quit 热键 Tab 命令补全、文件补齐 Ctrl+C 中断目前的程序 Ctrl+D 相当于输入exit Shift+PgUp/PgDn 向前/后翻页 chmod 文件权限 chmod(change mode) 功能：变更文件或目录的权限 语法： # 格式 chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;] # 参数 -R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理 权限范围的表示法如下： u：User，即文件或目录的拥有者 g：Group，即文件或目录的所属群组 o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围 a：All，即全部的用户，包含拥有者，所属群组以及其他用户 符号： ‘+’添加权限 ‘-‘取消权限 有关权限代号的部分，列表于下： r：读取权限，数字代号为”4” w：写入权限，数字代号为”2” x：执行或切换权限，数字代号为”1” -：不具任何权限，数字代号为”0” eg: mkdir xxx ll | grep xxx chmod u-rwx xxx #取消xxx目录，用户“读写执行”权限 chmod g-rwx xxx #取消xxx目录，组“读写执行”权限 chmod 777 xxx #给xxx目录添加所有权限 linux 权限格式：&lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt; 网络配置 VIM命令配置 网卡配置 cat /etc/sysconfig/network-scripts/ifcfg-eth0 概要信息如下: DEVICE=eth0 #网卡名称 TYPE=Ethernet #网卡类型 ONBOOT=yes #是否开机启动网卡 BOOTPROTO=static #静态获取IP，其他取值：dhcp （如果设置dhcp下面红色不需要） IPADDR=192.168.44.100 #ip地址 GATEWAY=192.168.44.2 #网关 NETMASK=255.255.255.0 #子网掩码 setup设置 选择“网络配置” 选择“设备配置” 选择“第一块网卡” 设置IP地址等详细信息 3 命令总结 和 帮助 内部命令：属于Shell解析器的一部分 （系统启动直接加载到内存的） cd 切换目录（change directory） pwd 显示当前工作目录（print working directory） help 帮助 外部命令：独立于Shell解析器之外的文件程序（独立的可执行文件） ls 显示文件和目录列表（list） mkdir 创建目录（make directoriy） cp 复制文件或目录（copy） 查看帮助文档 内部命令：help + 命令（eg：help cd） 外部命令：man + 命令（eg：man ls）；在man中空格键为翻页，按q离开 不用特意记忆命令分类，开发中，如果需要查看命令参数，先使用man，如果没有结果，再使用help man page# 格式 man [命令] # 查看某个命令的操作说明 举个栗子👇： [root@localhost ~]$ man date DATE(1) User Commands DATE(1) Name ... SYNOPSIS ... DATE(1)中括号内的数字具体表示内容如下： 数字 代表内容 1 使用者在shell环境中可以操作的指令或可执行文件【重要】 2 系统核心可调用的函数与工具等 3 一些常用的函数（function）与函数库（library），大部分为C的函数库（libc） 4 设备文件的说明，通常在/dev下的文件 5 配置文件或者是某些文件的格式【重要】 6 游戏（games） 7 惯例与协定等，例如Linux文件系统、网络协定、ASCII code等等的说明 8 系统管理员可用的管理指令【重要】 9 跟kernel有关的文件 man page的内容以 NAME 作为开始介绍，最后还有个 SEE ALSO 来作为结束，大致分成下面这几个部分： 名称 内容说明 NAME 简短的指令、数据名称说明 SYNOPSIS 简短的指令下达语法（syntax）简介 DESCRIPTION 较为完整的说明，这部分最好仔细看看！ OPTIONS 针对 SYNOPSIS 部分中，有列举的所有可用的选项说明 COMMANDS 当这个程序（软件）在执行的时候，可以在此程序（软件）中下达的指令 FILES 这个程序或数据所使用或参考或链接到的某些文件 SEE ALSO 可以参考的，跟这个指令或数据有相关的其他说明！ EXAMPLE 一些可以参考的范例 在man page当中可以使用 PgUp/PgDn 来翻页，可以输入 /word 来查询关键字，按下 q 可以退出 参考资料与延伸阅读 鸟哥的Linux私房菜 : 基础学习篇 第四版","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.xiongtianci.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.xiongtianci.com/tags/Linux/"}],"author":"天赐"},{"title":"豆瓣Top250资源合集","slug":"豆瓣Top250资源合集","date":"2018-11-28T17:45:30.000Z","updated":"2025-10-26T01:44:36.058Z","comments":true,"path":"2018/11/29/豆瓣Top250资源合集/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/29/豆瓣Top250资源合集/","excerpt":"","text":"点击影片”名称”即可获取资源链接 # 更新至Top1-Top100，敬请期待… 排名名称年份评分Top1肖申克的救赎19949.6Top2霸王别姬19939.6Top3这个杀手不太冷19949.4Top4阿甘正传19949.4Top5美丽人生19979.5Top6泰坦尼克号19979.3Top7千与千寻20019.3Top8辛德勒的名单19939.5Top9盗梦空间20109.3Top10机器人总动员20089.3Top11忠犬八公的故事20099.3Top12三傻大闹宝莱坞20099.2Top13海上钢琴师19989.2Top14放牛班的春天20049.2Top15大话西游之大圣娶亲19959.2Top16楚门的世界19989.2Top17教父19729.2Top18星际穿越20149.2Top19龙猫19889.1Top20熔炉20119.3Top21无间道20029.1Top22当幸福来敲门20069.0Top23触不可及20119.2Top24怦然心动20109.0Top25乱世佳人19399.2Top26疯狂动物城20169.2Top27蝙蝠侠：黑暗骑士20089.1Top28天堂电影院19889.1Top29活着19949.1Top30少年派的奇幻漂流20129.0Top31十二怒汉19579.4Top32鬼子来了20009.2Top33指环王3：王者无敌20039.1Top34控方证人19579.6Top35搏击俱乐部19999.0Top36天空之城19869.0Top37飞屋环游记20098.9Top38大话西游之月光宝盒19958.9Top39罗马假日19539.0Top40摔跤吧！爸爸20169.1Top41窃听风暴20069.1Top42辩护人20139.2Top43两杆大烟枪19989.1Top44闻香识女人19929.0Top45哈尔的移动城堡20048.9Top46飞越疯人院19759.0Top47死亡诗社19899.0Top48V字仇杀队20058.8Top49海豚湾20099.3Top50教父219749.1Top51指环王2：双塔奇兵20029.0Top52指环王1：魔戒再现20018.9Top53美丽心灵20018.9Top54饮食男女19949.1Top55情书19958.8Top56素媛20139.1Top57狮子王19948.9Top58钢琴家20029.1Top59美国往事19849.1Top60小鞋子19979.2Top61七宗罪19958.8Top62被嫌弃的松子的一生20068.9Top63致命魔术20068.8Top64本杰明·巴顿奇事20088.8Top65末代皇帝19879.0Top66西西里的美丽传说20008.8Top67天使爱美丽20018.7Top68黑客帝国19998.9Top69让子弹飞20108.7Top70拯救大兵瑞恩19988.9Top71看不见的客人20168.7Top72音乐之声19658.9Top73低俗小说19948.8Top74勇敢的心19958.8Top75剪刀手爱德华19908.7Top76大闹天宫19611964197820049.3Top77沉默的羔羊19918.8Top78蝴蝶效应20048.7Top79哈利·波特与魔法石20018.8Top80春光乍泄19978.8Top81入殓师20088.8Top82心灵捕手19978.8Top83猫鼠游戏20028.8Top84布达佩斯大饭店20148.8Top85禁闭岛20108.7Top86玛丽和马克思20098.9Top87阳光灿烂的日子19948.8Top88第六感19998.8Top89幽灵公主19978.8Top90重庆森林19948.7Top91狩猎20129.1Top92致命ID20038.7Top93穿条纹睡衣的男孩20088.9Top94断背山20058.7Top95加勒比海盗20038.6Top96大鱼20038.7Top97阿凡达20098.6Top98摩登时代19369.2Top99告白20108.7Top100一一20009.0Top101射雕英雄传之东成西就19938.7Top102甜蜜蜜19968.8Top103阳光姐妹淘20118.8Top104消失的爱人20148.7Top105爱在黎明破晓前19958.7Top106上帝之城20028.9Top107小森林 夏秋篇20148.9Top108侧耳倾听19958.8Top109喜剧之王19998.6Top110倩女幽魂19878.6Top111恐怖直播20138.7Top112风之谷19848.8Top113爱在日落黄昏时20048.8Top114超脱20118.8Top115红辣椒20068.9Top116菊次郎的夏天19998.8Top117驯龙高手20108.7Top118幸福终点站20048.7Top119神偷奶爸20108.5Top120借东西的小人阿莉埃蒂20108.7Top121杀人回忆20038.7Top122七武士19549.2Top123岁月神偷20108.6Top124请以你的名字呼唤我20178.8Top125萤火虫之墓19888.7Top126怪兽电力公司20018.6Top127小森林 冬春篇20159.0Top128哈利·波特与死亡圣器(下)20118.7Top129谍影重重320078.7Top130喜宴19938.8Top131东邪西毒19948.6Top132电锯惊魂20048.7Top133贫民窟的百万富翁20088.5Top134疯狂原始人20138.7Top135记忆碎片20008.6Top1367号房的礼物20138.7Top137黑天鹅20108.5Top138萤火之森20118.8Top139真爱至上20038.5Top140英雄本色19868.6Top141超能陆战队20148.6Top142雨人19888.6Top143心迷宫20148.7Top144蝙蝠侠：黑暗骑士崛起20128.6Top145卢旺达饭店20048.9Top146唐伯虎点秋香19938.5Top147海洋20099.0Top148傲慢与偏见20058.5Top149荒蛮故事20148.8Top150纵横四海19918.7Top151海边的曼彻斯特20168.6Top152教父319908.8Top153虎口脱险19668.9Top154无人知晓20049.1Top155时空恋旅人20138.7Top156完美的世界19939.0Top157寻梦环游记20179.0Top158玩具总动员320108.8Top159燃情岁月19948.7Top160花样年华20008.5Top161恋恋笔记本20048.5Top162达拉斯买家俱乐部20138.7Top163血战钢锯岭20168.7Top164二十二20158.7Top165雨中曲19529.0Top166魂断蓝桥19408.8Top167穿越时空的少女20068.6Top168猜火车19968.5Top169我是山姆20018.8Top170冰川时代20028.5Top171人工智能20018.6Top172爆裂鼓手20148.6Top173头脑特工队20158.7Top174被解救的姜戈20128.6Top175未麻的部屋19978.8Top176罗生门19508.7Top177浪潮20088.7Top178香水20068.4Top179朗读者20088.5Top180阿飞正传19908.5Top181你的名字。20168.4Top182房间20158.8Top183可可西里20048.7Top184恐怖游轮20098.4Top185模仿游戏20148.6Top186一个叫欧维的男人决定去死20158.8Top187一次别离20118.7Top188忠犬八公物语19879.1Top189战争之王20058.6Top190追随19988.9Top191魔女宅急便19898.5Top192撞车20048.6Top193谍影重重20028.5Top194完美陌生人20168.6Top195地球上的星星20078.9Top196牯岭街少年杀人事件19918.8Top197谍影重重220048.6Top198哪吒闹海19798.9Top199惊魂记19608.9Top200青蛇19938.5Top201梦之安魂曲20008.7Top202无敌破坏王20128.7Top203黑客帝国3：矩阵革命20038.6Top204小萝莉的猴神大叔20158.5Top205再次出发之纽约遇见你20138.5Top206海街日记20158.7Top207新龙门客栈19928.5Top208东京物语19539.2Top209步履不停20088.8Top210终结者2：审判日19918.6Top211源代码20118.4Top212初恋这件小事20108.3Top213绿里奇迹19998.7Top214城市之光19319.2Top215末路狂花19918.7Top216爱在午夜降临前20138.8Top217疯狂的石头20068.3Top218秒速5厘米20078.3Top219无耻混蛋20098.5Top220这个男人来自地球20078.5Top221勇闯夺命岛19968.6Top222E.T. 外星人19828.5Top223碧海蓝天19888.7Top224变脸19978.4Top225卡萨布兰卡19428.6Top226黄金三镖客19669.1Top227发条橙19718.5Top228彗星来的那一夜20138.4Top229聚焦20158.8Top230海盗电台20098.6Top231美国丽人19998.5Top232血钻20068.5Top233非常嫌疑犯19958.6Top234国王的演讲20108.3Top235荒野生存20078.6Top236英国病人19968.5Top237黑鹰坠落20018.6Top238我爱你20119.0Top239迁徙的鸟20019.1Top240遗愿清单20078.5Top241勇士20118.9Top242荒岛余生20008.5Top2432001太空漫游19688.7Top244枪火19998.7Top245燕尾蝶19968.6Top246叫我第一名20088.6Top247穆赫兰道20018.3Top248千钧一发19978.7Top249大卫·戈尔的一生20038.6Top250上帝也疯狂19808.7","categories":[{"name":"电影","slug":"电影","permalink":"https://blog.xiongtianci.com/categories/电影/"},{"name":"资源","slug":"资源","permalink":"https://blog.xiongtianci.com/categories/资源/"}],"tags":[{"name":"公众号文章","slug":"公众号文章","permalink":"https://blog.xiongtianci.com/tags/公众号文章/"},{"name":"Top电影","slug":"Top电影","permalink":"https://blog.xiongtianci.com/tags/Top电影/"},{"name":"电仪","slug":"电仪","permalink":"https://blog.xiongtianci.com/tags/电仪/"}],"author":"天赐"},{"title":"使用 Hexo+GitHub 搭建个人博客","slug":"使用Hexo+GitHub搭建个人博客","date":"2018-11-28T07:36:06.000Z","updated":"2025-10-26T01:44:36.042Z","comments":true,"path":"2018/11/28/使用Hexo+GitHub搭建个人博客/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/28/使用Hexo+GitHub搭建个人博客/","excerpt":"","text":"昨天偶然看见一篇有关使用Hexo搭建个人博客的文章，瞬间吸引我的注意。今天使用的一天的时间在GitHub上搭建了一个个人博客，感觉还不错，分享给大家，并记录下我搭建过程中趟过的坑 环境：Win10 + Hexo + GitHub 效果展示：脚印的博客 一、准备工作1. 了解Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官方文档：https://hexo.io/zh-cn/docs/ 2. 搭建Node.js环境Hexo基于Node.js环境，那么我们搭建博客网站首先需要安装Node.js环境 下载地址：http://nodejs.cn/download 详细安装文档：http://www.runoob.com/nodejs/nodejs-install-setup.html 测试安装：命令行使用 node -v 、npm -v，查看显示版本号即成功。如下图： 3. 注册Github账号这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件 注册地址：https://github.com注册流程：https://blog.csdn.net/p10010/article/details/51336332 注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦 4. 安装Git版本工具 使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步 下载地址：https://git-scm.com/downloads Windows系统需下载，Mac系统因为自带Git无需操作 详细安装文档：https://blog.csdn.net/u013295518/article/details/78746007 测试安装：git --version，查看显示版本号即成功。如下图： 配置SSH：https://blog.csdn.net/qq_35246620/article/details/69061355 SSH key添加之后，就可以在本机git bash中进行测试，输入ssh -T git@github.com进行测试 显示 Hi username ！You&#39;ve successfully... 说明ssh配置成功了 5. 在本地安装 Hexo Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件 npm install -g hexo-cli 注意：在回车之后，可能会出现一行WARN的警告语句，不用管它，这个不妨碍安装 过一段时间如果出现hexo版本号之类的语句就代表差不多了 然后输入 npm install hexo --save 这个时候你会看到命令行出现了一堆白字，紧接着输入hexo v查看是否安装成功： 此时，Hexo已经安装完成 二、搭建博客1. 开启GitHub Pages服务搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是： 仓库名固定：你的github的username.github.io 这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。 点击Create Repository后，选着仓库的Setting进入设置 往下滑找到 Github Pages 如下： 这里我们需要点击 Choose a theme 任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 点击 Select theme 选着主题后，此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 输入你的 GitHub 的用户名和密码，成功后复制https://username.github.io/到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！ 2. 创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下： hexo init myHexoBlog //myHexoBlog是项目名 等一会，如果出现橙色的 WARN 没关系，只要不出现红色的 ERROR 就行。好了后，输入命令： hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 然后点开 http://localhost:4000/ ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！ 3. 同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地博客目录的配置：修改本地博客根目录下的_config.yml文件，修改deploy下的配置，如下： deploy: type: git repository: git@github.com:xiongtianci-tc/xiongtianci-tc.github.io.git #复制的仓库地址 branch: master 注意： repository后面的内容是 git@gitbub.com:username/库地址 的形式 type、repository、branch冒号的后面都有一个空格（切记~~） 最后执行控制台命令： npm install hexo-deployer-git --save //安装部署插件 hexo d //部署到github 现在，我们再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三、发布你的第一篇博客终于可以发布自己的第一篇博客了，是不是很激动？（博主当时可是超级激动的~）首先，在本地博客文件夹根目录输入： hexo new &quot;我个人博客的第一篇博客，激动~&quot; hexo g //生成网页 hexo d //部署到远端(github) 现在打开我们的博客网站：http://UserName.github.io,会看到网页如下(可能需要刷新几次页面)： 需要编写博客内容时，只需编写本地博客的 _posts 的博客原文，然后通过 hexo g &amp;&amp; hexo d 重新部署到github即可 四、更换主题此时，我们的个人博客已经搭建完成。但是我们需要网站更加高大上，更加美观些，我们可以通过更换主题来实现个性化博客 这里以使用github上的next主题为例： 1. 下载主题next主题：https://github.com/iissnan/hexo-theme-next 在控制台中切换到本地博客根目录输入： $ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next 下载成之后我们会看到next的主题已经存在 thems 里了如下： 2. 更换主题修改博客根目录(不是next主题)下的 _config.yml 文件，搜索 theme 字段，并将其值修改为 next 然后在控制台下输入如下命令： hexo clean //清理缓存 hexo g //重新生成博客代码 hexo d //部署到本地 // 或者直接输入：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 再次打开我们的博客网站：https://UserName.github.io，将会发现我们的博客主题已经发生了改变 五、个性化通过此步骤我们可以设置博客的作者、格言、语言… 在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项 1. 站点配置在本地的博客根目录下找到_config.yml，用编辑器打开进行内容的设置，如下： 这里可以修改博客网站的标题、描述，语言等属性 2. 主题设置网上有个超级详细的教程，我就不赘述了： 文档地址：http://theme-next.iissnan.com/getting-started.html 终于结束了， 最后，","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"},{"name":"生活","slug":"生活","permalink":"https://blog.xiongtianci.com/categories/生活/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.xiongtianci.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog.xiongtianci.com/tags/GitHub/"},{"name":"博客","slug":"博客","permalink":"https://blog.xiongtianci.com/tags/博客/"}],"author":"天赐"},{"title":"java中的&#92;t&#92;r&#92;n&#92;b(Java转义字符)分别是什么？","slug":"java中的-t-r-n-b(Java转义字符)分别是什么？","date":"2018-11-27T08:29:04.000Z","updated":"2025-10-26T01:44:36.008Z","comments":true,"path":"2018/11/27/java中的-t-r-n-b(Java转义字符)分别是什么？/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/27/java中的-t-r-n-b(Java转义字符)分别是什么？/","excerpt":"","text":"转义序列 描述 \\b 退格符(Backspace) \\t 水平制表符(相当于tab，缩进) \\n 换行符 \\f 换页符 \\r 回车符 \\&quot; 转义&quot; \\\\ 转义\\ 转义序列 描述 \\xxx 转义Latin-1编码xxx 是八进制数，介于 000 到 377 之间。其中 \\x 和 \\xx 两种形式也是合法的，例如 \\0，但不推荐这么用，因为转义序列只有一个数字，在字符串常量中会导致歧义。这种用法在 \\uxxxx 中也不鼓励使用 \\uxxxx 转义Unicode编码xxxx 是四个十六进制数","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"使用Notepad++替换某一特定中文后面的所有内容","slug":"使用Notepad++替换某一特定中文后面的所有内容","date":"2018-11-27T02:48:26.000Z","updated":"2025-10-26T01:44:36.024Z","comments":true,"path":"2018/11/27/使用Notepad++替换某一特定中文后面的所有内容/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/27/使用Notepad++替换某一特定中文后面的所有内容/","excerpt":"","text":"需求：删除”电影描述”以及其后面的内容 Top1 肖申克的救赎 评分：9.6 电影描述：希望让人自由Top2 霸王别姬 评分：9.5 电影描述：风华绝代Top3 这个杀手不太冷 评分：9.4 电影描述：怪蜀黍和小萝莉不得不说的故事Top4 阿甘正传 评分：9.4 电影描述：一部美国近现代史Top5 美丽人生 评分：9.5 电影描述：最美的谎言Top6 千与千寻 评分：9.2 电影描述：最好的宫崎骏，最好的久石让Top7 泰坦尼克号 评分：9.2 电影描述：失去的才是永恒的Top8 辛德勒的名单 评分：9.4 电影描述：拯救一个人，就是拯救整个世界Top9 盗梦空间 评分：9.3 电影描述：诺兰给了我们一场无法盗取的梦Top10 机器人总动员 评分：9.3 电影描述：小瓦力，大人生Top11 海上钢琴师 评分：9.2 电影描述：每个人都要走一条自己坚定了的路，就算是粉身碎骨Top12 三傻大闹宝莱坞 评分：9.1 电影描述：英俊版憨豆，高情商版谢耳朵Top13 忠犬八公的故事 评分：9.2 电影描述：永远都不能忘记你所爱的人Top14 放牛班的春天 评分：9.2 电影描述：天籁一般的童声，是最接近上帝的存在Top15 大话西游之大圣娶亲 评分：9.2 电影描述：一生所爱 解决： Ctrl+R 打开替换窗口 在”查找目标”中输入：特定字符.* 选择右下角的”正则表达式” 点击”全部替换” 结果： Top1 肖申克的救赎 评分：9.6Top2 霸王别姬 评分：9.5Top3 这个杀手不太冷 评分：9.4Top4 阿甘正传 评分：9.4Top5 美丽人生 评分：9.5Top6 千与千寻 评分：9.2Top7 泰坦尼克号 评分：9.2Top8 辛德勒的名单 评分：9.4Top9 盗梦空间 评分：9.3Top10 机器人总动员 评分：9.3Top11 海上钢琴师 评分：9.2Top12 三傻大闹宝莱坞 评分：9.1Top13 忠犬八公的故事 评分：9.2Top14 放牛班的春天 评分：9.2Top15 大话西游之大圣娶亲 评分：9.2","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Notepad","slug":"Notepad","permalink":"https://blog.xiongtianci.com/tags/Notepad/"}],"author":"天赐"},{"title":"win10常用快捷键","slug":"win10常用快捷键","date":"2018-11-26T08:52:44.000Z","updated":"2025-10-26T01:44:35.990Z","comments":true,"path":"2018/11/26/win10常用快捷键/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/26/win10常用快捷键/","excerpt":"","text":"常用 快捷键 描述 Alt + F4 关闭活动项，或者退出活动应用 Alt + Tab 在打开的应用之间切换 Win + L 锁定电脑 Win + D 显示和隐藏桌面 Ctrl + D（或 Delete） 删除选定项并将其移动到“回收站” 快捷键 描述 Win + A 打开操作中心 Win + E 打开文件资源管理器 Win + I 打开Windows设置 Win + Q / Win + S 打开Cortana Win + R 打开运行 Win + L 锁定笔记本 Ctrl + Shift + Esc 打开任务管理器 Win + X 打开开始菜单左侧选项 Win + 加号 打开放大镜并放大屏幕内容 Win + 减号 打开放大镜并缩小屏幕内容 Win + Esc 退出放大镜 运行(Win+R)的常用命令 命令 描述 notepad 打开记事本 calc 打开计算器 mspaint 打开画图 osk 打开虚拟键盘 sysdm.cpl 打开系统设置（常用于配置环境变量） appwiz.cpl 打开控制面板（常用于卸载程序） psr.exe 打开步骤记录器（常用于记录操作步骤） cmd 打开命令行窗口 管理窗口 快捷键 描述 Win + D 最小化所有窗口，重复按下可还原 Win + 1…9 打开任务栏对应窗口 Win + T 将焦点切换到任务栏图标，并在图标之间进行切换 Win + 上/下 使窗口在最大化，正常状态以及最小化之间切换 Win + 左/右 使窗口在左半屏幕，正常状态以及右半屏幕之间切换 Ctrl + Tab 切换当前程序中的不同页面 Alt + Tab 切换当前程序 Ctrl + F4 关闭当前程序中的当前页面 Alt + F4 关闭当前程序 虚拟窗口 快捷键 描述 Win + Ctrl + D 创建新的虚拟桌面 Win + Ctrl + F4 关闭当前虚拟桌面 Win + Ctrl + 左/右 切换虚拟桌面 录频和截图 快捷键 描述 Win + G 打开屏幕录制工具栏 PtrSc 全屏截图并保存到剪贴板 Alt + PtrSc 当前窗口截图并保存到剪贴板 Win + PtrSc 全屏截图并保存到本地 输入法 快捷键 描述 Shift 切换输入法 Shift + Space 切换全半角 触控板常用手势 操作 描述 单指双击拖动 拖拽文件 两指上下移动 滚动屏幕 两指缩放 缩放 两指旋转 旋转 三指扩张 显示所有窗口 三指上下移动 隐藏或显示窗口 三指左右移动 切换窗口","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"},{"name":"快捷键","slug":"快捷键","permalink":"https://blog.xiongtianci.com/tags/快捷键/"}],"author":"天赐"},{"title":"Java中的线程安全问题","slug":"Java中的线程安全问题","date":"2018-11-22T17:07:37.000Z","updated":"2025-10-26T01:44:35.973Z","comments":true,"path":"2018/11/23/Java中的线程安全问题/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/23/Java中的线程安全问题/","excerpt":"","text":"线程安全线程安全：如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，此时我们就称之为是线程安全的。 我们通过一个案例，演示线程的安全问题： 电影院卖票，使用了A、B、C三个窗口进行卖票，电影票总数为100张 采用线程对象来模拟卖票窗口A、B、C；使用Runnable接口的子类来模拟买的电影票 模拟电影票： public class Ticket implements Runnable{ // 在成员位置 定义票的总数100 int ticket = 100; @Override public void run() { // 模拟买票窗口 // 买票窗口永远开启 while (true){ // 判断是否还有票可以卖 if(ticket &gt; 0){ // 使用sleep增加“程序的时间”--每张票卖50ms try { Thread.sleep(50); } catch (Exception e) { e.printStackTrace(); } // 获得线程名称 即买票窗口名称 String name = Thread.currentThread().getName(); System.out.println(name + &quot;卖掉第&quot; + ticket-- + &quot;票&quot;); } } } } 模拟买票： /** * 模拟买票操作 * 假设一场电影有100张票 * 三个窗口同时买票 * * 窗口 线程对象 * 买票 线程任务 实现runnable接口 */ public class Demo { public static void main(String[] args) { // 创建买票任务对象 Ticket ticket = new Ticket(); // 创建三个窗口 Thread t1 = new Thread(ticket, &quot;窗口A&quot;); Thread t2 = new Thread(ticket, &quot;窗口B&quot;); Thread t3 = new Thread(ticket, &quot;窗口C&quot;); // 开启线程 t1.start(); t2.start(); t3.start(); } } 运行结果： 窗口A卖掉第100张票 窗口C卖掉第98张票 窗口B卖掉第99张票 窗口A卖掉第97张票 窗口B卖掉第95张票 窗口C卖掉第96张票 窗口C卖掉第94张票 ⇐ 窗口B卖掉第94张票 ⇐ 窗口A卖掉第94张票 ⇐ ... 窗口C卖掉第1张票 窗口A卖掉第0张票 窗口B卖掉第-1张票 ⇐ 发现程序出现了两个问题： 1. 相同的票数被卖了多次，如第94张被三个窗口都卖了 2. 卖出了不存在的票，如窗口B卖掉了第-1张票 此时，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 线程安全问题都是有全局变量即静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作。一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有些的操作，就容易出现线程安全问题要解决上述多想成并发访问一个资源的安全性问题：也就是解决重复卖同一张票和卖不存在的票问题，Java中提供了同步机制(synchronized)来解决根据案例简述： 窗口A线程进入操作(买票)的时候，窗口B和窗口C线程只能在外等着， 窗口A操作结束，窗口A、窗口B和窗口C(CPU分配内存是随机的，所以还有可能是窗口A进入)才有机会进入代码去执行。 也就是说，在某个线程修改共享资源的时候，其他线程不能修改该资源， 等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。 有三种方式完成同步操作： 1. 同步代码块 2. 同步方法 3. 锁机制 同步代码块同步代码块：synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式： synchronized(同步锁){ // 需要同步的操作的代码 } 同步锁： 对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。 1. 锁对象可以是任意类型 2. 多个线程对象要使用同一把锁 注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到就进入代码块，其他的线程只能在外等着 使用同步代码块解决卖票问题： /** * synchronized(锁对象){ * * } * 1. 锁对象可以是任意类型 * 2. 互斥线程需要使用同一把锁 */ public class Ticket implements Runnable{ // 在成员位置 定义票的总数100 int ticket = 100; Object obj = new Object(); @Override public void run() { // 模拟买票窗口 // 买票窗口永远开启 while (true){ // 同步锁 synchronized (obj){ // 判断是否还有票可以卖 if(ticket &gt; 0){ // 使用sleep增加“程序的时间”--每张票卖50ms try { Thread.sleep(50); } catch (Exception e) { e.printStackTrace(); } // 获得线程名称 即买票窗口名称 String name = Thread.currentThread().getName(); System.out.println(name + &quot;卖掉第&quot; + ticket-- + &quot;票&quot;); } } } } } 执行结果： 窗口A卖掉第100票 窗口C卖掉第99票 窗口B卖掉第98票 窗口B卖掉第97票 ... 窗口C卖掉第4票 窗口A卖掉第3票 窗口A卖掉第2票 窗口A卖掉第1票 此时，每张票都只会被卖掉一次，不会存在卖掉不存在的电影票的问题。 当使用了同步代码块后，上述的线程的安全问题即可解决","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.xiongtianci.com/tags/多线程/"}],"author":"天赐"},{"title":"Word2016问题导致无法创建其他博客账号","slug":"Word2016问题导致无法创建其他博客账号","date":"2018-11-22T11:23:57.000Z","updated":"2025-10-26T01:44:35.956Z","comments":true,"path":"2018/11/22/Word2016问题导致无法创建其他博客账号/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/22/Word2016问题导致无法创建其他博客账号/","excerpt":"","text":"网友介绍能够在word上直接将博文发布到CSDN上，纯洁的我跟着网友的说法一顿操作，结果凉凉~按照网友说法在word中创建博客账号时，需要选择“其他”，就是这个&darr;&darr;&darr;结果&darr;&darr;&darr;网上搜了半天，终于找到一篇看似有用的文章：Word 2016 无法创建其他博客账号然并卵，我并没有找到所谓的补丁( 一群羊驼奔腾而过~ )希望各位大神赐教","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Word2016","slug":"Word2016","permalink":"https://blog.xiongtianci.com/tags/Word2016/"}],"author":"天赐"},{"title":"JS中Cookie、LocalStorage与SessionStorage","slug":"JS中Cookie、LocalStorage与SessionStorage","date":"2018-11-22T07:56:16.000Z","updated":"2025-10-26T01:44:35.940Z","comments":true,"path":"2018/11/22/JS中Cookie、LocalStorage与SessionStorage/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/22/JS中Cookie、LocalStorage与SessionStorage/","excerpt":"","text":"一、基本概念1. Cookie cookie：主要用途有保存登录信息。cookie 非常小，它的大小限制为4KB左右。用途：比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 2. LocalStorage localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信 3. SessionStorage sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 二、区别 特性 Cookie LocalStorage SessionStorage 数据的生命周期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 LocalStorage和SessionStorage： 不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。 相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。 这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的 三、LocalStorage 和 SessionStorage 的操作LocalStorage 和 SessionStorage 具有相同的操作方法，例如setItem、 getItem 和 removeItem 等 1. 添加value描述：使用 key/value 的形式将数据存储进本地存储中格式： sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;); localStorage.setItem(&quot;site&quot;, &quot;js8.in&quot;); 2.获取value描述：获取指定 key 本地存储的值格式： var value = sessionStorage.getItem(&quot;key&quot;); var site = localStorage.getItem(&quot;site&quot;); 3.删除value描述：删除指定 key 本地存储的值格式： sessionStorage.removeItem(&quot;key&quot;); localStorage.removeItem(&quot;site&quot;); 4.清除value描述：清除所有的 key/value格式： sessionStorage.clear(); localStorage.clear();","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"JS","slug":"JS","permalink":"https://blog.xiongtianci.com/tags/JS/"}],"author":"天赐"},{"title":"Java中创建线程的两种方式","slug":"Java中创建线程的两种方式","date":"2018-11-22T03:35:47.000Z","updated":"2025-10-26T01:44:35.923Z","comments":true,"path":"2018/11/22/Java中创建线程的两种方式/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/22/Java中创建线程的两种方式/","excerpt":"","text":"创建线程方式一 通过继承Thread类来创建并启动多线程 Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 自定义线程类： /** * 自定义线程类 */ public class MyThread extends Thread { public MyThread(String name){ super(name); } @Override public void run() { for(int i = 1; i &lt;= 20; i++){ System.out.println(getName() + &quot; &quot; + i); } } } 测试类： /** * 创建线程方式一： * 1. 创建自定义类继承Thread类 * 2. 重写run方法(run方法就是新的线程要执行的代码) * 3. 创建自定义类对象(线程对象) * 4. 调用start方法开启新的线程 */ public class Demo01 { public static void main(String[] args) { System.out.println(&quot;main线程开启&quot;); // 创建线程对象 MyThread myThread = new MyThread(&quot;线程A&quot;); // 开启新的线程myThread myThread.start(); // 这个循环在main线程中执行 for (int i = 1; i &lt;= 20; i++) { System.out.println(&quot;mian线程 &quot; + i); } } } 创建线程方式二 通过实现Runnable类来创建并启动多线程 采用java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象 调用线程对象的start()方法来启动线程 代码如下： public class MyRunnable implements Runnable { @Override public void run() { for (int i = 1; i &lt;= 20; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } /** * 创建线程方式二： * 1. 定义自定义类实现Runnable接口 * 2. 重写run方法 * 3. 创建自定义对象 * 4. 创建Threed对象的时候，作为构造方法的参数进行传递 * 5. 启动线程start方法 */ public class Demo02 { public static void main(String[] args) { // 创建线程任务对象 MyRunnable myRunnable = new MyRunnable(); // 创建线程对象 Thread t1 = new Thread(myRunnable, &quot;线程A&quot;); Thread t2 = new Thread(myRunnable, &quot;线程B&quot;); // 开启线程 t1.start(); t2.start(); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"线程","slug":"线程","permalink":"https://blog.xiongtianci.com/tags/线程/"}],"author":"天赐"},{"title":"重载(overload)和重写(override)的区别？","slug":"重载(overload)和重写(override)的区别？","date":"2018-11-21T12:04:30.000Z","updated":"2025-10-26T01:44:35.908Z","comments":true,"path":"2018/11/21/重载(overload)和重写(override)的区别？/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/21/重载(overload)和重写(override)的区别？/","excerpt":"","text":"方法重载： 方法名相同，参数列表【参数的顺序，类型，个数】不同 重载与方法的返回值无关，发生在同一类中 是编译时的多态性 方法重写： 参数列表和返回值类型必须相同 重写发生在子类与父类之间 子类抛出的异常不能超过父类相应方法抛出的异常 子类方法的的访问级别不能低于父类相应方法的访问级别 是运行时的多态性","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"常用转义字符","slug":"常用转义字符","date":"2018-11-20T10:01:33.000Z","updated":"2025-10-26T01:45:42.202Z","comments":true,"path":"2018/11/20/常用转义字符/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/20/常用转义字符/","excerpt":"","text":"提示：请直接按Ctrl+F搜索您要查找的转义字符 常用表 字符 转义字符 描述 ‘ &amp;#39; 单引号 “ &amp;quot; 双引号 &amp; &amp;#38; &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; 不断开空格(non-breaking space) &amp;nbsp; 空格 # &amp;#35; . &amp;#46; 句号 ¥ &amp;yen; ¦ &amp;brvbar; § &amp;sect; ¨ &amp;uml; © &amp;copy; « &amp;laquo; ® &amp;reg; ¼ &amp;frac14; ½ &amp;frac12; ¾ &amp;frac34; $ &amp;#36; % &amp;#37; ( &amp;#40; ) &amp;#41; * &amp;#42; + &amp;#43; , &amp;#44; 逗号 : &amp;#58; 冒号 ; &amp;#59; 分号 = &amp;#61; - &amp;#45; 连字号 / &amp;#47; 斜杠 \\ &amp;#92; 反斜杠 &amp; &amp;#124; 竖杠 ¦ &amp;#166; 断竖杠 [ &amp;#91; ] &amp;#93; ^ &amp;#94; _ &amp;#95; 下划线 ` &amp;#96; 尖重音符 ISO 8859-1 characters char glyph HTML tag 空格 &amp;nbsp; ¡ &amp;iexcl; ¢ &amp;cent; £ &amp;pound; ¤ &amp;curren; ¥ &amp;yen; ¦ &amp;brvbar; § &amp;sect; ¨ &amp;uml; © &amp;copy; ª &amp;ordf; « &amp;laquo; ¬ &amp;not; &amp;shy; ® &amp;reg; ¯ &amp;macr; ° &amp;deg; ± &amp;plusmn; ² &amp;sup2; ³ &amp;sup3; ´ &amp;acute; µ &amp;micro; ¶ &amp;para; · &amp;middot; ¸ &amp;cedil; ¹ &amp;sup1; º &amp;ordm; » &amp;raquo; ¼ &amp;frac14; ½ &amp;frac12; ¾ &amp;frac34; ¿ &amp;iquest; À &amp;Agrave; Á &amp;Aacute; Â &amp;Acirc; Ã &amp;Atilde; Ä &amp;Auml; Å &amp;Aring; Æ &amp;AElig; Ç &amp;Ccedil; È &amp;Egrave; É &amp;Eacute; Ê &amp;Ecirc; Ë &amp;Euml; Ì &amp;Igrave; Í &amp;Iacute; Î &amp;Icirc; Ï &amp;Iuml; Ð &amp;ETH; Ñ &amp;Ntilde; Ò &amp;Ograve; Ó &amp;Oacute; Ô &amp;Ocirc; Õ &amp;Otilde; Ö &amp;Ouml; × &amp;times; Ø &amp;Oslash; Ù &amp;Ugrave; Ú &amp;Uacute; Û &amp;Ucirc; Ü &amp;Uuml; Ý &amp;Yacute; Þ &amp;THORN; ß &amp;szlig; à &amp;agrave; á &amp;aacute; â &amp;acirc; ã &amp;atilde; ä &amp;auml; å &amp;aring; æ &amp;aelig; ç &amp;ccedil; è &amp;egrave; é &amp;eacute; ê &amp;ecirc; ë &amp;euml; ì &amp;igrave; í &amp;iacute; î &amp;icirc; ï &amp;iuml; ð &amp;eth; ñ &amp;ntilde; ò &amp;ograve; ó &amp;oacute; ô &amp;ocirc; õ &amp;otilde; ö &amp;ouml; ÷ &amp;divide; ø &amp;oslash; ù &amp;ugrave; ú &amp;uacute; û &amp;ucirc; ü &amp;uuml; ý &amp;yacute; þ &amp;thorn; ÿ &amp;yuml; Math symbolsLatin Extended-B char glyph HTML tag ƒ &amp;fnof; Arrows char glyph HTML tag ← &amp;larr; ↑ &amp;uarr; → &amp;rarr; ↓ &amp;darr; ↔ &amp;harr; ↵ &amp;crarr; ⇐ &amp;lArr; ⇑ &amp;uArr; ⇒ &amp;rArr; ⇓ &amp;dArr; ⇔ &amp;hArr; Mathematical Operators char glyph HTML tag ∀ &amp;forall; ∂ &amp;part; ∃ &amp;exist; ∅ &amp;empty; ∇ &amp;nabla; ∈ &amp;isin; ∉ &amp;notin; ∋ &amp;ni; ∏ &amp;prod; ∑ &amp;sum; − &amp;minus; ∗ &amp;lowast; √ &amp;radic; ∝ &amp;prop; ∞ &amp;infin; ∠ &amp;ang; ∧ &amp;and; ∨ &amp;or; ∩ &amp;cap; ∪ &amp;cup; ∫ &amp;int; ∴ &amp;there4; ∼ &amp;sim; ≅ &amp;cong; ≈ &amp;asymp; ≠ &amp;ne; ≡ &amp;equiv; ≤ &amp;le; ≥ &amp;ge; ⊂ &amp;sub; ⊃ &amp;sup; ⊄ &amp;nsub; ⊆ &amp;sube; ⊇ &amp;supe; ⊕ &amp;oplus; ⊗ &amp;otimes; ⊥ &amp;perp; ⋅ &amp;sdot; Miscellaneous Technical char glyph HTML tag ⌈ &amp;lceil; ⌉ &amp;rceil; ⌊ &amp;lfloor; ⌋ &amp;rfloor; ⟨ &amp;lang; ⟩ &amp;rang; Geometric Shapes char glyph HTML tag ◊ &amp;loz; Miscellaneous Symbols char glyph HTML tag ♠ &amp;spades; ♣ &amp;clubs; ♥ &amp;hearts; ♦ &amp;diams; Letterlike Symbols char glyph HTML tag ℘ &amp;weierp; ℑ &amp;image; ℜ &amp;real; ™ &amp;trade; ℵ &amp;alefsym; Greek char glyph HTML tag Α &amp;Alpha; Β &amp;Beta; Γ &amp;Gamma; Δ &amp;Delta; Ε &amp;Epsilon; Ζ &amp;Zeta; Η &amp;Eta; Θ &amp;Theta; Ι &amp;Iota; Κ &amp;Kappa; Λ &amp;Lambda; Μ &amp;Mu; Ν &amp;Nu; Ξ &amp;Xi; Ο &amp;Omicron; Π &amp;Pi; Ρ &amp;Rho; Σ &amp;Sigma; Τ &amp;Tau; Υ &amp;Upsilon; Φ &amp;Phi; Χ &amp;Chi; Ψ &amp;Psi; Ω &amp;Omega; α &amp;alpha; β &amp;beta; γ &amp;gamma; δ &amp;delta; ε &amp;epsilon; ζ &amp;zeta; η &amp;eta; θ &amp;theta; ι &amp;iota; κ &amp;kappa; λ &amp;lambda; μ &amp;mu; ν &amp;nu; ξ &amp;xi; ο &amp;omicron; π &amp;pi; ρ &amp;rho; ς &amp;sigmaf; σ &amp;sigma; τ &amp;tau; υ &amp;upsilon; φ &amp;phi; χ &amp;chi; ψ &amp;psi; ω &amp;omega; ϑ &amp;thetasym; ϒ &amp;upsih; ϖ &amp;piv; Special characters for HTMLC0 Controls and Basic Latin char glyph HTML tag “ &amp;quot; &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; Latin Extended-A char glyph HTML tag Œ &amp;OElig; œ &amp;oelig; Š &amp;Scaron; š &amp;scaron; Ÿ &amp;Yuml; Spacing Modifier Letters char glyph HTML tag ˆ &amp;circ; ˜ &amp;tilde; General Punctuation char glyph HTML tag &amp;ensp; &amp;emsp; &amp;thinsp; ‌ &amp;zwnj; ‍ &amp;zwj; ‎ &amp;lrm; ‏ &amp;rlm; – &amp;ndash; — &amp;mdash; ‘ &amp;lsquo; ’ &amp;rsquo; ‚ &amp;sbquo; “ &amp;ldquo; ” &amp;rdquo; „ &amp;bdquo; † &amp;dagger; ‡ &amp;Dagger; ‰ &amp;permil; ‹ &amp;lsaquo; › &amp;rsaquo; € &amp;euro;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"转义字符","slug":"转义字符","permalink":"https://blog.xiongtianci.com/tags/转义字符/"}],"author":"天赐"},{"title":"js中window&#46;location&#46;search的用法和作用","slug":"js中window-46-location-46-search的用法和作用","date":"2018-11-20T09:29:20.000Z","updated":"2025-10-26T01:44:35.872Z","comments":true,"path":"2018/11/20/js中window-46-location-46-search的用法和作用/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/20/js中window-46-location-46-search的用法和作用/","excerpt":"","text":"window.location.search的作用为：获取页面 URL 地址 属性 描述 hash 从 # 开始的 URL（锚） host 主机名和当前 URL 的端口号 hostname 当前 URL 的主机名 href 完整的 URL pathname 当前 URL 的路径部分 port 当前 URL 的端口号 protocol 当前 URL 的协议 search 从问号 (?) 开始的 URL（查询部分）","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.xiongtianci.com/tags/JS/"}],"author":"天赐"},{"title":"JSP九大内置对象及其作用和四大作用域详解","slug":"JSP九大内置对象及其作用和四大作用域详解","date":"2018-11-20T06:33:08.000Z","updated":"2025-10-26T01:44:35.853Z","comments":true,"path":"2018/11/20/JSP九大内置对象及其作用和四大作用域详解/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/20/JSP九大内置对象及其作用和四大作用域详解/","excerpt":"","text":"一、什么是内置对象？在JSP开发中会频繁使用到一些对象，SUN公司为简化开发，在设计JSP时规定JSP页面加载完毕之后自动帮开发者创建好了这些对象，开发者只需要使用相应的对象调用相应的方法即可。这些系统创建好的对象就叫做内置对象。 二、九大内置对象内置对象名 类型 request HttpServletRequest response HttpServletResponse config ServletConfig application ServletContext session HttpSession exception Throwable page Object(this) out JspWriter pageContext PageContext 1、request对象request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。 2、response对象response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。 3、session对象session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。 4、application对象 application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。 5、out 对象out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。 6、pageContext 对象pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。 7、config 对象config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。 8、page 对象page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。 9、exception 对象exception 对象的作用是显示异常信息，只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。 三、四大作用域page域: 只能在当前jsp页面使用 (当前页面) request域: 只能在同一个请求中使用 (转发) session域: 只能在同一个会话(session对象)中使用 (私有的) context域: 只能在同一个web应用中使用 (全局的)","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"JSP","slug":"JSP","permalink":"https://blog.xiongtianci.com/tags/JSP/"}],"author":"天赐"},{"title":"==和equals()的区别","slug":"==和equals的区别","date":"2018-11-20T02:26:33.000Z","updated":"2025-10-26T01:44:35.836Z","comments":true,"path":"2018/11/20/==和equals的区别/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/20/==和equals的区别/","excerpt":"","text":"1、====是运算符 在对==基本数据类型==进行比较时，是判断数值是否相等 对==引用数据类型==进行比较时，判断的是对象的地址值(内存地址)是否相等 int i1 = 1; int i2 = 1; System.out.println(i1 == i2); //true Integer i3 = new Integer(1); Integer i4 = new Integer(1); System.out.println(i3 == i4); //false 2、equals()equals()是Object中的方法，不能用于基本数据类型的比较，比较的是==引用类型==的变量所指向的对象的地址由于String类重写了equals方法，比较的是属性的值 String s1 = new String(&quot;a&quot;); String s2 = new String(&quot;a&quot;); System.out.println(s1 == s2); //false，s1和s2的内存地址不相等 System.out.println(s1.equals(s2)); //true，s1和s2的值相等","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"String、StringBuffer、StringBuilder以及对String不变性的理解","slug":"String、StringBuffer、StringBuilder以及对String不变性的理解","date":"2018-11-20T01:21:22.000Z","updated":"2025-10-26T01:44:35.888Z","comments":true,"path":"2018/11/20/String、StringBuffer、StringBuilder以及对String不变性的理解/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/20/String、StringBuffer、StringBuilder以及对String不变性的理解/","excerpt":"","text":"String、StringBuffer、StringBuilder 都是final 类, 都不允许被继承 String 长度是不可变的, StringBuffer、StringBuilder 长度是可变的; StringBuffer 是线程安全的, StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer在StringBuilder的方法之上添加了synchronized修饰，保证线程安全 StringBuilder比StringBuffer拥有更好的性能 如果一个String类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时String的速度比StringBuffer和StringBuilder的性能好的多 String不变性的理解 String 类是被final进行修饰的，不能被继承 在用+号链接字符串的时候会创建新的字符串；对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象 String s = new String(“Hello world”); 可能创建两个对象也可能创建一个对象。如果静态区中有“Hello world”字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有“Hello world”对象，则堆上和静态区中都需要创建对象 在java 中, 通过使用”+” 符号来串联字符串的时候, 实际上底层会转成通过StringBuilder 实例的append() 方法来实现","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"同源策略与JS跨域","slug":"同源策略与JS跨域","date":"2018-11-19T02:49:12.000Z","updated":"2025-10-26T01:44:35.819Z","comments":true,"path":"2018/11/19/同源策略与JS跨域/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/19/同源策略与JS跨域/","excerpt":"","text":"为什么要跨域为了用户的信息安全，浏览器就引入了同源策略那么同源策略是如何保证用户的信息安全的呢？ 如果没有同源策略，你打开了你的银行账户页面A，又打开了另一个不相关的页面B，这时候如果B是恶意网站，B可以通过Javascript轻松访问和修改A页面中的内容 现在我们广泛的使用cookie来维护用户的登录状态，而如果没有同源策略，这些cookie信息就会泄露，其他网站就可以冒充这个登录用户 由此可以看出，同源策略确实是必不可少的，那么它会带来哪些限制呢？ Cookie、LocalStorage和IndexDB无法读取 DOM无法获得 AJAX请求不能发送 有时候我们需要突破上述限制，就需要用跨域的方法来解决 跨域是什么？ 什么叫做不同的域？协议（http）、域名（www.a.com）、端口（8000）三者中有一个不同就叫不同的域 跨域就是不同的域间相互访问时使用某些方法来突破上述限制 协议或者端口的不同，只能通过后台来解决如何实现跨域？一、解决上面提到的1、2两点限制：1. 通过document.domain跨子域 适用范围： 两个域只是子域不同 只适用于iframe窗口与父窗口之间互相获取cookie和DOM节点，不能突破LocalStorage和IndexDB的限制 当两个不同的域只是子域不同时，可以通过把document.domain设置为他们共同的父域来解决 eg:A: http://www.example.com/a.htmlB: http://example.com/b.html 当A、B想要获取对方的cookie或者DOM节点时，可以设置: document.domain=’example.com’; 这时A网页通过脚本设置: document.cookie = “testA=hello”; B网页就可以拿到这个cookie： var aCookie = document.cookie; 2. 通过window.name跨域 使用范围： 可以是两个完全不同源的域 同一个窗口内：即同一个标签页内先后打开的窗口 window.name属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。 基于这个思想，我们可以在某个页面设置好 window.name 的值，然后在本标签页内跳转到另外一个域下的页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。 结合iframe还有更高级的用法： 父窗口先打开一个与自己不同源的子窗口，在这个子窗口里设置： window.name = data; 然后让子窗口跳转到一个与父窗口同域的网址： location=’http://www.parent.com/a.html&#39;; 这时，因为同域并且同一窗口window.name是不变的，所以父窗口可以获取到子窗口下的window.name。 var data = document.getElementById(‘myFrame’).contentWindow.name; 优点：window.name容量很大，可以放置非常长的字符串；缺点：必须监听子窗口window.name属性的变化，影响网页性能。 3. 使用HTML5的window.postMessage跨域window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。 otherWindow.postMessage(message, targetOrigin); otherWindow:接受消息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message:所要发送的数据，string类型。targetOrigin:用于限制otherWindow，*表示不做限制。 eg1:在父页面中嵌入子页面，通过postMessage发送数据。parent.com/index.html中的代码： &lt;iframe id=&quot;ifr&quot; src=&quot;child.com/index.html&quot;&gt;&lt;/iframe&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { var ifr = document.getElementById(&#39;ifr&#39;); var targetOrigin = &#39;http://child.com&#39;; // 若写成&#39;http://child.com/c/proxy.html&#39;效果一样 // 若写成&#39;http://c.com&#39;就不会执行postMessage了 ifr.contentWindow.postMessage(&#39;I was there!&#39;, targetOrigin); }; &lt;/script&gt; 在子页面中通过message事件监听父页面发送来的消息并显示。child.com/index.html中的代码： &lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#39;message&#39;, function(event){ // 通过origin属性判断消息来源地址 if (event.origin == &#39;http://parent.com&#39;) { alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对parent.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 } }, false); &lt;/script&gt; eg2:假设在a.html里嵌套个 &lt;iframe src=&quot;http://www.child.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 在这两个页面里互相通信 a.html window.onload = function() { window.addEventListener(&quot;message&quot;, function(e) { alert(e.data); }); window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.child.com/b.html&quot;); } b.html window.onload = function() { window.addEventListener(&quot;message&quot;, function(e) { alert(e.data); }); window.parent.postMessage(&quot;a data&quot;, &quot;http://www.parent.com/a.html&quot;); } 这样打开a页面，首先监听到了b.html通过postMessage传来的消息，就先弹出 a data，然后a通过postMessage传递消息给子页面b.html，这时会弹出 b data 二、解决第3点限制： AJAX请求不能发送 4. 通过JSONP跨域 适用范围： 可以是两个完全不同源的域； 只支持HTTP请求中的GET方式； 老式浏览器全部支持； 需要服务端支持 JSONP(JSON with Padding)是资料格式JSON的一种使用模式，可以让网页从别的网域要资料。 由于浏览器的同源策略，在网页端出现了这个“跨域”的问题，然而我们发现，所有的 src 属性并没有受到相关的限制，比如 img / script 等。 JSONP 的原理就要从 script 说起。script 可以引用其他域的脚本文件，比如这样： a.html ... &lt;script&gt; function callback(data) { console.log(data.url) } &lt;/script&gt; &lt;script src=&#39;b.js&#39;&gt;&lt;/script&gt; ... b.js callback({url: &#39;http://www.rccoder.net&#39;}) 这就类似于JSONP的原理了。 JSONP的基本思想是：先在网页上添加一个script标签，设置这个script标签的src属性用于向服务器请求JSON数据 ，需要注意的是，src属性的查询字符串一定要加一个callback参数，用来指定回调函数的名字 。而这个函数是在资源加载之前就已经在前端定义好的，这个函数接受一个参数并利用这个参数做一些事情。向服务器请求后，服务器会将JSON数据放在一个指定名字的回调函数里作为其参数传回来。这时，因为函数已经在前端定义好了，所以会直接调用。 eg： function addScriptTag(src) { var script = document.createElement(&#39;script&#39;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script); } window.onload = function () { addScriptTag(&#39;http://example.com/ip?callback=foo&#39;);//请求服务器数据并规定回调函数为foo } function foo(data) { console.log(&#39;Your public IP address is: &#39; + data.ip); }; 向服务器example.com请求数据，这时服务器会先生成JSON数据，这里是{“ip”: “8.8.8.8”}，然后以JS语法的方式生成一个函数，函数名就是传递上来的callback参数的值，最后将数据放在函数的参数中返回： foo({ &quot;ip&quot;: &quot;8.8.8.8&quot; }); 客户端解析script标签，执行返回的JS代码，调用函数。 5. 通过CORS跨域 适用范围： 可以是两个完全不同源的域； 支持所有类型的HTTP请求； 被绝大多数现代浏览器支持，老式浏览器不支持； 需要服务端支持 对于前端开发者来说，跨域的CORS通信与同源的AJAX通信没有差别，代码完全一样。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 简单请求：下面是一次跨源AJAX请求，浏览器发现它是简单请求，就会直接在头信息中加一个origin字段： GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 服务器收到这条请求，如果这个origin指定的源在许可范围内，那么服务器返回的头信息中会包含Access-Control-Allow-Origin字段，值与origin的值相同，以及其他几个相关字段： Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Access-Control-Allow-Origin: 该字段是必须的。要么与origin相同，要么为*Access-Control-Allow-Credentials: 该字段可选。设为true表示服务器允许发送cookieAccess-Control-Expose-Headers: 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 想要发送cookie，这里还有两点需要额外注意： 1）开发者必须在AJAX请求中打开withCredentials属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则即使服务器允许，客户端也不会发送。 2）Access-Control-Allow-Origin不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求：1.预检请求： 非简单请求会在正式通信前加一次预检（preflight）请求。作用是浏览器先询问服务器当前网页所在域名是否在服务器的许可名单中，以及可以使用哪些HTTP方法以及头信息字段。只有得到肯定答复，浏览器才会发送XMLHttpRequest，否则报错。一个例子： var url = &#39;http://api.alice.com/cors&#39;; var xhr = new XMLHttpRequest(); xhr.open(&#39;PUT&#39;, url, true); xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;); xhr.send(); HTTP请求方法为PUT，并发送一个自定义头信息”X-Custom-Header”，浏览器发现这是一个非简单请求，就会自动发送一个预检请求，预检请求的HTTP头信息如下： OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 请求方法是OPTIONS，表示这个请求是用来询问的，头信息中的关键信息有3个： （1）表示请求来自哪个源 Origin: http://api.bob.com （2）列出浏览器的CORS请求会用到哪些HTTP方法 Access-Control-Request-Method: PUT （3）指定浏览器CORS请求会额外发送的头信息字段 Access-Control-Request-Headers: X-Custom-Header 2.预检请求的回应（有两种情况：A允许、B不允许） A.服务器允许这次跨域请求 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 服务器返回中要注意的字段： （1）服务器同意的跨域请求源： Access-Control-Allow-Origin: http://api.bob.com （2）服务器支持的所有跨域请求的方法： Access-Control-Allow-Methods: GET, POST, PUT （3）表明服务器支持的所有头信息字段： Access-Control-Allow-Headers: X-Custom-Header （4）指定本次预检请求的有效期，单位为秒，即允许请求该条回应在有效期之前都不用再发送预检请求： Access-Control-Max-Age: 1728000 B.服务器不允许这次跨域请求即origin指定的源不在许可范围内，服务器会返回一个正常的HTTP回应。但是头信息中没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。但是要注意的是，这种HTTP回应的状态码很有可能是200，所以无法通过状态码识别这种错误。 3.正式请求过了预检请求，非简单请求的正式请求就与简单请求一样了。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题、","slug":"面试题、","permalink":"https://blog.xiongtianci.com/tags/面试题、/"},{"name":"同源策略","slug":"同源策略","permalink":"https://blog.xiongtianci.com/tags/同源策略/"},{"name":"JS跨域","slug":"JS跨域","permalink":"https://blog.xiongtianci.com/tags/JS跨域/"}],"author":"天赐"},{"title":"电商项目中的SPU和SKU概念","slug":"电商项目中的SPU和SKU概念","date":"2018-11-16T06:58:37.000Z","updated":"2025-10-26T01:44:35.802Z","comments":true,"path":"2018/11/16/电商项目中的SPU和SKU概念/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/16/电商项目中的SPU和SKU概念/","excerpt":"","text":"SPUSPU：Standard Product Unit，标准产品单位。 概念：SPU 是商品信息聚合的最小单位【即：商品共同的属性】，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的货品就可以称为一个 SPU SPU是用来定位的例如：iphone8 就是一个 SPU，与商家、颜色、款式、套餐都无关 SKUSKU：Stock Keeping Unit，库存量单位。 概念：SKU 即库存进出计量的单位， 可以是以件、盒、托盘等为单位，是物理上不可分割的最小存货单元。在使用时要根据不同业务，不同管理模式来处理 SKU是用来定价和管理库存的iphone8 有很多颜色，很多配置，每个颜色和配置的组合都会形成新的产品，这时就产生很多SKU例如：银色 64G 的 iphone8 就是一个SKU；纺织品中一个 SKU 通常表示：规格、颜色、款式","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"Servlet简介及其生命周期详解","slug":"Servlet简介及其生命周期详解","date":"2018-11-16T02:36:38.000Z","updated":"2025-10-26T01:44:35.784Z","comments":true,"path":"2018/11/16/Servlet简介及其生命周期详解/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/16/Servlet简介及其生命周期详解/","excerpt":"","text":"一、什么是Servlet？Servlet：是用Java编写的服务器端程序，一门用于开发动态web资源的技术。其主要功能在与交互式的浏览和修改数据，生成动态web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet的类。一般对Servlet的理解是后者。若想开发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 1、编写一个Java类，实现servlet接口。 2、把开发好的Java类部署到web服务器中。按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet 二、Servlet的运行流程Servlet程序是由WEB服务器调用，WEB服务器收到客户端的Servlet访问请求后： Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步 装载并创建该Servlet的一个实例对象 调用Servlet实例对象的init()方法 创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去 WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法 三、Servlet的生命周期Servlet运行在Servlet容器中，其生命周期由容器来管理。Servlet的生命周期通过javax.servlet.Servlet接口中的init()、service()和destroy()方法来表示Servlet的生命周期包含了下面4个阶段： 加载和实例化：第一次请求时创建，通过服务器反射机制创建Servlet对象 初始化：调用Servlet对象的init()方法，初始化Servlet的信息，init()方法只会在创建后被调用一次 请求处理：调用service()或者是doGet()，doPost()方法来处理请求 服务终止：在长时间没有被调用或者是服务器关闭时，会调用destroy()方法来销毁Servlet对象 在整个Servlet的生命周期过程中，创建Servlet实例、调用实例的init()和destroy()方法都只执行一次，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的service()方法，为接收到的请求服务","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"Servlet","slug":"Servlet","permalink":"https://blog.xiongtianci.com/tags/Servlet/"}],"author":"天赐"},{"title":"反向安装jar包到Mave本地仓库","slug":"反向安装jar包到Mave本地仓库","date":"2018-11-14T17:17:48.000Z","updated":"2025-10-26T01:44:35.770Z","comments":true,"path":"2018/11/15/反向安装jar包到Mave本地仓库/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/15/反向安装jar包到Mave本地仓库/","excerpt":"","text":"当maven中央仓库没有所需jar的坐标时，需要自行将jar包反向安装到maven的本地仓库中步骤： 注意：前提是安装好Maven并且配置好maven的环境变量 准备所需的jar包 打开命令行，输入以下命令，按下回车即可安装 mvn install:install-file -Dfile=d:\\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar 可以在Maven本地仓库中查看是否安装成功 在pom文件中导入坐标 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.8.4&lt;/version&gt; &lt;/dependency&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://blog.xiongtianci.com/tags/maven/"}],"author":"天赐"},{"title":"SpringMVC的工作原理","slug":"SpringMVC的工作原理","date":"2018-11-09T13:17:04.000Z","updated":"2025-10-26T01:44:35.751Z","comments":true,"path":"2018/11/09/SpringMVC的工作原理/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/09/SpringMVC的工作原理/","excerpt":"","text":"1. SpringMVC的主要组件 DispatchServlet：前端控制器，接收请求，响应结果，返回可以是json,String等数据类型，也可以是页面（Model） HandlerMapping：处理器映射器，根据URL去查找处理器，一般通过xml配置或者注解进行查找 Handler：处理器，即Controller控制器，由我们程序员编写 HandlerAdapter：处理器适配器，可以将处理器包装成适配器，这样就可以支持多种类型的处理器 ViewResolver：视图解析器，进行视图解析，返回view对象（常见的有JSP,FreeMark等） 2. SpringMVC的工作原理 用户向服务器发送请求，请求被 SpringMVC 前端控制器DispatchServlet 捕获 DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping将请求映射到处理器 HandlerExcutionChain DispatchServlet 根据获得 Handler 选择一个合适的 HandlerAdapter 适配器处理； Handler 对数据处理完成以后将返回一个 ModelAndView() 对象给 DisPatchServlet; Handler 返回的 ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet 通过 ViewResolver 试图解析器将逻辑视图转化为真正的视图View; DispatcherServle 通过model 解析出 ModelAndView() 中的参数进行解析最终展现出完整的 view 并返回给客户端","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://blog.xiongtianci.com/tags/SpringMVC/"}],"author":"天赐"},{"title":"Java 的基本数据类型都有哪些，各占几个字节","slug":"Java的基本数据类型都有哪些，各占几个字节","date":"2018-11-09T09:37:25.000Z","updated":"2025-10-26T01:44:35.734Z","comments":true,"path":"2018/11/09/Java的基本数据类型都有哪些，各占几个字节/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/09/Java的基本数据类型都有哪些，各占几个字节/","excerpt":"","text":"四类 八种 字节数 数据表示范围 整型 byte 1 -128~127 short 2 -32768~32767 int 4 -2147483648～2147483647 long 8 -2^63^～2^63^-1 浮点型 float 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308 字符型 char 2 表示一个字符，如(‘a’，’A’，’0’，’家’) 布尔型 boolean 1 只有两个值true与false","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"final、finally、finalize 的区别","slug":"final、finally、finalize-的区别","date":"2018-11-09T08:33:44.000Z","updated":"2025-10-26T01:44:35.717Z","comments":true,"path":"2018/11/09/final、finally、finalize-的区别/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/09/final、finally、finalize-的区别/","excerpt":"","text":"final：用于声明属性( 变量 )，方法和类。分别表示属性不可变( 不可二次赋值 )，方法不可覆盖，被其修饰的类不可继承 finally：异常处理语句 try/catch 结构的一部分，表示总是执行 finalize：Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"}],"author":"天赐"},{"title":"数组的两种排序方式：选择排序和冒泡排序","slug":"数组的两种排序方式：选择排序和冒泡排序","date":"2018-11-09T08:23:06.000Z","updated":"2025-10-26T01:44:35.768Z","comments":true,"path":"2018/11/09/数组的两种排序方式：选择排序和冒泡排序/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/09/数组的两种排序方式：选择排序和冒泡排序/","excerpt":"","text":"选择排序 原理：在数组中选择出最小（大）的一个数，与第一个位置的数进行交换位置；`int[] arr = {5,8,3,9,10,2};System.out.println(“排序前：” + Arrays.toString(arr)); // 使用两层循环遍历数组，将前一位数值与后面以为数值进行比较，// 如果前一位数值要大于后一位数值，则交换他们的位置。故而可以实现排序for(int m = 0; m&lt;arr.length-1; m++){ for(int n = m+1; n&lt;arr.length; n++){ if(arr[m] &gt; arr[n]){ // 用于临时储存需要交换位置的某一个值 int temp = arr[m]; // 交换位置 arr[m] = arr[n]; arr[n] = temp; } }}System.out.println(“排序后：” + Arrays.toString(arr)); ## 冒泡排序 int[] arr = {5,8,3,9,10,2};System.out.println(“排序前：” + Arrays.toString(arr)); // 使用两层循环遍历数组for(int m = 0; m&lt;arr.length-1; m++){ // 第二层循环，将 arr 索引为 0~arr.length-1-m 中最大的一个数移动到 arr[arr.length-1-m] 的位置 for(int n = 0; n&lt;arr.length-1-m; n++){ if(arr[n] &gt; arr[n+1]){ // 用于临时储存需要交换位置的某一个值 int temp = arr[n]; // 交换位置 arr[n] = arr[n+1]; arr[n+1] = temp; } }}System.out.println(“排序后：” + Arrays.toString(arr));`","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"数组","slug":"数组","permalink":"https://blog.xiongtianci.com/tags/数组/"},{"name":"排序","slug":"排序","permalink":"https://blog.xiongtianci.com/tags/排序/"}],"author":"天赐"},{"title":"如何显示隐藏的Chrome扩展程序图标","slug":"如何显示隐藏的Chrome扩展程序图标","date":"2018-11-08T07:33:35.000Z","updated":"2025-10-26T01:44:35.693Z","comments":true,"path":"2018/11/08/如何显示隐藏的Chrome扩展程序图标/","link":"","permalink":"https://blog.xiongtianci.com/2018/11/08/如何显示隐藏的Chrome扩展程序图标/","excerpt":"","text":"1. 将扩展程序图标在 Chrome 菜单中隐藏将鼠标移动到需要隐藏的扩展程序上面，点击鼠标右键，选择“在 Chrome 菜单中隐藏”即可进行隐藏 2. 将隐藏的扩展程序图标在 Chrome 菜单中重新显示在浏览器地址栏最右边，待鼠标变成左右双向箭头图标的时候向左拖动，会发现隐藏的扩展程序出现了","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.xiongtianci.com/tags/Chrome/"},{"name":"扩展程序","slug":"扩展程序","permalink":"https://blog.xiongtianci.com/tags/扩展程序/"}],"author":"天赐"},{"title":"Typora设置图片的相对路径（win系统）","slug":"Typora设置图片的相对路径（win系统）","date":"2018-09-30T07:17:41.000Z","updated":"2025-10-26T01:44:35.662Z","comments":true,"path":"2018/09/30/Typora设置图片的相对路径（win系统）/","link":"","permalink":"https://blog.xiongtianci.com/2018/09/30/Typora设置图片的相对路径（win系统）/","excerpt":"","text":"Typora设置图片的相对路径（win系统）步骤：文件–&gt;偏好设置–&gt;图片插入结果：将插入的图片路径设置成相对路径（./assets目录）","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.xiongtianci.com/tags/Typora/"}],"author":"天赐"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://blog.xiongtianci.com/categories/技术/"},{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/categories/工具/"},{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/categories/软件/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.xiongtianci.com/categories/Linux/"},{"name":"IDE","slug":"IDE","permalink":"https://blog.xiongtianci.com/categories/IDE/"},{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/categories/踩坑/"},{"name":"资料","slug":"资料","permalink":"https://blog.xiongtianci.com/categories/资料/"},{"name":"win","slug":"win","permalink":"https://blog.xiongtianci.com/categories/win/"},{"name":"操作","slug":"操作","permalink":"https://blog.xiongtianci.com/categories/操作/"},{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/categories/win10/"},{"name":"面试","slug":"面试","permalink":"https://blog.xiongtianci.com/categories/面试/"},{"name":"资源","slug":"资源","permalink":"https://blog.xiongtianci.com/categories/资源/"},{"name":"日语","slug":"日语","permalink":"https://blog.xiongtianci.com/categories/日语/"},{"name":"电影","slug":"电影","permalink":"https://blog.xiongtianci.com/categories/电影/"},{"name":"转载","slug":"转载","permalink":"https://blog.xiongtianci.com/categories/转载/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/categories/笔记/"},{"name":"生活","slug":"生活","permalink":"https://blog.xiongtianci.com/categories/生活/"},{"name":"装载","slug":"装载","permalink":"https://blog.xiongtianci.com/categories/装载/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://blog.xiongtianci.com/tags/路由器/"},{"name":"软路由","slug":"软路由","permalink":"https://blog.xiongtianci.com/tags/软路由/"},{"name":"JUC","slug":"JUC","permalink":"https://blog.xiongtianci.com/tags/JUC/"},{"name":"高并发","slug":"高并发","permalink":"https://blog.xiongtianci.com/tags/高并发/"},{"name":"C","slug":"C","permalink":"https://blog.xiongtianci.com/tags/C/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.xiongtianci.com/tags/Typora/"},{"name":"Git","slug":"Git","permalink":"https://blog.xiongtianci.com/tags/Git/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xiongtianci.com/tags/MySQL/"},{"name":"AI","slug":"AI","permalink":"https://blog.xiongtianci.com/tags/AI/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://blog.xiongtianci.com/tags/ChatGPT/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog.xiongtianci.com/tags/GitHub/"},{"name":"MQ","slug":"MQ","permalink":"https://blog.xiongtianci.com/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.xiongtianci.com/tags/RabbitMQ/"},{"name":"微服务","slug":"微服务","permalink":"https://blog.xiongtianci.com/tags/微服务/"},{"name":"CentOS6.5","slug":"CentOS6-5","permalink":"https://blog.xiongtianci.com/tags/CentOS6-5/"},{"name":"软件","slug":"软件","permalink":"https://blog.xiongtianci.com/tags/软件/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.xiongtianci.com/tags/IDEA/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.xiongtianci.com/tags/Spring/"},{"name":"SpringTask","slug":"SpringTask","permalink":"https://blog.xiongtianci.com/tags/SpringTask/"},{"name":"Cron","slug":"Cron","permalink":"https://blog.xiongtianci.com/tags/Cron/"},{"name":"Adobe","slug":"Adobe","permalink":"https://blog.xiongtianci.com/tags/Adobe/"},{"name":"Acrobat","slug":"Acrobat","permalink":"https://blog.xiongtianci.com/tags/Acrobat/"},{"name":"SVN","slug":"SVN","permalink":"https://blog.xiongtianci.com/tags/SVN/"},{"name":"Eclispe","slug":"Eclispe","permalink":"https://blog.xiongtianci.com/tags/Eclispe/"},{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.xiongtianci.com/tags/Eclipse/"},{"name":"VMware","slug":"VMware","permalink":"https://blog.xiongtianci.com/tags/VMware/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.xiongtianci.com/tags/CentOS7/"},{"name":"十次方","slug":"十次方","permalink":"https://blog.xiongtianci.com/tags/十次方/"},{"name":"win","slug":"win","permalink":"https://blog.xiongtianci.com/tags/win/"},{"name":"Everything","slug":"Everything","permalink":"https://blog.xiongtianci.com/tags/Everything/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xiongtianci.com/tags/CentOS/"},{"name":"Xftp6","slug":"Xftp6","permalink":"https://blog.xiongtianci.com/tags/Xftp6/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.xiongtianci.com/tags/Linux/"},{"name":"win10","slug":"win10","permalink":"https://blog.xiongtianci.com/tags/win10/"},{"name":"系统","slug":"系统","permalink":"https://blog.xiongtianci.com/tags/系统/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.xiongtianci.com/tags/Chrome/"},{"name":"工具","slug":"工具","permalink":"https://blog.xiongtianci.com/tags/工具/"},{"name":"CodeGlance","slug":"CodeGlance","permalink":"https://blog.xiongtianci.com/tags/CodeGlance/"},{"name":"面试题","slug":"面试题","permalink":"https://blog.xiongtianci.com/tags/面试题/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.xiongtianci.com/tags/JavaSE/"},{"name":"转载","slug":"转载","permalink":"https://blog.xiongtianci.com/tags/转载/"},{"name":"注释","slug":"注释","permalink":"https://blog.xiongtianci.com/tags/注释/"},{"name":"踩坑","slug":"踩坑","permalink":"https://blog.xiongtianci.com/tags/踩坑/"},{"name":"激活","slug":"激活","permalink":"https://blog.xiongtianci.com/tags/激活/"},{"name":"日语","slug":"日语","permalink":"https://blog.xiongtianci.com/tags/日语/"},{"name":"正则","slug":"正则","permalink":"https://blog.xiongtianci.com/tags/正则/"},{"name":"Notepad++","slug":"Notepad","permalink":"https://blog.xiongtianci.com/tags/Notepad/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.xiongtianci.com/tags/笔记/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.xiongtianci.com/tags/CSS/"},{"name":"选择器","slug":"选择器","permalink":"https://blog.xiongtianci.com/tags/选择器/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.xiongtianci.com/tags/Hexo/"},{"name":"Valine","slug":"Valine","permalink":"https://blog.xiongtianci.com/tags/Valine/"},{"name":"google扩展","slug":"google扩展","permalink":"https://blog.xiongtianci.com/tags/google扩展/"},{"name":"Octotree","slug":"Octotree","permalink":"https://blog.xiongtianci.com/tags/Octotree/"},{"name":"电影","slug":"电影","permalink":"https://blog.xiongtianci.com/tags/电影/"},{"name":"博客","slug":"博客","permalink":"https://blog.xiongtianci.com/tags/博客/"},{"name":"Pages","slug":"Pages","permalink":"https://blog.xiongtianci.com/tags/Pages/"},{"name":"黑马","slug":"黑马","permalink":"https://blog.xiongtianci.com/tags/黑马/"},{"name":"乐优商城","slug":"乐优商城","permalink":"https://blog.xiongtianci.com/tags/乐优商城/"},{"name":"Mysql","slug":"Mysql","permalink":"https://blog.xiongtianci.com/tags/Mysql/"},{"name":"Navicat","slug":"Navicat","permalink":"https://blog.xiongtianci.com/tags/Navicat/"},{"name":"POI","slug":"POI","permalink":"https://blog.xiongtianci.com/tags/POI/"},{"name":"Excel","slug":"Excel","permalink":"https://blog.xiongtianci.com/tags/Excel/"},{"name":"cc.png","slug":"cc-png","permalink":"https://blog.xiongtianci.com/tags/cc-png/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.xiongtianci.com/tags/SpringBoot/"},{"name":"Snowflake","slug":"Snowflake","permalink":"https://blog.xiongtianci.com/tags/Snowflake/"},{"name":"自增ID","slug":"自增ID","permalink":"https://blog.xiongtianci.com/tags/自增ID/"},{"name":"bat","slug":"bat","permalink":"https://blog.xiongtianci.com/tags/bat/"},{"name":"脚本","slug":"脚本","permalink":"https://blog.xiongtianci.com/tags/脚本/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://blog.xiongtianci.com/tags/SpringMVC/"},{"name":"跨域","slug":"跨域","permalink":"https://blog.xiongtianci.com/tags/跨域/"},{"name":"CrossOrigin","slug":"CrossOrigin","permalink":"https://blog.xiongtianci.com/tags/CrossOrigin/"},{"name":"WIFI密码","slug":"WIFI密码","permalink":"https://blog.xiongtianci.com/tags/WIFI密码/"},{"name":"Swagger","slug":"Swagger","permalink":"https://blog.xiongtianci.com/tags/Swagger/"},{"name":"415","slug":"415","permalink":"https://blog.xiongtianci.com/tags/415/"},{"name":"RequestParam","slug":"RequestParam","permalink":"https://blog.xiongtianci.com/tags/RequestParam/"},{"name":"RequestBody","slug":"RequestBody","permalink":"https://blog.xiongtianci.com/tags/RequestBody/"},{"name":"datetime","slug":"datetime","permalink":"https://blog.xiongtianci.com/tags/datetime/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.xiongtianci.com/tags/MyBatis/"},{"name":"驼峰命名","slug":"驼峰命名","permalink":"https://blog.xiongtianci.com/tags/驼峰命名/"},{"name":"js","slug":"js","permalink":"https://blog.xiongtianci.com/tags/js/"},{"name":"textarea","slug":"textarea","permalink":"https://blog.xiongtianci.com/tags/textarea/"},{"name":"ModelAndView","slug":"ModelAndView","permalink":"https://blog.xiongtianci.com/tags/ModelAndView/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://blog.xiongtianci.com/tags/thymeleaf/"},{"name":"RestController","slug":"RestController","permalink":"https://blog.xiongtianci.com/tags/RestController/"},{"name":"乱码","slug":"乱码","permalink":"https://blog.xiongtianci.com/tags/乱码/"},{"name":"小程序","slug":"小程序","permalink":"https://blog.xiongtianci.com/tags/小程序/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://blog.xiongtianci.com/tags/MongoDB/"},{"name":"缓存","slug":"缓存","permalink":"https://blog.xiongtianci.com/tags/缓存/"},{"name":"SpringCache","slug":"SpringCache","permalink":"https://blog.xiongtianci.com/tags/SpringCache/"},{"name":"SpringDataRedis","slug":"SpringDataRedis","permalink":"https://blog.xiongtianci.com/tags/SpringDataRedis/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.xiongtianci.com/tags/Redis/"},{"name":"JPA","slug":"JPA","permalink":"https://blog.xiongtianci.com/tags/JPA/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.xiongtianci.com/tags/Docker/"},{"name":"RunDashboard","slug":"RunDashboard","permalink":"https://blog.xiongtianci.com/tags/RunDashboard/"},{"name":"List","slug":"List","permalink":"https://blog.xiongtianci.com/tags/List/"},{"name":"迅雷","slug":"迅雷","permalink":"https://blog.xiongtianci.com/tags/迅雷/"},{"name":"XMind","slug":"XMind","permalink":"https://blog.xiongtianci.com/tags/XMind/"},{"name":"Oracle","slug":"Oracle","permalink":"https://blog.xiongtianci.com/tags/Oracle/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://blog.xiongtianci.com/tags/虚拟机/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.xiongtianci.com/tags/多线程/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.xiongtianci.com/tags/SQL/"},{"name":"事务","slug":"事务","permalink":"https://blog.xiongtianci.com/tags/事务/"},{"name":"快捷键","slug":"快捷键","permalink":"https://blog.xiongtianci.com/tags/快捷键/"},{"name":"JDBC","slug":"JDBC","permalink":"https://blog.xiongtianci.com/tags/JDBC/"},{"name":"工具类","slug":"工具类","permalink":"https://blog.xiongtianci.com/tags/工具类/"},{"name":"CollectionUtils","slug":"CollectionUtils","permalink":"https://blog.xiongtianci.com/tags/CollectionUtils/"},{"name":"Mapper","slug":"Mapper","permalink":"https://blog.xiongtianci.com/tags/Mapper/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.xiongtianci.com/tags/Nginx/"},{"name":"反向代理","slug":"反向代理","permalink":"https://blog.xiongtianci.com/tags/反向代理/"},{"name":"ES6","slug":"ES6","permalink":"https://blog.xiongtianci.com/tags/ES6/"},{"name":"百度网盘","slug":"百度网盘","permalink":"https://blog.xiongtianci.com/tags/百度网盘/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.xiongtianci.com/tags/微信小程序/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://blog.xiongtianci.com/tags/SpringCloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.xiongtianci.com/tags/Hystrix/"},{"name":"HashSet","slug":"HashSet","permalink":"https://blog.xiongtianci.com/tags/HashSet/"},{"name":"Java线程","slug":"Java线程","permalink":"https://blog.xiongtianci.com/tags/Java线程/"},{"name":"Flex","slug":"Flex","permalink":"https://blog.xiongtianci.com/tags/Flex/"},{"name":"公众号文章","slug":"公众号文章","permalink":"https://blog.xiongtianci.com/tags/公众号文章/"},{"name":"Top电影","slug":"Top电影","permalink":"https://blog.xiongtianci.com/tags/Top电影/"},{"name":"电仪","slug":"电仪","permalink":"https://blog.xiongtianci.com/tags/电仪/"},{"name":"Notepad","slug":"Notepad","permalink":"https://blog.xiongtianci.com/tags/Notepad/"},{"name":"Word2016","slug":"Word2016","permalink":"https://blog.xiongtianci.com/tags/Word2016/"},{"name":"JS","slug":"JS","permalink":"https://blog.xiongtianci.com/tags/JS/"},{"name":"线程","slug":"线程","permalink":"https://blog.xiongtianci.com/tags/线程/"},{"name":"转义字符","slug":"转义字符","permalink":"https://blog.xiongtianci.com/tags/转义字符/"},{"name":"JSP","slug":"JSP","permalink":"https://blog.xiongtianci.com/tags/JSP/"},{"name":"面试题、","slug":"面试题、","permalink":"https://blog.xiongtianci.com/tags/面试题、/"},{"name":"同源策略","slug":"同源策略","permalink":"https://blog.xiongtianci.com/tags/同源策略/"},{"name":"JS跨域","slug":"JS跨域","permalink":"https://blog.xiongtianci.com/tags/JS跨域/"},{"name":"Servlet","slug":"Servlet","permalink":"https://blog.xiongtianci.com/tags/Servlet/"},{"name":"maven","slug":"maven","permalink":"https://blog.xiongtianci.com/tags/maven/"},{"name":"数组","slug":"数组","permalink":"https://blog.xiongtianci.com/tags/数组/"},{"name":"排序","slug":"排序","permalink":"https://blog.xiongtianci.com/tags/排序/"},{"name":"扩展程序","slug":"扩展程序","permalink":"https://blog.xiongtianci.com/tags/扩展程序/"}]}