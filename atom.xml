<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天赐</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-06-10T05:02:58.749Z</updated>
  <id>/</id>
  
  <author>
    <name>天赐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>致迷茫中的自己</title>
    <link href="/2019/06/10/%E8%87%B4%E8%BF%B7%E8%8C%AB%E4%B8%AD%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
    <id>/2019/06/10/致迷茫中的自己/</id>
    <published>2019-06-10T04:40:33.000Z</published>
    <updated>2019-06-10T05:02:58.749Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果感到迷茫，而且选择比较多的时候，就先都试着做做呗，大不了就累一点不睡觉嘛。</p></blockquote><p>上面这句话来自我超喜欢的一个<code>B站</code>up主–<a href="https://space.bilibili.com/60614881/" target="_blank" rel="noopener">无聊的Do君</a>5月1号的<a href="https://www.bilibili.com/video/av51058296" target="_blank" rel="noopener">视频</a></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190610-%E8%87%B4%E8%BF%B7%E8%8C%AB%E4%B8%AD%E7%9A%84%E8%87%AA%E5%B7%B1/20190610125121.jpg" alt="20190610125121"></p>]]></content>
    
    <summary type="html">
    
      如果感到迷茫，而且选择比较多的时候，就先都试着做做呗，大不了就累一点不睡觉嘛。
    
    </summary>
    
      <category term="随想" scheme="/categories/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="生活" scheme="/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>一千行MySQL学习笔记</title>
    <link href="/2019/06/05/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/06/05/一千行MySQL学习笔记/</id>
    <published>2019-06-05T09:41:17.000Z</published>
    <updated>2019-06-10T01:33:52.449Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jioby</p><p>链接： <a href="https://shockerli.net/post/1000-line-mysql-note/" target="_blank" rel="noopener">https://shockerli.net/post/1000-line-mysql-note/</a></p></blockquote><h1 id="Windows服务"><a href="#Windows服务" class="headerlink" title="Windows服务"></a>Windows服务</h1><pre><code class="sql">-- 启动mysqlnet start mysql-- 创建windows服务(注意：等号与值之间有空格)sc create mysql binpath= mysqld_bin_path</code></pre><h1 id="连接与断开服务器"><a href="#连接与断开服务器" class="headerlink" title="连接与断开服务器"></a>连接与断开服务器</h1><pre><code class="sql">-- 连接（地址、端口可不填，默认为localhost:3306）mysql -h 地址 -p 端口 -u 用户名 -p 密码-- 显示哪些线程正在运行show processlist-- 显示系统变量信息show variables</code></pre><h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><pre><code class="sql">-- 查看当前数据库select database();-- 显示当前时间、用户名、数据库版本select now(), user(), version();-- 创建库create database[ if not exists] 数据库名 数据库选项    -- 数据库选项：    character set charset_name    collate collation_name-- 查看已有库show databases[ like &#39;pattern&#39;]-- 查看当前库信息show create database 数据库名-- 修改库的选项信息alter database 库名 选项信息-- 删除库drop database[ if exists] 数据库名    -- 同时删除该数据库相关的目录及其目录内容</code></pre><h1 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h1><pre><code class="sql">-- 创建表create [temporary] table [if not exists] [库名.]表名 (表的结构定义) [表选项]    每个字段必须有数据类型    最后一个字段后不能有逗号    temporary 临时表，会话结束时表自动消失    对于字段的定义：        字段名 数据类型 [not null | null] [default default_value] [auto_increment] [unique [key] | [primary] key] [comment &#39;string&#39;]    -- 表选项        -- 字符集            charset = charset_name            如果表没有设定，则使用数据库字符集        -- 存储引擎            engine = engine_name            表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同            常见的引擎：innodb myisam memory/heap bdb merge example csv maxdb archive            不同的引擎在保存表的结构和数据时采用不同的方式            myisam表文件含义：.frm表定义，.myd表数据，.myi表索引            innodb表文件含义：.frm表定义，表空间数据和日志文件            show engines -- 显示存储引擎的状态信息            show engine 引擎名 {logs|status} -- 显示存储引擎的日志或状态信息        -- 自增起始数            auto_increment = 行数        -- 数据文件目录            data directory = &#39;目录&#39;        -- 索引文件目录            index directory = &#39;目录&#39;        -- 表注释            comment = &#39;string&#39;        -- 分区选项            partition by ... (详细见手册)-- 查看所有表show tables[ like &#39;pattern&#39;]show tables from 表名-- 查看表机构show create table 表名 （信息更详细）desc 表名 / describe 表名 / explain 表名 / show columns from 表名 [like &#39;pattern&#39;]show table status [from db_name] [like &#39;pattern&#39;]-- 修改表    -- 修改表本身的选项        alter table 表名 表的选项        eg: alter table 表名 engine=myisam;    -- 对表进行重命名        rename table 原表名 to 新表名        rename table 原表名 to 库名.表名 （可将表移动到另一个数据库）        -- rename可以交换两个表名    -- 修改表的字段机构（13.1.2. alter table语法）        alter table 表名 操作名        -- 操作名            add[ column] 字段定义       -- 增加字段                after 字段名          -- 表示增加在该字段名后面                first               -- 表示增加在第一个            add primary key(字段名)   -- 创建主键            add unique [索引名] (字段名)-- 创建唯一索引            add index [索引名] (字段名) -- 创建普通索引            drop[ column] 字段名      -- 删除字段            modify[ column] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)            change[ column] 原字段名 新字段名 字段属性      -- 支持对字段名修改            drop primary key    -- 删除主键(删除主键前需删除其auto_increment属性)            drop index 索引名 -- 删除索引            drop foreign key 外键    -- 删除外键-- 删除表drop table[ if exists] 表名 ...-- 清空表数据truncate [table] 表名-- 复制表结构create table 表名 like 要复制的表名-- 复制表结构和数据create table 表名 [as] select * from 要复制的表名-- 检查表是否有错误check table tbl_name [, tbl_name] ... [option] ...-- 优化表optimize [local | no_write_to_binlog] table tbl_name [, tbl_name] ...-- 修复表repair [local | no_write_to_binlog] table tbl_name [, tbl_name] ... [quick] [extended] [use_frm]-- 分析表analyze [local | no_write_to_binlog] table tbl_name [, tbl_name] ...</code></pre><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><pre><code class="sql">-- 增insert [into] 表名 [(字段列表)] values (值列表)[, (值列表), ...]    -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。    -- 可同时插入多条数据记录！    replace 与 insert 完全一样，可互换。insert [into] 表名 set 字段名=值[, 字段名=值, ...]-- 查select 字段列表 from 表名[ 其他子句]    -- 可来自多个表的多个字段    -- 其他子句可以不使用    -- 字段列表可以用*代替，表示所有字段-- 删delete from 表名[ 删除条件子句]    没有条件子句，则会删除全部-- 改update 表名 set 字段名=新值[, 字段名=新值] [更新条件]</code></pre><h1 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h1><pre><code class="sql">-- mysql、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致show variables like &#39;character_set_%&#39;   -- 查看所有字符集编码项    character_set_client        客户端向服务器发送数据时使用的编码    character_set_results       服务器端将结果返回给客户端所使用的编码    character_set_connection    连接层编码set 变量名 = 变量值    set character_set_client = gbk;    set character_set_results = gbk;    set character_set_connection = gbk;set names gbk;  -- 相当于完成以上三个设置-- 校对集    校对集用以排序    show character set [like &#39;pattern&#39;]/show charset [like &#39;pattern&#39;]   查看所有字符集    show collation [like &#39;pattern&#39;]     查看所有校对集    charset 字符集编码     设置字符集编码    collate 校对集编码     设置校对集编码</code></pre><h1 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h1><pre><code class="sql">1. 数值类型-- a. 整型 ----------    类型         字节     范围（有符号位）    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255    smallint    2字节    -32768 ~ 32767    mediumint   3字节    -8388608 ~ 8388607    int         4字节    bigint      8字节    int(m)  m表示总位数    - 默认存在符号位，unsigned 属性修改    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;    - 在满足要求的情况下，越小越好。    - 1表示bool值真，0表示bool值假。mysql没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。-- b. 浮点型 ----------    类型             字节     范围    float(单精度)     4字节    double(双精度)    8字节    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。        不同于整型，前后均会补填0.    定义浮点型时，需指定总位数和小数位数。        float(m, d)     double(m, d)        m表示总位数，d表示小数位数。        m和d的大小会决定浮点数的范围。不同于整型的固定范围。        m既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。        支持科学计数法表示。        浮点数表示近似值。-- c. 定点数 ----------    decimal -- 可变长度    decimal(m, d)   m也表示总位数，d表示小数位数。    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。    将浮点数转换为字符串来保存，每9位数字保存为4个字节。2. 字符串类型-- a. char, varchar ----------    char    定长字符串，速度快，但浪费空间    varchar 变长字符串，速度慢，但节省空间    m表示能存储的最大长度，此长度是字符数，非字节数。    不同的编码，所占用的空间不同。    char,最多255个字符，与编码无关。    varchar,最多65535字符，与编码有关。    一条有效记录最大不能超过65535个字节。        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。    varchar 的最大有效长度由最大行大小和使用的字符集确定。    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。    例：若一个表定义为 create table tb(c1 int, c2 char(30), c3 varchar(n)) charset=utf8; 问n的最大值是多少？ 答：(65535-1-2-4-30*3)/3-- b. blob, text ----------    blob 二进制字符串（字节字符串）        tinyblob, blob, mediumblob, longblob    text 非二进制字符串（字符字符串）        tinytext, text, mediumtext, longtext    text 在定义时，不需要定义长度，也不会计算总长度。    text 类型在定义时，不可给default值-- c. binary, varbinary ----------    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。    char, varchar, text 对应 binary, varbinary, blob.3. 日期时间类型    一般用整型保存时间戳，因为php可以很方便的将时间戳进行格式化。    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59    date        3字节    日期         1000-01-01 到 9999-12-31    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07    time        3字节    时间         -838:59:59 到 838:59:59    year        1字节    年份         1901 - 2155datetime    yyyy-mm-dd hh:mm:sstimestamp   yy-mm-dd hh:mm:ss            yyyymmddhhmmss            yymmddhhmmss            yyyymmddhhmmss            yymmddhhmmssdate        yyyy-mm-dd            yy-mm-dd            yyyymmdd            yymmdd            yyyymmdd            yymmddtime        hh:mm:ss            hhmmss            hhmmssyear        yyyy            yy            yyyy            yy4. 枚举和集合-- 枚举(enum) ----------enum(val1, val2, val3...)    在已知的值中进行单选。最大数量为65535.    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。    表现为字符串类型，存储却是整型。    null值的索引是null。    空字符串错误值的索引值是0。-- 集合（set） ----------set(val1, val2, val3...)    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );    insert into tab values (&#39;男, 女&#39;);    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。    当创建表时，set成员值的尾部空格将自动被删除。</code></pre><h1 id="选择类型"><a href="#选择类型" class="headerlink" title="选择类型"></a>选择类型</h1><pre><code class="sql">-- php角度1. 功能满足2. 存储空间尽量小，处理效率更高3. 考虑兼容问题-- ip存储 ----------1. 只需存储，可用字符串2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned    1) php函数转换        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。        利用sprintf函数格式化字符串        sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;));        然后用long2ip将整型转回ip字符串    2) mysql函数转换(无符号整型，unsigned)        inet_aton(&#39;127.0.0.1&#39;) 将ip转为整型        inet_ntoa(2130706433) 将整型转为ip</code></pre><h1 id="列属性（列约束）"><a href="#列属性（列约束）" class="headerlink" title="列属性（列约束）"></a>列属性（列约束）</h1><pre><code class="sql">1. primary 主键    - 能唯一标识记录的字段，可以作为主键。    - 一个表只能有一个主键。    - 主键具有唯一性。    - 声明字段时，用 primary key 标识。        也可以在字段列表之后声明            例：create table tab ( id int, stu varchar(10), primary key (id));    - 主键字段的值不能为null。    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. unique 唯一索引（唯一约束）    使得某字段的值也不能重复。3. null 约束    null不是数据类型，是列的一个属性。    表示当前列是否可以为null，表示什么都没有。    null, 允许为空。默认。    not null, 不允许为空。    insert into tab values (null, &#39;val&#39;);        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. default 默认值属性    当前字段的默认值。    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。    create table tab ( add_time timestamp default current_timestamp );        -- 表示将当前时间的时间戳设为默认值。        current_date, current_time5. auto_increment 自动增长约束    自动增长必须为索引（主键或unique）    只能存在一个字段为自动增长。    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. comment 注释    例：create table tab ( id int ) comment &#39;注释内容&#39;;7. foreign key 外键约束    用于限制主表与从表数据完整性。    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);        -- 将表t1的t1_id外键关联到表t2的id字段。        -- 每个外键都有一个名字，可以通过 constraint 指定    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。    mysql中，可以对innodb引擎使用外键约束：    语法：    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。    3. restrict，拒绝父表删除和更新。    注意，外键只被innodb存储引擎所支持。其他引擎是不支持的。</code></pre><h1 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h1><pre><code class="sql">-- normal format, nf    - 每个表保存一个实体信息    - 每个具有一个id字段作为主键    - id主键 + 原子表-- 1nf, 第一范式    字段不能再分，就满足第一范式。-- 2nf, 第二范式    满足第一范式的前提下，不能出现部分依赖。    消除符合主键就可以避免部分依赖。增加单列关键字。-- 3nf, 第三范式    满足第二范式的前提下，不能出现传递依赖。    某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。    将一个实体信息的数据放在一个表内实现。</code></pre><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><pre><code class="sql">select [all|distinct] select_expr from -&gt; where -&gt; group by [合计函数] -&gt; having -&gt; order by -&gt; limita. select_expr    -- 可以用 * 表示所有字段。        select * from tb;    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）        select stu, 29+25, now() from tb;    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。        - 使用 as 关键字，也可省略 as.        select stu+10 as add10 from tb;b. from 子句    用于标识查询来源。    -- 可以为表起别名。使用as关键字。        select * from tb1 as tt, tb2 as bb;    -- from子句后，可以同时出现多个表。        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。        select * from tb1, tb2;    -- 向优化符提示如何选择索引        use index、ignore index、force index        select * from table1 use index (key1,key2) where key1=1 and key2=2 and key3=3;        select * from table1 ignore index (key3) where key1=1 and key2=2 and key3=3;c. where 子句    -- 从from获得的数据源中进行筛选。    -- 整型1表示真，0表示假。    -- 表达式由运算符和运算数组成。        -- 运算数：变量（字段）、值、函数返回值        -- 运算符：            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor            is/is not 加上ture/false/unknown，检验某个值的真假            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. group by 子句, 分组子句    group by 字段/别名 [排序方式]    分组后会进行排序。升序：asc，降序：desc    以下[合计函数]需配合 group by 使用：    count 返回不同的非null值数目  count(*)、count(字段)    sum 求和    max 求最大值    min 求最小值    avg 求平均值    group_concat 返回带有来自一个组的连接的非null值的字符串结果。组内字符串连接。e. having 子句，条件子句    与 where 功能、用法相同，执行时机不同。    where 在开始时执行检测数据，对原数据进行过滤。    having 对筛选出的结果再次进行过滤。    having 字段必须是查询出来的，where 字段必须是数据表存在的。    where 不可以使用字段的别名，having 可以。因为执行where代码时，可能尚未确定列值。    where 不可以使用合计函数。一般需用合计函数才会用 having    sql标准要求having必须引用group by子句中的列或用于合计函数中的列。f. order by 子句，排序子句    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...    升序：asc，降序：desc    支持多个字段的排序。g. limit 子句，限制结果数量子句    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。    limit 起始位置, 获取条数    省略第一个参数，表示从索引0开始。limit 获取条数h. distinct, all 选项    distinct 去除重复记录    默认为 all, 全部记录</code></pre><h1 id="union"><a href="#union" class="headerlink" title="union"></a>union</h1><pre><code class="sql">将多个select查询的结果组合成一个结果集合。select ... union [all|distinct] select ...默认 distinct 方式，即所有返回的行都是唯一的建议，对每个select查询加上小括号包裹。order by 排序时，需加上 limit 进行结合。需要各select查询的字段数量一样。每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</code></pre><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><pre><code>    - 子查询需用括号包裹。-- from型    from后要求是一个表，必须给子查询结果取个别名。    - 简化每个查询内的条件。    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。    - 子查询返回一个表，表型子查询。    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;-- where型    - 子查询返回一个值，标量子查询。    - 不需要给子查询取别名。    - where子查询内的表，不能直接用以更新。    select * from tb where money = (select max(money) from tb);    -- 列子查询        如果子查询结果返回的是一列。        使用 in 或 not in 完成查询        exists 和 not exists 条件            如果子查询返回数据，则返回1或0。常用于判断条件。            select column1 from t1 where exists (select * from t2);    -- 行子查询        查询条件是一个行。        select * from t1 where (id, gender) in (select id, gender from t2);        行构造符：(col1, col2, ...) 或 row(col1, col2, ...)        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。    -- 特殊运算符    != all()    相当于 not in    = some()    相当于 in。any 是 some 的别名    != some()   不等同于 not in，不等于其中某一个。    all, some 可以配合其他运算符一起使用。</code></pre><h1 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h1><pre><code class="sql">    将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join)    - 默认就是内连接，可省略inner。    - 只有数据存在时才能发送连接。即连接结果不能出现空行。    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）    也可用where表示连接条件。    还有 using, 但需字段名相同。 using(字段名)    -- 交叉连接 cross join        即，没有条件的内连接。        select * from tb1 cross join tb2;-- 外连接(outer join)    - 如果数据不存在，也会出现在连接结果中。    -- 左外连接 left join        如果数据不存在，左表记录会出现，而右表为null填充    -- 右外连接 right join        如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join)    自动判断连接条件完成连接。    相当于省略了using，会自动查找相同字段名。    natural join    natural left join    natural right joinselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;/* 导入导出 */ ------------------select * into outfile 文件地址 [控制格式] from 表名;   -- 导出表数据load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据    生成的数据默认的分隔符是制表符    local未指定，则数据文件必须在服务器上    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理-- 控制格式fields  控制字段格式默认：fields terminated by &#39;\t&#39; enclosed by &#39;&#39; escaped by &#39;\\&#39;    terminated by &#39;string&#39;  -- 终止    enclosed by &#39;char&#39;      -- 包裹    escaped by &#39;char&#39;       -- 转义    -- 示例：        select a,b,a+b into outfile &#39;/tmp/result.text&#39;        fields terminated by &#39;,&#39; optionally enclosed by &#39;&quot;&#39;        lines terminated by &#39;\n&#39;        from test_table;lines   控制行格式默认：lines terminated by &#39;\n&#39;    terminated by &#39;string&#39;  -- 终止</code></pre><h1 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h1><pre><code class="sql">select语句获得的数据可以用insert插入。可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。    或者使用set语法。    insert into tbl_name set field=value,...；可以一次性使用多个值，采用(), (), ();的形式。    insert into tbl_name values (), (), ();可以在列值指定时，使用表达式。    insert into tbl_name values (field_value, 10+10, now());可以使用一个特殊值 default，表示该列使用默认值。    insert into tbl_name values (field_value, default);可以通过一个查询的结果，作为需要插入的值。    insert into tbl_name select ...;可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。    insert into tbl_name values/set/select on duplicate key update 字段=值, …;</code></pre><h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><pre><code class="sql">delete from tbl_name [where where_definition] [order by ...] [limit row_count]按照条件删除。where指定删除的最多记录数。limit可以通过排序条件删除。order by + limit支持多表删除，使用类似连接语法。delete from 需要删除数据多表1，表2 using 表连接操作 条件。/* truncate */ ------------------truncate [table] tbl_name清空数据删除重建表区别：1，truncate 是删除表再创建，delete 是逐条删除2，truncate 重置auto_increment的值。而delete不会3，truncate 不知道删除了几条，而delete知道。4，当被用于带分区的表时，truncate 会保留分区</code></pre><h1 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h1><pre><code class="sql">备份，将数据的结构与表内数据保存起来。利用 mysqldump 指令完成。-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database db1 [db2 db3...]mysqldump [options] --all--database1. 导出一张表　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(d:/a.sql)2. 导出多张表　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(d:/a.sql)3. 导出所有表　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(d:/a.sql)4. 导出一个库　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(d:/a.sql)可以-w携带where条件-- 导入1. 在登录mysql的情况下：　　source  备份文件2. 在不登录的情况下　　mysql -u用户名 -p密码 库名 &lt; 备份文件</code></pre><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><pre><code class="sql">什么是视图：    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。    视图具有表结构文件，但不存在数据文件。    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。-- 创建视图create [or replace] [algorithm = {undefined | merge | temptable}] view view_name [(column_list)] as select_statement    - 视图名必须唯一，同时不能与表重名。    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。    - 可以指定视图执行的算法，通过algorithm指定。    - column_list如果存在，则数目必须等于select语句检索的列数-- 查看结构    show create view view_name-- 删除视图    - 删除视图后，数据依然存在。    - 可同时删除多个视图。    drop view [if exists] view_name ...-- 修改视图结构    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。    alter view view_name [(column_list)] as select_statement-- 视图作用    1. 简化业务逻辑    2. 对客户端隐藏真实的表结构-- 视图算法(algorithm)    merge       合并        将视图的查询语句，与外部查询需要先合并再执行！    temptable   临时表        将视图执行完毕后，形成临时表，再做外层查询！    undefined   未定义(默认)，指的是mysql自主去选择相应的算法。</code></pre><h1 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h1><pre><code class="sql">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。    - 支持连续sql的集体成功或集体撤销。    - 事务是数据库在数据晚自习方面的一个功能。    - 需要利用 innodb 或 bdb 存储引擎，对自动提交的特性支持完成。    - innodb被称为事务安全型引擎。-- 事务开启    start transaction; 或者 begin;    开启事务后，所有被执行的sql语句均被认作当前事务内的sql语句。-- 事务提交    commit;-- 事务回滚    rollback;    如果部分操作发生问题，映射到事务开启前。-- 事务的特性    1. 原子性（atomicity）        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。    2. 一致性（consistency）        事务前后数据的完整性必须保持一致。        - 事务开始和结束时，外部数据一致        - 在整个事务过程中，操作是连续的    3. 隔离性（isolation）        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。    4. 持久性（durability）        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现    1. 要求是事务支持的表类型    2. 执行一组相关的操作前开启事务    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理    利用innodb的自动提交(autocommit)特性完成。    普通的mysql执行语句后，当前的数据提交操作均可被其他客户端可见。    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意    1. 数据定义语言（ddl）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。    2. 事务不能被嵌套-- 保存点    savepoint 保存点名称 -- 设置一个事务保存点    rollback to savepoint 保存点名称 -- 回滚到保存点    release savepoint 保存点名称 -- 删除保存点-- innodb自动提交特性设置    set autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。    - 也可以关闭自动提交来开启事务。但与start transaction不同的是，        set autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)        而start transaction记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</code></pre><h1 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h1><pre><code class="sql">表锁定只用于防止其它客户端进行不正当地读取和写入myisam 支持表锁，innodb 支持行锁-- 锁定    lock tables tbl_name [as alias]-- 解锁    unlock tables</code></pre><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><pre><code class="sql">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象    监听：记录的增加、修改、删除。-- 创建触发器create trigger trigger_name trigger_time trigger_event on tbl_name for each row trigger_stmt    参数：    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。    trigger_event指明了激活触发程序的语句的类型        insert：将新行插入表时激活触发程序        update：更改某一行时激活触发程序        delete：从表中删除某一行时激活触发程序    tbl_name：监听的表，必须是永久性的表，不能将触发程序与temporary表或视图关联起来。    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用begin...end复合语句结构-- 删除drop trigger [schema_name.]trigger_name可以使用old和new代替旧的和新的数据    更新操作，更新前是old，更新后是new.    删除操作，只有old.    增加操作，只有new.-- 注意    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。-- 字符连接函数concat(str1,str2,...])concat_ws(separator,str1,str2,...)-- 分支语句if 条件 then    执行语句elseif 条件 then    执行语句else    执行语句end if;-- 修改最外层语句结束符delimiter 自定义结束符号    sql语句自定义结束符号delimiter ;     -- 修改回原来的分号-- 语句块包裹begin    语句块end-- 特殊的执行1. 只要添加记录，就会触发程序。2. insert into on duplicate key update 语法会触发：    如果没有重复记录，会触发 before insert, after insert;    如果有重复记录并更新，会触发 before insert, before update, after update;    如果有重复记录但是没有发生更新，则触发 before insert, before update3. replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</code></pre><h1 id="SQL编程"><a href="#SQL编程" class="headerlink" title="SQL编程"></a>SQL编程</h1><pre><code class="sql">--// 局部变量 ------------ 变量声明    declare var_name[,...] type [default value]    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值    使用 set 和 select into 语句为变量赋值。    - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。    -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10;    - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then    statement_list   [elseif search_condition then    statement_list]...[else    statement_list]end if;-- case语句case value when [compare-value] then result[when [compare-value] then result ...][else result]end-- while循环[begin_label:] while search_condition do    statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。    -- 退出循环        退出整个循环 leave        退出当前循环 iterate        通过退出的标签决定退出哪个循环--// 内置函数 ------------ 数值函数abs(x)          -- 绝对值 abs(-10.9) = 10format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x)         -- 向上取整 ceil(10.1) = 11floor(x)        -- 向下取整 floor (10.1) = 10round(x)        -- 四舍五入去整mod(m, n)       -- m%n m mod n 求余 10%3=1pi()            -- 获得圆周率pow(m, n)       -- m^nsqrt(x)         -- 算术平方根rand()          -- 随机数truncate(x, d)  -- 截取d位小数-- 时间日期函数now(), current_timestamp();     -- 当前日期时间current_date();                 -- 当前日期current_time();                 -- 当前时间date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间unix_timestamp();               -- 获得unix时间戳from_unixtime();                -- 从时间戳获得时间-- 字符串函数length(string)          -- string长度，字节char_length(string)     -- string的字符个数substring(str, position [,length])      -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_strinstr(string ,substring)    -- 返回substring首次在string中出现的位置concat(string [,...])   -- 连接字串charset(str)            -- 返回字串字符集lcase(string)           -- 转换成小写left(string, length)    -- 从string2中的左边起取length个字符load_file(file_name)    -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为lengthltrim(string)           -- 去除前端空格repeat(string, count)   -- 重复count次rpad(string, length, pad)   --在str后用pad补充,直到长度为lengthrtrim(string)           -- 去除后端空格strcmp(string1 ,string2)    -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end   多分支if(expr1,expr2,expr3)  双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();--// 存储函数，自定义函数 ------------ 新建    create function function_name (参数列表) returns 返回值类型        函数体    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。    - 多条语句应该使用 begin...end 语句块包含。    - 一定要有 return 返回值语句。-- 删除    drop function [if exists] function_name;-- 查看    show function status like &#39;partten&#39;    show create function function_name;-- 修改    alter function function_name 函数选项--// 存储过程，自定义功能 ------------ 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建create procedure sp_name (参数列表)    过程体参数列表：不同于函数的参数列表，需要指明参数类型in，表示输入型out，表示输出型inout，表示混合型注意，没有返回值。</code></pre><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><pre><code class="sql">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：call 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数in|out|inout 参数名 数据类型in      输入：在调用过程中，将数据输入到过程体内部的参数out     输出：在调用过程中，将过程体处理完的结果返回到客户端inout   输入输出：既可输入，也可输出-- 语法create procedure 过程名 (参数列表)begin    过程体end</code></pre><h1 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h1><pre><code class="sql">-- root密码重置1. 停止mysql服务2.  [linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;    [windows] mysqld --skip-grant-tables3. use mysql;4. update `user` set password=password(&quot;密码&quot;) where `user` = &quot;root&quot;;5. flush privileges;用户信息表：mysql.user-- 刷新权限flush privileges;-- 增加用户create user 用户名 identified by [password] 密码(字符串)    - 必须拥有mysql数据库的全局create user权限，或拥有insert权限。    - 只能创建用户，不能赋予权限。    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;    - 密码也需引号，纯数字密码也要加引号    - 要在纯文本中指定密码，需忽略password关键词。要把密码指定为由password()函数返回的混编值，需包含关键字password-- 重命名用户rename user old_user to new_user-- 设置密码set password = password(&#39;密码&#39;)  -- 为当前用户设置密码set password for 用户名 = password(&#39;密码&#39;) -- 为指定用户设置密码-- 删除用户drop user 用户名-- 分配权限/添加用户grant 权限列表 on 表名 to 用户名 [identified by [password] &#39;password&#39;]    - all privileges 表示所有权限    - *.* 表示所有库的所有表    - 库名.表名 表示某库下面的某表    grant all privileges on `pms`.* to &#39;pms&#39;@&#39;%&#39; identified by &#39;pms0817&#39;;-- 查看权限show grants for 用户名    -- 查看当前用户权限    show grants; 或 show grants for current_user; 或 show grants for current_user();-- 撤消权限revoke 权限列表 on 表名 from 用户名revoke all privileges, grant option from 用户名   -- 撤销所有权限-- 权限层级-- 要使用grant或revoke，您必须拥有grant option权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user    grant all on *.*和 revoke all on *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host    grant all on db_name.*和revoke all on db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv    grant all on db_name.tbl_name和revoke all on db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv    当使用revoke时，您必须指定与被授权列相同的列。-- 权限列表all [privileges]    -- 设置除grant option之外的所有简单权限alter   -- 允许使用alter tablealter routine   -- 更改或取消已存储的子程序create  -- 允许使用create tablecreate routine  -- 创建已存储的子程序create temporary tables     -- 允许使用create temporary tablecreate user     -- 允许使用create user, drop user, rename user和revoke all privileges。create view     -- 允许使用create viewdelete  -- 允许使用deletedrop    -- 允许使用drop tableexecute     -- 允许用户运行已存储的子程序file    -- 允许使用select...into outfile和load data infileindex   -- 允许使用create index和drop indexinsert  -- 允许使用insertlock tables     -- 允许对您拥有select权限的表使用lock tablesprocess     -- 允许使用show full processlistreferences  -- 未被实施reload  -- 允许使用flushreplication client  -- 允许用户询问从属服务器或主服务器的地址replication slave   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）select  -- 允许使用selectshow databases  -- 显示所有数据库show view   -- 允许使用show create viewshutdown    -- 允许使用mysqladmin shutdownsuper   -- 允许使用change master, kill, purge master logs和set global语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。update  -- 允许使用updateusage   -- “无权限”的同义词grant option    -- 允许授予权限</code></pre><h1 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h1><pre><code class="sql">-- 分析和存储表的关键字分布analyze [local | no_write_to_binlog] table 表名 ...-- 检查一个或多个表是否有错误check table tbl_name [, tbl_name] ... [option] ...option = {quick | fast | medium | extended | changed}-- 整理数据文件的碎片optimize [local | no_write_to_binlog] table tbl_name [, tbl_name] ...</code></pre><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><pre><code class="sql">1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！2. 每个库目录存在一个保存当前数据库的选项文件db.opt。3. 注释：    单行注释 # 注释内容    多行注释 /* 注释内容 */    单行注释 -- 注释内容     (标准sql注释风格，要求双破折号后加一空格符（空格、tab、换行等）)4. 模式通配符：    _   任意单个字符    %   任意多个字符，甚至包括零字符    单引号需要进行转义 \&#39;5. cmd命令行内的语句结束符可以为 &quot;;&quot;, &quot;\g&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。6. sql对大小写不敏感7. 清除已有语句：\c</code></pre>]]></content>
    
    <summary type="html">
    
      SQL笔记
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="转载" scheme="/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="MySQL" scheme="/tags/MySQL/"/>
    
      <category term="笔记" scheme="/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>重新搭建博客</title>
    <link href="/2019/05/20/%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>/2019/05/20/重新搭建博客/</id>
    <published>2019-05-20T12:49:00.000Z</published>
    <updated>2019-06-10T01:33:10.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>3月份初，许久没写博客（主要就是懒）的博主在莫一天心血来潮写好一篇文章后，使用<code>hexo d</code>部署博客文章时，发现<code>hexo</code>抛出各种错误。但由于当时准备面试的面试题（主要就是懒），然后就放着没管它。紧接着面试实习岗位，工作后也一直没有闲下来。<br>最近终于抽出时间来重构博客，写下这篇文章，记录一下重构博客的过程~</p><h2 id="博客目录介绍"><a href="#博客目录介绍" class="headerlink" title="博客目录介绍"></a>博客目录介绍</h2><pre><code>.├── .deploy├── public├── scaffolds├── scripts├── source|   ├── _drafts|   └── _posts├── themes├── _config.yml└── package.json</code></pre><ul><li>.deploy：执行hexo deploy命令部署到GitHub上的内容目录</li><li>public：执行hexo generate命令，输出的静态网页内容目录</li><li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li><li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li><li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</li><li>_drafts：草稿文章</li><li>_posts：发布文章</li><li>themes：主题文件目录</li><li>_config.yml：全局配置文件，大多数的设置都在这里</li><li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的 关于 按钮</li></ul><p>接下来是重头戏 _config.yml ，做个简单说明：</p><pre><code class="yml"># Hexo Configuration## Docs: http://zespia.tw/hexo/docs/configure.html## Source: https://github.com/tommy351/hexo/# Site #整站的基本信息title: 不如 #网站标题subtitle: 码农，程序猿，未来的昏析师 #网站副标题description: bruce sha&#39;s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到author: bruce #网站作者，在下方显示email: bu.ru@qq.com #联系邮箱language: zh-CN #语言# URL #域名和文件结构## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://ibruce.info #你的域名root: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code# Writing #写文章选项new_post_name: :title.md # File name of new postsdefault_layout: post #默认layout方式auto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabmax_open_file: 100multi_thread: truefilename_case: 0render_drafts: falsehighlight: #代码高亮  enable: true #是否启用  line_number: false #是否显示行号  tab_replace:# Category &amp; Tag #分类与标签default_category: uncategorized # defaultcategory_map:tag_map:# Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server #本地服务参数## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: truelogger_format:# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination #分页设置## Set per_page to 0 to disable paginationper_page: 10 #每页10篇文章pagination_dir: page# Disqus #社会化评论disqus，我使用多说，在主题中配置disqus_shortname:# Extensions #插件，暂时未安装插件## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themes## 主题theme: modernist # raytaylorism # pacman # modernist # lightexclude_generator:# Deployment #部署## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy:  type: github  repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库</code></pre><h2 id="主题目录介绍"><a href="#主题目录介绍" class="headerlink" title="主题目录介绍"></a>主题目录介绍</h2><pre><code>.├── languages          #多语言|   ├── default.yml    #默认语言|   └── zh-CN.yml      #中文语言├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制|   ├── _partial       #局部的布局，此目录下的*.ejs是对头尾等局部的控制|   └── _widget        #小挂件的布局，页面下方小挂件的控制├── source             #源码|   ├── css            #css源码 |   |   ├── _base      #*.styl基础css|   |   ├── _partial   #*.styl局部css|   |   ├── fonts      #字体|   |   ├── images     #图片|   |   └── style.styl #*.styl引入需要的css源码|   ├── fancybox       #fancybox效果源码|   └── js             #javascript源代码├── _config.yml        #主题配置文件└── README.md          #用GitHub的都知道</code></pre><p>如果你需要修改头部，直接修改 <code>hexo\themes\modernist\layout\_partial\header.ejs</code> ，比如头上加个搜索框：</p><pre><code class="ejs">&lt;div&gt;&lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\/\//, &#39;&#39;) %&gt;&quot;&gt;&lt;/form&gt;&lt;/div&gt;</code></pre><p>将如上代码加入即可，您需要修改css以便这个搜索框比较美观。<br>再如，你要修改页脚版权信息，直接编辑 <code>hexo\themes\modernist\layout\_partial\footer.ejs</code>。同理，你需要修改css，直接去修改对应位置的styl文件。</p><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><blockquote><p><a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">https://www.haomwei.com/technology/maupassant-hexo.html</a></p></blockquote><pre><code class="shell">$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save</code></pre><blockquote><p><code>npm install hexo-renderer-pug --save</code>安装时可能会报错，以下是解决方案：<br>改用cnpm来安装软件</p><blockquote><p>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>目的是直接改npm为淘宝的npm，也为防止某些依赖直接用npm来安装，导致无法顺利安装完成<br>$ npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></blockquote></blockquote><p>编辑Hexo目录下的 <code>_config.yml</code>，将<code>theme</code>的值改为<code>maupassant</code></p><pre><code class="yml">theme: matery</code></pre><h1 id="功能配置"><a href="#功能配置" class="headerlink" title="功能配置"></a>功能配置</h1><pre><code class="yml"># 是否启用Fancybox图片灯箱效果# Disqus评论 shortnamdisqus: # 友言评论 iduyan: # 来必力评论 data-uidlivere: # 畅言评论 appidchangyan: changyan_conf: ## Your changyan conf, e.g. prod_d8a508c2825ab57eeb43e7c69bba0e8b# Gitment评论相关参数gitment:  enable: false  owner:   repo:   client_id:   client_secret: # Gitalk评论相关参数gitalk:  enable: false   owner:    repo:   client_id:    client_secret:    admin:  # Valine评论相关参数valine:   enable: false   appid:   appkey:   notify: false # 评论系统中的邮件提醒设置  verify: false ## Validation code.  placeholder: Just so so   avatar: &#39;mm&#39;   pageSize: 10  guest_info: nick,mail,link# 默认使用Google搜索引擎google_search: true# 若想使用百度搜索，将其设定为 truebaidu_search: false# Swiftype 站内搜索keyswiftype: # 微搜索 keytinysou: # 基于jQuery的本地搜索引擎，需要安装hexo-generator-search插件使用self_search: false# Google Analytics 跟踪IDgoogle_analytics: # 百度统计 跟踪IDbaidu_analytics: # fancybox: true ## If you want to use fancybox please set the value to true.# 是否显示侧边栏分类数目show_category_count: false# 是否显示文章中目录列表自动编号toc_number: true#  是否使用分享按鈕，需要安装hexo-helper-qrcode插件使用shareto: false#  是否使用不蒜子页面访问计数busuanzi: false# wordcount: false ## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed.# 是否在移动设备屏幕底部显示侧边栏widgets_on_small_screens: false ## Set to true to enable widgets on small screens.# 是否使用canvas动态背景canvas_nest:  enable: false  color: ## RGB value of the color, e.g. &quot;100,99,98&quot;  opacity: ## Transparency of lines, e.g. &quot;0.7&quot;  zIndex: ## The z-index property of the background, e.g. &quot;-1&quot;  count: ## Quantity of lines, e.g. &quot;150&quot;# 是否启用捐赠按钮donate:  enable: false  github: ## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page  alipay_qr: ## Path of Alipay QRcode image, e.g. /img/AliPayQR.png  wechat_qr: ## Path of Wechat QRcode image, e.g. /img/WeChatQR.png  btc_qr: ## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png  btc_key: ## Bitcoin key, e.g. 1KuK5eK2BLsqpsFVXXSBG5wbSAwZVadt6L  paypal_url: ## Paypal URL, e.g. https://www.paypal.me/tufu9441post_copyright:  enable: false ## If you want to display the copyright info after each post, please set the value to true and fill the following items on your need.  author: ## Your author name, e.g. tufu9441  copyright_text: ## Your copyright text, e.g. The author owns the copyright, please indicate the source reproduced.# 自定义页面及菜单，依照已有格式填写。# 填写后请在source目录下建立相应名称的文件夹，并包含index.md文件，以正确显示页面。# 导航菜单中集成了FontAwesome图标字体，可以在这里选择新的图标，并按照相关说明使用。menu:  - page: home    directory: .    icon: fa-home  - page: archive    directory: archives/    icon: fa-archive  - page: about    directory: about/    icon: fa-user  - page: rss    directory: atom.xml    icon: fa-rss# 选择和排列希望使用的侧边栏小工具widgets: ## Six widgets in sidebar provided: search, category, tag, recent_posts, rencent_comments and links.  - search  - category  - tag  - recent_posts  - recent_comments  - links# 友情链接，请依照格式填写links:  - title: site-name1    url: http://www.example1.com/  - title: site-name2    url: http://www.example2.com/  - title: site-name3    url: http://www.example3.com/# 网站历史时间线，在页面front-matter中设置layout: timeline可显示timeline:  - num: 1    word: 2014/06/12-Start  - num: 2    word: 2014/11/29-XXX  - num: 3    word: 2015/02/18-DDD  - num: 4    word: More# Static files# 静态文件存储路径，方便设置CDN缓存js: jscss: css# Theme version# 主题版本，便于静态文件更新后刷新CDN缓存version: 0.0.0</code></pre><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><h3 id="Disqus配置使用"><a href="#Disqus配置使用" class="headerlink" title="Disqus配置使用"></a>Disqus配置使用</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><blockquote><p><a href="https://link.jianshu.com/?t=https://disqus.com/" target="_blank" rel="noopener">https://disqus.com/</a></p></blockquote><h1 id="主题特性"><a href="#主题特性" class="headerlink" title="主题特性"></a>主题特性</h1><h2 id="主题目录结构"><a href="#主题目录结构" class="headerlink" title="主题目录结构"></a>主题目录结构</h2><pre><code>-maupassant|-languages</code></pre><h2 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h2><p>网站Favicon：<code>/blog/source/favicon.ico</code>，建议的大小：<code>32px*32px</code>。</p>]]></content>
    
    <summary type="html">
    
      记录一次重构个人博客
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="生活" scheme="/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Hexo" scheme="/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>MySQL面试题</title>
    <link href="/2019/01/02/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>/2019/01/02/MySQL面试题/</id>
    <published>2019-01-02T12:05:58.000Z</published>
    <updated>2019-06-10T01:34:09.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-主键-超键-候选键-外键"><a href="#1-主键-超键-候选键-外键" class="headerlink" title="1. 主键 超键 候选键 外键"></a>1. 主键 超键 候选键 外键</h1><p><strong>主 键：</strong></p><pre><code>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）</code></pre><p><strong>超 键：</strong></p><pre><code>在关系中能唯一标识元组的属性集称为关系模式的超键一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键超键包含候选键和主键。</code></pre><p><strong>候选键：</strong></p><pre><code>是最小超键，即没有冗余元素的超键。</code></pre><p><strong>外 键：</strong></p><pre><code>在一个表中存在的另一个表的主键称此表的外键</code></pre><h1 id="2-数据库事务的四个特性及含义"><a href="#2-数据库事务的四个特性及含义" class="headerlink" title="2.数据库事务的四个特性及含义"></a>2.数据库事务的四个特性及含义</h1><blockquote><p>数据库事务( transanction )正确执行的四个基本要素( ACID )：原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p></blockquote><p><strong>原子性</strong>：</p><pre><code>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</code></pre><p><strong>一致性</strong>：</p><pre><code>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</code></pre><p><strong>隔离性</strong>：</p><pre><code>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</code></pre><p><strong>持久性</strong>：</p><pre><code>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</code></pre><h1 id="3-drop-delete与truncate的区别"><a href="#3-drop-delete与truncate的区别" class="headerlink" title="3.drop,delete与truncate的区别"></a>3.drop,delete与truncate的区别</h1><blockquote><p>drop直接删掉表<br>delete删除表中数据，可以加where字句<br>truncate删除表中数据，再插入时自增长id又从1开始</p></blockquote><pre><code>1、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除的数据是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。2、表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。3、一般而言，drop &gt; truncate &gt; delete4、应用范围。truncate 只能对 table；delete 可以是table和view5、truncate 和 DELETE 只删除数据，而DROP则删除整个表（结构和数据）。6、truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。7、delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。8、truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚9、在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。10、Truncate table 表名 速度快,而且效率高,因为:truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。11、TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。12、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</code></pre><h1 id="4-索引的工作原理及其种类"><a href="#4-索引的工作原理及其种类" class="headerlink" title="4.索引的工作原理及其种类"></a>4.索引的工作原理及其种类</h1><blockquote><p><strong>数据库索引</strong>：是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。<strong>索引的实现通常使用B树及其变种B+树</strong>。<br>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是<strong>索引</strong>。</p></blockquote><p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><p><img src="img/1546432394934.png" alt="1546432394934"></p><p>图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O($log_2n$)的复杂度内获取到相应数据。</p><p>创建索引可以大大提高系统的性能。</p><p>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p><p>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。<strong>一般来说，应该在这些列上创建索引：</strong>在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p>同样，对于有些列不应该创建索引。<strong>一般来说，不应该创建索引的的这些列具有下列特点：</strong></p><p>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p><p>根据数据库的功能，可以在<a href="http://www.2cto.com/database/" target="_blank" rel="noopener">数据库设计</a>器中创建三种索引：<strong>唯一索引、主键索引和聚集索引</strong>。</p><p><strong>唯一索引</strong></p><p>唯一索引是不允许其中任何两行具有相同索引值的索引。</p><p>当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 <strong>主键索引</strong> 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 <strong>聚集索引</strong> 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。<strong>一个表只能包含一个聚集索引。</strong></p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。<strong>与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</strong></p>]]></content>
    
    <summary type="html">
    
      MySQL面试题
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法指南</title>
    <link href="/2018/12/18/ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    <id>/2018/12/18/ES6语法指南/</id>
    <published>2018-12-18T08:10:28.000Z</published>
    <updated>2019-06-10T01:34:28.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-语法指南"><a href="#ES6-语法指南" class="headerlink" title="ES6 语法指南"></a>ES6 语法指南</h1><p>后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。</p><p>什么是ES6？就是ECMAScript第6版标准。</p><h2 id="1-什么是ECMAScript？"><a href="#1-什么是ECMAScript？" class="headerlink" title="1.什么是ECMAScript？"></a>1.什么是ECMAScript？</h2><p>来看下前端的发展历程：</p><blockquote><p>web1.0时代：</p></blockquote><ul><li>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。<strong>开发人员也只关心页面的样式和内容</strong>即可。</li></ul><blockquote><p>web2.0时代：</p></blockquote><ul><li>1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。</li><li>1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。</li><li>1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了<code>ECMAscript</code>标准规范。JavaScript和JScript都是<code>ECMAScript</code>的标准实现者，随后各大浏览器厂商纷纷实现了<code>ECMAScript</code>标准。</li></ul><p>所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。</p><h2 id="2-ECMAScript的快速发展"><a href="#2-ECMAScript的快速发展" class="headerlink" title="2.ECMAScript的快速发展"></a>2.ECMAScript的快速发展</h2><p>而后，ECMAScript就进入了快速发展期。</p><ul><li><p>1998年6月，ECMAScript 2.0 发布。</p></li><li><p>1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。</p></li><li><p>2007年10月。。。。ECMAScript 4.0 草案发布。</p><p>这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。</p><ul><li>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。</li><li>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</li></ul><p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中</p></li><li><p>2009年12月，ECMAScript 5 发布。</p></li><li><p>2011年6月，ECMAScript 5.1 发布。</p></li><li><p>2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 </p></li></ul><h2 id="3-ES5和6的一些新特性"><a href="#3-ES5和6的一些新特性" class="headerlink" title="3.ES5和6的一些新特性"></a>3.ES5和6的一些新特性</h2><p>我们这里只把一些常用的进行学习，更详细的大家参考：<a href="http://es6.ruanyifeng.com/?search=reduce&amp;x=0&amp;y=0#README" target="_blank" rel="noopener">阮一峰的ES6教程</a></p><h3 id="3-1-let-和-const-命令"><a href="#3-1-let-和-const-命令" class="headerlink" title="3.1.let 和 const 命令"></a>3.1.let 和 const 命令</h3><blockquote><p>var</p></blockquote><p>之前，js定义变量只有一个关键字：<code>var</code></p><p><code>var</code>有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。</p><p>例如这样的一段代码：</p><pre><code class="js">for(var i = 0; i &lt; 5; i++){    console.log(i);}console.log(&quot;循环外：&quot; + i)</code></pre><p>你猜下打印的结果是什么？</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526107278999.png" alt="1526107278999"></p><blockquote><p>let</p></blockquote><p><code>let</code>所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><p>我们把刚才的<code>var</code>改成<code>let</code>试试：</p><pre><code class="js">for(let i = 0; i &lt; 5; i++){    console.log(i);}console.log(&quot;循环外：&quot; + i)</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526107347275.png" alt="1526107347275"></p><blockquote><p>const</p></blockquote><p><code>const</code>声明的变量是常量，不能被修改</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526107425000.png" alt="1526107425000"></p><h3 id="3-2-字符串扩展"><a href="#3-2-字符串扩展" class="headerlink" title="3.2.字符串扩展"></a>3.2.字符串扩展</h3><blockquote><p>新的API</p></blockquote><p>ES6为字符串扩展了几个新的API：</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><p>实验一下：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526107640349.png" alt="1526107640349"></p><blockquote><p>字符串模板</p></blockquote><p>ES6中提供了`来作为字符串模板标记。我们可以这么玩：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526108070980.png" alt="1526108070980"></p><p>在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本</p><p>键盘是的1的左侧，tab的上侧，esc的正下方</p><h3 id="3-3-解构表达式"><a href="#3-3-解构表达式" class="headerlink" title="3.3.解构表达式"></a>3.3.解构表达式</h3><blockquote><p>数组解构</p></blockquote><p>比如有一个数组：</p><pre><code class="js">let arr = [1,2,3]</code></pre><p>我想获取其中的值，只能通过角标。ES6可以这样：</p><pre><code class="js">const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z);</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526109778368.png" alt="1526109778368"></p><blockquote><p>对象解构</p></blockquote><p>例如有个person对象：</p><pre><code class="js">const person = {    name:&quot;jack&quot;,    age:21,    language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;]}</code></pre><p>我们可以这么做：</p><pre><code class="js">// 解构表达式获取值const {name,age,language} = person;// 打印console.log(name);console.log(age);console.log(language);</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526109984544.png" alt="1526109984544"></p><p>如过想要用其它变量接收，需要额外指定别名：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526110159450.png" alt="1526110159450"></p><ul><li><code>{name:n}</code>：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。</li></ul><h3 id="3-4-函数优化"><a href="#3-4-函数优化" class="headerlink" title="3.4.函数优化"></a>3.4.函数优化</h3><blockquote><p>函数参数默认值</p></blockquote><p>在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法：</p><pre><code class="js">    function add(a , b) {        // 判断b是否为空，为空就给默认值1        b = b || 1;        return a + b;    }    // 传一个参数    console.log(add(10));</code></pre><p>现在可以这么写：</p><pre><code class="js">function add(a , b = 1) {    return a + b;}// 传一个参数console.log(add(10));</code></pre><blockquote><p>箭头函数</p></blockquote><p>ES6中定义函数的简写方式：</p><p>一个参数时：</p><pre><code class="js">var print = function (obj) {    console.log(obj);}// 简写为：var print2 = obj =&gt; console.log(obj);</code></pre><p>多个参数：</p><pre><code class="js">// 两个参数的情况：var sum = function (a , b) {    return a + b;}// 简写为：var sum2 = (a,b) =&gt; a+b;</code></pre><p>代码不止一行，可以用<code>{}</code>括起来</p><pre><code class="js">var sum3 = (a,b) =&gt; {    return a + b;}</code></pre><blockquote><p>对象的函数属性简写</p></blockquote><p>比如一个Person对象，里面有eat方法：</p><pre><code class="js">let person = {    name: &quot;jack&quot;,    // 以前：    eat: function (food) {        console.log(this.name + &quot;在吃&quot; + food);    },    // 箭头函数版：    eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food),// 这里拿不到this    // 简写版：    eat3(food){        console.log(this.name + &quot;在吃&quot; + food);    }}</code></pre><blockquote><p>箭头函数结合解构表达式</p></blockquote><p>比如有一个函数：</p><pre><code class="js">const person = {    name:&quot;jack&quot;,    age:21,    language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;]}function hello(person) {    console.log(&quot;hello,&quot; + person.name)}</code></pre><p>如果用箭头函数和解构表达式</p><pre><code class="js">var hi = ({name}) =&gt;  console.log(&quot;hello,&quot; + name);</code></pre><h3 id="3-5-map和reduce"><a href="#3-5-map和reduce" class="headerlink" title="3.5.map和reduce"></a>3.5.map和reduce</h3><p>数组中新增了map和reduce方法。</p><blockquote><p>map</p></blockquote><p><code>map()</code>：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p><p>举例：有一个字符串数组，我们希望转为int数组</p><pre><code class="js">let arr = [&#39;1&#39;,&#39;20&#39;,&#39;-5&#39;,&#39;3&#39;];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr)</code></pre><p>  <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526110796839.png" alt="1526110796839"></p><blockquote><p>reduce</p></blockquote><p><code>reduce()</code>：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数：</p><ul><li>第一个参数是上一次reduce处理的结果</li><li>第二个参数是数组中要处理的下一个元素</li></ul><p><code>reduce()</code>会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数</p><p>举例：</p><pre><code>const arr = [1,20,-5,3]</code></pre><p>没有初始值：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526111537204.png" alt="1526111537204"></p><p>指定初始值：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526111580742.png" alt="1526111580742"></p><h3 id="3-6-promise"><a href="#3-6-promise" class="headerlink" title="3.6.promise"></a>3.6.promise</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>感觉跟java的Future类很像啊，有木有！</p><p>我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。</p><p>语法：</p><pre><code class="js">const promise = new Promise(function(resolve, reject) {  // ... 执行异步操作  if (/* 异步操作成功 */){    resolve(value);// 调用resolve，代表Promise将返回成功的结果  } else {    reject(error);// 调用reject，代表Promise会返回失败结果  }});</code></pre><p>这样，在promise中就封装了一段异步执行的结果。</p><p>如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法：</p><pre><code class="js">promise.then(function(value){    // 异步执行成功后的回调});</code></pre><p>如果想要处理promise异步执行失败的事件，还可以跟上catch：</p><pre><code class="js">promise.then(function(value){    // 异步执行成功后的回调}).catch(function(error){    // 异步执行失败后的回调})</code></pre><p>示例：</p><pre><code>const p = new Promise(function (resolve, reject) {    // 这里我们用定时任务模拟异步    setTimeout(() =&gt; {        const num = Math.random();        // 随机返回成功或失败        if (num &lt; 0.5) {            resolve(&quot;成功！num:&quot; + num)        } else {            reject(&quot;出错了！num:&quot; + num)        }    }, 300)})// 调用promisep.then(function (msg) {    console.log(msg);}).catch(function (msg) {    console.log(msg);})</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526113115887.png" alt="1526113115887"></p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526113140074.png" alt="1526113140074"></p><h3 id="3-7-set和map（了解）"><a href="#3-7-set和map（了解）" class="headerlink" title="3.7.set和map（了解）"></a>3.7.set和map（了解）</h3><p>ES6提供了Set和Map的数据结构。</p><p>Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。</p><p>构造函数：</p><pre><code class="js">// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5]</code></pre><p>普通方法：</p><pre><code>set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。</code></pre><p>map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即：</p><ul><li>object是 &lt;string,object&gt;集合</li><li>map是&lt;object,object&gt;集合</li></ul><p>构造函数：</p><pre><code class="js">// map接收一个数组，数组中的元素是键值对数组const map = new Map([    [&#39;key1&#39;,&#39;value1&#39;],    [&#39;key2&#39;,&#39;value2&#39;],])// 或者接收一个setconst set = new Set([    [&#39;key1&#39;,&#39;value1&#39;],    [&#39;key2&#39;,&#39;value2&#39;],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map);</code></pre><p>方法：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526114799767.png" alt="1526114799767"></p><h3 id="3-8-模块化"><a href="#3-8-模块化" class="headerlink" title="3.8.模块化"></a>3.8.模块化</h3><h4 id="3-8-1-什么是模块化"><a href="#3-8-1-什么是模块化" class="headerlink" title="3.8.1.什么是模块化"></a>3.8.1.什么是模块化</h4><p>模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。</p><p>而JS中没有包的概念，换来的是 模块。</p><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。</p><ul><li><code>export</code>命令用于规定模块的对外接口，</li><li><code>import</code>命令用于导入其他模块提供的功能。</li></ul><h4 id="3-8-2-export"><a href="#3-8-2-export" class="headerlink" title="3.8.2.export"></a>3.8.2.export</h4><p>比如我定义一个js文件:hello.js，里面有一个对象：</p><pre><code class="js">const util = {    sum(a,b){        return a + b;    }}</code></pre><p>我可以使用export将这个对象导出：</p><pre><code class="js">const util = {    sum(a,b){        return a + b;    }}export util;</code></pre><p>当然，也可以简写为：</p><pre><code class="js">export const util = {    sum(a,b){        return a + b;    }}</code></pre><p><code>export</code>不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。</p><p>当要导出多个值时，还可以简写。比如我有一个文件：user.js：</p><pre><code class="js">var name = &quot;jack&quot;var age = 21export {name,age}</code></pre><blockquote><p>省略名称</p></blockquote><p>上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。</p><p>因此js提供了<code>default</code>关键字，可以对导出的变量名进行省略</p><p>例如：</p><pre><code class="js">// 无需声明对象的名字export default {    sum(a,b){        return a + b;    }}</code></pre><p>这样，当使用者导入时，可以任意起名字</p><h4 id="3-8-3-import"><a href="#3-8-3-import" class="headerlink" title="3.8.3.import"></a>3.8.3.import</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><p>例如我要使用上面导出的util：</p><pre><code class="js">// 导入utilimport util from &#39;hello.js&#39;// 调用util中的属性util.sum(1,2)</code></pre><p>要批量导入前面导出的name和age： </p><pre><code class="js">import {name, age} from &#39;user.js&#39;console.log(name + &quot; , 今年&quot;+ age +&quot;岁了&quot;)</code></pre><p>但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如<code>Babel-cli</code>工具</p><p> 我们暂时不做测试，大家了解即可。</p><h3 id="3-9-对象扩展"><a href="#3-9-对象扩展" class="headerlink" title="3.9.对象扩展"></a>3.9.对象扩展</h3><p>ES6给Object拓展了许多新的方法，如：</p><ul><li>keys(obj)：获取对象的所有key形成的数组</li><li>values(obj)：获取对象的所有value形成的数组</li><li>entries(obj)：获取对象的所有key和value形成的二维数组。格式：<code>[[k1,v1],[k2,v2],...]</code></li><li><p>assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1527210872966.png" alt="1527210872966"></p></li></ul><h3 id="3-10-数组扩展"><a href="#3-10-数组扩展" class="headerlink" title="3.10.数组扩展"></a>3.10.数组扩展</h3><p>ES6给数组新增了许多方法：</p><ul><li>find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素</li><li>findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引</li><li>includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。</li></ul>]]></content>
    
    <summary type="html">
    
      ES6语法指南
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="转载" scheme="/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="ES6" scheme="/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>自定义百度云分享密码</title>
    <link href="/2018/12/14/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/"/>
    <id>/2018/12/14/自定义百度云分享密码/</id>
    <published>2018-12-14T01:13:35.000Z</published>
    <updated>2019-06-10T01:34:37.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>打开百度云盘网页版</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544750054257.png" alt="1544750054257"></p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>找到需要分享的资源，点击分享之后看见下面内容：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544750254778.png" alt="1544750254778"></p><p>别动，重点的在后面</p><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>按下F12，进入开发者模式，点击 consle 进入控制台，如下图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544750550143.png" alt="1544750550143"></p><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><p>在控制台中输入下面代码，按下回车</p><blockquote><p>avascript:require([“function-widget-1:share/util/shareFriend/createLinkShare.js”]).prototype.makePrivatePassword=function(){return prompt(“请输入自定义的密码”,”1234”)}</p></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544750784118.png" alt="1544750784118"></p><h1 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h1><p>关闭开发者模式，点击“创建链接”，输入你想要自定义的密码，回车确定即可</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544751090180.png" alt="1544751090180"></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544751100617.png" alt="1544751100617"></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544751152701.png" alt="1544751152701"></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544751191191.png" alt="1544751191191"></p>]]></content>
    
    <summary type="html">
    
      自定义百度云分享密码
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="百度网盘" scheme="/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序笔记</title>
    <link href="/2018/12/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/"/>
    <id>/2018/12/11/微信小程序笔记/</id>
    <published>2018-12-11T13:15:58.000Z</published>
    <updated>2019-06-10T01:34:46.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序账号与工具"><a href="#微信小程序账号与工具" class="headerlink" title="微信小程序账号与工具"></a>微信小程序账号与工具</h1><p>在线文档：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/</a></p><h2 id="小程序开发者账号注册"><a href="#小程序开发者账号注册" class="headerlink" title="小程序开发者账号注册"></a>小程序开发者账号注册</h2><p>微信公众平台：<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a></p><p>小程序开发者账号注册：<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a></p><h2 id="微信开发者工具"><a href="#微信开发者工具" class="headerlink" title="微信开发者工具"></a>微信开发者工具</h2><p>微信开发者工具：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html</a></p><h2 id="小程序在线Demo二维码"><a href="#小程序在线Demo二维码" class="headerlink" title="小程序在线Demo二维码"></a>小程序在线Demo二维码</h2><p>体验小程序官方源码：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip</a></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181211-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/weChatAppdemo.jpg?raw=true"></p><h1 id="微信小程序文件结构"><a href="#微信小程序文件结构" class="headerlink" title="微信小程序文件结构"></a>微信小程序文件结构</h1><h2 id="主体文件结构"><a href="#主体文件结构" class="headerlink" title="主体文件结构"></a>主体文件结构</h2><p>主体部分由三个文件组成，必须放在项目的根目录，如下：</p><table><thead><tr><th>文件</th><th>必填</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html" target="_blank" rel="noopener">app.js</a></td><td>是</td><td>小程序逻辑</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="noopener">app.json</a></td><td>是</td><td>小程序公共设置</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html" target="_blank" rel="noopener">app.wxss</a></td><td>否</td><td>小程序公共样式表</td></tr></tbody></table><h2 id="页面文件结构"><a href="#页面文件结构" class="headerlink" title="页面文件结构"></a>页面文件结构</h2><p>页面由四个文件组成，分别是：</p><table><thead><tr><th>文件类型</th><th>必填</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html" target="_blank" rel="noopener">js</a></td><td>是</td><td>页面逻辑 ( 微信小程序没有window和document对象 )</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/" target="_blank" rel="noopener">wxml</a></td><td>是</td><td>页面结构  ( XML语法，不是HTML语法 )</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html" target="_blank" rel="noopener">wxss</a></td><td>否</td><td>页面样式表 ( <strong>拓展了rpx尺寸单位，微信专属响应式像素</strong> )</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pagejson" target="_blank" rel="noopener">json</a></td><td>否</td><td>页面配置  ( 不能写注释，否则编译报错 )</td></tr></tbody></table><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181211-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/fileTree.png"></p><h1 id="WXML-结构-基础-标签、组件"><a href="#WXML-结构-基础-标签、组件" class="headerlink" title="WXML 结构_基础 (标签、组件)"></a>WXML 结构_基础 (标签、组件)</h1><p>组件文档：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/component/</a></p><h2 id="常用布局标签-组件"><a href="#常用布局标签-组件" class="headerlink" title="常用布局标签(组件)"></a>常用布局标签(组件)</h2><pre><code class="xml">&lt;view&gt;&lt;/view&gt;                相当于    &lt;div&gt;&lt;/div&gt;&lt;text&gt;&lt;/text&gt;                相当于    &lt;span&gt;&lt;/span&gt;&lt;image&gt;&lt;/image&gt;                相当于    &lt;img /&gt;&lt;navigator&gt;&lt;/navigator&gt;        相当于    &lt;a&gt;&lt;/a&gt;&lt;block&gt;&lt;/block&gt;                区块标签，不会渲染到页面</code></pre><p><strong>注意：image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高</strong></p><h2 id="常用表单标签-组件"><a href="#常用表单标签-组件" class="headerlink" title="常用表单标签(组件)"></a>常用表单标签(组件)</h2><pre><code class="xml">&lt;button&gt;&lt;/button&gt;&lt;input type=&quot;text&quot; /&gt;                &lt;checkbox /&gt;&lt;radio/&gt;</code></pre><h2 id="轮播图组件"><a href="#轮播图组件" class="headerlink" title="轮播图组件"></a>轮播图组件</h2><pre><code class="xml">&lt;swiper indicator-dots=&quot;是否显示面板指示点&quot; autoplay=&quot;是否自动切换&quot; interval=&quot;自动切换时间间隔&quot; duration=&quot;滑动动画时长&quot;&gt;    &lt;swiper-item&gt;          &lt;image src=&quot;图片路径1&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt;    &lt;/swiper-item&gt;    &lt;swiper-item&gt;          &lt;image src=&quot;图片路径2&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt;    &lt;/swiper-item&gt;&lt;/swiper&gt;</code></pre><p>探索：实现无缝轮播怎么办？</p><h1 id="WXSS-样式"><a href="#WXSS-样式" class="headerlink" title="WXSS 样式"></a>WXSS 样式</h1><p>WXSS (WeiXin Style Sheets) 是一套样式语言。</p><p>WXSS文档： <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html</a></p><h2 id="WXSS-新增特性"><a href="#WXSS-新增特性" class="headerlink" title="WXSS 新增特性"></a>WXSS 新增特性</h2><p>与 CSS 相比，WXSS 扩展以下2个特性：</p><ul><li>尺寸单位      rpx ( responsive pixel 响应式像素) </li><li>样式导入      @import  “样式表路径”;</li></ul><h2 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h2><ul><li>rpx  ( responsive pixel 响应式像素) : 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li><li><strong>建议：</strong> 开发微信小程序时设计师可以用 <code>iPhone6</code> 作为视觉稿的标准。</li></ul><h1 id="JSON-配置"><a href="#JSON-配置" class="headerlink" title="JSON 配置"></a>JSON 配置</h1><p>配置文档：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html</a></p><h2 id="app-json-配置项列表"><a href="#app-json-配置项列表" class="headerlink" title="app.json 配置项列表"></a>app.json 配置项列表</h2><blockquote><p><code>app.json</code> 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pages" target="_blank" rel="noopener">pages</a></td><td>String Array</td><td>是</td><td>设置页面路径</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#window" target="_blank" rel="noopener">window</a></td><td>Object</td><td>否</td><td>设置默认页面的窗口表现</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar" target="_blank" rel="noopener">tabBar</a></td><td>Object</td><td>否</td><td>设置底部 tab 的表现</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#networktimeout" target="_blank" rel="noopener">networkTimeout</a></td><td>Object</td><td>否</td><td>设置网络超时时间</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#debug" target="_blank" rel="noopener">debug</a></td><td>Boolean</td><td>否</td><td>设置是否开启 debug 模式</td></tr></tbody></table></blockquote><p>如：<code>app.json</code> </p><pre><code class="javascript">{  &quot;pages&quot;: [    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;  ],  &quot;window&quot;: {    &quot;navigationBarTitleText&quot;: &quot;小程序标题&quot;  },  &quot;tabBar&quot;: {    &quot;list&quot;: [{      &quot;pagePath&quot;: &quot;pages/index/index&quot;,      &quot;text&quot;: &quot;首页&quot;    }, {      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,      &quot;text&quot;: &quot;Tab栏&quot;    }]  },  &quot;networkTimeout&quot;: {    &quot;request&quot;: 10000,    &quot;downloadFile&quot;: 10000  },  &quot;debug&quot;: true}</code></pre><h2 id="window-配置"><a href="#window-配置" class="headerlink" title="window 配置"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#window" target="_blank" rel="noopener">window</a> 配置</h2><blockquote><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>navigationBarBackgroundColor</td><td>HexColor</td><td>#000000</td><td>导航栏背景颜色，如”#000000”</td></tr><tr><td>navigationBarTextStyle</td><td>String</td><td>white</td><td>导航栏标题颜色，仅支持 black/white</td></tr><tr><td>navigationBarTitleText</td><td>String</td><td></td><td>导航栏标题文字内容</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>#ffffff</td><td>窗口的背景色</td></tr><tr><td>backgroundTextStyle</td><td>String</td><td>dark</td><td>下拉背景字体、loading 图的样式，仅支持 dark/light</td></tr><tr><td>enablePullDownRefresh</td><td>Boolean</td><td>false</td><td>是否开启下拉刷新，详见<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html#页面相关事件处理函数" target="_blank" rel="noopener">页面相关事件处理函数</a>。</td></tr><tr><td>onReachBottomDistance</td><td>Number</td><td>50</td><td>页面上拉触底事件触发时距页面底部距离，单位为px</td></tr></tbody></table><h3 id="window-配置图示"><a href="#window-配置图示" class="headerlink" title="window 配置图示"></a>window 配置图示</h3><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181211-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/config.jpg?raw=true"></p><h3 id="window-配置注意事项"><a href="#window-配置注意事项" class="headerlink" title="window 配置注意事项"></a>window 配置注意事项</h3><blockquote><p>!! 注意：页面的<code>.json</code>只能设置 <code>window</code> 相关的配置项，以决定本页面的窗口表现，所以无需写 <code>window</code> 这个关键词。</p></blockquote><p>如：/pages/message/message.json</p><pre><code class="javascript">{    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,    &quot;navigationBarTitleText&quot;: &quot;内页标题修改&quot;,    &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,    &quot;backgroundTextStyle&quot;: &quot;light&quot;}</code></pre><h2 id="tabBar-配置"><a href="#tabBar-配置" class="headerlink" title="tabBar 配置"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar" target="_blank" rel="noopener">tabBar</a> 配置</h2><p>如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p><p><strong>属性说明：</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>HexColor</td><td>是</td><td></td><td>tab 上的文字默认颜色</td></tr><tr><td>selectedColor</td><td>HexColor</td><td>是</td><td></td><td>tab 上的文字选中时的颜色</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>是</td><td></td><td>tab 的背景色</td></tr><tr><td>borderStyle</td><td>String</td><td>否</td><td>black</td><td>tabbar上边框的颜色， 仅支持 black/white</td></tr><tr><td>list</td><td>Array</td><td>是</td><td></td><td>tab 的列表，详见 list 属性说明，最少2个、最多5个 tab</td></tr><tr><td>position</td><td>String</td><td>否</td><td>bottom</td><td>可选值 bottom、top，设置成top是无图标</td></tr></tbody></table><p>其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：</p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>pagePath</td><td>String</td><td>是</td><td>页面路径，必须在 pages 中先定义</td></tr><tr><td>text</td><td>String</td><td>是</td><td>tab 上按钮文字</td></tr><tr><td>iconPath</td><td>String</td><td>否</td><td>图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效</td></tr><tr><td>selectedIconPath</td><td>String</td><td>否</td><td>选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效</td></tr></tbody></table><h3 id="tabBar-配置图示"><a href="#tabBar-配置图示" class="headerlink" title="tabBar 配置图示"></a>tabBar 配置图示</h3><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181211-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/tabBar.png"></p><h3 id="tabBar-配置注意事项"><a href="#tabBar-配置注意事项" class="headerlink" title="tabBar 配置注意事项"></a>tabBar 配置注意事项</h3><blockquote><ol><li>当设置 position 为 top 时，将不会显示 icon。</li><li>tabBar 中的 list 是一个数组，<strong>只能配置最少2个、最多5个 tab</strong>，tab 按数组的顺序排序。</li><li>icon 大小限制为40kb，建议尺寸为 81px * 81px。</li></ol></blockquote><h1 id="JS-行为-逻辑"><a href="#JS-行为-逻辑" class="headerlink" title="JS 行为(逻辑)"></a>JS 行为(逻辑)</h1><h2 id="微信小程序生命周期函数"><a href="#微信小程序生命周期函数" class="headerlink" title="微信小程序生命周期函数"></a>微信小程序生命周期函数</h2><pre><code class="javascript">Page({  /** 页面的初始数据 */  data: {  },  /** 生命周期函数--监听页面加载 */  onLoad: function (options) {      console.log(options);  },  /** 生命周期函数--监听页面初次渲染完成 */  onReady: function () {  },  /** 生命周期函数--监听页面显示 */  onShow: function () {  },  /** 生命周期函数--监听页面隐藏 */  onHide: function () {  },  /** 生命周期函数--监听页面卸载 */  onUnload: function () {  }})</code></pre><h2 id="页面相关事件处理函数"><a href="#页面相关事件处理函数" class="headerlink" title="页面相关事件处理函数"></a>页面相关事件处理函数</h2><pre><code class="javascript"> /** 页面相关事件处理函数--监听用户下拉动作 */  onPullDownRefresh: function () {  },  /** 页面上拉触底事件的处理函数 */  onReachBottom: function () {  },  /** 用户点击右上角分享 */  onShareAppMessage: function () {  }</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>微信小程序没有BOM和DOM概念，所以不能使用window对象和document对象。</p></blockquote><h1 id="WXML-高级-指令、事件"><a href="#WXML-高级-指令、事件" class="headerlink" title="WXML  高级(指令、事件)"></a>WXML  高级(指令、事件)</h1><h2 id="数据绑定-123-123-125-125"><a href="#数据绑定-123-123-125-125" class="headerlink" title="数据绑定  &#123;&#123; &#125;&#125;"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html" target="_blank" rel="noopener">数据绑定</a>  &#123;&#123; &#125;&#125;</h2><pre><code class="xml">&lt;!--wxml--&gt;&lt;view&gt; {{message}} &lt;/view&gt;</code></pre><pre><code class="javascript">// page.jsPage({  data: {    message: &#39;Hello MINA!&#39;  }})</code></pre><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li><strong>花括号和引号之间不能有空格。</strong></li><li><strong>不要直接写 checked=”false”，其计算结果是一个字符串，转成 boolean 类型后代表真值。</strong></li></ol><pre><code class="xml">&lt;checkbox checked=&quot;false&quot;&gt; &lt;/checkbox&gt;                    其计算结果是一个字符串，转成 boolean 类型后变成了 true&lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt;                正确写法</code></pre><h2 id="列表渲染-wx-for"><a href="#列表渲染-wx-for" class="headerlink" title="列表渲染  wx:for"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html" target="_blank" rel="noopener">列表渲染</a>  wx:for</h2><pre><code class="xml">&lt;!--wxml--&gt;&lt;view wx:for=&quot;{{array}}&quot;&gt; {{item}} &lt;/view&gt;</code></pre><pre><code class="javascript">// page.jsPage({  data: {    array: [1, 2, 3, 4, 5]  }})</code></pre><h3 id="wx-key"><a href="#wx-key" class="headerlink" title="wx:key"></a>wx:key</h3><p>主要功能：提高列表渲染时排序的效率。</p><p><code>wx:key</code> 的值以两种形式提供：</p><ol><li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li><li>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。</li></ol><blockquote><p>如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p></blockquote><h2 id="条件渲染-wx-if-wx-else-wx-elif"><a href="#条件渲染-wx-if-wx-else-wx-elif" class="headerlink" title="条件渲染  wx:if   wx:else   wx:elif"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html" target="_blank" rel="noopener">条件渲染</a>  wx:if   wx:else   wx:elif</h2><pre><code class="xml">&lt;!--wxml--&gt;&lt;view wx:if=&quot;{{length >= 80}}&quot;&gt; 优秀 &lt;/view&gt;&lt;view wx:elif=&quot;{{length >= 60}}&quot;&gt; 良好 &lt;/view&gt;&lt;view wx:else&gt; 加油 &lt;/view&gt;</code></pre><pre><code class="javascript">// page.jsPage({  data: {    length: &#39;95&#39;  }})</code></pre><h3 id="wx-if-与-hidden-区别"><a href="#wx-if-与-hidden-区别" class="headerlink" title="wx:if 与 hidden 区别"></a><code>wx:if</code> 与 <code>hidden</code> 区别</h3><p> <code>wx:if</code>  是否渲染， <code>hidden</code>  是否隐藏。</p><p>一般来说，<code>wx:if</code> 有更高的切换消耗而 <code>hidden</code> 有更高的初始渲染消耗。</p><p>因此，如果需要频繁切换的情景下，用 <code>hidden</code> 更好。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html" target="_blank" rel="noopener">事件</a></h2><ul><li>事件对象可以获取额外信息，如 id, dataset(自定义属性集合), touches(触摸点坐标)。</li></ul><h3 id="事件绑定和冒泡"><a href="#事件绑定和冒泡" class="headerlink" title="事件绑定和冒泡"></a>事件绑定和冒泡</h3><ol><li>冒泡事件    bind事件类型        如     <code>bindtap</code>   <code>bindlongpress</code></li><li>非冒泡事件    catch事件类型    如  <code>catchtap</code>   <code>catchlongpress</code></li></ol><h3 id="常用事件类型"><a href="#常用事件类型" class="headerlink" title="常用事件类型"></a>常用事件类型</h3><table><thead><tr><th>类型</th><th>触发条件</th></tr></thead><tbody><tr><td>tap</td><td>手指触摸后马上离开</td></tr><tr><td>longpress</td><td>手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td></tr></tbody></table><pre><code class="xml">&lt;!--wxml--&gt;&lt;view data-index=&quot;自定义属性&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt;</code></pre><pre><code class="javascript">// page.jsPage({  tapHandle: function(event) {    console.log(event)  }})</code></pre><h3 id="事件传参注意"><a href="#事件传参注意" class="headerlink" title="事件传参注意"></a>事件传参注意</h3><p>小程序绑定事件只能写函数名称，不能通过括号方式传参。</p><pre><code class="xml">&lt;!--wxml--&gt;&lt;view bindtap=&quot;tapHandle(520)&quot;&gt; 点我触发事件 &lt;/view&gt;                                错误，事件不能触发&lt;view data-index=&quot;520&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt;    </code></pre><pre><code class="javascript">// page.jsPage({  tapHandle: function(event) {     console.log( event.target.dataset.index );  // 输出标签自定义属性上的index值  }})</code></pre><h2 id="WXS-脚本"><a href="#WXS-脚本" class="headerlink" title="WXS  脚本"></a>WXS  脚本</h2><p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，功能类似<code>&lt;script&gt;</code>标签，主要用于在视图层定义函数(比较少用)。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。</li><li>wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。</li><li>wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。</li><li>wxs 函数不能作为组件的事件回调。</li><li>由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。</li></ol><pre><code class="xml">&lt;!--wxml--&gt;&lt;wxs module=&quot;foo&quot;&gt;var sum = function(a,b){  return a+b;};// 这里可以导出一个对象，这个对象可以直接在界面上使用 module.exports.sum = sum;&lt;/wxs&gt;&lt;view&gt; {{foo.sum(1,2)}} &lt;/view&gt;</code></pre><h1 id="微信开发者工具常用快捷键"><a href="#微信开发者工具常用快捷键" class="headerlink" title="微信开发者工具常用快捷键"></a>微信开发者工具常用快捷键</h1><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>Shift + Alt + F</td><td>格式化代码</td></tr><tr><td>Ctrl + P</td><td>跳到文件</td></tr><tr><td>Ctrl + E</td><td>跳到最近文件</td></tr><tr><td>Ctrl + Shift + P</td><td>上传扫码预览</td></tr><tr><td>Ctrl + Shift + I</td><td>显示/隐藏调试器</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      小程序基础
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="微信小程序" scheme="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix状态</title>
    <link href="/2018/12/07/Hystrix%E7%8A%B6%E6%80%81/"/>
    <id>/2018/12/07/Hystrix状态/</id>
    <published>2018-12-07T00:12:05.000Z</published>
    <updated>2019-06-10T01:34:58.856Z</updated>
    
    <content type="html"><![CDATA[<p>@SpringCloudApplication 相当于：@EnableCircuitBreaker、@EnableDiscoveryClilent、@SpringBootApplication</p><h3 id="熔断器状态的相关配置"><a href="#熔断器状态的相关配置" class="headerlink" title="熔断器状态的相关配置"></a>熔断器状态的相关配置</h3><p>@HystrixProperty相关配置在抽象类：package com.netflix.hystrix.HystrixCommandProperties 中</p><p><strong>熔断器开启或者关闭的条件：</strong></p><p>1、  当满足一定的阀值的时候（默认10秒内超过20个请求次数）</p><p>2、  当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p><p>3、  到达以上阀值，断路器将会开启</p><p>4、  当开启的时候，所有请求都不会进行转发</p><p>5、  一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。</p><pre><code class="java">// 开启服务降级@HystrixCommand(        // 熔断器状态相关配置        commandProperties = {                // 当请求次数达到10次时才能开启熔断                @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),                // 状态变换的时间，由开启 --&gt; 半开                @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;20000&quot;),                // 失败请求/所有请求=60% --&gt; 开启熔断器                @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;)        })</code></pre>]]></content>
    
    <summary type="html">
    
      Hystrix状态
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SpringCloud" scheme="/tags/SpringCloud/"/>
    
      <category term="Hystrix" scheme="/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>HashSet如何去重？</title>
    <link href="/2018/12/06/HashSet%E5%A6%82%E4%BD%95%E5%8E%BB%E9%87%8D/"/>
    <id>/2018/12/06/HashSet如何去重/</id>
    <published>2018-12-06T02:37:51.000Z</published>
    <updated>2019-06-10T01:35:22.008Z</updated>
    
    <content type="html"><![CDATA[<p>&lt; !– more –&gt;<br>HashSet存储元素的原理：<br>往hashSet添加元素的时候，首先会调用元素的 <code>hashCode</code> 方法得到元素的哈希码值，然后把哈希码值经过运算算出该元素存在哈希表中的位置。有两种情况：</p><ul><li><p>情况1：如果算出的位置目前还没有存在任何的元素，那么该元素可以直接添加到哈希表中。</p></li><li><p>情况2： 如果算出的位置目前已经存在其他的元素，那么还会调用元素的 <code>equals</code> 方法再与这个位置上的元素比较一次。<br>如果 <code>equals</code> 方法返回的是true，那么该元素被视为重复元素，不允许添加。如果equals方法返回的是false，那么该元素也可以被添加。  </p></li></ul><h2 id="先看个最简单的构造方法"><a href="#先看个最简单的构造方法" class="headerlink" title="先看个最简单的构造方法"></a>先看个最简单的构造方法</h2><pre><code class="java">* Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has* default initial capacity (16) and load factor (0.75).*/public HashSet() {    map = new HashMap&lt;&gt;();}</code></pre><p>很明显，HashSet底层是Hashmap存储的。借大神的话</p><blockquote><p>HashSet 就是HashMap的马甲       —–someone</p></blockquote><h2 id="再看看add方法"><a href="#再看看add方法" class="headerlink" title="再看看add方法"></a>再看看add方法</h2><pre><code class="java">// Dummy value to associate with an Object in the backing Map private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object();/**     * Adds the specified element to this set if it is not already present.     * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if     * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that     * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.     * If this set already contains the element, the call leaves the set     * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.     *     * @param e element to be added to this set     * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified     * element     */    public boolean add(E e) {        return map.put(e, PRESENT)==null;    }</code></pre><p>add方法的参数：</p><ul><li>map：map是一个HashMap的实例</li><li>e：我们要存储的值，是HashMap的key</li><li>PRESENT：固定值( Object PRESENT = new Object(); )，空的obj对象</li></ul><p>Set偷偷的用了HashMap的 <code>put</code> 方法，然而HashMap并没有去重的功能呀，那么Set是如何做到去重的呢？</p><p>从add方法中可以看到，E是我们要存储的值，而到了HashMap里面却变成了Key，PRESENT就是个空对象。</p><p>在HashMap中Key的HashCode是决定底层数组的下标，进一步使用 <code>equals</code> 进行遍历对象链表中的<strong>Key</strong>进而覆盖原来的Value。</p><p>那么对于HashSet，如果 <code>e</code> 已经存在（先HashCode相同定位到链表，然后equals比较定位到具体的Node），那么覆盖oldValue（value其实就是个傀儡，没啥用），Key不变；如果不存在，就添加一个新的节点（即加了一个新的Key）。</p><p>HashMap的返回值是oldValue，oldValue==null说明节点之前不存在；反之说明节点存在，虽然返回false但实际上还是对底层数据进行了改变（即旧的空对象变成了新的空对象）。</p><p>总而言之，HashSet确定相同的方式其实就是HashCode相同（才能找到同一链表），然后equals的返回值（才能比较具体节点进行覆盖）。</p><h2 id="重点看key（敲黑板）"><a href="#重点看key（敲黑板）" class="headerlink" title="重点看key（敲黑板）"></a>重点看key（敲黑板）</h2><p>HashMap中的put方法</p><pre><code class="java">public V put(K key, V value) {        return putVal(hash(key), key, value, false, true);    }   /**     * Implements Map.put and related methods     *     * @param hash hash for key     * @param key the key     * @param value the value to put     * @param onlyIfAbsent if true, don&#39;t change existing value     * @param evict if false, the table is in creation mode.     * @return previous value, or null if none     */    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else {            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else {                for (int binCount = 0; ; ++binCount) {                    if ((e = p.next) == null) {                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    }                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                }            }            if (e != null) { // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            }        }        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    }</code></pre><p><strong>这里边有两个看点：</strong></p><ul><li>HashMap中key存储是hash后的值，对于String类型的相同值的hash值是一致的（其他接触类型类似，自定义对象类型需要重写hashcode方法与equel方法）。换句话说相同的值在hashMap中的存储位置是一样的。</li><li>基于上一点来看看怎么存储重复值的。如下代码对于hashMap中已经存在的key，key不变，新value覆盖就value。对于HashSet而言新旧value都是PRESENT对象，所以set在存储的时候就不会重复。</li></ul><pre><code class="java">if (e != null) { // existing mapping for key    V oldValue = e.value;    if (!onlyIfAbsent || oldValue == null)        e.value = value;        afterNodeAccess(e);    return oldValue;}</code></pre><p>所以hashset中存储的值输出的顺序和存储的先后顺序不一致，这是因为hashset是按照值的hash顺序进行输出。</p>]]></content>
    
    <summary type="html">
    
      HeshSet如何去重
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HashSet" scheme="/tags/HashSet/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>IDEA常用快捷键</title>
    <link href="/2018/12/04/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>/2018/12/04/IDEA常用快捷键/</id>
    <published>2018-12-04T07:45:52.000Z</published>
    <updated>2019-06-10T01:35:36.690Z</updated>
    
    <content type="html"><![CDATA[<p><code>Ctrl+Alt+D</code> –&gt; 查看当前类的实现类</p><p>ctrl+l –&gt; 重写方法</p>]]></content>
    
    <summary type="html">
    
      IDEA常用快捷键
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="IDEA" scheme="/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA创建SpringBoot开启找回RunDashboard</title>
    <link href="/2018/12/04/IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/"/>
    <id>/2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/</id>
    <published>2018-12-04T06:32:05.000Z</published>
    <updated>2019-06-10T01:35:30.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Run-Dashboard-面板"><a href="#Run-Dashboard-面板" class="headerlink" title="Run Dashboard 面板"></a>Run Dashboard 面板</h1><p><strong>Run Dashboard</strong>：微服务项目的开发过程中，工程会非常多，经常要启动很多个服务，才能完成一项测试。启动的多了，容易给开发者带来错乱的感觉，很不方便管理。IDEA开发工具推荐了一个很好用的功能–Run Dashboard。他是 Run 的升级版</p><p>我们可以对比一下这个是Run Dashboard的窗口</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543905902634.png" alt="1543905902634"> </p><p>普通的Run窗口：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543905965611.png" alt="1543905965611"> </p><p>显然如果启动多个端口Run Dashboard窗口显得更好管理。<br>一般有时候创建springboot项目的时候右下角可以提示你打开Run Dashboard，但是如果不提醒就需要自己配置了。</p><h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>新建项目或者通过 <code>open</code> 打开项目时，可能会弹出提示 “Multiple Spring Boot run configurations were detected. Run Dashboard allows to manage multiple run configurations at once.” 见下图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543906387601.png" alt="1543906387601"> </p><p>点击 <code>Show run configurations in Run Dashboard</code> ，<code>Run Dashboard</code> 面板重新在底部区域展示了出来。</p><p>如没有此提示，请选择方式二或方式三</p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>打开Run Dashboard：View –&gt; Tool Windows –&gt; Run Dashboard</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543906576903.png" alt="1543906576903"></p><h2 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h2><p>如果上述的方式都没有打开 <code>Run Dashboard</code> 面板，可以在工程目录下找 <code>.idea</code> 文件夹下的 <code>workspace.xml</code>文件，通过修改此文件可达到打开 <code>Run Dashboard</code> 面板的目的</p><ol><li><p>找到当前项目中 <code>.idea</code> 文件下的 <code>workspace.xml</code> 文件，双击打开<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543906852844.png" alt="1543906852844"> </p></li><li><p>接下来找到 <code>&lt;component name=&quot;RunDashboard&quot;&gt;</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543907062997.png" alt="1543907062997"> </p></li><li><p>加入如下配置：</p><pre><code class="xml">&lt;option name=&quot;configurationTypes&quot;&gt;  &lt;set&gt;    &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;  &lt;/set&gt;&lt;/option&gt;</code></pre><p>这样 <code>Run Dashboard</code> 自动就弹出来了</p><p>最终配置如下：</p><pre><code class="xml">&lt;component name=&quot;RunDashboard&quot;&gt;  &lt;option name=&quot;configurationTypes&quot;&gt;    &lt;set&gt;      &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;    &lt;/set&gt;  &lt;/option&gt;  &lt;option name=&quot;ruleStates&quot;&gt;    &lt;list&gt;      &lt;RuleState&gt;        &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt;      &lt;/RuleState&gt;      &lt;RuleState&gt;        &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt;      &lt;/RuleState&gt;    &lt;/list&gt;  &lt;/option&gt;&lt;/component&gt;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      IDEA
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="IDEA" scheme="/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础-基本语法</title>
    <link href="/2018/11/30/Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>/2018/11/30/Vue基础-基本语法/</id>
    <published>2018-11-30T09:37:11.000Z</published>
    <updated>2019-06-10T01:35:43.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Vue-js"><a href="#1-什么是Vue-js" class="headerlink" title="1. 什么是Vue.js"></a>1. 什么是Vue.js</h1><ul><li>Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</li><li>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</li><li>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</li><li>前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；</li></ul><h1 id="2-安装-Vue"><a href="#2-安装-Vue" class="headerlink" title="2. 安装 Vue"></a>2. 安装 Vue</h1><h2 id="2-1-下载安装"><a href="#2-1-下载安装" class="headerlink" title="2.1 下载安装"></a>2.1 下载安装</h2><p>下载地址：<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a></p><p>可以下载2.5.16版本<a href="https://github.com/vuejs/vue/archive/v2.5.16.zip" target="_blank" rel="noopener">https://github.com/vuejs/vue/archive/v2.5.16.zip</a></p><p>下载解压，得到vue.js文件</p><h2 id="2-2-使用CDN"><a href="#2-2-使用CDN" class="headerlink" title="2.2 使用CDN"></a>2.2 使用CDN</h2><p>或者也可以直接使用公共的CDN服务：</p><pre><code class="html">&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></pre><p>或者：</p><pre><code class="html">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;</code></pre><h1 id="3-框架和库的区别"><a href="#3-框架和库的区别" class="headerlink" title="3. 框架和库的区别"></a>3. 框架和库的区别</h1><ul><li>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。<ul><li>node 中的 express；</li></ul></li><li>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。<ul><li>从Jquery 切换到 Zepto</li><li>从 EJS 切换到 art-template</li></ul></li></ul><h1 id="4-Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别（了解内容）"><a href="#4-Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别（了解内容）" class="headerlink" title="4. Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别（了解内容）"></a>4. Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别（了解内容）</h1><ul><li>MVC 主要是后端的分层开发思想；把 一个完整的后端项目，分成了三个部分：<ul><li>Model：（数据层）主要负责 数据库的操作；</li><li>View：（视图层）所有前端页面，统称为 View 层</li><li>Controller：（业务逻辑层）主要处理对应的业务逻辑；（对于后台来说，这是开发的重点）</li></ul></li><li>MVVM是<strong>前端页面的分层开发思想</strong>，主要关注于 <strong>视图层</strong> 分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View,  ViewModel<ul><li>Model 是 页面中，需要用到的数据</li><li>View 是页面中的HTML结构；</li><li>ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念；</li></ul></li><li>为什么有了MVC还要有MVVM<ul><li>因为 MVC是后端的开发思想，并没有明确定义前端的页面该如何开发；</li><li>MVVM 是前端的页面的开发思想，把每个页面，分成了三个部分，同时 VM 作为 MVVM 的核心，提供了双向数据绑定的概念，前端程序员，不需要手动渲染页面了，而且，页面数据发送变化，也不需要程序员手动把 数据的变化同步到Model中；这所有的操作，都是 VM 自动完成的！</li><li>有了 MVVM 的思想以后，前端只关心 页面交互逻辑，不关心页面如何渲染；</li></ul></li></ul><h2 id="4-2-Vue-js-基本代码-和-MVVM-之间的对应关系"><a href="#4-2-Vue-js-基本代码-和-MVVM-之间的对应关系" class="headerlink" title="4.2 Vue.js 基本代码 和 MVVM 之间的对应关系"></a>4.2 Vue.js 基本代码 和 MVVM 之间的对应关系</h2><ol><li>注意：Vue中，不推荐程序员手动操作DOM元素；所以，在Vue项目中，没有极其变态的需求，一般不要引入 Jquery；</li><li>Vue代码解析执行的步骤：<ol><li>当 VM 实例对象，被 创建完成之后，会立即解析 el 指定区域中的所有代码；</li><li>当 VM 在解析 el 区域中所有代码的时候，会把 data 中的数据，按需，填充到 页面指定的区域；</li></ol></li><li>注意：每当 vm 实例对象，监听到 data 中数据发生了变化，就会立即 重新解析 执行 el 区域内，所有的代码；</li></ol><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1540830117063.png" alt="1540830117063"></p><p>mvvm是前端思想，mvc是后台思想</p><h1 id="5-Vue调试工具vue-devtools的安装和使用"><a href="#5-Vue调试工具vue-devtools的安装和使用" class="headerlink" title="5. Vue调试工具vue-devtools的安装和使用"></a>5. Vue调试工具<code>vue-devtools</code>的安装和使用</h1><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p><h1 id="6-快速入门"><a href="#6-快速入门" class="headerlink" title="6. 快速入门"></a>6. 快速入门</h1><h1 id="7-Vue实例"><a href="#7-Vue实例" class="headerlink" title="7. Vue实例"></a>7. Vue实例</h1><h2 id="7-1-创建Vue实例"><a href="#7-1-创建Vue实例" class="headerlink" title="7.1 创建Vue实例"></a>7.1 创建Vue实例</h2><p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的：</p><pre><code class="javascript">var vm = new Vue({  // 选项})</code></pre><p>在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括：</p><ul><li>el</li><li>data</li><li>methods</li></ul><p>等等</p><p>接下来我们一 一介绍。</p><h2 id="7-2-模板或元素"><a href="#7-2-模板或元素" class="headerlink" title="7.2 模板或元素"></a>7.2 模板或元素</h2><p>每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。</p><p>我们可以通过el属性来指定。</p><p>例如一段html模板：</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code></pre><p>然后创建Vue实例，关联这个div</p><pre><code class="js">var vm = new Vue({    el:&quot;#app&quot;})</code></pre><p>这样，Vue就可以基于id为<code>app</code>的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。</p><h2 id="7-3-数据"><a href="#7-3-数据" class="headerlink" title="7.3 数据"></a>7.3 数据</h2><p>当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。</p><p>html：</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;&lt;/div&gt;</code></pre><p>js:</p><pre><code class="js">var vm = new Vue({    el:&quot;#app&quot;,    data:{        name:&quot;刘德华&quot;    }})</code></pre><ul><li>name的变化会影响到<code>input</code>的值</li><li>input中输入的值，也会导致vm中的name发生改变</li></ul><h2 id="7-4-方法"><a href="#7-4-方法" class="headerlink" title="7.4 方法"></a>7.4 方法</h2><p>Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue的作用范围内使用。</p><p>html:</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    {{num}}    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;&lt;/div&gt;</code></pre><p>js写法一：</p><pre><code class="js">&lt;div id=&quot;app&quot;&gt;    {{num}}    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vm = new Vue({       el:&quot;#app&quot;,       data:{           num:0       },       methods:{           add:function(){               this.num++;           }       }    });&lt;/script&gt;</code></pre><p>js写法二：</p><pre><code class="javascript">&lt;div id=&quot;app&quot;&gt;    {{num}}    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vm = new Vue({       el:&quot;#app&quot;,       data:{           num:0       },       methods:{           add(){               this.num++;           }       }    });&lt;/script&gt;</code></pre><h2 id="7-5-生命周期"><a href="#7-5-生命周期" class="headerlink" title="7.5 生命周期"></a>7.5 生命周期</h2><h3 id="7-5-1-生命周期"><a href="#7-5-1-生命周期" class="headerlink" title="7.5.1 生命周期"></a>7.5.1 生命周期</h3><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。</p><p>生命周期：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/lifecycle.png" alt="Vue life cycle"></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1540850010193.png" alt="1540850010193"></p><h3 id="7-5-2-钩子函数"><a href="#7-5-2-钩子函数" class="headerlink" title="7.5.2 钩子函数"></a>7.5.2 钩子函数</h3><p><strong>钩子函数</strong>：生命周期函数的别名；</p><ul><li>生命周期钩子 = 生命周期函数 = 生命周期事件</li><li>主要的生命周期函数分类：<ul><li>创建期间的生命周期函数：<ul><li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li><li><strong>created</strong>：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板【当 vm 实例的 data 和 methods 初始化完毕后，vm 实例会自动执行 created 函数】</li><li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li><li><strong>mounted</strong>：此时，已经将编译好的模板，挂载到了页面指定的容器中显示【如果要通过某些插件操作页面上的DOM元素节点，最早要在 mounted 中进行】</li></ul></li><li>运行期间的生命周期函数：<ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul></li><li>销毁期间的生命周期函数：<ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></li></ul></li></ul><ul><li>例1：created代表在vue实例创建后；</li></ul><p>我们可以在Vue中定义一个created函数，代表这个时期的构造函数：</p><p>html:</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    {{hello}}&lt;/div&gt;</code></pre><p>js:</p><pre><code class="js">&lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vm = new Vue({       el:&quot;#app&quot;,       data:{           hello:&#39;&#39;       },       created(){           this.hello = &#39;czdx,一统江湖，千秋万代&#39;       }    });&lt;/script&gt;</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1540845983254.png" alt="1540845983254"></p><ul><li>例2：</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;   &lt;head&gt;      &lt;meta charset=&quot;utf-8&quot; /&gt;      &lt;title&gt;vuejs生命周期&lt;/title&gt;      &lt;script src=&quot;vuejs-2.5.17.js&quot;&gt;&lt;/script&gt;   &lt;/head&gt;   &lt;body&gt;      &lt;div id=&quot;app&quot;&gt;         {{message}}      &lt;/div&gt;   &lt;/body&gt;   &lt;script&gt;      var vm = new Vue({         el: &quot;#app&quot;,         data: {            message: &#39;hello world&#39;         },         beforeCreate: function() {            showData(&#39;创建vue实例前&#39;, this);         },         created: function() {            showData(&#39;创建vue实例后&#39;, this);         },         beforeMount: function() {            showData(&#39;挂载到dom前&#39;, this);         },         mounted: function() {            showData(&#39;挂载到dom后&#39;, this);         },         beforeUpdate: function() {            showData(&#39;数据变化更新前&#39;, this);         },         updated: function() {            showData(&#39;数据变化更新后&#39;, this);         },         beforeDestroy: function() {            showData(&#39;vue实例销毁前&#39;, this);         },         destroyed: function() {            showData(&#39;vue实例销毁后&#39;, this);         }      });      function realDom() {         console.log(&#39;真实dom结构：&#39; + document.getElementById(&#39;app&#39;).innerHTML);      }      function showData(process, obj) {         console.log(process);         console.log(&#39;data 数据：&#39; + obj.message)         console.log(&#39;挂载的对象：&#39;)         console.log(obj.$el)         realDom();         console.log(&#39;------------------&#39;)         console.log(&#39;------------------&#39;)      }      vm.message = &quot;good...&quot;;      vm.$destroy();   &lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="7-5-3-this"><a href="#7-5-3-this" class="headerlink" title="7.5.3 this"></a>7.5.3 this</h3><p>我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this</p><pre><code class="js">var vm = new Vue({    el:&quot;#app&quot;,    data:{        hello: &#39;&#39; // hello初始化为空    },    created(){        this.hello = &quot;czdx,一统江湖，千秋万代&quot;;        console.log(this);    }})</code></pre><p> 控制台的输出：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1540846042618.png" alt="1540846042618"></p><h1 id="8-指令"><a href="#8-指令" class="headerlink" title="8. 指令"></a>8. 指令</h1><p><strong>指令</strong> (Directives)： 是带有 <code>v-</code> 前缀的特殊特性。指令特性的预期值是：<strong>单个 JavaScript 表达式</strong>。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 </p><p>例如我们在入门案例中的v-on，代表绑定事件。</p><h2 id="8-1-插值表达式"><a href="#8-1-插值表达式" class="headerlink" title="8.1 插值表达式"></a>8.1 插值表达式</h2><h3 id="8-1-1-大括号-u007B-u007B"><a href="#8-1-1-大括号-u007B-u007B" class="headerlink" title="8.1.1 大括号 u007B;u007B;"></a>8.1.1 大括号 u007B;u007B;</h3><ol><li><p>格式：</p><pre><code>u007B;u007B;表达式</code></pre><p>说明：</p></li></ol>]]></content>
    
    <summary type="html">
    
      Vue基础
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vue" scheme="/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Java线程状态</title>
    <link href="/2018/11/30/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>/2018/11/30/Java线程状态/</id>
    <published>2018-11-30T09:23:50.000Z</published>
    <updated>2019-06-10T01:35:58.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h1><p>网上流传了很久的线程具备5种状态，这样是不贴切JDK中描述的，JDK中描述线程状态只有6种，而网络流传的5种<br>状态就是进程的五态模型。那张广为流传的来自网络的图如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1542897157060.png" alt="1542897157060"></p><p>很明显这是操作系统中进程的5种状态，在很多操作系统书中也由介绍分别为new，ready，running，waiting，<br>terminated。不幸的是，有很多的书上常常把这些进程状态，线程状态与Java线程状态混在一起谈。</p><p>进程与线程的区分总图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1542897357723.png" alt="1542897357723"></p><blockquote><ol><li>很多人觉得在JVM线程中应该有，Running运行状态。对JAVA而言，Runnable包含了就绪与运行，那为<br>什么JAVA不区分开呢？这跟CPU分配的时间片有关，而且JAVA进行的是抢占式轮转调度，由于我们的JVM线程是服务于监控，线程又是切换的如此之快，那么区分ready与running又没有多大意义了。<br>再者，我们都知道现在使用的很多JVM底层都将线程映射到操作系统上了，JVM本身没有做什么调度，因为虚拟机看到的都是底层的映射与封装，故而将ready与running映射来也没有太大意义，不如统一为Runnable</li><li>总之还是有些乱的，我们不妨就拿Windows系统为例，用的就是“进程”和“线程”这两种较为标准的叫法，<br>这时一个进程下至少有一个线程，<strong>线程是CPU调度的基本单位</strong>，<strong>进程不参与CPU调度</strong>，CPU根本不知道进程的存在。</li><li>为了避免混乱，下面说的线程状态，只是站在JVM层面上</li></ol></blockquote><p>我们先来看下，这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1543039901810.png" alt="1543039901810"></p><table><thead><tr><th style="text-align:center">线程状态</th><th style="text-align:center">导致状态发生条件</th></tr></thead><tbody><tr><td style="text-align:center">NEW(新建)</td><td style="text-align:center">线程刚被创建，但是并未启动</td></tr><tr><td style="text-align:center">Runnable(可运行)</td><td style="text-align:center">线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器</td></tr><tr><td style="text-align:center">Blocked(锁阻塞)</td><td style="text-align:center">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态</td></tr><tr><td style="text-align:center">Waiting(无限等待)</td><td style="text-align:center">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</td></tr><tr><td style="text-align:center">Timed Waiting(计时等待)</td><td style="text-align:center">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td style="text-align:center">Teminated(被终止)</td><td style="text-align:center">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡</td></tr></tbody></table><blockquote><ol><li>初始(NEW)：新创建了一个线程对象，但还没有调用 <code>start()</code> 方法。</li><li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）</li><li>阻塞(BLOCKED)：表示线程阻塞于锁</li><li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）</li><li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回</li><li>终止(TERMINATED)：表示该线程已经执行完毕</li></ol></blockquote><h2 id="1-NEW-新建-状态"><a href="#1-NEW-新建-状态" class="headerlink" title="1. NEW(新建)状态"></a>1. NEW(新建)状态</h2><blockquote><p>概念：线程对象创建了，但是还没有启动之前，就是新建状态</p></blockquote><p>实现 <code>Runnable接口</code> 或继承 <code>Thread</code> 可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p><p>这里强调两点：</p><ul><li>线程对象创建之后，还未开启( 调用start()方法 )时候，就处于NEW的状态</li><li>开启线程，指的是调用start方法，并不是run方法，run方法仅仅作为一个普通方法存在</li></ul><blockquote><p>线程对象调用 <code>run()</code> 方法不开启线程，仅是对象调用方法。线程对象调用 <code>start()</code> 方法开启线程，并让jvm调用 <code>run()</code> 方法在开启的线程中执行</p></blockquote><p>当我们执行 <code>new Thread(target)</code> 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 <code>Runnable</code> (可运行)状态。</p><blockquote><p>在我们研究线程状态时，采用Thread中的getState()方法进行研究</p></blockquote><p>通过代码演示：</p><pre><code class="java">public class MyThread extends Thread{    @Override    public void run() {        // 线程执行的代码    }}</code></pre><pre><code class="java">/** * 研究新建线程状态 *   新建状态：至今还未启动的线程处于这一状态 */public class ThreadStateTest1 {    public static void main(String[] args) {        // 创建线程对象        MyThread myThread = new MyThread();        // 线程默认名：Thread-0 Thread-1...        System.out.println(myThread.getName());        System.out.println(&quot;线程创建之后处于：&quot; + myThread.getState());        myThread.run();        System.out.println(&quot;线程run之后处于：&quot; + myThread.getState());        myThread.start();        System.out.println(&quot;线程start之后处于：&quot; + myThread.getState());    }}// 输出：//   线程创建之后处于：NEW//   线程run之后处于：NEW//   线程start之后处于：RUNNABLE</code></pre><blockquote><p>当我们执行 <code>new Thread(target)</code> 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 <code>Runnable</code> (可运行)状态。所以说</p><p>当业务需要频繁创建线城市，最好使用线程池，提高效率减轻JVM的压力。当然如果大量线程进行频繁上下文切换，此时多线程的效率会大打折扣。</p></blockquote><h2 id="2-RUNNABLE-可运行-状态"><a href="#2-RUNNABLE-可运行-状态" class="headerlink" title="2. RUNNABLE(可运行)状态"></a>2. RUNNABLE(可运行)状态</h2><blockquote><p>可运行状态：一个在JVM中执行的线程处于这个状态中，等待JVM调度，德能在执行，也可能在等待</p></blockquote><blockquote><p>注：这里的等待指的是等待调度，等待的是系统资源，如IO、CPU时间片，与 sleep、lock 的等待有着本质差别。</p></blockquote><p>接下来使用代码演示一个最简单的可运行状态：</p><pre><code class="java">public class MyThread extends Thread {    @Override    public void run() {        System.out.println(&quot;线程开始执行&quot;);        System.out.println(&quot;线程开始执行具体的任务&quot;);        // 假设这个任务使用5秒钟        long beiginTime = System.currentTimeMillis();        while (System.currentTimeMillis()-beiginTime &lt; 5000){            // 假设做了5秒钟的任务        }        System.out.println(&quot;线程执行完毕&quot;);    }}</code></pre><pre><code class="java">/** * 可运行状态 *   当线程有资格运行，调用了start方法，线程首先进入可运行状态 *   这种可运行状态不一定被线程调度运行 *   简单来说，调用start方法之后，该线程处于可运行状态，但未运行 *   此时存放在&quot;可运行池&quot;中 *   线程在运行的过程中，自然该线程也是处于可运行状态 * *   JDK中处于可运行状态的线程，有两种，一种是正在JVM中运行， *   另一种是可能正在等待操作系统其它资源，比如处理器 */public class Demo {    public static void main(String[] args) {        // 创建线程对象        MyThread myThread = new MyThread();        System.out.println(&quot;创建完成之后：&quot; + myThread.getState());        // 开启线程        myThread.start();        System.out.println(&quot;开启线程之后：&quot; + myThread.getState());    }}</code></pre><h2 id="3-BLOCHED-阻塞-状态"><a href="#3-BLOCHED-阻塞-状态" class="headerlink" title="3. BLOCHED(阻塞)状态"></a>3. BLOCHED(阻塞)状态</h2><p>我们还是使用代码来解析一下锁阻塞状态：</p><pre><code class="java">public class ThreadA extends Thread {    private Object obj;    public ThreadA(String name,Object obj){        super(name);        this.obj = obj;    }    @Override    public void run() {        // 同步代码块        synchronized (obj){            System.out.println(&quot;线程A开始执行&quot;);            System.out.println(&quot;线程A真正开始执行代码了&quot;);            long beginTime = System.currentTimeMillis();            // 模拟5秒钟的任务            while(System.currentTimeMillis()-beginTime &lt; 5000){            }            System.out.println(&quot;线程A执行完毕&quot;);        }    }}</code></pre><pre><code class="java">public class ThreadB extends Thread{    private Object obj;    public ThreadB(String name,Object obj){        super(name);        this.obj = obj;    }    @Override    public void run() {        // 同步代码块        synchronized (obj){            System.out.println(&quot;线程B开始执行&quot;);            System.out.println(&quot;线程B真正开始执行代码了&quot;);            long beginTime = System.currentTimeMillis();            // 模拟5秒钟的任务            while(System.currentTimeMillis()-beginTime &lt; 5000){            }            System.out.println(&quot;线程B执行完毕&quot;);        }    }}</code></pre><pre><code class="java">/** * 线程状态之阻塞状态BLOCKED *    JDK：锁阻塞并且正在等待监视器锁的某一线程状态 *    处于受阻状态的某一线程正在等待监视器锁，以便进入一个同步代码块/同步方 *    还有就是 调用Object.wart方法之后，再次进入同步中时 * */public class BlockedDemo {    public static void main(String[] args) throws InterruptedException {        // 创建一个锁对象        Object obj = new Object();        // 创建线程A、B        ThreadA a = new ThreadA(&quot;线程A&quot;, obj);        ThreadB b = new ThreadB(&quot;线程B&quot;, obj);        // 开启线程        a.start();        b.start();        //        Thread.sleep(3000);        System.out.println(&quot;线程A的状态是：&quot; + a.getState());        System.out.println(&quot;线程B的状态是：&quot; + b.getState());        //        Thread.sleep(3000);        System.out.println(&quot;线程A的状态是：&quot; + a.getState());        System.out.println(&quot;线程B的状态是：&quot; + b.getState());    }}</code></pre><p>在这里我们只是对之前分析的情况一进行了阐释</p><h2 id="4-Timed-Waiting-计时等待-状态"><a href="#4-Timed-Waiting-计时等待-状态" class="headerlink" title="4. Timed Waiting(计时等待)状态"></a>4. Timed Waiting(计时等待)状态</h2><blockquote></blockquote><p>带指定的等待时间的等待线程所处的状态。一个线程处于这一状态是因为用一个指定的正的等待时间（为参数）调用了一下方法中的其一：</p><ul><li>Thread.sleep</li><li>带时限（timeout）的 Object.wait</li><li>带时限（timeout）的 Thread.join</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul><p>Timed Waiting 在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？</p><p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p><blockquote><p>注：sleep的使用时区别去其他方法的。</p></blockquote><p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting（计时等待），那么我们通过一个案例加深对该状态的一个理解：</p><p>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</p><p>代码：</p><pre><code class="java">/** * 限时等待 */public class MyThread extends Thread {    public static void main(String[] args) {        MyThread myThread = new MyThread();        myThread.start();        for (int i = 0; i &lt; 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(&quot;mt的线程状态： &quot; + myThread.getState());        }    }    // 实现一个计算器，0-99计数，在每个数字之间暂停1秒，每个10个数字输出一个字符串    @Override    public void run() {        for (int i = 0; i &lt; 99; i++) {            if (i%10 == 0){                System.out.println(&quot;oewewowllskd &quot; + i);            }            System.out.println(i);            try {                Thread.sleep(1000);                System.out.println(&quot;    休息了1秒&quot;);            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><p>通过案例可以发西咸，sleep方法的使用还是很简单的。我们需要记住下面几点：</p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep() 的调用放线程run()之内，这样才能保证该线程执行过程中会睡眠</li><li>sleep 与锁无关，线程睡眠到期自动苏醒，并返回到 Runnable（可运行）状态</li></ol><blockquote><p>小提示：sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep() 方法不能保证该线程睡眠到期后就开始立刻执行</p></blockquote><h2 id="5-WAITING-无限等待-状态"><a href="#5-WAITING-无限等待-状态" class="headerlink" title="5. WAITING(无限等待)状态"></a>5. WAITING(无限等待)状态</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p><p>一个线程进入 WAITING 状态是因为调用了以下方法：</p><ul><li>不带时限的 Object.wait 方法</li><li>不带时限的 Thread.join 方法</li><li>LockSupport.park</li></ul><p>然后会等其他线程执行一个特别的动作，比如：</p><ul><li>一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 或 Object.notifyAll()</li><li>一个调用了 Thread.join 方法的线程会等待指定的线程结束</li></ul><p>代码演示：</p><pre><code class="java">/** * 无限等待 *   Object中的wait方法完成 *     使用当前线程 进入无限等待状态，直到其他线程有唤醒 notify 或 notifyAll 才能被唤醒 * *     线程间通信 两个线程执行不同的操作 关联的 *       两个线程 使用同样的锁 只能使用锁对象调用wait方法或者notify方法 */public class WaitingTest {    private static Object obj = new Object();    public static void main(String[] args) throws InterruptedException {        // 使用匿名函数创建线程        Thread t1 = new Thread() {            @Override            public void run() {                synchronized (obj){                    System.out.println(&quot;获取到锁，调用wait方法，当前线程进入无线等待状态。。。等待着别的线程来唤醒&quot;);                    try {                        obj.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(&quot;唤醒了这个线程，就不再是线程等待了，线程执行完毕&quot;);                }            }        };        // 开启线程t1        t1.start();        // 使用匿名内部内方式创建一个新的线程，用来唤醒t1线程        new Thread(){            @Override            public void run() {                // 获取到锁                synchronized (obj){                    try {                        // 3秒钟后执行唤醒操作                        Thread.sleep(3000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(&quot;获取到锁 执行 唤醒操作&quot;);                    // 唤醒操作                    obj.notify();                }            }        }.start();        // 4秒后查看线程t1状态        Thread.sleep(4000);        System.out.println(&quot;查看t1的线程状态&quot; + t1.getState());    }}</code></pre><p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 方法或 Object.notifyAll() 方法</p><p>其实 waiting 状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，<br>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司了你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作一完成某些任务。</p><h2 id="6-TEMINATED-终止-状态"><a href="#6-TEMINATED-终止-状态" class="headerlink" title="6. TEMINATED(终止)状态"></a>6. TEMINATED(终止)状态</h2><p>线程因如下两个原因之一将被终止：</p><ol><li>run() 方法正常退出而自然死亡</li><li>一个没有捕获的异常终止了 run() 方法而意外死亡</li></ol><h1 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h1><h2 id="1-wait-notify-notifyAll-等方法介绍"><a href="#1-wait-notify-notifyAll-等方法介绍" class="headerlink" title="1. wait(), notify(), notifyAll()等方法介绍"></a>1. wait(), notify(), notifyAll()等方法介绍</h2><p>在Object.java中，定义了wait(), notify()和notifyAll()等接口。<strong><code>wait()</code> 的作用是让当前线程进入等待状态</strong>，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；<strong><code>notify()</code> 是唤醒单个线程</strong>，<strong>而 <code>notifyAll()</code> 是唤醒所有的线程</strong>。</p><p>Object类中关于等待/唤醒的API详细信息如下：<br><strong>notify()</strong>        – 唤醒在此对象监视器上等待的单个线程。<br><strong>notifyAll()</strong>   – 唤醒在此对象监视器上等待的所有线程。<br><strong>wait()</strong>                                         – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout)</strong>                    – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout, int nanos)</strong>  – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>]]></content>
    
    <summary type="html">
    
      Java线程状态
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java线程" scheme="/tags/Java%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="/2018/11/30/Flex%E5%B8%83%E5%B1%80/"/>
    <id>/2018/11/30/Flex布局/</id>
    <published>2018-11-30T09:12:44.000Z</published>
    <updated>2019-06-10T01:36:05.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex-布局教程：语法篇"><a href="#Flex-布局教程：语法篇" class="headerlink" title="Flex 布局教程：语法篇"></a>Flex 布局教程：语法篇</h1><p>作者： <a href="http://www.ruanyifeng.com/blog//" target="_blank" rel="noopener">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2015/07/" target="_blank" rel="noopener">2015年7月10日</a></p><p>网页布局（layout）是 CSS 的一个重点应用</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071001.gif?raw=true" alt="img"></p><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">垂直居中</a>就不容易实现。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071002.png" alt="img"></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071003.jpg" alt="img"></p><p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">下一篇文章</a>给出常见布局的 Flex 写法。网友<a href="http://vgee.cn/" target="_blank" rel="noopener">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html" target="_blank" rel="noopener">Demo</a>，也可以参考。</p><p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="noopener">A Visual Guide to CSS3 Flexbox Properties</a>。</p><h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><blockquote><pre><code class="css">.box{  display: flex;}</code></pre></blockquote><p>行内元素也可以使用 Flex 布局。</p><blockquote><pre><code class="css">.box{  display: inline-flex;}</code></pre></blockquote><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><blockquote><pre><code class="css">.box{  display: -webkit-flex; /* Safari */  display: flex;}</code></pre></blockquote><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071004.png" alt="img"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、容器的属性-紫色大盒子"><a href="#三、容器的属性-紫色大盒子" class="headerlink" title="三、容器的属性  (紫色大盒子) *"></a>三、容器的属性  (紫色大盒子) *</h2><p>以下6个属性设置在容器上。</p><blockquote><ul><li>flex-direction  √</li><li>flex-wrap  √</li><li>flex-flow</li><li>justify-content  √</li><li>align-items √</li><li>align-content</li></ul></blockquote><h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性 **"></a>3.1 flex-direction属性 **</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><blockquote><pre><code>.box {  flex-direction: row | row-reverse | column | column-reverse;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071005.png" alt="img"></p><p>它可能有4个值。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性 **"></a>3.2 flex-wrap属性 **</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071006.png" alt="img"></p><blockquote><pre><code>.box{  flex-wrap: nowrap | wrap | wrap-reverse;}</code></pre></blockquote><p>它可能取三个值。</p><p>（1）<code>nowrap</code>（默认）：不换行。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071007.png" alt="img"></p><p>（2）<code>wrap</code>：换行，第一行在上方。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071008.jpg" alt="img"></p><p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071009.jpg" alt="img"></p><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><blockquote><pre><code>.box {  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;}</code></pre></blockquote><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性  **"></a>3.4 justify-content属性  **</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><blockquote><pre><code class="css">.box {  justify-content: flex-start | flex-end | center | space-between | space-around;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071010.png" alt="img"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性 **"></a>3.5 align-items属性 **</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><blockquote><pre><code>.box {  align-items: flex-start | flex-end | center | baseline | stretch;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071011.png" alt="img"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><blockquote><pre><code>.box {  align-content: flex-start | flex-end | center | space-between | space-around | stretch;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071012.png" alt="img"></p><p>该属性可能取6个值。</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h2 id="四、项目的属性-橙色小盒子"><a href="#四、项目的属性-橙色小盒子" class="headerlink" title="四、项目的属性  (橙色小盒子) *"></a>四、项目的属性  (橙色小盒子) *</h2><p>以下6个属性设置在项目上。</p><blockquote><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul></blockquote><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><blockquote><pre><code>.item {  order: &lt;integer&gt;;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071013.png" alt="img"></p><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><blockquote><pre><code>.item {  flex-grow: &lt;number&gt;; /* default 0 */}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071014.png" alt="img"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><blockquote><pre><code>.item {  flex-shrink: &lt;number&gt;; /* default 1 */}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071015.jpg" alt="img"></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><blockquote><pre><code>.item {  flex-basis: &lt;length&gt; | auto; /* default auto */}</code></pre></blockquote><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性 **"></a>4.5 flex属性 **</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><blockquote><pre><code>.item {  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]}</code></pre></blockquote><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><blockquote><pre><code>.item {  align-self: auto | flex-start | flex-end | center | baseline | stretch;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071016.png" alt="img"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
    
    <summary type="html">
    
      Flex布局
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Flex" scheme="/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2018/11/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>/2018/11/30/Linux常用命令/</id>
    <published>2018-11-30T08:19:55.000Z</published>
    <updated>2019-06-10T01:35:51.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux介绍（了解）"><a href="#1-Linux介绍（了解）" class="headerlink" title="1. Linux介绍（了解）"></a>1. Linux介绍（了解）</h1><h2 id="1-1、Linux和Windows的区别"><a href="#1-1、Linux和Windows的区别" class="headerlink" title="1.1、Linux和Windows的区别"></a>1.1、Linux和Windows的区别</h2><p>Linux是一款操作系统。正规开发服务器项目部署都是放在Linux操作系统上。</p><p>Windows一款操作系统，民用操作系统。娱乐、影音、上网。</p><h2 id="1-2、Linux历史及使用场景"><a href="#1-2、Linux历史及使用场景" class="headerlink" title="1.2、Linux历史及使用场景"></a>1.2、Linux历史及使用场景</h2><p>Linux诞生90年代，仿制Unix操作系统。</p><p>Linux是免费的，开源的</p><p>Unix是收费的，封闭的。 </p><p>Linux使用场景：<strong>服务器操作系统</strong>，移动设备（安卓手机，平板电脑），路由器（WIFI），交换机，智能家居，Java程序开发</p><h2 id="1-3、Linux的版本"><a href="#1-3、Linux的版本" class="headerlink" title="1.3、Linux的版本"></a>1.3、Linux的版本</h2><p>Linux的版本分为两种：内核版本(<a href="https://www.kernel.org/)和发行版本" target="_blank" rel="noopener">https://www.kernel.org/)和发行版本</a></p><p>Linux内核版本：Linux内核运维开发小组。 源码在一定程度上不是开源的。</p><p>Linux发行版本：由各大互联网/软件公司定制。 外围的样式功能的源码完全开源</p><p>一个内核版本是有多种多样的发行版本 </p><p>Ubuntu：以强大的桌面应用为主，吸收不少Windows用户。</p><ul><li>因为桌面应用会在一定程度上大量占用系统资源，开发。</li><li>服务器部署上，不会优先选择Ubuntu</li></ul><p><strong>CentOS</strong>：对服务器性能进行了一定程度的优化，性能比较高，比较稳定。</p><ul><li>服务器操作系统的优选CentOS</li></ul><h1 id="2、Linux安装【重点】"><a href="#2、Linux安装【重点】" class="headerlink" title="2、Linux安装【重点】"></a>2、Linux安装【重点】</h1><h2 id="2-1、虚拟机、Linux安装"><a href="#2-1、虚拟机、Linux安装" class="headerlink" title="2.1、虚拟机、Linux安装"></a>2.1、虚拟机、Linux安装</h2><h2 id="2-2、CentOS安装jdk、tomcat、mysql"><a href="#2-2、CentOS安装jdk、tomcat、mysql" class="headerlink" title="2.2、CentOS安装jdk、tomcat、mysql"></a>2.2、CentOS安装jdk、tomcat、mysql</h2><h2 id="2-3、Linux目录介绍"><a href="#2-3、Linux目录介绍" class="headerlink" title="2.3、Linux目录介绍"></a>2.3、Linux目录介绍</h2><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538621186769.png" alt="1538621186769"></p><ul><li><p><strong>/</strong>：<strong>Linux系统根目录</strong></p></li><li><p><strong>/etc</strong>：(etcetera) <strong>系统配置文件存放的目录</strong>，不建议在此目录下存放可执行文件。</p><p>重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。</p><p>注：/etc/X11存放与 x windows 有关的设置（防火墙文件，网络设置文件，JDK环境配置文件，mysql）</p></li><li><p><strong>home</strong>:存放所有普通用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用<code>~user</code>表示</p></li><li><p><strong>/root</strong>： <strong>系统管理员root(超级用户)的家目录</strong>，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下</p><p>每一个用户都有家目录，超级管理员root家目录  /root</p><p>Linux命令行模式中相当于Windows的桌面</p></li><li><p><strong>/usr</strong>：(unix shared resources)：<strong>应用程序存放目录</strong>，比较重要的目录<code>/usr/local</code>本地系统管理员软件安装目录（安装系统级的应用）</p><p>/usr/bin 存放应用程序</p><p>/usr/share 存放共享数据</p><p>/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</p><p>/usr/local:存放软件升级包</p><p>/usr/share/doc: 系统说明文件存放目录</p><p>/usr/share/man: 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间。<br>​    Jdk,tomcat,mysql,redis,nginx</p></li><li><p><strong>/opt</strong>：<strong>额外安装的可选应用程序包</strong>所放置的位置。一般情况下，我们可以把tomcat等都安装到这里</p></li></ul><p>以上建议并不是强制性约束</p><h2 id="2-4-网络三种连接方式"><a href="#2-4-网络三种连接方式" class="headerlink" title="2.4 网络三种连接方式"></a>2.4 网络三种连接方式</h2><h3 id="2-4-1-桥接模式"><a href="#2-4-1-桥接模式" class="headerlink" title="2.4.1 桥接模式"></a>2.4.1 桥接模式</h3><p><strong>桥接模式</strong>(Bridged)：虚拟机是一台独立的电脑，直接连接到实际的网络上，与宿主机没有任何联系。</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1543535328477.png" alt="1543535328477"></p><h3 id="2-4-2-仅主机模式"><a href="#2-4-2-仅主机模式" class="headerlink" title="2.4.2 仅主机模式"></a>2.4.2 仅主机模式</h3><blockquote><p>这种方式下，虚拟机的网卡连接到宿主的 VMnet1 上，但系统并不为虚拟机提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。</p></blockquote><p> <strong>仅主机模式</strong>(host-only)：虚拟机可以访问宿主机，宿主机无法访问虚拟机，虚拟机无法上网</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1543535410144.png" alt="1543535410144"></p><h3 id="2-4-3-NAT-模式"><a href="#2-4-3-NAT-模式" class="headerlink" title="2.4.3 NAT 模式"></a>2.4.3 NAT 模式</h3><blockquote><p>这种方式下，虚拟机的网卡连接到宿主的 VMnet8 上。此时系统的 VMWare NAT Service 服务就充当了路由器的作用，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。VMWare DHCP Service 负责为虚拟机提供 DHCP 服务。</p></blockquote><p><strong>NAT模式</strong>：</p><ul><li><p>虚拟机可以访问宿主机，宿主机可以访问虚拟机</p></li><li><p>此时宿主机相当于路由器，虚拟机可以通过宿主机上网</p></li><li><p>宿主机可以配置254个虚拟机 </p></li></ul><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1543535431117.png" alt="1543535431117"></p><h1 id="3、常用命令【重点】"><a href="#3、常用命令【重点】" class="headerlink" title="3、常用命令【重点】"></a>3、常用命令【重点】</h1><p>Linux命令中参数，一般都是无序的。特殊情况下除外</p><p>注意：Linux中的命令<strong>严格区分大小写</strong>的！</p><h2 id="3-1、磁盘管理命令"><a href="#3-1、磁盘管理命令" class="headerlink" title="3.1、磁盘管理命令"></a>3.1、磁盘管理命令</h2><h3 id="ls-列出目录内容"><a href="#ls-列出目录内容" class="headerlink" title="ls 列出目录内容"></a><em>ls</em> 列出目录内容</h3><ol><li><p>ls（list）功能：列出目录内容</p></li><li><p>格式：</p><pre><code class="shell">ls [参数] [文件或目录]# 参数-a或--all   查询所有文件和文件夹，包含隐藏。注意隐藏文件、特殊目录、. 和 ..-l           查询详细列表    ls -l--&gt;简写：ll-h             友好展示信息    ll -h (d目录，-普通文件, l链接)-t          用文件和目录的更改时间排序。-r             反向排序--help       在线帮助</code></pre></li><li><p>常用：</p><pre><code>ls -l        --&gt; 此命令非常常用，提供简化版命令 llls -alll /home/    --&gt; 显示指定目录下的内容</code></pre></li><li><p>eg:</p><pre><code>需求：展示某个目录下的内容    ls 目录名所在位置：/root想要查看:/etc目录下的内容命令：ll -h /etc</code></pre></li></ol><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd 切换目录"></a><em>cd</em> 切换目录</h3><ol><li><p>cd(change directory) 功能：切换目录</p></li><li><p>语法：</p><pre><code class="shell"># 格式cd [目录]# 常用cd /目录名   ，任意目录切换到指定目录中     /目录名--&gt;Linux的绝对路径                                       windows绝对路径--&gt;c:/xxxx/xxx.jpg?raw=truecd ../      ，向上一层目录cd ~        ，切换到当前用户 家目录。root用户家目录 /rootcd /        ，切换到Linux的 根目录cd -          ，切换到上一次访问的目录。   只能两个目录相互切换cd ..        ，上一级目录cd            ，缺省当前用户目录</code></pre></li></ol><ul><li><strong>Linux绝对</strong>：  <ul><li>eg：<code>cd /etc/x1</code>   先切换到 /目录，然后在 /目录 中找到子目录 etc，在 etc 中找 子目录x1</li><li>特点：在任意目录都可以随意切换</li></ul></li><li><strong>Linux相对</strong>：<ul><li>eg：<code>cd x1/x2</code>   在当前目录中寻找子目录x1, 在x1中寻找子目录x2</li><li>特点：必须确定 当前目录 下有子目录x1</li></ul></li></ul><h3 id="pwd-显示当前的所在目录"><a href="#pwd-显示当前的所在目录" class="headerlink" title="pwd 显示当前的所在目录"></a><em>pwd</em> 显示当前的所在目录</h3><ul><li>pwd(print working directory) 功能：显示工作目录(当前的所在目录)。返回绝对路径</li></ul><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a><em>mkdir</em> 创建目录</h3><ol><li><p>mkdir（make directoriy）功能： 创建目录</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式mkdir -p 文件夹名称# 参数-p  父目录不存在情况下先生成父目录 （parents）-v    显示命令执行过程中的详细信息</code></pre></li><li><p>注意：</p><p>使用<code>mkdir</code>创建带后缀的文件时，创建的是<strong>目录</strong>，不是文件（创建文件使用<code>touch</code>命令）</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539658915126.png" alt="1539658915126"> </p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539659032657.png" alt="1539659032657"> </p></li><li><p>eg:</p><pre><code class="shell"># 1需要在/root/t1目录下创建一个t2目录位置：/root命令：相对路径：mkdir t1/t2绝对：mkdir /root/t1/t2# 2需要在/root/t3目录下创建一个t4目录位置：/root条件：t3和t4都不存在命令：mkdir -p t3/t4</code></pre></li></ol><h3 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir 删除空目录"></a><em>rmdir</em> 删除空目录</h3><ul><li>rmdir(remove directory) 功能：删除空目录</li></ul><h3 id="指令快捷键"><a href="#指令快捷键" class="headerlink" title="指令快捷键"></a>指令快捷键</h3><ol><li><p>历史输入<br>使用上、下箭头可以找出上一条指令和下一条指令</p></li><li><p>Tab代码补全<br>使用tab键可以快速输入指令<br>比如：我要输入shutdown指令，这时，我们可以只输入shut然后按下tab键，即可自动把shutdown补全</p><p><strong>注意</strong>：使用两下Tab补全时，如果匹配的结果有多个，这时候将会把所有匹配的结果展示出来。当结果很多时将会出现以下结果：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539654279277.png" alt="1539654279277"> </p><p>按<code>y</code>之后会列出所有匹配的结果，但因为129个比较多，而在电脑中无法一次全显示出来，所以先显示一部分：（More代表还有更多，这时按<code>回车</code>就可以向下滚动，按下<code>Ctrl+C</code>将会退出）</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539654354678.png" alt="1539654354678"> </p></li></ol><h2 id="3-2、文件浏览-管理-命令"><a href="#3-2、文件浏览-管理-命令" class="headerlink" title="3.2、文件浏览(管理)命令"></a>3.2、文件浏览(管理)命令</h2><p>日志文件,XML,properties文件</p><h3 id="cat-快捷查看当前文件的内容"><a href="#cat-快捷查看当前文件的内容" class="headerlink" title="cat 快捷查看当前文件的内容"></a><em>cat</em> 快捷查看当前文件的内容</h3><ol><li><p>cat（catenate）功能：快捷查看当前文件的内容</p><p>cat适合查看少量信息的文件</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式cat 文件名</code></pre></li></ol><h3 id="more-分页显示文件内容"><a href="#more-分页显示文件内容" class="headerlink" title="more 分页显示文件内容"></a><em>more</em> 分页显示文件内容</h3><ol><li><p>more功能：分页显示文件内容，还支持直接跳转行等功能</p></li><li><p><strong>语法</strong>：</p><pre><code>more 文件名</code></pre></li><li><p>操作：</p><pre><code>Enter    向下n行，需要定义。默认为1行空格键    向下滚动一屏 或 Ctrl+FB        返回上一屏 或 Ctrl+Bq        退出more</code></pre></li></ol><h3 id="less-分页显示文件内容"><a href="#less-分页显示文件内容" class="headerlink" title="less 分页显示文件内容"></a><em>less</em> 分页显示文件内容</h3><ol><li><p>less功能：分页显示文件内容，操作更详细</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式less -mN 文件名 # 参数-m  显示类似more命令的百分比-N  显示每行的行号</code></pre></li><li><p>操作：</p><pre><code class="shell">Enter    向下n行，需要定义。默认为1行空格键    向下滚动一屏 或 Ctrl+F    B    返回上一屏 或 Ctrl+B    q    退出more    d    前进半页    u    后退半页回车键    前进一行 或 方向键向下    y    后退一行    或 方向键向上    v    进入vim编辑器/字符串   向下搜索?字符串   向上搜索左右方向键 相当于水平滚动条</code></pre></li><li><p>特点：</p><p>适用于<strong>大量数据</strong>的查看</p></li></ol><h3 id="tail-指定文件末尾内容"><a href="#tail-指定文件末尾内容" class="headerlink" title="tail 指定文件末尾内容"></a><em>tail</em> 指定文件末尾内容</h3><ol><li><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式tail[必要参数][选择参数][文件]# 参数-n&lt;行数&gt;    显示行数-f         循环读取</code></pre></li><li><p>eg：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image001.png" alt="img"></p><ul><li>&amp; 表示后台运行，否则占用终端</li><li>ctrl + c 退出</li></ul></li></ol><h2 id="3-3、文件操作命令"><a href="#3-3、文件操作命令" class="headerlink" title="3.3、文件操作命令"></a>3.3、文件操作命令</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ol><li><p>隐藏文件</p><p>Linux中以 点<code>.</code> 开头的是隐藏文件，使用<code>ls</code>命令是查看不到的，需使用<code>ls -a</code></p></li><li><p>目录与文件的区别</p><p>当我们使用ls命令列出目录中的所有子目录和文件时，如何区分哪些是文件哪些是目录？<br>可以通过详细信息中第一列的信息来区分：以 <code>d</code> 开头的是目录，以 <code>-</code> 开头的是文件</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539658318279.png" alt="1539658318279"> </p></li></ol><h3 id="touch创建文件"><a href="#touch创建文件" class="headerlink" title="touch创建文件"></a><em>touch</em>创建文件</h3><ol><li><p>功能：创建文件</p></li><li><p>语法：</p><pre><code class="shell">touch 绝对路径/相对路径</code></pre></li></ol><h3 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp 复制"></a><em>cp</em> 复制</h3><ol><li><p>cp（copy）：复制文件或者复制目录</p></li><li><p>复制<strong>文件</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell">cp 需要复制的文件 复制的位置</code></pre><p>注意：cp可以进行重命名操作：</p><ul><li><p>cp demo1.java t1/ddd.java</p><p>当将一个 文件位置 以不同名字复制到<strong>当前文件</strong>时，意思是复制并重命名；即 将demo1.java复制到t1目录中，并重命名成ddd.java</p></li></ul></li><li><p>eg：</p><pre><code>需求：把/root/Demo1.java文件 复制到  /root/t1 目录中位置：/root命令：cp Demo1.java t1     cp /root/Demo1.java /root/t1需求：把/root/Demo1.java文件 复制到  /root/t1 目录中，改名为ddd.java位置：/root命令：cp Demo1.java t1/ddd.java</code></pre></li></ul></li><li><p>复制<strong>目录</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式cp -r 需要复制的目录 复制的位置# 参数-r或--recursive  递归处理，将指定目录下的文件与子目录一并处理 复制目录必须使用-r</code></pre></li></ul></li></ol><ul><li><p>eg：</p><pre><code>需求：把/root/t5目录 复制到  /root/t1目录中位置：/root命令：cp -r t5 t1     cp -r /root/t5 /root/t1cp ./abc ./xxx                #无法复制目录cp -r ./abc ./xxx            #复制目录必须使用 -r参数</code></pre></li></ul><h3 id="mv-移动、更名"><a href="#mv-移动、更名" class="headerlink" title="mv 移动、更名"></a><em>mv</em> 移动、更名</h3><ol><li><p>mv(move) 功能： <strong>移动</strong> 或 <strong>更名</strong> 现有的文件或目录</p></li><li><p>移动<strong>文件</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式mv -f 需要移动的文件 移动的位置# 参数-f或--force 　若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录，不进行询问</code></pre></li><li><p>eg：</p><pre><code>需求：把/root/t5 目录 移动到 /root/t3目录中位置：/root命令：mv t5 t3需求：把/root/t5 目录 移动到 /root/t3目录中        不询问，直接覆盖位置：/root已知：/root/t3目录中 已经有一个t5目录了命令：mv -f t5 t3</code></pre></li></ul></li><li><p>文件<strong>更名</strong>：</p><ul><li><p>格式：</p><pre><code class="shell">mv 需要移动的文件 新名字## 必须是在同一目录中进行此操作</code></pre></li><li><p>eg：</p><pre><code>文件/目录更名操作：需求：把/root/Demo1.java  改名为 hehe.java位置：/root命令：mv Demo1.java hehe.java</code></pre></li></ul></li></ol><h3 id="rm-删除"><a href="#rm-删除" class="headerlink" title="rm 删除"></a><em>rm</em> 删除</h3><ol><li><p>rm(remove) 功能：删除文件或目录</p></li><li><p>删除<strong>文件</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell">rm 文件名</code></pre></li></ul></li><li><p>删除<strong>目录</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式rm -rf 目录名# 参数-f或--force 　        强制删除文件或目录，不进行询问-r或-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。删除目录必须使用-r</code></pre></li></ul></li><li><p><strong>注意</strong>：</p><pre><code class="shell">rm -rf *     删除 当前目录 下所有内容rm –rf /*    删除Linux系统 根目录 下所有内容</code></pre></li><li><p>eg：</p><pre><code>需求：删除/root/t5 目录， 位置：/root已知：t5目录下有子目录或者文件命令：rm -rf t5</code></pre></li></ol><h3 id="find-查找"><a href="#find-查找" class="headerlink" title="find 查找"></a><em>find</em> 查找</h3><ol><li><p>find功能：查找文件或目录</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell">find 目录名 -name &#39;需要查找的字符串&#39;-name 指定字符串作为寻找文件或目录的范本样式* 表示0~多个任意字符 eg：find t1 -name &#39;*.txt&#39;</code></pre></li><li><p>eg:</p><pre><code>需求：查找/root目录下 所有以ins开头的文件或者目录位置：/root命令：find /root -name &#39;ins*&#39;</code></pre></li></ol><h2 id="3-4、文档编辑命令"><a href="#3-4、文档编辑命令" class="headerlink" title="3.4、文档编辑命令"></a>3.4、文档编辑命令</h2><p>Windows是有记事本<br>Linux也有类似的记事本功能   VIM编辑器</p><h3 id="VI-编辑"><a href="#VI-编辑" class="headerlink" title="VI 编辑"></a><em>VI</em> 编辑</h3><ol><li><p>操作：</p><ul><li>输入 <code>vi 文件名</code>  进入 “命令(一般)模式”</li><li>按下 “<strong>i</strong>” 从一般模式，进入“插入模式”</li><li>按下 “<strong>esc</strong>” 从“插入模式”退出到“一般模式”</li><li>在“一般模式”下，输入 “<strong>:wq</strong>”，退出编辑</li></ul><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538637143785.png" alt="1538637143785"></p></li><li></li></ol><h3 id="vim-命令"><a href="#vim-命令" class="headerlink" title="vim 命令"></a><em>vim</em> 命令</h3><ol><li><p>操作：</p><ul><li>输入 <code>vim 文件名</code> 或 <code>vi 文件名</code> 进入 “一般模式”</li><li>按下 “<strong>i</strong>” 从一般模式，进入“插入模式”</li><li>按下 “<strong>esc</strong>” 从“插入模式”退出到“一般模式”</li><li>在“一般模式”下，输入 “<strong>:wq</strong>”，退出编辑</li></ul><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538637143785.png" alt="1538637143785"></p></li><li><ul><li><strong>一般(命令)</strong>模式:<ul><li>可以<strong>浏览文件内容</strong>，可以进行文本快捷操作（单行复制，多行复制，单行删除，多行删除…）</li><li>按 <strong>i/a/o</strong> 可以切换到 <strong>插入</strong>模式<br>按 <strong>:</strong> 可以切换到 <strong>底行</strong>模式</li></ul></li><li><strong>插入</strong>模式：<ul><li>可以<strong>编辑</strong>文件内容。</li><li>按 <strong>ESC</strong> 可以切回 <strong>一般</strong>模式</li></ul></li><li><strong>底行</strong>模式：<ul><li>可以进行<strong>强制退出不保存</strong>操作   <strong>q!</strong></li><li>可以进行<strong>保存并退出</strong>操作  <strong>wq</strong></li></ul></li></ul></li></ol><h2 id="3-5、grep-、-管道-、重定向输出-gt-gt"><a href="#3-5、grep-、-管道-、重定向输出-gt-gt" class="headerlink" title="3.5、grep 、 管道|、重定向输出&gt;&gt;"></a>3.5、<em>grep</em> 、 管道|、重定向输出&gt;&gt;</h2><h3 id="grep-正则表达式"><a href="#grep-正则表达式" class="headerlink" title="grep 正则表达式"></a><em>grep</em> 正则表达式</h3><ol><li><p>grep：正则表达式，进行字符串搜索工作</p><p>用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式grep -i 需要搜索的字符串 搜索的文件# 参数-i 忽略大小写查找数据</code></pre><p>符合规则，就会返回符合规则的<strong>行</strong></p></li></ol><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a><em>管道</em></h3><ol><li><p>管道命令： 可以连接多个Linux命令，其作用是<strong>将一个命令的输出用在另一个命令的输入</strong></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538638149167.png" alt="1538638149167"></p></li><li><p>格式：</p><pre><code class="seh">命令1 | 命令2 | 命令3……</code></pre></li><li><p>eg：</p><pre><code>需求：查询当前目录中，所有带ins关键字的行数据位置：/root思考：查询当前目录内容  ll     查询字符串，返回字符串所在行  grep命令：ll | grep ins需求：分页显示ls的help信息命令：ls --help | more</code></pre></li></ol><h3 id="重定向输出-gt-gt-gt"><a href="#重定向输出-gt-gt-gt" class="headerlink" title="重定向输出&gt; &gt;&gt;"></a>重定向输出&gt; &gt;&gt;</h3><ol><li><p>重定向输出</p><ul><li><p>&gt;</p><p>定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空</p></li><li><p>&gt;&gt;</p><p>将输出内容追加到目标文件中。如果文件不存在，就创建文件；如果文件存在，则将新的内容追加到那个文件的末尾，该文件中的原有内容不受影响</p></li></ul><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539671830735.png" alt="1539671830735"></p></li><li><p>格式：</p><p>注意：</p></li><li><p>使用：</p><ul><li><p>将一个文件夹的内容保存到文本文件中去，也就是将<code>ls</code>命令打印出来的内容都写到文本中去可以这样：</p><pre><code class="shell"># a.txt文件中就是ls命令打印出来的内容了ls -al &gt;&gt; a.txt</code></pre></li></ul></li></ol><h2 id="3-6、压缩、解压命令【重要】"><a href="#3-6、压缩、解压命令【重要】" class="headerlink" title="3.6、压缩、解压命令【重要】"></a>3.6、压缩、解压命令【重要】</h2><ol><li><p>Linux常见压缩包： <em>.tar        打包，大小不会进行压缩<br>​              </em>.tar.gz   打包并压缩文件大小</p></li><li><p><strong>压缩</strong>：(<strong>参数顺序不变</strong>)</p><pre><code># 格式tar -zcvf 压缩包名字.tar.gz 需要压缩的内容# 参数-z 是否需要用 gzip 压缩-c 建立一个压缩文件的参数指令（create）--压缩-v 压缩的过程中显示文件（verbose）-f 使用档案名称，在 f 之后要立即接档名（file）</code></pre><p>eg：</p><pre><code>例如：tar -zcvf hehe.tar.gz *   将当前目录下所有内容进行打包压缩，文件名hehe.tar.gz</code></pre></li><li><p><strong>解压</strong>：(<strong>参数顺序不变</strong>)</p><pre><code># 解压到当前目录tar -zxvf 需要解压的压缩包名称 解压到当前目录# 解压到指定目录tar -zxvf 需要解压的压缩包名称 -C 指定压缩路径  解压到指定目录中# 参数-z 是否需要用 gzip 压缩-x 解开一个压缩文件的参数指令（extract）--解压-v 压缩的过程中显示文件（verbose）-f 使用档名，在 f 之后要立即接档名（file）</code></pre><p>eg：</p><pre><code>需求：需要把/root/t5/hehe.tar.gz  压缩包 解压到 指定目录中。指定目录/root/t5/t5位置：/root/t5命令：tar -zxvf hehe.tar.gz -C /root/t5/t5tar -zxvf hehe.tar.gz -C t5</code></pre></li></ol><h2 id="3-7、系统命令"><a href="#3-7、系统命令" class="headerlink" title="3.7、系统命令"></a>3.7、系统命令</h2><h3 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h3><p>服务，是指常期运行，常驻内存中的进程，比如，apache、mysql、ssh等</p><h4 id="服务与端口"><a href="#服务与端口" class="headerlink" title="服务与端口"></a>服务与端口</h4><p>每个服务软件一般在运行时都会对应一个端口。<br>查看监听的端口：</p><pre><code class="shell">ss –lntp</code></pre><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539792074690.png" alt="1539792074690"></p><h4 id="防火墙及防火墙设置"><a href="#防火墙及防火墙设置" class="headerlink" title="防火墙及防火墙设置"></a>防火墙及防火墙设置</h4><p>CentOS 7.0默认使用的是<code>firewall</code>作为防火墙，使用<code>iptables</code>必须重新设置一下</p><p>查看防火墙状态：</p><pre><code class="shell">firewall-cmd --state# running 防火墙处于开启状态# not running 防火墙处于关闭状态</code></pre><h5 id="直接关闭防火墙"><a href="#直接关闭防火墙" class="headerlink" title="直接关闭防火墙"></a>直接关闭防火墙</h5><p>停止<strong>firewall</strong>：</p><pre><code class="shell">systemctl stop firewalld.service</code></pre><p>禁止<strong>firewall</strong>开机启动：</p><pre><code class="shell">systemctl disable firewalld.service </code></pre><h4 id="查看系统进程：ps-ef"><a href="#查看系统进程：ps-ef" class="headerlink" title="查看系统进程：ps -ef"></a>查看系统进程：ps -ef</h4><pre><code>需求：查看进程中 和 vim相关的进程命令：ps -ef|grep -i vim-e 　此参数的效果和指定&quot;A&quot;参数相同，显示所有程序-f 　显示UID,PPIP,C与STIME栏位</code></pre><h4 id="强制杀死某个进程：kill-9-pid号"><a href="#强制杀死某个进程：kill-9-pid号" class="headerlink" title="强制杀死某个进程：kill -9 pid号"></a>强制杀死某个进程：kill -9 pid号</h4><pre><code>需求：查看进程 和 vim相关的进程有哪些，并将vim进程杀死命令：ps -ef|grep -i vim     Kill -9 pid号-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称kill 9 表示强制终止</code></pre><ol><li>查看网络配置：<strong>ifconfig</strong><ul><li>显示网络设备</li></ul></li><li>测试和目标的连通性：<strong>ping 主机名或ip地址</strong><ul><li>测试与目标主机的连通性</li><li>会持续不断一直测试，直到ctrl+c</li></ul></li><li>Linux centos重启命令：<strong>reboot</strong></li><li>Linux centos关机命令：<strong>halt</strong></li></ol><h2 id="3-8、其他命令（了解）"><a href="#3-8、其他命令（了解）" class="headerlink" title="3.8、其他命令（了解）"></a>3.8、其他命令（了解）</h2><h3 id="chmod-文件权限"><a href="#chmod-文件权限" class="headerlink" title="chmod 文件权限"></a><em>chmod</em> 文件权限</h3><ol><li><p>hmod(change mode) 功能：变更文件或目录的权限</p></li><li><p>语法：</p><pre><code># 格式chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;]# 参数-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理</code></pre><ul><li>权限范围的表示法如下：<ul><li>u：User，即文件或目录的拥有者</li><li>g：Group，即文件或目录的所属群组</li><li>o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围</li><li>a：All，即全部的用户，包含拥有者，所属群组以及其他用户</li></ul></li><li>符号：<ul><li>‘+’添加权限</li><li>‘-‘取消权限</li></ul></li><li>有关权限代号的部分，列表于下：<ul><li>r：读取权限，数字代号为”4”</li><li>w：写入权限，数字代号为”2”</li><li>x：执行或切换权限，数字代号为”1”</li><li>-：不具任何权限，数字代号为”0”</li></ul></li></ul></li><li><p>eg:</p><pre><code>mkdir xxxll | grep xxxchmod u-rwx xxx        #取消xxx目录，用户“读写执行”权限chmod g-rwx xxx     #取消xxx目录，组“读写执行”权限chmod 777 xxx        #给xxx目录添加所有权限</code></pre></li><li><p>linux 权限格式：&lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt;</p><p><img src="https://raw.githubusercontent.com/xiongtianci-tc/myHexoBlog/master/img/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1543568285232.png" alt="img"></p></li></ol><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><ol><li><p>VIM命令配置</p><ul><li><p>网卡配置 cat /etc/sysconfig/network-scripts/ifcfg-eth0</p></li><li><p>概要信息如下:</p><pre><code>DEVICE=eth0                 #网卡名称TYPE=Ethernet               #网卡类型ONBOOT=yes                  #是否开机启动网卡BOOTPROTO=static            #静态获取IP，其他取值：dhcp （如果设置dhcp下面红色不需要）IPADDR=192.168.44.100       #ip地址GATEWAY=192.168.44.2        #网关NETMASK=255.255.255.0       #子网掩码</code></pre></li></ul></li><li><p>setup设置</p><ol><li><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image002-1538642819190.jpg?raw=true" alt="img"> </p></li><li><p>选择“网络配置”</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image002-1538642858562.jpg?raw=true" alt="img"> </p></li><li><p>选择“设备配置”</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image001-1538642873407.png" alt="img"> </p></li><li><p>选择“第一块网卡”</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538642891449.png" alt="1538642891449"> </p></li><li><p>设置IP地址等详细信息</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image001.png" alt="img"> </p></li></ol></li></ol><h1 id="命令总结-和-帮助"><a href="#命令总结-和-帮助" class="headerlink" title="命令总结 和 帮助"></a>命令总结 和 帮助</h1><ul><li><p>内部命令：属于Shell解析器的一部分 （系统启动直接加载到内存的）</p><pre><code>cd   切换目录（change directory）pwd  显示当前工作目录（print working directory）help 帮助</code></pre></li><li><p>外部命令：独立于Shell解析器之外的文件程序（独立的可执行文件）</p><pre><code>ls    显示文件和目录列表（list）mkdir 创建目录（make directoriy）cp    复制文件或目录（copy）</code></pre></li><li><p>查看帮助文档</p><ul><li><p>内部命令：help + 命令（eg：help cd）</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538643143565.png" alt="1538643143565"> </p></li><li><p>外部命令：man + 命令（eg：man ls）</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538643159745.png" alt="1538643159745"> </p></li></ul></li><li><p>不用特意记忆命令分类，开发中，如果需要查看命令参数，先使用<strong>man</strong>，如果没有结果，再使用<strong>help</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      Linux常用命令
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣Top250资源合集</title>
    <link href="/2018/11/29/%E8%B1%86%E7%93%A3Top250%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/"/>
    <id>/2018/11/29/豆瓣Top250资源合集/</id>
    <published>2018-11-28T17:45:30.000Z</published>
    <updated>2019-06-10T01:36:17.999Z</updated>
    
    <content type="html"><![CDATA[<p><br><br><div style="display:flex;justify-content:center;"><font color="hotpink">点击影片”名称”即可获取资源链接</font></div></p><div style="display:flex;justify-content:flex-end"><font color="red"># 更新至Top1-Top100，敬请期待…</font></div><table border="1" style="text-align: center;"><thead><tr><th>排名</th><th>名称</th><th>年份</th><th>评分</th></tr></thead><tbody><tr><td>Top1</td><td><a href="https://pan.baidu.com/s/1Hl1j9BGzvxhdaRfGGGL2zQ" target="_blank" rel="noopener">肖申克的救赎</a></td><td>1994</td><td>9.6</td></tr><tr><td>Top2</td><td><a href="http://pan.baidu.com/s/1gfOr0Dd" target="_blank" rel="noopener">霸王别姬</a></td><td>1993</td><td>9.6</td></tr><tr><td>Top3</td><td><a href="http://pan.baidu.com/s/1bpNdERt" target="_blank" rel="noopener">这个杀手不太冷</a></td><td>1994</td><td>9.4</td></tr><tr><td>Top4</td><td><a href="https://pan.baidu.com/s/1o8Nejc2?fid=853395936269539" target="_blank" rel="noopener">阿甘正传</a></td><td>1994</td><td>9.4</td></tr><tr><td>Top5</td><td><a href="https://pan.baidu.com/s/14sshh?fid=738933366388433" target="_blank" rel="noopener">美丽人生</a></td><td>1997</td><td>9.5</td></tr><tr><td>Top6</td><td><a href="http://pan.baidu.com/s/1o7PiQ3w" target="_blank" rel="noopener">泰坦尼克号</a></td><td>1997</td><td>9.3</td></tr><tr><td>Top7</td><td><a href="https://pan.baidu.com/s/11xA1VNyZZlboNTckXywkxQ" target="_blank" rel="noopener">千与千寻</a></td><td>2001</td><td>9.3</td></tr><tr><td>Top8</td><td><a href="http://pan.baidu.com/s/1qXCTBic" target="_blank" rel="noopener">辛德勒的名单</a></td><td>1993</td><td>9.5</td></tr><tr><td>Top9</td><td><a href=" http://pan.baidu.com/s/1i5w3bkp" target="_blank" rel="noopener">盗梦空间</a></td><td>2010</td><td>9.3</td></tr><tr><td>Top10</td><td><a href="https://pan.baidu.com/s/1ge5y0nD?fid=923497949059553" target="_blank" rel="noopener">机器人总动员</a></td><td>2008</td><td>9.3</td></tr><tr><td>Top11</td><td><a href="https://pan.baidu.com/s/1mhQXQIG?fid=859409840409891" target="_blank" rel="noopener">忠犬八公的故事</a></td><td>2009</td><td>9.3</td></tr><tr><td>Top12</td><td><a href="http://pan.baidu.com/s/1eRFpHLK" target="_blank" rel="noopener">三傻大闹宝莱坞</a></td><td>2009</td><td>9.2</td></tr><tr><td>Top13</td><td><a href="http://pan.baidu.com/s/1boR7j3p" target="_blank" rel="noopener">海上钢琴师</a></td><td>1998</td><td>9.2</td></tr><tr><td>Top14</td><td><a href="http://pan.baidu.com/s/1eRDnUi2" target="_blank" rel="noopener">放牛班的春天</a></td><td>2004</td><td>9.2</td></tr><tr><td>Top15</td><td><a href="https://pan.baidu.com/s/1Cd9bMZjqWbhTS0wLKWfr_w?fid=351298108017917" target="_blank" rel="noopener">大话西游之大圣娶亲</a></td><td>1995</td><td>9.2</td></tr><tr><td>Top16</td><td><a href="https://pan.baidu.com/s/1GZ356B4GumSYp2afnrcCpg?fid=354248154465777" target="_blank" rel="noopener">楚门的世界</a></td><td>1998</td><td>9.2</td></tr><tr><td>Top17</td><td><a href="https://pan.baidu.com/s/1i3YIMAp?fid=1074753729212605" target="_blank" rel="noopener">教父</a></td><td>1972</td><td>9.2</td></tr><tr><td>Top18</td><td><a href="https://pan.baidu.com/s/14wznp?fid=823033633333159" target="_blank" rel="noopener">星际穿越</a></td><td>2014</td><td>9.2</td></tr><tr><td>Top19</td><td><a href="https://pan.baidu.com/s/1bo0FnXl?fid=252951322427901" target="_blank" rel="noopener">龙猫</a></td><td>1988</td><td>9.1</td></tr><tr><td>Top20</td><td><a href="https://pan.baidu.com/s/1zLis1PHuhxILsa7Ac7Wx9Q" target="_blank" rel="noopener">熔炉</a></td><td>2011</td><td>9.3</td></tr><tr><td>Top21</td><td><a href="https://pan.baidu.com/s/1MUAbY8A5kUaAh_6HXPCjqA" target="_blank" rel="noopener">无间道</a></td><td>2002</td><td>9.1</td></tr><tr><td>Top22</td><td><a href="https://pan.baidu.com/s/1nuSZ9ix?fid=703054725115319" target="_blank" rel="noopener">当幸福来敲门</a></td><td>2006</td><td>9.0</td></tr><tr><td>Top23</td><td><a href="https://pan.baidu.com/s/1FlfH_qZf38PlbwX9E512yA" target="_blank" rel="noopener">触不可及</a></td><td>2011</td><td>9.2</td></tr><tr><td>Top24</td><td><a href="https://pan.baidu.com/s/1s6_q9mZKLAKwNAh4O7-r3w" target="_blank" rel="noopener">怦然心动</a></td><td>2010</td><td>9.0</td></tr><tr><td>Top25</td><td><a href="https://pan.baidu.com/s/15svfI?fid=2938514528" target="_blank" rel="noopener">乱世佳人</a></td><td>1939</td><td>9.2</td></tr><tr><td>Top26</td><td><a href="https://pan.baidu.com/s/1jIvYj2m?fid=859083213231438" target="_blank" rel="noopener">疯狂动物城</a></td><td>2016</td><td>9.2</td></tr><tr><td>Top27</td><td><a href="https://pan.baidu.com/s/1gUs1lMPvhWLP8x_ijzpNGw" target="_blank" rel="noopener">蝙蝠侠：黑暗骑士</a></td><td>2008</td><td>9.1</td></tr><tr><td>Top28</td><td><a href="https://pan.baidu.com/s/1bqOlUAr?fid=1002856157420219" target="_blank" rel="noopener">天堂电影院</a></td><td>1988</td><td>9.1</td></tr><tr><td>Top29</td><td><a href="https://pan.baidu.com/s/1dE79wGx?fid=267490512661091" target="_blank" rel="noopener">活着</a></td><td>1994</td><td>9.1</td></tr><tr><td>Top30</td><td><a href="https://pan.baidu.com/s/1ZszH2VXTSPUAqNo8By1lfA" target="_blank" rel="noopener">少年派的奇幻漂流</a></td><td>2012</td><td>9.0</td></tr><tr><td>Top31</td><td><a href="https://pan.baidu.com/s/1IOy5uip6rYWhQsgbsxbB0g" target="_blank" rel="noopener">十二怒汉</a></td><td>1957</td><td>9.4</td></tr><tr><td>Top32</td><td><a href="https://pan.baidu.com/s/1gNtiJXKiXQ9DH0goLVuA2Q" target="_blank" rel="noopener">鬼子来了</a></td><td>2000</td><td>9.2</td></tr><tr><td>Top33</td><td><a href="https://pan.baidu.com/s/18wC7U?fid=254565905159819" target="_blank" rel="noopener">指环王3：王者无敌</a></td><td>2003</td><td>9.1</td></tr><tr><td>Top34</td><td><a href="https://pan.baidu.com/s/15m0uRMjTz07_TZ88L2uTUA" target="_blank" rel="noopener">控方证人</a></td><td>1957</td><td>9.6</td></tr><tr><td>Top35</td><td><a href="https://pan.baidu.com/s/1sjqhVGx?fid=906768803799193" target="_blank" rel="noopener">搏击俱乐部</a></td><td>1999</td><td>9.0</td></tr><tr><td>Top36</td><td><a href="https://pan.baidu.com/s/12MgZrABxuQ-oPNJ9auTgVA" target="_blank" rel="noopener">天空之城</a></td><td>1986</td><td>9.0</td></tr><tr><td>Top37</td><td><a href="https://pan.baidu.com/s/1Jc-0DcaIoJuUrtP2pH4vOg" target="_blank" rel="noopener">飞屋环游记</a></td><td>2009</td><td>8.9</td></tr><tr><td>Top38</td><td><a href="https://pan.baidu.com/s/10raMk?fid=973205912028341" target="_blank" rel="noopener">大话西游之月光宝盒</a></td><td>1995</td><td>8.9</td></tr><tr><td>Top39</td><td><a href="https://pan.baidu.com/s/13WJuB?fid=937467810241967" target="_blank" rel="noopener">罗马假日</a></td><td>1953</td><td>9.0</td></tr><tr><td>Top40</td><td><a href="https://pan.baidu.com/s/1sl3D0Gd#list/path=%2F" target="_blank" rel="noopener">摔跤吧！爸爸</a></td><td>2016</td><td>9.1</td></tr><tr><td>Top41</td><td><a href="https://pan.baidu.com/s/1TfnhXTgWsPub6HQwck3Oag" target="_blank" rel="noopener">窃听风暴</a></td><td>2006</td><td>9.1</td></tr><tr><td>Top42</td><td><a href="https://pan.baidu.com/s/14u2gB?fid=263900955744687" target="_blank" rel="noopener">辩护人</a></td><td>2013</td><td>9.2</td></tr><tr><td>Top43</td><td><a href="https://pan.baidu.com/share/link?shareid=558455183&uk=3623880440&fid=2141965982" target="_blank" rel="noopener">两杆大烟枪</a></td><td>1998</td><td>9.1</td></tr><tr><td>Top44</td><td><a href="https://pan.baidu.com/s/1-9SOF2mFoQSseIntwx_N9Q?fid=754656724538878" target="_blank" rel="noopener">闻香识女人</a></td><td>1992</td><td>9.0</td></tr><tr><td>Top45</td><td><a href="https://pan.baidu.com/s/1waI720ZTkEYh_KV_V102oQ" target="_blank" rel="noopener">哈尔的移动城堡</a></td><td>2004</td><td>8.9</td></tr><tr><td>Top46</td><td><a href="https://pan.baidu.com/s/1ifJ7h4Q_RWCsMOeRFY_RbA" target="_blank" rel="noopener">飞越疯人院</a></td><td>1975</td><td>9.0</td></tr><tr><td>Top47</td><td><a href="https://pan.baidu.com/s/1ge38MlH?fid=389555883875523" target="_blank" rel="noopener">死亡诗社</a></td><td>1989</td><td>9.0</td></tr><tr><td>Top48</td><td><a href="https://pan.baidu.com/s/1Js4qCj2GEQ9DF9hgkDL4cw" target="_blank" rel="noopener">V字仇杀队</a></td><td>2005</td><td>8.8</td></tr><tr><td>Top49</td><td><a href="https://pan.baidu.com/s/1gf4TipX?fid=309002731979882" target="_blank" rel="noopener">海豚湾</a></td><td>2009</td><td>9.3</td></tr><tr><td>Top50</td><td><a href="https://pan.baidu.com/s/1gfPWl0n?fid=95543062299217" target="_blank" rel="noopener">教父2</a></td><td>1974</td><td>9.1</td></tr><tr><td>Top51</td><td><a href="https://pan.baidu.com/s/15IgbR?fid=695943185158780" target="_blank" rel="noopener">指环王2：双塔奇兵</a></td><td>2002</td><td>9.0</td></tr><tr><td>Top52</td><td><a href="https://pan.baidu.com/s/19f0HS?fid=803394449358026" target="_blank" rel="noopener">指环王1：魔戒再现</a></td><td>2001</td><td>8.9</td></tr><tr><td>Top53</td><td><a href="https://pan.baidu.com/s/1Fo42K5QFS0ZLvnxFkmGVBQ" target="_blank" rel="noopener">美丽心灵</a></td><td>2001</td><td>8.9</td></tr><tr><td>Top54</td><td><a href="https://pan.baidu.com/s/1_GEJ_CoHeQuqUFtyzrwDIg" target="_blank" rel="noopener">饮食男女</a></td><td>1994</td><td>9.1</td></tr><tr><td>Top55</td><td><a href="https://pan.baidu.com/s/1O1Wi9V1ikEggIVpMMZSqZQ" target="_blank" rel="noopener">情书</a></td><td>1995</td><td>8.8</td></tr><tr><td>Top56</td><td><a href="https://pan.baidu.com/s/1jIBD8iU?fid=241575748710910" target="_blank" rel="noopener">素媛</a></td><td>2013</td><td>9.1</td></tr><tr><td>Top57</td><td><a href="https://pan.baidu.com/s/1acVbcpPFtCkuVaR0NuvVMA" target="_blank" rel="noopener">狮子王</a></td><td>1994</td><td>8.9</td></tr><tr><td>Top58</td><td><a href="https://pan.baidu.com/s/1ISIPJI1CzZ0wyxgchU7ZUQ" target="_blank" rel="noopener">钢琴家</a></td><td>2002</td><td>9.1</td></tr><tr><td>Top59</td><td><a href="https://pan.baidu.com/s/1Lr6zQTA94CbMXZP8CKePNA" target="_blank" rel="noopener">美国往事</a></td><td>1984</td><td>9.1</td></tr><tr><td>Top60</td><td><a href="https://pan.baidu.com/s/1e62DBaMv9qaYgP960B0dpQ" target="_blank" rel="noopener">小鞋子</a></td><td>1997</td><td>9.2</td></tr><tr><td>Top61</td><td><a href="https://pan.baidu.com/s/1K5Zgnm7DAFx_ZeNo18ayjA" target="_blank" rel="noopener">七宗罪</a></td><td>1995</td><td>8.8</td></tr><tr><td>Top62</td><td><a href="https://pan.baidu.com/s/1eoFq0O4ZrFo3mBs_3jPajA" target="_blank" rel="noopener">被嫌弃的松子的一生</a></td><td>2006</td><td>8.9</td></tr><tr><td>Top63</td><td><a href="https://pan.baidu.com/s/1KDC_qYq-nxCSAqZE0qDTIg" target="_blank" rel="noopener">致命魔术</a></td><td>2006</td><td>8.8</td></tr><tr><td>Top64</td><td><a href="https://pan.baidu.com/s/19a04jR2acwbTx2ho1v8Ejg" target="_blank" rel="noopener">本杰明·巴顿奇事</a></td><td>2008</td><td>8.8</td></tr><tr><td>Top65</td><td><a href="https://pan.baidu.com/s/1EwTT6TsO_yrrJxS0LVnOHw" target="_blank" rel="noopener">末代皇帝</a></td><td>1987</td><td>9.0</td></tr><tr><td>Top66</td><td><a href="https://pan.baidu.com/s/1XnhKY7Hxon8IQoTgUsFT_A?fid=1096320857195922" target="_blank" rel="noopener">西西里的美丽传说</a></td><td>2000</td><td>8.8</td></tr><tr><td>Top67</td><td><a href="https://pan.baidu.com/s/1453_7kpPiqeQnoG0LFiV5w" target="_blank" rel="noopener">天使爱美丽</a></td><td>2001</td><td>8.7</td></tr><tr><td>Top68</td><td><a href="https://pan.baidu.com/s/1ysPw4189zFZBDFm_Pe2FVA" target="_blank" rel="noopener">黑客帝国</a></td><td>1999</td><td>8.9</td></tr><tr><td>Top69</td><td><a href="https://pan.baidu.com/s/1AdCvtWEOE457L2mOCRJgPA" target="_blank" rel="noopener">让子弹飞</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top70</td><td><a href="https://pan.baidu.com/s/1KkAEvlGPBjVcS_3ugScM_A" target="_blank" rel="noopener">拯救大兵瑞恩</a></td><td>1998</td><td>8.9</td></tr><tr><td>Top71</td><td><a href="https://pan.baidu.com/s/1bqFwEvl#list/path=%2F&parentPath=%2F%E6%88%91%E7%9A%84%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">看不见的客人</a></td><td>2016</td><td>8.7</td></tr><tr><td>Top72</td><td><a href="https://pan.baidu.com/s/1EAE2GMs5tCz09Proae6uyw" target="_blank" rel="noopener">音乐之声</a></td><td>1965</td><td>8.9</td></tr><tr><td>Top73</td><td><a href="https://pan.baidu.com/s/1p_yW-ruXtEK5heKsFmQNUw" target="_blank" rel="noopener">低俗小说</a></td><td>1994</td><td>8.8</td></tr><tr><td>Top74</td><td><a href="https://pan.baidu.com/s/1WVXAxAM0I2b8SNIjDMGE0Q" target="_blank" rel="noopener">勇敢的心</a></td><td>1995</td><td>8.8</td></tr><tr><td>Top75</td><td><a href="https://pan.baidu.com/s/16XvuTxWzJh4s_w7-whqrOA" target="_blank" rel="noopener">剪刀手爱德华</a></td><td>1990</td><td>8.7</td></tr><tr><td>Top76</td><td><a href="https://pan.baidu.com/s/1mlcerfQxK3WForgNa6SKwg" target="_blank" rel="noopener">大闹天宫</a></td><td>1961196419782004</td><td>9.3</td></tr><tr><td>Top77</td><td><a href="https://pan.baidu.com/s/1pLgFPbX?fid=464690874078412" target="_blank" rel="noopener">沉默的羔羊</a></td><td>1991</td><td>8.8</td></tr><tr><td>Top78</td><td><a href="https://pan.baidu.com/s/1x7yq0ULCJtAtMtuVDemGRA" target="_blank" rel="noopener">蝴蝶效应</a></td><td>2004</td><td>8.7</td></tr><tr><td>Top79</td><td><a href="https://pan.baidu.com/s/1elizCqrt3kU7kHXjm_A-zQ" target="_blank" rel="noopener">哈利·波特与魔法石</a></td><td>2001</td><td>8.8</td></tr><tr><td>Top80</td><td><a href="https://pan.baidu.com/s/1gfOcT2r?fid=35225760102993" target="_blank" rel="noopener">春光乍泄</a></td><td>1997</td><td>8.8</td></tr><tr><td>Top81</td><td><a href="https://pan.baidu.com/s/1ZxEIADzr_rO3ZIDW5nGB3w" target="_blank" rel="noopener">入殓师</a></td><td>2008</td><td>8.8</td></tr><tr><td>Top82</td><td><a href="https://pan.baidu.com/s/1bGhs44VwbBZEqaaelsz8GQ" target="_blank" rel="noopener">心灵捕手</a></td><td>1997</td><td>8.8</td></tr><tr><td>Top83</td><td><a href="https://pan.baidu.com/s/13Lg1sGGb7aFN0oESt6F9Gw" target="_blank" rel="noopener">猫鼠游戏</a></td><td>2002</td><td>8.8</td></tr><tr><td>Top84</td><td><a href="https://pan.baidu.com/s/1pIugxrDIO6fZn7kqF-T2pw?fid=360967812964633" target="_blank" rel="noopener">布达佩斯大饭店</a></td><td>2014</td><td>8.8</td></tr><tr><td>Top85</td><td><a href="https://pan.baidu.com/s/15Lc06yp0Uu2-mrkDXa9V2g" target="_blank" rel="noopener">禁闭岛</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top86</td><td><a href="https://pan.baidu.com/s/1ZhGG3ccQiZmr2CJYr6BhEA" target="_blank" rel="noopener">玛丽和马克思</a></td><td>2009</td><td>8.9</td></tr><tr><td>Top87</td><td><a href="https://pan.baidu.com/s/1GuL7JmjlihphuNpV5ENc_A" target="_blank" rel="noopener">阳光灿烂的日子</a></td><td>1994</td><td>8.8</td></tr><tr><td>Top88</td><td><a href="https://pan.baidu.com/s/1gnDTK-Y2GV-ywPky8b75vg" target="_blank" rel="noopener">第六感</a></td><td>1999</td><td>8.8</td></tr><tr><td>Top89</td><td><a href="https://pan.baidu.com/s/1iQ_obdzemXyp7sd9-YEsUA" target="_blank" rel="noopener">幽灵公主</a></td><td>1997</td><td>8.8</td></tr><tr><td>Top90</td><td><a href="https://pan.baidu.com/s/17_MV94EH_TKT8XElVrGzFw" target="_blank" rel="noopener">重庆森林</a></td><td>1994</td><td>8.7</td></tr><tr><td>Top91</td><td><a href="https://pan.baidu.com/s/1bA7IQEPDwSEQXmEbGhp1Jw" target="_blank" rel="noopener">狩猎</a></td><td>2012</td><td>9.1</td></tr><tr><td>Top92</td><td><a href="https://pan.baidu.com/s/1XCZDkMDTvfSKOkPY-8VVDQ" target="_blank" rel="noopener">致命ID</a></td><td>2003</td><td>8.7</td></tr><tr><td>Top93</td><td><a href="https://pan.baidu.com/s/1kd0rlbX-aAJsDZhzzjBusw" target="_blank" rel="noopener">穿条纹睡衣的男孩</a></td><td>2008</td><td>8.9</td></tr><tr><td>Top94</td><td><a href="https://pan.baidu.com/s/1cCdglN-WrcOgcIKSsq9d_w" target="_blank" rel="noopener">断背山</a></td><td>2005</td><td>8.7</td></tr><tr><td>Top95</td><td><a href="https://pan.baidu.com/s/1Z0TdybqvMFqiGf5AssaP_w" target="_blank" rel="noopener">加勒比海盗</a></td><td>2003</td><td>8.6</td></tr><tr><td>Top96</td><td><a href="https://pan.baidu.com/s/1-tx2TPNbGAKQgId6fz8geA" target="_blank" rel="noopener">大鱼</a></td><td>2003</td><td>8.7</td></tr><tr><td>Top97</td><td><a href="https://pan.baidu.com/s/126MI3BRV4xc8yPGveGHKzw" target="_blank" rel="noopener">阿凡达</a></td><td>2009</td><td>8.6</td></tr><tr><td>Top98</td><td><a href="https://pan.baidu.com/s/1ef5Yb_O7HSUKAy_Gkr7zlg" target="_blank" rel="noopener">摩登时代</a></td><td>1936</td><td>9.2</td></tr><tr><td>Top99</td><td><a href="https://pan.baidu.com/s/1ruqr3uwuVTYLIBv5XP77LQ" target="_blank" rel="noopener">告白</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top100</td><td><a href="https://pan.baidu.com/s/1QvOiIg25WAtGBpE88AbOGw" target="_blank" rel="noopener">一一</a></td><td>2000</td><td>9.0</td></tr><tr><td>Top101</td><td><a href>射雕英雄传之东成西就</a></td><td>1993</td><td>8.7</td></tr><tr><td>Top102</td><td><a href>甜蜜蜜</a></td><td>1996</td><td>8.8</td></tr><tr><td>Top103</td><td><a href>阳光姐妹淘</a></td><td>2011</td><td>8.8</td></tr><tr><td>Top104</td><td><a href>消失的爱人</a></td><td>2014</td><td>8.7</td></tr><tr><td>Top105</td><td><a href>爱在黎明破晓前</a></td><td>1995</td><td>8.7</td></tr><tr><td>Top106</td><td><a href>上帝之城</a></td><td>2002</td><td>8.9</td></tr><tr><td>Top107</td><td><a href>小森林 夏秋篇</a></td><td>2014</td><td>8.9</td></tr><tr><td>Top108</td><td><a href>侧耳倾听</a></td><td>1995</td><td>8.8</td></tr><tr><td>Top109</td><td><a href>喜剧之王</a></td><td>1999</td><td>8.6</td></tr><tr><td>Top110</td><td><a href>倩女幽魂</a></td><td>1987</td><td>8.6</td></tr><tr><td>Top111</td><td><a href>恐怖直播</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top112</td><td><a href>风之谷</a></td><td>1984</td><td>8.8</td></tr><tr><td>Top113</td><td><a href>爱在日落黄昏时</a></td><td>2004</td><td>8.8</td></tr><tr><td>Top114</td><td><a href>超脱</a></td><td>2011</td><td>8.8</td></tr><tr><td>Top115</td><td><a href>红辣椒</a></td><td>2006</td><td>8.9</td></tr><tr><td>Top116</td><td><a href>菊次郎的夏天</a></td><td>1999</td><td>8.8</td></tr><tr><td>Top117</td><td><a href>驯龙高手</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top118</td><td><a href>幸福终点站</a></td><td>2004</td><td>8.7</td></tr><tr><td>Top119</td><td><a href>神偷奶爸</a></td><td>2010</td><td>8.5</td></tr><tr><td>Top120</td><td><a href>借东西的小人阿莉埃蒂</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top121</td><td><a href>杀人回忆</a></td><td>2003</td><td>8.7</td></tr><tr><td>Top122</td><td><a href>七武士</a></td><td>1954</td><td>9.2</td></tr><tr><td>Top123</td><td><a href>岁月神偷</a></td><td>2010</td><td>8.6</td></tr><tr><td>Top124</td><td><a href>请以你的名字呼唤我</a></td><td>2017</td><td>8.8</td></tr><tr><td>Top125</td><td><a href>萤火虫之墓</a></td><td>1988</td><td>8.7</td></tr><tr><td>Top126</td><td><a href>怪兽电力公司</a></td><td>2001</td><td>8.6</td></tr><tr><td>Top127</td><td><a href>小森林 冬春篇</a></td><td>2015</td><td>9.0</td></tr><tr><td>Top128</td><td><a href>哈利·波特与死亡圣器(下)</a></td><td>2011</td><td>8.7</td></tr><tr><td>Top129</td><td><a href>谍影重重3</a></td><td>2007</td><td>8.7</td></tr><tr><td>Top130</td><td><a href>喜宴</a></td><td>1993</td><td>8.8</td></tr><tr><td>Top131</td><td><a href>东邪西毒</a></td><td>1994</td><td>8.6</td></tr><tr><td>Top132</td><td><a href>电锯惊魂</a></td><td>2004</td><td>8.7</td></tr><tr><td>Top133</td><td><a href>贫民窟的百万富翁</a></td><td>2008</td><td>8.5</td></tr><tr><td>Top134</td><td><a href>疯狂原始人</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top135</td><td><a href>记忆碎片</a></td><td>2000</td><td>8.6</td></tr><tr><td>Top136</td><td><a href>7号房的礼物</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top137</td><td><a href>黑天鹅</a></td><td>2010</td><td>8.5</td></tr><tr><td>Top138</td><td><a href>萤火之森</a></td><td>2011</td><td>8.8</td></tr><tr><td>Top139</td><td><a href>真爱至上</a></td><td>2003</td><td>8.5</td></tr><tr><td>Top140</td><td><a href>英雄本色</a></td><td>1986</td><td>8.6</td></tr><tr><td>Top141</td><td><a href>超能陆战队</a></td><td>2014</td><td>8.6</td></tr><tr><td>Top142</td><td><a href>雨人</a></td><td>1988</td><td>8.6</td></tr><tr><td>Top143</td><td><a href>心迷宫</a></td><td>2014</td><td>8.7</td></tr><tr><td>Top144</td><td><a href>蝙蝠侠：黑暗骑士崛起</a></td><td>2012</td><td>8.6</td></tr><tr><td>Top145</td><td><a href>卢旺达饭店</a></td><td>2004</td><td>8.9</td></tr><tr><td>Top146</td><td><a href>唐伯虎点秋香</a></td><td>1993</td><td>8.5</td></tr><tr><td>Top147</td><td><a href>海洋</a></td><td>2009</td><td>9.0</td></tr><tr><td>Top148</td><td><a href>傲慢与偏见</a></td><td>2005</td><td>8.5</td></tr><tr><td>Top149</td><td><a href>荒蛮故事</a></td><td>2014</td><td>8.8</td></tr><tr><td>Top150</td><td><a href>纵横四海</a></td><td>1991</td><td>8.7</td></tr><tr><td>Top151</td><td><a href>海边的曼彻斯特</a></td><td>2016</td><td>8.6</td></tr><tr><td>Top152</td><td><a href>教父3</a></td><td>1990</td><td>8.8</td></tr><tr><td>Top153</td><td><a href>虎口脱险</a></td><td>1966</td><td>8.9</td></tr><tr><td>Top154</td><td><a href>无人知晓</a></td><td>2004</td><td>9.1</td></tr><tr><td>Top155</td><td><a href>时空恋旅人</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top156</td><td><a href>完美的世界</a></td><td>1993</td><td>9.0</td></tr><tr><td>Top157</td><td><a href>寻梦环游记</a></td><td>2017</td><td>9.0</td></tr><tr><td>Top158</td><td><a href>玩具总动员3</a></td><td>2010</td><td>8.8</td></tr><tr><td>Top159</td><td><a href>燃情岁月</a></td><td>1994</td><td>8.7</td></tr><tr><td>Top160</td><td><a href>花样年华</a></td><td>2000</td><td>8.5</td></tr><tr><td>Top161</td><td><a href>恋恋笔记本</a></td><td>2004</td><td>8.5</td></tr><tr><td>Top162</td><td><a href>达拉斯买家俱乐部</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top163</td><td><a href>血战钢锯岭</a></td><td>2016</td><td>8.7</td></tr><tr><td>Top164</td><td><a href>二十二</a></td><td>2015</td><td>8.7</td></tr><tr><td>Top165</td><td><a href>雨中曲</a></td><td>1952</td><td>9.0</td></tr><tr><td>Top166</td><td><a href>魂断蓝桥</a></td><td>1940</td><td>8.8</td></tr><tr><td>Top167</td><td><a href>穿越时空的少女</a></td><td>2006</td><td>8.6</td></tr><tr><td>Top168</td><td><a href>猜火车</a></td><td>1996</td><td>8.5</td></tr><tr><td>Top169</td><td><a href>我是山姆</a></td><td>2001</td><td>8.8</td></tr><tr><td>Top170</td><td><a href>冰川时代</a></td><td>2002</td><td>8.5</td></tr><tr><td>Top171</td><td><a href>人工智能</a></td><td>2001</td><td>8.6</td></tr><tr><td>Top172</td><td><a href>爆裂鼓手</a></td><td>2014</td><td>8.6</td></tr><tr><td>Top173</td><td><a href>头脑特工队</a></td><td>2015</td><td>8.7</td></tr><tr><td>Top174</td><td><a href>被解救的姜戈</a></td><td>2012</td><td>8.6</td></tr><tr><td>Top175</td><td><a href>未麻的部屋</a></td><td>1997</td><td>8.8</td></tr><tr><td>Top176</td><td><a href>罗生门</a></td><td>1950</td><td>8.7</td></tr><tr><td>Top177</td><td><a href>浪潮</a></td><td>2008</td><td>8.7</td></tr><tr><td>Top178</td><td><a href>香水</a></td><td>2006</td><td>8.4</td></tr><tr><td>Top179</td><td><a href>朗读者</a></td><td>2008</td><td>8.5</td></tr><tr><td>Top180</td><td><a href>阿飞正传</a></td><td>1990</td><td>8.5</td></tr><tr><td>Top181</td><td><a href>你的名字。</a></td><td>2016</td><td>8.4</td></tr><tr><td>Top182</td><td><a href>房间</a></td><td>2015</td><td>8.8</td></tr><tr><td>Top183</td><td><a href>可可西里</a></td><td>2004</td><td>8.7</td></tr><tr><td>Top184</td><td><a href>恐怖游轮</a></td><td>2009</td><td>8.4</td></tr><tr><td>Top185</td><td><a href>模仿游戏</a></td><td>2014</td><td>8.6</td></tr><tr><td>Top186</td><td><a href>一个叫欧维的男人决定去死</a></td><td>2015</td><td>8.8</td></tr><tr><td>Top187</td><td><a href>一次别离</a></td><td>2011</td><td>8.7</td></tr><tr><td>Top188</td><td><a href>忠犬八公物语</a></td><td>1987</td><td>9.1</td></tr><tr><td>Top189</td><td><a href>战争之王</a></td><td>2005</td><td>8.6</td></tr><tr><td>Top190</td><td><a href>追随</a></td><td>1998</td><td>8.9</td></tr><tr><td>Top191</td><td><a href>魔女宅急便</a></td><td>1989</td><td>8.5</td></tr><tr><td>Top192</td><td><a href>撞车</a></td><td>2004</td><td>8.6</td></tr><tr><td>Top193</td><td><a href>谍影重重</a></td><td>2002</td><td>8.5</td></tr><tr><td>Top194</td><td><a href>完美陌生人</a></td><td>2016</td><td>8.6</td></tr><tr><td>Top195</td><td><a href>地球上的星星</a></td><td>2007</td><td>8.9</td></tr><tr><td>Top196</td><td><a href>牯岭街少年杀人事件</a></td><td>1991</td><td>8.8</td></tr><tr><td>Top197</td><td><a href>谍影重重2</a></td><td>2004</td><td>8.6</td></tr><tr><td>Top198</td><td><a href>哪吒闹海</a></td><td>1979</td><td>8.9</td></tr><tr><td>Top199</td><td><a href>惊魂记</a></td><td>1960</td><td>8.9</td></tr><tr><td>Top200</td><td><a href>青蛇</a></td><td>1993</td><td>8.5</td></tr><tr><td>Top201</td><td><a href>梦之安魂曲</a></td><td>2000</td><td>8.7</td></tr><tr><td>Top202</td><td><a href>无敌破坏王</a></td><td>2012</td><td>8.7</td></tr><tr><td>Top203</td><td><a href>黑客帝国3：矩阵革命</a></td><td>2003</td><td>8.6</td></tr><tr><td>Top204</td><td><a href>小萝莉的猴神大叔</a></td><td>2015</td><td>8.5</td></tr><tr><td>Top205</td><td><a href>再次出发之纽约遇见你</a></td><td>2013</td><td>8.5</td></tr><tr><td>Top206</td><td><a href>海街日记</a></td><td>2015</td><td>8.7</td></tr><tr><td>Top207</td><td><a href>新龙门客栈</a></td><td>1992</td><td>8.5</td></tr><tr><td>Top208</td><td><a href>东京物语</a></td><td>1953</td><td>9.2</td></tr><tr><td>Top209</td><td><a href>步履不停</a></td><td>2008</td><td>8.8</td></tr><tr><td>Top210</td><td><a href>终结者2：审判日</a></td><td>1991</td><td>8.6</td></tr><tr><td>Top211</td><td><a href>源代码</a></td><td>2011</td><td>8.4</td></tr><tr><td>Top212</td><td><a href>初恋这件小事</a></td><td>2010</td><td>8.3</td></tr><tr><td>Top213</td><td><a href>绿里奇迹</a></td><td>1999</td><td>8.7</td></tr><tr><td>Top214</td><td><a href>城市之光</a></td><td>1931</td><td>9.2</td></tr><tr><td>Top215</td><td><a href>末路狂花</a></td><td>1991</td><td>8.7</td></tr><tr><td>Top216</td><td><a href>爱在午夜降临前</a></td><td>2013</td><td>8.8</td></tr><tr><td>Top217</td><td><a href>疯狂的石头</a></td><td>2006</td><td>8.3</td></tr><tr><td>Top218</td><td><a href>秒速5厘米</a></td><td>2007</td><td>8.3</td></tr><tr><td>Top219</td><td><a href>无耻混蛋</a></td><td>2009</td><td>8.5</td></tr><tr><td>Top220</td><td><a href>这个男人来自地球</a></td><td>2007</td><td>8.5</td></tr><tr><td>Top221</td><td><a href>勇闯夺命岛</a></td><td>1996</td><td>8.6</td></tr><tr><td>Top222</td><td><a href>E.T. 外星人</a></td><td>1982</td><td>8.5</td></tr><tr><td>Top223</td><td><a href>碧海蓝天</a></td><td>1988</td><td>8.7</td></tr><tr><td>Top224</td><td><a href>变脸</a></td><td>1997</td><td>8.4</td></tr><tr><td>Top225</td><td><a href>卡萨布兰卡</a></td><td>1942</td><td>8.6</td></tr><tr><td>Top226</td><td><a href>黄金三镖客</a></td><td>1966</td><td>9.1</td></tr><tr><td>Top227</td><td><a href>发条橙</a></td><td>1971</td><td>8.5</td></tr><tr><td>Top228</td><td><a href>彗星来的那一夜</a></td><td>2013</td><td>8.4</td></tr><tr><td>Top229</td><td><a href>聚焦</a></td><td>2015</td><td>8.8</td></tr><tr><td>Top230</td><td><a href>海盗电台</a></td><td>2009</td><td>8.6</td></tr><tr><td>Top231</td><td><a href>美国丽人</a></td><td>1999</td><td>8.5</td></tr><tr><td>Top232</td><td><a href>血钻</a></td><td>2006</td><td>8.5</td></tr><tr><td>Top233</td><td><a href>非常嫌疑犯</a></td><td>1995</td><td>8.6</td></tr><tr><td>Top234</td><td><a href>国王的演讲</a></td><td>2010</td><td>8.3</td></tr><tr><td>Top235</td><td><a href>荒野生存</a></td><td>2007</td><td>8.6</td></tr><tr><td>Top236</td><td><a href>英国病人</a></td><td>1996</td><td>8.5</td></tr><tr><td>Top237</td><td><a href>黑鹰坠落</a></td><td>2001</td><td>8.6</td></tr><tr><td>Top238</td><td><a href>我爱你</a></td><td>2011</td><td>9.0</td></tr><tr><td>Top239</td><td><a href>迁徙的鸟</a></td><td>2001</td><td>9.1</td></tr><tr><td>Top240</td><td><a href>遗愿清单</a></td><td>2007</td><td>8.5</td></tr><tr><td>Top241</td><td><a href>勇士</a></td><td>2011</td><td>8.9</td></tr><tr><td>Top242</td><td><a href>荒岛余生</a></td><td>2000</td><td>8.5</td></tr><tr><td>Top243</td><td><a href>2001太空漫游</a></td><td>1968</td><td>8.7</td></tr><tr><td>Top244</td><td><a href>枪火</a></td><td>1999</td><td>8.7</td></tr><tr><td>Top245</td><td><a href>燕尾蝶</a></td><td>1996</td><td>8.6</td></tr><tr><td>Top246</td><td><a href>叫我第一名</a></td><td>2008</td><td>8.6</td></tr><tr><td>Top247</td><td><a href>穆赫兰道</a></td><td>2001</td><td>8.3</td></tr><tr><td>Top248</td><td><a href>千钧一发</a></td><td>1997</td><td>8.7</td></tr><tr><td>Top249</td><td><a href>大卫·戈尔的一生</a></td><td>2003</td><td>8.6</td></tr><tr><td>Top250</td><td><a href>上帝也疯狂</a></td><td>1980</td><td>8.7</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      《龙猫》 12.14不见不散
    
    </summary>
    
      <category term="资源" scheme="/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="公众号文章" scheme="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Top电影" scheme="/tags/Top%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo+GitHub 搭建个人博客</title>
    <link href="/2018/11/28/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>/2018/11/28/使用Hexo+GitHub搭建个人博客/</id>
    <published>2018-11-28T07:36:06.000Z</published>
    <updated>2019-06-10T01:36:25.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>昨天偶然看见一篇有关使用Hexo搭建个人博客的文章，瞬间吸引我的注意。今天使用的一天的时间在GitHub上搭建了一个个人博客，感觉还不错，分享给大家，并记录下我搭建过程中趟过的坑</p><p>环境：Win10 + Hexo + GitHub</p><p>效果展示：<a href="https://xiongtianci-tc.github.io/" target="_blank" rel="noopener">脚印的博客</a></p></blockquote><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-了解Hexo"><a href="#1-了解Hexo" class="headerlink" title="1. 了解Hexo"></a>1. 了解Hexo</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>官方文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h2 id="2-搭建Node-js环境"><a href="#2-搭建Node-js环境" class="headerlink" title="2. 搭建Node.js环境"></a>2. 搭建Node.js环境</h2><p>Hexo基于Node.js环境，那么我们搭建博客网站首先需要安装Node.js环境</p><p>下载地址：<a href="http://nodejs.cn/download" target="_blank" rel="noopener">http://nodejs.cn/download</a></p><p>详细安装文档：<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-install-setup.html</a></p><p>测试安装：命令行使用 <code>node -v</code> 、<code>npm -v</code>，查看显示版本号即成功。如下图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543458424692.png" alt="1543458424692"> </p><h2 id="3-注册Github账号"><a href="#3-注册Github账号" class="headerlink" title="3. 注册Github账号"></a>3. 注册Github账号</h2><p>这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件</p><p>注册地址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com</a><br>注册流程：<a href="https://blog.csdn.net/p10010/article/details/51336332" target="_blank" rel="noopener">https://blog.csdn.net/p10010/article/details/51336332</a></p><blockquote><p>注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦</p></blockquote><h2 id="4-安装Git版本工具"><a href="#4-安装Git版本工具" class="headerlink" title="4. 安装Git版本工具"></a>4. 安装Git版本工具</h2><blockquote><p>使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步</p></blockquote><ul><li><p>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>Windows系统需下载，Mac系统因为自带Git无需操作</p><p>详细安装文档：<a href="https://blog.csdn.net/u013295518/article/details/78746007" target="_blank" rel="noopener">https://blog.csdn.net/u013295518/article/details/78746007</a></p><p>测试安装：<code>git --version</code>，查看显示版本号即成功。如下图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543458907014.png" alt="1543458907014"> </p></li><li><p>配置SSH：<a href="https://blog.csdn.net/qq_35246620/article/details/69061355" target="_blank" rel="noopener">https://blog.csdn.net/qq_35246620/article/details/69061355</a></p><p>SSH key添加之后，就可以在本机git bash中进行测试，输入<code>ssh -T git@github.com</code>进行测试</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543476938196.png" alt="1543476938196"> </p><p>显示 <code>Hi username ！You&#39;ve successfully...</code> 说明ssh配置成功了</p></li></ul><h2 id="5-在本地安装-Hexo"><a href="#5-在本地安装-Hexo" class="headerlink" title="5. 在本地安装 Hexo"></a>5. 在本地安装 Hexo</h2><blockquote><p>Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件</p></blockquote><pre><code>npm install -g hexo-cli</code></pre><blockquote><p>注意：在回车之后，可能会出现一行WARN的警告语句，不用管它，这个不妨碍安装</p><p>过一段时间如果出现hexo版本号之类的语句就代表差不多了</p></blockquote><p>然后输入</p><pre><code>npm install hexo --save</code></pre><p>这个时候你会看到命令行出现了一堆白字，紧接着输入<code>hexo v</code>查看是否安装成功：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543477381834.png" alt="1543477381834"> </p><p>此时，Hexo已经安装完成</p><h1 id="二、搭建博客"><a href="#二、搭建博客" class="headerlink" title="二、搭建博客"></a>二、搭建博客</h1><h2 id="1-开启GitHub-Pages服务"><a href="#1-开启GitHub-Pages服务" class="headerlink" title="1. 开启GitHub Pages服务"></a>1. 开启GitHub Pages服务</h2><p>搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543474709681.png" alt="1543474709681"></p><p>这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是：</p><blockquote><p>仓库名固定：你的github的username.github.io</p></blockquote><p> 这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：<code>https://UserName.github.io</code>的形式。</p><p>点击<code>Create Repository</code>后，选着仓库的<code>Setting</code>进入设置</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543476148226.png" alt="1543476148226"></p><p>往下滑找到 <code>Github Pages</code> 如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543477847990.png" alt="1543477847990"></p><p>这里我们需要点击 <code>Choose a theme</code> 任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543477980475.png" alt="1543477980475"></p><p>点击 <code>Select theme</code> 选着主题后，此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543478176563.png" alt="1543478176563"></p><p>输入你的 GitHub 的用户名和密码，成功后复制<code>https://username.github.io/</code>到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！</p><h2 id="2-创建本地博客站点"><a href="#2-创建本地博客站点" class="headerlink" title="2. 创建本地博客站点"></a>2. 创建本地博客站点</h2><p>上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下：</p><blockquote><p>hexo init  myHexoBlog       //myHexoBlog是项目名</p></blockquote><p>等一会，如果出现橙色的 <strong>WARN</strong> 没关系，只要不出现红色的 <strong>ERROR</strong> 就行。好了后，输入命令：</p><blockquote><p> hexo g      //g是generetor的缩写，生成博客</p><p> hexo s     //s是server的缩写，启动服务</p></blockquote><p>然后点开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！</p><h2 id="3-同步Github-允许公共访问"><a href="#3-同步Github-允许公共访问" class="headerlink" title="3. 同步Github,允许公共访问"></a>3. 同步Github,允许公共访问</h2><p>在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。<br>首先找到我们的博客仓库，并拷贝仓库地址：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543480461386.png" alt="1543480461386"></p><p>然后修改本地博客目录的配置：<br>修改本地博客根目录下的<code>_config.yml</code>文件，修改<code>deploy</code>下的配置，如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543480729831.png" alt="1543480729831"></p><pre><code>deploy:  type: git  repository: git@github.com:xiongtianci-tc/xiongtianci-tc.github.io.git #复制的仓库地址  branch: master</code></pre><blockquote><p>注意：</p><ol><li>repository后面的内容是 <a href="mailto:git@gitbub.com" target="_blank" rel="noopener">git@gitbub.com</a>:username/库地址 的形式</li><li>type、repository、branch冒号的后面都有一个空格（切记~~）</li></ol></blockquote><p>最后执行控制台命令：</p><pre><code>npm install hexo-deployer-git --save //安装部署插件hexo d //部署到github</code></pre><p>现在，我们再次访问链接：<code>https://userName.github.io</code>，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。</p><h1 id="三、发布你的第一篇博客"><a href="#三、发布你的第一篇博客" class="headerlink" title="三、发布你的第一篇博客"></a>三、发布你的第一篇博客</h1><p>终于可以发布自己的第一篇博客了，是不是很激动？（博主当时可是超级激动的~）<br>首先，在本地博客文件夹根目录输入：</p><pre><code>hexo new &quot;我个人博客的第一篇博客，激动~&quot;hexo g   //生成网页hexo d  //部署到远端(github)</code></pre><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543481316715.png" alt="1543481316715"> </p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543481394185.png" alt="1543481394185"> </p><p>现在打开我们的博客网站：<code>http://UserName.github.io</code>,会看到网页如下(可能需要刷新几次页面)：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543483567301.png" alt="1543483567301"></p><p>需要编写博客内容时，只需编写本地博客的 <code>_posts</code> 的博客原文，然后通过 <code>hexo g &amp;&amp; hexo d</code> 重新部署到github即可</p><h1 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h1><p>此时，我们的个人博客已经搭建完成。但是我们需要网站更加高大上，更加美观些，我们可以通过更换主题来实现个性化博客</p><p>这里以使用github上的next主题为例：</p><h2 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h2><p>next主题：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><p>在控制台中切换到本地博客根目录输入：</p><pre><code>$ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>下载成之后我们会看到next的主题已经存在 <code>thems</code> 里了如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543484274020.png" alt="1543484274020"> </p><h2 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2. 更换主题"></a>2. 更换主题</h2><p>修改博客根目录(不是next主题)下的 <code>_config.yml</code> 文件，搜索 <code>theme</code> 字段，并将其值修改为 <code>next</code></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543484383922.png" alt="1543484383922"> </p><p>然后在控制台下输入如下命令：</p><pre><code>hexo clean  //清理缓存hexo g    //重新生成博客代码hexo d   //部署到本地// 或者直接输入：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>再次打开我们的博客网站：<code>https://UserName.github.io</code>，将会发现我们的博客主题已经发生了改变</p><h1 id="五、个性化"><a href="#五、个性化" class="headerlink" title="五、个性化"></a>五、个性化</h1><p>通过此步骤我们可以设置博客的作者、格言、语言…</p><blockquote><p>在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项</p></blockquote><h2 id="1-站点配置"><a href="#1-站点配置" class="headerlink" title="1. 站点配置"></a>1. 站点配置</h2><p>在本地的博客根目录下找到_config.yml，用编辑器打开进行内容的设置，如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543485321688.png" alt="1543485321688"></p><p>这里可以修改博客网站的标题、描述，语言等属性</p><h2 id="2-主题设置"><a href="#2-主题设置" class="headerlink" title="2. 主题设置"></a>2. 主题设置</h2><p>网上有个超级详细的教程，我就不赘述了：</p><p>文档地址：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p><hr><p>终于结束了，</p><p>最后，</p>]]></content>
    
    <summary type="html">
    
      搭建博客
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Hexo" scheme="/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>同源策略与JS跨域</title>
    <link href="/2018/11/19/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8EJS%E8%B7%A8%E5%9F%9F/"/>
    <id>/2018/11/19/同源策略与JS跨域/</id>
    <published>2018-11-19T02:49:12.000Z</published>
    <updated>2019-06-10T07:58:31.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要跨域"><a href="#为什么要跨域" class="headerlink" title="为什么要跨域"></a>为什么要跨域</h1><p>为了用户的信息安全，浏览器就引入了同源策略<br>那么同源策略是如何保证用户的信息安全的呢？</p><ul><li>如果没有同源策略，你打开了你的银行账户页面A，又打开了另一个不相关的页面B，这时候如果B是恶意网站，B可以通过Javascript轻松访问和修改A页面中的内容</li><li>现在我们广泛的使用cookie来维护用户的登录状态，而如果没有同源策略，这些cookie信息就会泄露，其他网站就可以冒充这个登录用户</li></ul><p>由此可以看出，同源策略确实是必不可少的，那么它会带来哪些限制呢？</p><blockquote><ol><li>Cookie、LocalStorage和IndexDB无法读取</li><li>DOM无法获得</li><li>AJAX请求不能发送</li></ol></blockquote><p>有时候我们需要突破上述限制，就需要用跨域的方法来解决</p><h1 id="跨域是什么？"><a href="#跨域是什么？" class="headerlink" title="跨域是什么？"></a>跨域是什么？</h1><ol><li>什么叫做不同的域？<br>协议（http）、域名（<a href="http://www.a.com）、端口（8000）三者中有一个不同就叫不同的域" target="_blank" rel="noopener">www.a.com）、端口（8000）三者中有一个不同就叫不同的域</a></li><li>跨域就是不同的域间相互访问时使用某些方法来突破上述限制</li><li>协议或者端口的不同，只能通过后台来解决<h1 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h1><h3 id="一、解决上面提到的1、2两点限制："><a href="#一、解决上面提到的1、2两点限制：" class="headerlink" title="一、解决上面提到的1、2两点限制："></a>一、解决上面提到的1、2两点限制：</h3><h4 id="1-通过document-domain跨子域"><a href="#1-通过document-domain跨子域" class="headerlink" title="1. 通过document.domain跨子域"></a>1. 通过document.domain跨子域</h4><blockquote><p>适用范围：</p><ol><li>两个域只是子域不同</li><li>只适用于iframe窗口与父窗口之间互相获取cookie和DOM节点，不能突破LocalStorage和IndexDB的限制</li></ol></blockquote></li></ol><p>当两个不同的域只是子域不同时，可以通过把document.domain设置为他们共同的父域来解决</p><blockquote><p>eg:<br>A: <a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a><br>B: <a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a></p></blockquote><p>当A、B想要获取对方的<code>cookie</code>或者<code>DOM节点</code>时，可以设置:</p><blockquote><p>document.domain=’example.com’;</p></blockquote><p>这时A网页通过脚本设置:</p><blockquote><p>document.cookie = “testA=hello”;</p></blockquote><p>B网页就可以拿到这个cookie：</p><blockquote><p>var aCookie = document.cookie;</p></blockquote><h4 id="2-通过window-name跨域"><a href="#2-通过window-name跨域" class="headerlink" title="2. 通过window.name跨域"></a>2. 通过window.name跨域</h4><blockquote><p>使用范围：</p><ol><li>可以是两个完全不同源的域</li><li>同一个窗口内：即同一个标签页内先后打开的窗口</li></ol></blockquote><p>window.name属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。</p><p>基于这个思想，我们可以在某个页面设置好 window.name 的值，然后在本标签页内跳转到另外一个域下的页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。</p><p>结合iframe还有更高级的用法：</p><p>父窗口先打开一个与自己不同源的子窗口，在这个子窗口里设置：</p><blockquote><p>window.name = data;</p></blockquote><p>然后让子窗口跳转到一个与父窗口同域的网址：</p><blockquote><p>location=’<a href="http://www.parent.com/a.html&#39;" target="_blank" rel="noopener">http://www.parent.com/a.html&#39;</a>;</p></blockquote><p>这时，因为同域并且同一窗口window.name是不变的，所以父窗口可以获取到子窗口下的window.name。</p><blockquote><p>var data = document.getElementById(‘myFrame’).contentWindow.name;</p></blockquote><p>优点：window.name容量很大，可以放置非常长的字符串；缺点：必须监听子窗口window.name属性的变化，影响网页性能。</p><h4 id="3-使用HTML5的window-postMessage跨域"><a href="#3-使用HTML5的window-postMessage跨域" class="headerlink" title="3. 使用HTML5的window.postMessage跨域"></a>3. 使用HTML5的window.postMessage跨域</h4><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p><p>otherWindow.postMessage(message, targetOrigin);</p><p>otherWindow:接受消息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。<br>message:所要发送的数据，string类型。<br>targetOrigin:用于限制otherWindow，*表示不做限制。</p><h5 id="eg1"><a href="#eg1" class="headerlink" title="eg1:"></a>eg1:</h5><p>在父页面中嵌入子页面，通过postMessage发送数据。<br>parent.com/index.html中的代码：</p><pre><code>&lt;iframe id=&quot;ifr&quot; src=&quot;child.com/index.html&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() {    var ifr = document.getElementById(&#39;ifr&#39;);    var targetOrigin = &#39;http://child.com&#39;;     // 若写成&#39;http://child.com/c/proxy.html&#39;效果一样    // 若写成&#39;http://c.com&#39;就不会执行postMessage了    ifr.contentWindow.postMessage(&#39;I was there!&#39;, targetOrigin);};&lt;/script&gt;</code></pre><p>在子页面中通过message事件监听父页面发送来的消息并显示。<br>child.com/index.html中的代码：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;window.addEventListener(&#39;message&#39;, function(event){    // 通过origin属性判断消息来源地址    if (event.origin == &#39;http://parent.com&#39;) {        alert(event.data);    // 弹出&quot;I was there!&quot;        alert(event.source);          // 对parent.com、index.html中window对象的引用        // 但由于同源策略，这里event.source不可以访问window对象    }}, false);&lt;/script&gt;</code></pre><h5 id="eg2"><a href="#eg2" class="headerlink" title="eg2:"></a>eg2:</h5><p>假设在a.html里嵌套个</p><pre><code>&lt;iframe src=&quot;http://www.child.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code></pre><p>在这两个页面里互相通信</p><p><strong>a.html</strong></p><pre><code>window.onload = function() {    window.addEventListener(&quot;message&quot;, function(e) {        alert(e.data);    });    window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.child.com/b.html&quot;);}</code></pre><p><strong>b.html</strong></p><pre><code>window.onload = function() {    window.addEventListener(&quot;message&quot;, function(e) {        alert(e.data);    });    window.parent.postMessage(&quot;a data&quot;, &quot;http://www.parent.com/a.html&quot;);}</code></pre><p>这样打开a页面，首先监听到了b.html通过postMessage传来的消息，就先弹出 a data，然后a通过postMessage传递消息给子页面b.html，这时会弹出 b data</p><h3 id="二、解决第3点限制："><a href="#二、解决第3点限制：" class="headerlink" title="二、解决第3点限制："></a>二、解决第3点限制：</h3><blockquote><p>AJAX请求不能发送</p></blockquote><h4 id="4-通过JSONP跨域"><a href="#4-通过JSONP跨域" class="headerlink" title="4. 通过JSONP跨域"></a>4. 通过JSONP跨域</h4><blockquote><p>适用范围：</p><ol><li>可以是两个完全不同源的域；</li><li>只支持HTTP请求中的GET方式；</li><li>老式浏览器全部支持；</li><li>需要服务端支持</li></ol></blockquote><p>JSONP(JSON with Padding)是资料格式JSON的一种使用模式，可以让网页从别的网域要资料。</p><p>由于浏览器的同源策略，在网页端出现了这个“跨域”的问题，然而我们发现，所有的 src 属性并没有受到相关的限制，比如 img / script 等。</p><p>JSONP 的原理就要从 script 说起。script 可以引用其他域的脚本文件，比如这样：</p><pre><code>a.html...&lt;script&gt;    function callback(data) {        console.log(data.url)    }&lt;/script&gt;&lt;script src=&#39;b.js&#39;&gt;&lt;/script&gt;...b.jscallback({url: &#39;http://www.rccoder.net&#39;})</code></pre><p>这就类似于JSONP的原理了。</p><p>JSONP的基本思想是：先在网页上添加一个script标签，设置这个script标签的src属性用于向服务器请求JSON数据 ，需要注意的是，src属性的查询字符串一定要加一个callback参数，用来指定回调函数的名字 。而这个函数是在资源加载之前就已经在前端定义好的，这个函数接受一个参数并利用这个参数做一些事情。向服务器请求后，服务器会将JSON数据放在一个指定名字的回调函数里作为其参数传回来。这时，因为函数已经在前端定义好了，所以会直接调用。</p><p>eg：</p><pre><code>function addScriptTag(src) {    var script = document.createElement(&#39;script&#39;);    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);    script.src = src;    document.body.appendChild(script);}window.onload = function () {    addScriptTag(&#39;http://example.com/ip?callback=foo&#39;);//请求服务器数据并规定回调函数为foo}function foo(data) {    console.log(&#39;Your public IP address is: &#39; + data.ip);};</code></pre><p>向服务器example.com请求数据，这时服务器会先生成JSON数据，这里是{“ip”: “8.8.8.8”}，然后以JS语法的方式生成一个函数，函数名就是传递上来的callback参数的值，最后将数据放在函数的参数中返回：</p><pre><code>foo({    &quot;ip&quot;: &quot;8.8.8.8&quot;});</code></pre><p>客户端解析script标签，执行返回的JS代码，调用函数。</p><h5 id="5-通过CORS跨域"><a href="#5-通过CORS跨域" class="headerlink" title="5. 通过CORS跨域"></a>5. 通过CORS跨域</h5><blockquote><p>适用范围：</p><ol><li>可以是两个完全不同源的域；</li><li>支持所有类型的HTTP请求；</li><li>被绝大多数现代浏览器支持，老式浏览器不支持；</li><li>需要服务端支持</li></ol></blockquote><p>对于前端开发者来说，跨域的CORS通信与同源的AJAX通信没有差别，代码完全一样。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><pre><code>（1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre><p>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p><p>简单请求：<br>下面是一次跨源AJAX请求，浏览器发现它是简单请求，就会直接在头信息中加一个origin字段：</p><pre><code>GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>服务器收到这条请求，如果这个origin指定的源在许可范围内，那么服务器返回的头信息中会包含Access-Control-Allow-Origin字段，值与origin的值相同，以及其他几个相关字段：</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBar</code></pre><p>Access-Control-Allow-Origin: 该字段是必须的。要么与origin相同，要么为*<br>Access-Control-Allow-Credentials: 该字段可选。设为true表示服务器允许发送cookie<br>Access-Control-Expose-Headers: 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><p>想要发送cookie，这里还有两点需要额外注意：</p><p>1）开发者必须在AJAX请求中打开withCredentials属性。</p><pre><code>var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre><p>否则即使服务器允许，客户端也不会发送。</p><p>2）Access-Control-Allow-Origin不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><p>非简单请求：<br>1.预检请求：</p><p>非简单请求会在正式通信前加一次预检（preflight）请求。作用是浏览器先询问服务器当前网页所在域名是否在服务器的许可名单中，以及可以使用哪些HTTP方法以及头信息字段。只有得到肯定答复，浏览器才会发送XMLHttpRequest，否则报错。<br>一个例子：</p><pre><code>var url = &#39;http://api.alice.com/cors&#39;;var xhr = new XMLHttpRequest();xhr.open(&#39;PUT&#39;, url, true);xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;);xhr.send();</code></pre><p>HTTP请求方法为PUT，并发送一个自定义头信息”X-Custom-Header”，浏览器发现这是一个非简单请求，就会自动发送一个预检请求，预检请求的HTTP头信息如下：</p><pre><code>OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>请求方法是OPTIONS，表示这个请求是用来询问的，头信息中的关键信息有3个：</p><p>（1）表示请求来自哪个源</p><pre><code>Origin: http://api.bob.com</code></pre><p>（2）列出浏览器的CORS请求会用到哪些HTTP方法</p><pre><code>Access-Control-Request-Method: PUT</code></pre><p>（3）指定浏览器CORS请求会额外发送的头信息字段</p><pre><code>Access-Control-Request-Headers: X-Custom-Header</code></pre><p>2.预检请求的回应（有两种情况：A允许、B不允许）</p><p>A.服务器允许这次跨域请求</p><pre><code>HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plainAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000</code></pre><p>服务器返回中要注意的字段：</p><p>（1）服务器同意的跨域请求源：</p><pre><code>Access-Control-Allow-Origin: http://api.bob.com</code></pre><p>（2）服务器支持的所有跨域请求的方法：</p><pre><code>Access-Control-Allow-Methods: GET, POST, PUT</code></pre><p>（3）表明服务器支持的所有头信息字段：</p><pre><code>Access-Control-Allow-Headers: X-Custom-Header</code></pre><p>（4）指定本次预检请求的有效期，单位为秒，即允许请求该条回应在有效期之前都不用再发送预检请求：</p><pre><code>Access-Control-Max-Age: 1728000</code></pre><p>B.服务器不允许这次跨域请求<br>即origin指定的源不在许可范围内，服务器会返回一个正常的HTTP回应。但是头信息中没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。但是要注意的是，这种HTTP回应的状态码很有可能是200，所以无法通过状态码识别这种错误。</p><p>3.正式请求<br>过了预检请求，非简单请求的正式请求就与简单请求一样了。</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>电商项目中的SPU和SKU概念</title>
    <link href="/2018/11/16/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84SPU%E5%92%8CSKU%E6%A6%82%E5%BF%B5/"/>
    <id>/2018/11/16/电商项目中的SPU和SKU概念/</id>
    <published>2018-11-16T06:58:37.000Z</published>
    <updated>2019-06-10T07:57:46.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPU"><a href="#SPU" class="headerlink" title="SPU"></a>SPU</h2><p><strong>SPU</strong>：Standard Product Unit，标准产品单位。</p><blockquote><p>概念：SPU 是商品信息聚合的最小单位【即：商品共同的属性】，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。<br>通俗点讲，属性值、特性相同的货品就可以称为一个 SPU</p></blockquote><p>SPU是用来定位的<br>例如：iphone8 就是一个 SPU，与商家、颜色、款式、套餐都无关</p><h2 id="SKU"><a href="#SKU" class="headerlink" title="SKU"></a>SKU</h2><p><strong>SKU</strong>：Stock Keeping Unit，库存量单位。</p><blockquote><p>概念：SKU 即库存进出计量的单位， 可以是以件、盒、托盘等为单位，是物理上不可分割的最小存货单元。<br>在使用时要根据不同业务，不同管理模式来处理</p></blockquote><p>SKU是用来定价和管理库存的<br>iphone8 有很多颜色，很多配置，每个颜色和配置的组合都会形成新的产品，这时就产生很多SKU<br>例如：银色 64G 的 iphone8 就是一个SKU；纺织品中一个 SKU 通常表示：规格、颜色、款式</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Servlet简介及其生命周期详解</title>
    <link href="/2018/11/16/Servlet%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>/2018/11/16/Servlet简介及其生命周期详解/</id>
    <published>2018-11-16T02:36:38.000Z</published>
    <updated>2019-06-10T07:56:44.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Servlet？"><a href="#一、什么是Servlet？" class="headerlink" title="一、什么是Servlet？"></a>一、什么是Servlet？</h2><p><strong>Servlet</strong>：是用Java编写的服务器端程序，一门用于开发动态web资源的技术。其主要功能在与交互式的浏览和修改数据，生成动态web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet的类。一般对Servlet的理解是后者。<br>若想开发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：<br>　　1、编写一个Java类，实现servlet接口。<br>　　2、把开发好的Java类部署到web服务器中。<br>按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet</p><h2 id="二、Servlet的运行流程"><a href="#二、Servlet的运行流程" class="headerlink" title="二、Servlet的运行流程"></a>二、Servlet的运行流程</h2><p>Servlet程序是由WEB服务器调用，WEB服务器收到客户端的Servlet访问请求后：</p><ol><li>Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步</li><li>装载并创建该Servlet的一个实例对象 </li><li>调用Servlet实例对象的<code>init()</code>方法</li><li>创建一个用于封装HTTP请求消息的<code>HttpServletRequest</code>对象和一个代表HTTP响应消息的<code>HttpServletResponse</code>对象，然后调用Servlet的<code>service()</code>方法并将请求和响应对象作为参数传递进去</li><li>WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的<code>destroy()</code>方法</li></ol><p><img src="https://img-blog.csdnimg.cn/20181116103539879.png" alt="在这里插入图片描述"></p><h2 id="三、Servlet的生命周期"><a href="#三、Servlet的生命周期" class="headerlink" title="三、Servlet的生命周期"></a>三、Servlet的生命周期</h2><p>Servlet运行在Servlet容器中，其生命周期由容器来管理。Servlet的生命周期通过javax.servlet.Servlet接口中的<code>init()</code>、<code>service()</code>和<code>destroy()</code>方法来表示<br>Servlet的生命周期包含了下面4个阶段：</p><ol><li><strong>加载和实例化</strong>：第一次请求时创建，通过服务器反射机制创建Servlet对象</li><li><strong>初始化</strong>：调用Servlet对象的<code>init()</code>方法，初始化Servlet的信息，<code>init()</code>方法只会在创建后被调用一次</li><li><strong>请求处理</strong>：调用<code>service()</code>或者是<code>doGet()</code>，<code>doPost()</code>方法来处理请求</li><li><strong>服务终止</strong>：在长时间没有被调用或者是服务器关闭时，会调用<code>destroy()</code>方法来销毁Servlet对象</li></ol><p>在整个Servlet的生命周期过程中，创建Servlet实例、调用实例的<code>init()</code>和<code>destroy()</code>方法都只执行一次，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的<code>service()</code>方法，为接收到的请求服务</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>反向安装jar包到Mave本地仓库</title>
    <link href="/2018/11/15/%E5%8F%8D%E5%90%91%E5%AE%89%E8%A3%85jar%E5%8C%85%E5%88%B0Mave%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"/>
    <id>/2018/11/15/反向安装jar包到Mave本地仓库/</id>
    <published>2018-11-14T17:17:48.000Z</published>
    <updated>2019-06-10T07:55:39.494Z</updated>
    
    <content type="html"><![CDATA[<p>当maven中央仓库没有所需jar的坐标时，需要自行将jar包反向安装到maven的本地仓库中<br>步骤：</p><blockquote><p>注意：前提是安装好Maven并且配置好maven的环境变量</p><ol><li>准备所需的jar包<br><img src="https://img-blog.csdnimg.cn/20181115010549472.png" alt="在这里插入图片描述"></li><li>打开命令行，输入以下命令，按下回车即可安装<pre><code>mvn install:install-file -Dfile=d:\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</code></pre><img src="https://img-blog.csdnimg.cn/20181115011230828.png" alt="在这里插入图片描述"></li><li>可以在Maven本地仓库中查看是否安装成功<br><img src="https://img-blog.csdnimg.cn/20181115011514373.png" alt="在这里插入图片描述"></li><li>在pom文件中导入坐标<br><code>`</code>xml</li></ol></blockquote><p><dependency><br>    <groupid>com.alibaba</groupid><br>    <artifactid>dubbo</artifactid><br>    <version>2.8.4</version><br></dependency><br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC的工作原理</title>
    <link href="/2018/11/09/SpringMVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>/2018/11/09/SpringMVC的工作原理/</id>
    <published>2018-11-09T13:17:04.000Z</published>
    <updated>2019-06-10T07:54:40.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SpringMVC的主要组件"><a href="#1-SpringMVC的主要组件" class="headerlink" title="1. SpringMVC的主要组件"></a>1. SpringMVC的主要组件</h2><ul><li><strong>DispatchServlet</strong>：前端控制器，接收请求，响应结果，返回可以是json,String等数据类型，也可以是页面（Model）</li><li><strong>HandlerMapping</strong>：处理器映射器，根据URL去查找处理器，一般通过xml配置或者注解进行查找</li><li><strong>Handler</strong>：处理器，即Controller控制器，由我们程序员编写</li><li><strong>HandlerAdapter</strong>：处理器适配器，可以将处理器包装成适配器，这样就可以支持多种类型的处理器</li><li><strong>ViewResolver</strong>：视图解析器，进行视图解析，返回view对象（常见的有JSP,FreeMark等）</li></ul><h2 id="2-SpringMVC的工作原理"><a href="#2-SpringMVC的工作原理" class="headerlink" title="2. SpringMVC的工作原理"></a>2. SpringMVC的工作原理</h2><p><img src="https://img-blog.csdnimg.cn/20181109211450528.png" alt="在这里插入图片描述"></p><ol><li>用户向服务器发送请求，请求被 SpringMVC 前端控制器DispatchServlet 捕获</li><li>DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping<br>将请求映射到处理器 HandlerExcutionChain</li><li>DispatchServlet 根据获得 Handler 选择一个合适的 HandlerAdapter 适配器处理；</li><li>Handler 对数据处理完成以后将返回一个 ModelAndView() 对象给 DisPatchServlet;</li><li>Handler 返回的 ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet 通过 ViewResolver 试图解析器将逻辑视图转化为真正的视图View;</li><li>DispatcherServle 通过model 解析出 ModelAndView() 中的参数进行解析最终展现出完整的 view 并返回给<br>客户端</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 的基本数据类型都有哪些，各占几个字节</title>
    <link href="/2018/11/09/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/"/>
    <id>/2018/11/09/Java的基本数据类型都有哪些，各占几个字节/</id>
    <published>2018-11-09T09:37:25.000Z</published>
    <updated>2019-06-10T07:54:57.530Z</updated>
    
    <content type="html"><![CDATA[<table><br>    <thead><br>        <tr><br>            <th>四类</th><br>            <th>八种</th><br>            <th>字节数</th><br>            <th>数据表示范围</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <th rowspan="4">整型</th><br>            <td>byte</td><br>            <td>1</td><br>            <td>-128~127</td><br>        </tr><br>        <tr><br>            <td>short</td><br>            <td>2</td><br>            <td>-32768~32767</td><br>        </tr><br>        <tr><br>            <td>int</td><br>            <td>4</td><br>            <td>-2147483648～2147483647</td><br>        </tr><br>        <tr><br>            <td>long</td><br>            <td>8</td><br>            <td>-2^63^～2^63^-1</td><br>        </tr><br>        <tr><br>            <th rowspan="2">浮点型</th><br>            <td>float</td><br>            <td>4</td><br>            <td>-3.403E38～3.403E38</td><br>        </tr><br>        <tr><br>            <td>double </td><br>            <td>8</td><br>            <td>-1.798E308～1.798E308</td><br>        </tr><br>        <tr><br>            <th>字符型</th><br>            <td>char</td><br>            <td>2</td><br>            <td>表示一个字符，如(‘a’，’A’，’0’，’家’)</td><br>        </tr><br>        <tr><br>            <th>布尔型</th><br>            <td>boolean</td><br>            <td>1</td><br>            <td>只有两个值true与false</td><br>        </tr><br>    </tbody><br></table>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>final、finally、finalize 的区别</title>
    <link href="/2018/11/09/final%E3%80%81finally%E3%80%81finalize-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>/2018/11/09/final、finally、finalize-的区别/</id>
    <published>2018-11-09T08:33:44.000Z</published>
    <updated>2019-06-10T07:50:58.128Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>final</strong>：用于声明属性( 变量 )，方法和类。分别表示属性不可变( 不可二次赋值 )，方法不可覆盖，被其修饰的类不可继承</li><li><strong>finally</strong>：异常处理语句 try/catch 结构的一部分，表示总是执行</li><li><strong>finalize</strong>：Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>数组的两种排序方式：选择排序和冒泡排序</title>
    <link href="/2018/11/09/%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>/2018/11/09/数组的两种排序方式：选择排序和冒泡排序/</id>
    <published>2018-11-09T08:23:06.000Z</published>
    <updated>2019-06-10T07:49:39.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>原理：在数组中选择出最小（大）的一个数，与第一个位置的数进行交换位置；<br><code>`</code><br>int[] arr = {5,8,3,9,10,2};<br>System.out.println(“排序前：” + Arrays.toString(arr));</p></blockquote><p>// 使用两层循环遍历数组，将前一位数值与后面以为数值进行比较，<br>// 如果前一位数值要大于后一位数值，则交换他们的位置。故而可以实现排序<br>for(int m = 0; m&lt;arr.length-1; m++){<br>    for(int n = m+1; n&lt;arr.length; n++){<br>        if(arr[m] &gt; arr[n]){<br>            // 用于临时储存需要交换位置的某一个值<br>            int temp = arr[m];<br>            // 交换位置<br>            arr[m] = arr[n];<br>            arr[n] = temp;<br>        }<br>    }<br>}<br>System.out.println(“排序后：” + Arrays.toString(arr));</p><pre><code>## 冒泡排序</code></pre><p>int[] arr = {5,8,3,9,10,2};<br>System.out.println(“排序前：” + Arrays.toString(arr));</p><p>// 使用两层循环遍历数组<br>for(int m = 0; m&lt;arr.length-1; m++){<br>    // 第二层循环，将 arr 索引为 0~arr.length-1-m 中最大的一个数移动到 arr[arr.length-1-m] 的位置<br>    for(int n = 0; n&lt;arr.length-1-m; n++){<br>        if(arr[n] &gt; arr[n+1]){<br>            // 用于临时储存需要交换位置的某一个值<br>            int temp = arr[n];<br>            // 交换位置<br>            arr[n] = arr[n+1];<br>            arr[n+1] = temp;<br>        }<br>    }<br>}<br>System.out.println(“排序后：” + Arrays.toString(arr));<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何显示隐藏的Chrome扩展程序图标</title>
    <link href="/2018/11/08/%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E7%9A%84Chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87/"/>
    <id>/2018/11/08/如何显示隐藏的Chrome扩展程序图标/</id>
    <published>2018-11-08T07:33:35.000Z</published>
    <updated>2019-06-10T07:50:03.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-将扩展程序图标在-Chrome-菜单中隐藏"><a href="#1-将扩展程序图标在-Chrome-菜单中隐藏" class="headerlink" title="1. 将扩展程序图标在 Chrome 菜单中隐藏"></a>1. 将扩展程序图标在 Chrome 菜单中隐藏</h2><p>将鼠标移动到需要隐藏的扩展程序上面，点击鼠标右键，选择“在 Chrome 菜单中隐藏”即可进行隐藏<br><img src="https://img-blog.csdnimg.cn/20181108152413697.png" alt="在这里插入图片描述"></p><h2 id="2-将隐藏的扩展程序图标在-Chrome-菜单中重新显示"><a href="#2-将隐藏的扩展程序图标在-Chrome-菜单中重新显示" class="headerlink" title="2. 将隐藏的扩展程序图标在 Chrome 菜单中重新显示"></a>2. 将隐藏的扩展程序图标在 Chrome 菜单中重新显示</h2><p>在浏览器地址栏最右边，待鼠标变成左右双向箭头图标的时候向左拖动，会发现隐藏的扩展程序出现了<br><img src="https://img-blog.csdnimg.cn/20181108152531335.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Typora设置图片的相对路径（win系统）</title>
    <link href="/2018/09/30/Typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/"/>
    <id>/2018/09/30/Typora设置图片的相对路径（win系统）/</id>
    <published>2018-09-30T07:17:41.000Z</published>
    <updated>2019-06-10T07:46:42.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typora设置图片的相对路径（win系统）"><a href="#Typora设置图片的相对路径（win系统）" class="headerlink" title="Typora设置图片的相对路径（win系统）"></a>Typora设置图片的相对路径（win系统）</h1><h4 id="步骤：文件–-gt-偏好设置–-gt-图片插入"><a href="#步骤：文件–-gt-偏好设置–-gt-图片插入" class="headerlink" title="步骤：文件–&gt;偏好设置–&gt;图片插入"></a>步骤：文件–&gt;偏好设置–&gt;图片插入</h4><h4 id="结果：将插入的图片路径设置成相对路径（-assets目录）"><a href="#结果：将插入的图片路径设置成相对路径（-assets目录）" class="headerlink" title="结果：将插入的图片路径设置成相对路径（./assets目录）"></a>结果：将插入的图片路径设置成相对路径（./assets目录）</h4><p><img src="https://img-blog.csdn.net/20180930151428623" alt="第一步"><br><img src="https://img-blog.csdn.net/20180930151509174" alt="第二步"><br><img src="https://img-blog.csdn.net/20180930151533395" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
