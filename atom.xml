<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天赐</title>
  
  <subtitle>Viva La Vida</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.xiongtianci.com/"/>
  <updated>2019-06-15T15:01:42.807Z</updated>
  <id>https://www.xiongtianci.com/</id>
  
  <author>
    <name>天赐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电影资源网址-珍藏</title>
    <link href="https://www.xiongtianci.com/2019/06/15/%E7%94%B5%E5%BD%B1%E8%B5%84%E6%BA%90%E7%BD%91%E5%9D%80-%E7%8F%8D%E8%97%8F/"/>
    <id>https://www.xiongtianci.com/2019/06/15/电影资源网址-珍藏/</id>
    <published>2019-06-15T13:55:43.000Z</published>
    <updated>2019-06-15T15:01:42.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电影讯息"><a href="#电影讯息" class="headerlink" title="电影讯息"></a>电影讯息</h1><ul><li><a href="http://movie.douban.com/" target="_blank" rel="noopener">豆瓣电影</a></li><li><a href="http://www.mtime.com/" target="_blank" rel="noopener">时光网</a></li><li><a href="http://www.imdb.com/" target="_blank" rel="noopener">IMDB</a></li><li><a href="http://www.rottentomatoes.com/" target="_blank" rel="noopener">烂番茄</a></li><li><a href="http://www.metacritic.com/" target="_blank" rel="noopener">MTC</a></li><li><a href="http://www.cbooo.cn/" target="_blank" rel="noopener">时时票房</a></li><li><a href="http://tvfantasy.net/" target="_blank" rel="noopener">天涯小筑</a></li><li><a href="https://www.criterion.com/" target="_blank" rel="noopener">CC官网</a></li><li><a href="http://www.atmovies.com.tw/movie/" target="_blank" rel="noopener">台湾电影资料站</a></li><li><a href="https://tw.movies.yahoo.com/index.html" target="_blank" rel="noopener">雅虎电影</a></li><li><a href="http://www.impawards.com/" target="_blank" rel="noopener">电影海报</a></li></ul><h1 id="新电影"><a href="#新电影" class="headerlink" title="新电影"></a>新电影</h1><h2 id="生肉"><a href="#生肉" class="headerlink" title="生肉"></a>生肉</h2><ul><li><a href="https://piratebayblocked.com/" target="_blank" rel="noopener"><strong>海盗湾</strong></a></li><li><a href="https://zooqle.com/" target="_blank" rel="noopener"><strong>Zooqle</strong></a></li><li><a href="https://torrentgalaxy.to/" target="_blank" rel="noopener"><strong>TorrentGalaxy</strong></a></li><li><a href="https://rarbg.to/torrents.php" target="_blank" rel="noopener">RARBG</a></li><li><a href="https://katcr.co/category/movies/page/" target="_blank" rel="noopener">kat片源</a></li><li><a href="https://limetorrents.unblocked.lc/browse-torrents/Movies/" target="_blank" rel="noopener">lime</a></li><li><a href="https://monova.org/" target="_blank" rel="noopener">Monova</a></li><li><a href="http://rutracker.org/forum/index.php" target="_blank" rel="noopener">俄站</a></li><li><a href="https://to.sshdd.co.kr/movies" target="_blank" rel="noopener">==韩站==</a></li><li><a href="https://eztv.ag/" target="_blank" rel="noopener">eztv美剧</a></li><li><a href="http://pianyuan.net/" target="_blank" rel="noopener">片源网</a></li><li><a href="http://www.piancang.cc/list/1-0-0-0-0-0-0-0-2.html" target="_blank" rel="noopener"><del>片仓网</del></a></li><li><a href="https://torrentking.eu/" target="_blank" rel="noopener"><del>torrentking</del></a></li></ul><h2 id="熟肉"><a href="#熟肉" class="headerlink" title="熟肉"></a>熟肉</h2><ul><li><a href="http://www.dysfz.cc/" target="_blank" rel="noopener">电影首发站</a></li><li><a href="http://www.shinybbs.com/forum.php?mod=forumdisplay&amp;fid=2" target="_blank" rel="noopener">深影论坛</a></li><li><a href="http://www.btbtt.me/" target="_blank" rel="noopener">BT之家</a></li><li><a href="http://www.gscq.me/" target="_blank" rel="noopener">GSCQ</a></li><li><a href="http://www.dygang.com/" target="_blank" rel="noopener">6V电影网</a></li><li><a href="http://www.xiaohx.net/" target="_blank" rel="noopener">小浣熊</a></li><li><a href="http://www.gagays.xyz/site/index" target="_blank" rel="noopener">嘎嘎影视</a></li><li><a href="http://www.btjia.cc/" target="_blank" rel="noopener">BT家</a></li><li><a href="http://bbs.btwuji.com/thread.php?fid=8" target="_blank" rel="noopener">无极论坛</a></li><li><a href="http://www.hdmayi.com/forum-38-1.html" target="_blank" rel="noopener">帝国出品</a></li><li><a href="http://www.ed2000.com/" target="_blank" rel="noopener">ed2000</a></li><li><a href="http://www.bttiantang.org/" target="_blank" rel="noopener">BT天堂</a></li><li><a href="http://www.cnscg.org/" target="_blank" rel="noopener">圣城影视</a></li><li><a href="https://www.xingk.cc/forum.php" target="_blank" rel="noopener">星空家园</a></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul><li><a href="http://www.jlpzj.net/" target="_blank" rel="noopener">纪录片之家</a></li><li><a href="http://docuwiki.net/index.php?title=Main_Page" target="_blank" rel="noopener">wiki</a></li><li><a href="http://www.laojilu.com/" target="_blank" rel="noopener">老纪录片</a></li><li><a href="http://www.jlpcn.net/" target="_blank" rel="noopener">纪录片天地</a></li><li><a href="http://www.xmqzmz.org/" target="_blank" rel="noopener">夏末秋字幕组</a></li><li><a href="https://sub.kamigami.org/category/documentary" target="_blank" rel="noopener">诸神字幕组</a></li></ul><h1 id="美剧"><a href="#美剧" class="headerlink" title="美剧"></a>美剧</h1><ul><li><a href="http://www.dysfz.cc/key/%E7%BE%8E%E5%89%A7/" target="_blank" rel="noopener">电影首发站美剧</a></li><li><a href="http://www.zimuzu.tv/fresourcelist" target="_blank" rel="noopener">字幕组</a></li><li><a href="http://cili001.com/" target="_blank" rel="noopener">磁力站</a></li><li><a href="http://www.ttmeiju.com/" target="_blank" rel="noopener">天天美剧</a></li><li><a href="http://videos.yizhansou.com/" target="_blank" rel="noopener">一键搜</a></li><li><a href="http://dbfansub.com/" target="_blank" rel="noopener">电波字幕组</a></li><li><a href="http://www.icezmz.com/series" target="_blank" rel="noopener">冰冰字幕组</a></li><li><a href="http://bbs.xuanzmz.cc/" target="_blank" rel="noopener">玄字幕组</a></li><li><a href="https://fantopia.club/" target="_blank" rel="noopener">Fantopia字幕组</a></li><li><a href="http://www.orangesub.com/" target="_blank" rel="noopener">Orange字幕组</a></li><li><a href="https://djzmz.org/" target="_blank" rel="noopener">大家字幕组</a></li><li><a href="http://www.yuzijiang.cc/" target="_blank" rel="noopener">鱼子酱</a></li></ul><h1 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h1><ul><li><a href="http://www.dilidili.com/" target="_blank" rel="noopener">D站</a></li><li><a href="https://nyaso.com/" target="_blank" rel="noopener">喵搜</a></li><li><a href="https://share.dmhy.org/" target="_blank" rel="noopener">动漫花园</a></li><li><a href="http://mikanani.me/" target="_blank" rel="noopener">密柑计划</a></li><li><a href="http://www.36dm.com/" target="_blank" rel="noopener">简单动漫</a></li><li><a href="http://www.xkdmbt.com/" target="_blank" rel="noopener">汐空动漫</a></li><li><a href="http://www.comicat.org/" target="_blank" rel="noopener">漫猫动漫</a></li><li><a href="https://bangumi.moe/" target="_blank" rel="noopener">萌番组</a></li></ul><h1 id="韩剧"><a href="#韩剧" class="headerlink" title="韩剧"></a>韩剧</h1><ul><li><a href="http://www.dysfz.cc/key/%E9%9F%A9%E5%89%A7/" target="_blank" rel="noopener">电影首发站韩剧</a></li><li><a href="http://www.hanmi520.com/forum-8-1.html" target="_blank" rel="noopener">韩迷字幕组</a></li><li><a href="http://www.hanfan.cc/variety/" target="_blank" rel="noopener">韩国综艺</a></li><li><a href="http://www.zzkorea.com/forum-67-1.html" target="_blank" rel="noopener">住在韩国</a></li></ul><h1 id="日剧"><a href="#日剧" class="headerlink" title="日剧"></a>日剧</h1><ul><li><a href="http://www.dysfz.cc/key/%E6%97%A5%E5%89%A7/" target="_blank" rel="noopener">电影首发站日剧</a></li><li><a href="http://www.hideystudio.com/drama/" target="_blank" rel="noopener">隐社导航</a></li><li><a href="http://zhuixinfan.com/main.php" target="_blank" rel="noopener">追新番网</a></li><li><a href="http://www.mytvbt.net/forumdisplay.php?fid=6&amp;page=1" target="_blank" rel="noopener">日菁字幕组</a></li><li><a href="http://www.jpdrama.cn/forum.php?mod=forumdisplay&amp;fid=306" target="_blank" rel="noopener">猪猪日剧字幕组</a></li><li><a href="http://www.fixsub.com/%E6%88%91%E4%BB%AC%E7%9A%84%E4%BD%9C%E5%93%81?cat=fix%E6%97%A5%E8%AF%AD%E7%A4%BE" target="_blank" rel="noopener">FIX日语社</a></li><li><a href="http://yuanweizimuzu.lofter.com/view" target="_blank" rel="noopener">原味字幕组</a></li><li><a href="http://pssclub.com/forum.php?mod=forumdisplay&amp;fid=2&amp;page=1" target="_blank" rel="noopener">三角字幕组</a></li><li><a href="http://www.tokyonothot.com/portal.php" target="_blank" rel="noopener">东京不够热</a></li><li><a href="http://forum.6cn.org/forum-105-1.html" target="_blank" rel="noopener">第六感</a></li></ul><h1 id="网盘搜索"><a href="#网盘搜索" class="headerlink" title="网盘搜索"></a>网盘搜索</h1><ul><li><a href="https://biliworld.com/" target="_blank" rel="noopener">哔哩网盘搜索</a></li><li><a href="http://www.bdsola.com/" target="_blank" rel="noopener">百度云</a></li><li><a href="http://www.panc.cc/" target="_blank" rel="noopener">胖次</a></li><li><a href="http://www.quzhuanpan.com/source/loadSourceList.do?type=1" target="_blank" rel="noopener">去转盘网</a></li><li><a href="http://www.5p44.com/" target="_blank" rel="noopener">5p44</a></li><li><a href="http://so.baiduyun.me/" target="_blank" rel="noopener">网盘搜</a></li><li><a href="http://www.daimugua.com/" target="_blank" rel="noopener">呆木瓜</a></li></ul><h1 id="BT搜索"><a href="#BT搜索" class="headerlink" title="BT搜索"></a>BT搜索</h1><ul><li><a href="https://www.chapianyuan.com/" target="_blank" rel="noopener">磁力&amp;电驴搜索</a></li><li><a href="http://sou.mj0351.com/index.html" target="_blank" rel="noopener">梦境搜索</a></li><li><a href="http://zhongziso.com/" target="_blank" rel="noopener">zhongziso</a></li><li><a href="https://www.torrentdownload.ch/" target="_blank" rel="noopener">torrentdownload</a></li><li><a href="http://diggbt.biz/" target="_blank" rel="noopener">Diggbt</a></li><li><a href="http://kikibt.net/" target="_blank" rel="noopener">kikiBT</a></li><li><a href="http://www.btput.com/" target="_blank" rel="noopener">BTPUT</a></li><li><a href="http://zhongzicili.net/" target="_blank" rel="noopener">种子cili</a></li><li><a href="http://btkitty.pet/" target="_blank" rel="noopener">BTKitty</a></li><li><a href="http://www.runbt.cc/" target="_blank" rel="noopener">runbt</a></li><li><a href="http://www.diaosisou.com/" target="_blank" rel="noopener">屌丝搜</a></li><li><a href="http://www.ciliyun.net/" target="_blank" rel="noopener">磁力云</a></li><li><a href="http://www.cilits.com/" target="_blank" rel="noopener">磁力探索</a></li><li><a href="http://m.sosobta.org/" target="_blank" rel="noopener">搜索BT</a></li></ul><h1 id="外挂字幕库"><a href="#外挂字幕库" class="headerlink" title="外挂字幕库"></a>外挂字幕库</h1><ul><li><a href="http://subhd.com/" target="_blank" rel="noopener">SUBHD</a></li><li><a href="http://www.zimuku.net/" target="_blank" rel="noopener">字幕库</a></li><li><a href="http://www.opensubtitles.org/zh/xltf-on" target="_blank" rel="noopener">opensubtitles</a></li><li><a href="http://sub.makedie.me/" target="_blank" rel="noopener">伪射手</a></li><li><a href="http://www.r3sub.com/" target="_blank" rel="noopener">R3字幕</a></li><li><a href="http://www.hd.club.tw/forum-25-1.html" target="_blank" rel="noopener">台湾精研社R3官字幕</a></li><li><a href="http://www.zmtiantang.com/" target="_blank" rel="noopener">字幕天堂</a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="http://www.iloveyoulong.com/" target="_blank" rel="noopener">龙轩导航</a></li><li><a href="http://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩搜书</a></li><li><a href="http://bluray.highdefdigest.com/releasedates.html" target="_blank" rel="noopener">蓝光发售时间查询</a></li><li><a href="http://www.blu-ray.com/" target="_blank" rel="noopener">蓝光发售查询</a></li><li><a href="http://assrt.net/calendar#today" target="_blank" rel="noopener">美剧时间更新表</a></li><li><a href="http://www.talkshowcn.com/" target="_blank" rel="noopener">美国脱口秀</a></li><li><a href="http://weibo.com/u/3201058590?topnav=1&amp;wvr=6&amp;topsug=1&amp;is_all=1" target="_blank" rel="noopener">最新韩剧OST</a></li><li><a href="http://www.yugaopian.com/" target="_blank" rel="noopener">预告片世界</a></li><li><a href="http://www.ilewo.cn/" target="_blank" rel="noopener">网站视频下载工具</a></li><li><a href="http://www.ibilibili.com/" target="_blank" rel="noopener">B站视频下载</a></li><li><a href="http://pan.baidu.com/s/1gelyu7T" target="_blank" rel="noopener">电驴工具</a></li><li><a href="https://www.baidu.com/link?url=JpV2q7DOACAmpXXMN5_5ByY778KO6VcDCVLMXHkh4HVWBY9kqZwTFJyLTVpwN12f4OM6MPJaDiz2r5T31_svDcnW-Eiwdin4-Iyj4cMVDvW&amp;wd=&amp;eqid=9eaab6c0000200bd0000000459753d5d" target="_blank" rel="noopener">MKV内封字幕提取工具</a></li><li><a href="http://xiazai.xiazaiba.com/Soft/S/Subtitle_Edit_3.5.3_XiaZaiBa.zip?pcid=6359&amp;filename=Subtitle_Edit_3.5.3_XiaZaiBa.zip&amp;downloadtype=xiazaiba_seo" target="_blank" rel="noopener">外挂字幕调轴工具</a></li><li><a href="http://pan.baidu.com/s/1jIRdZvS" target="_blank" rel="noopener">字幕格式转换工具</a></li><li><a href="http://www.flvcd.com/" target="_blank" rel="noopener">硕鼠下载</a></li><li><a href="http://pan.baidu.com/s/1c10BX3i" target="_blank" rel="noopener">截屏工具</a></li><li><a href="http://yun.zihu.tv/" target="_blank" rel="noopener">会员视频解析</a></li><li><a href="http://t.cn/RtX35ZM" target="_blank" rel="noopener">极速迅雷</a></li><li><a href="http://www.yilinliulanqi.icoc.cc/col.jsp?id=127" target="_blank" rel="noopener">度盘免安装高速下载器</a></li><li><a href="http://yun.baidu.com/?ref=PPZQ" target="_blank" rel="noopener">百度云盘</a></li><li><a href="http://www.kidsincinema.com/forum/forum.php" target="_blank" rel="noopener">童影论坛</a></li></ul><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><ul><li><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度搜索</a></li><li><a href="http://weixin.sogou.com/" target="_blank" rel="noopener">微信搜索</a></li><li><a href="https://www.so.com/" target="_blank" rel="noopener">360搜索</a></li><li><a href="http://coderschool.cn/1853.html" target="_blank" rel="noopener">谷歌镜像</a>  /  <a href="https://google.jiongjun.cc/" target="_blank" rel="noopener">备用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="资源" scheme="https://www.xiongtianci.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="电影" scheme="https://www.xiongtianci.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Typora锚点-页内跳转</title>
    <link href="https://www.xiongtianci.com/2019/06/13/Typora%E9%94%9A%E7%82%B9-%E9%A1%B5%E5%86%85%E8%B7%B3%E8%BD%AC/"/>
    <id>https://www.xiongtianci.com/2019/06/13/Typora锚点-页内跳转/</id>
    <published>2019-06-13T06:54:02.000Z</published>
    <updated>2019-06-13T10:29:39.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h1><p><strong>锚点：</strong>通俗简单地说，比如一篇很长的文章，你想按分段精确来看，那就可以用到锚点了。</p><p>锚点的用法有两种，但性质同样，都是通过链接标签<code>&lt;a&gt;&lt;/a&gt;</code>以及其<code>href</code>属性实现的：<br>一种是：页内跳转<br>一种是：跳到其他页面的某个指定区域</p><p>要想使用锚点必须在路径<code>href</code>值中使用<code>#</code></p><h2 id="的作用"><a href="#的作用" class="headerlink" title="# 的作用"></a><code>#</code> 的作用</h2><p><code>#</code>代表网页中的一个位置</p><p>其右面的字符，就是该位置的标识符。比如，<code>http://www.example.com/index.html#print</code>就代表网页index.html的<code>print</code>位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。<br><code>href</code>中<code>#</code>后面的值要跟<code>name</code>或<code>id</code>一致，</p>]]></content>
    
    <summary type="html">
    
      Typora中锚点使用
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Typora" scheme="https://www.xiongtianci.com/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>打造个性超赞博客Hexo+Next+GitHub Pages的超深度优化</title>
    <link href="https://www.xiongtianci.com/2019/06/13/%E6%89%93%E9%80%A0%E4%B8%AA%E6%80%A7%E8%B6%85%E8%B5%9E%E5%8D%9A%E5%AE%A2Hexo-NexT-GitHub-Pages%E7%9A%84%E8%B6%85%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%8C%96/"/>
    <id>https://www.xiongtianci.com/2019/06/13/打造个性超赞博客Hexo-NexT-GitHub-Pages的超深度优化/</id>
    <published>2019-06-13T02:11:45.000Z</published>
    <updated>2019-06-13T12:38:04.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：<a href="https://io-oi.me" target="_blank" rel="noopener">reuixiy</a></p><p>链接：<a href="https://io-oi.me/tech/hexo-next-optimization.html#main" target="_blank" rel="noopener">https://io-oi.me/tech/hexo-next-optimization.html#main</a></p><p>theme：<a href="https://github.com/xiongtianci-tc/hexo-theme-next" target="_blank" rel="noopener">https://github.com/xiongtianci-tc/hexo-theme-next</a></p></blockquote><h1 id="必读-写在前面"><a href="#必读-写在前面" class="headerlink" title="必读 写在前面"></a>必读 写在前面</h1><p>本文主要内容是 NexT 主题的个性化定制和一些细节的优化。搭建的过程，已有的优化，Markdown 的使用，都直接贴出大佬的文章链接。</p><p>首先肯定是感谢各位大佬的文章，我一个小白，没学 HTML，没学 CSS，没学 JavaScript，连 C 也还没学会……如果你是一个和我一样的小白，且对本博客感觉还蛮满意，恭喜你！看完这篇文章，你自己也可以拥有一个这样的博客啦！</p><p>给小白（像我一样，也许还有完美主义和强迫症<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f602.png" alt="😂">）却想搭建个性化博客提供参考，是我写这篇文章的主要目的，所以如果本文有幸被大佬读到，文中的不足还请大佬见谅。</p><p>本文参考的文章都会直接给出原文链接或者以注脚的形式标记出处，但 Google 参考了实在太多太多了，有些我当时没做记录，如有遗漏，欢迎指出。另外，有一些优化的很好的博客，有很多很酷的功能，我当时没收藏，后来非常后悔，提醒大家如果看到很赞的博客，一定要马上收藏。</p><h2 id="重要的定义"><a href="#重要的定义" class="headerlink" title="重要的定义"></a>重要的定义</h2><p>了解定义，防止懵逼和大脑混乱。这两个文件名字都叫<code>_config.yml</code>，容易乱。</p><p>1）<strong>站点</strong>配置文件，位于站点文件夹根目录内<br><code>~/blog/_config.yml</code></p><p>2）<strong>主题</strong>配置文件，位于主题文件夹根目录内<br><code>~/blog/themes/next/_config.yml</code></p><h2 id="我操作的环境"><a href="#我操作的环境" class="headerlink" title="我操作的环境"></a>我操作的环境</h2><p>留这个，是因为有时我 Google 教程，发现按流程走，却达不到应有的效果。故当按照这篇的某流程却达不到预期效果，可以考虑考虑这个，然后自己灵活点去 Google 解决方案。</p><pre><code class="yml"># [2017.12.13 更新]/* 调试浏览器 */Google Chrome Version 62.0.3202.94 (Official Build) (64-bit)/* 版本信息 */root@kali:~/blog# hexo version(node:6675) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.hexo: 3.4.1hexo-cli: 1.0.4os: Linux 4.13.0-kali1-amd64 linux x64http_parser: 2.7.0node: 8.3.0v8: 6.0.286.52uv: 1.13.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57openssl: 1.0.2licu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b/* 依赖包 */root@kali:~/blog# cat package.json{  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: {    &quot;version&quot;: &quot;3.4.1&quot;  },  &quot;dependencies&quot;: {    &quot;gulp&quot;: &quot;^3.9.1&quot;, /* 压缩代码 */    &quot;gulp-htmlclean&quot;: &quot;^2.7.15&quot;, /* 压缩代码 */    &quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;, /* 压缩代码 */    &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;, /* 压缩代码 */    &quot;hexo&quot;: &quot;^3.4.1&quot;, /* 默认安装 */    &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, /* Git 部署工具 */    &quot;hexo-filter-github-emojis&quot;: &quot;^1.4.3&quot;, /* emoji 支持 */    &quot;hexo-footnotes&quot;: &quot;^1.0.1&quot;, /* 注脚 */    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, /* 默认安装 */    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, /* 默认安装 */    &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;, /* RSS */    &quot;hexo-generator-index-pin-top&quot;: &quot;^0.2.2&quot;, /* 替代默认安装的，支持文章置顶 */    &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;, /* 本地搜索 */    &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;, /* 生成 sitemap.xml，利于 SEO */    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, /* 默认安装 */    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.0&quot;, /* 默认安装 */    &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;, /* 默认安装 */    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, /* 默认安装 */    &quot;hexo-server&quot;: &quot;^0.2.0&quot;, /* 默认安装 */    &quot;hexo-tag-aplayer&quot;: &quot;^2.0.5&quot;, /* 音乐播放插件，支持歌词 */    &quot;hexo-tag-dplayer&quot;: &quot;^0.2.1&quot;, /* 视频播放插件，支持弹幕 */    &quot;hexo-wordcount&quot;: &quot;^3.0.2&quot; /* 字数统计 */  }}/* 主题NexT版本 */version: 5.1.3/* 优化主题NexT的设计版式 */scheme: Muse</code></pre><h1 id="开始-搭建博客"><a href="#开始-搭建博客" class="headerlink" title="开始 搭建博客"></a>开始 搭建博客</h1><p>终于进入正文了！但是这个我却不打算写，因为看到了一些很好的文章，这里直接给出这些文章的链接<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f31a.png" alt="🌚">～</p><h2 id="在本地安装-Hexo"><a href="#在本地安装-Hexo" class="headerlink" title="在本地安装 Hexo"></a>在本地安装 Hexo</h2><p>直接参考 Hexo 官方文档，毕竟是<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a>。安装好 Hexo 后，先任意目录新建个文件夹，名字可以为 blog，然后进入这个文件夹，输入命令：</p><pre><code class="shell"># 所在目录：~/blog/hexo init</code></pre><p>等一会，如果出现橙色的 <em>WARN</em> 没关系，只要不出现红色的 <em>ERROR</em> 就行。好了后，输入命令：</p><pre><code class="shell"># 所在目录：~/blog/hexo g &amp;&amp; hexo s</code></pre><p>然后点开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！距离成功只差下一步——部署博客到 GitHub Pages 了～</p><h2 id="部署博客到-GitHub-Pages"><a href="#部署博客到-GitHub-Pages" class="headerlink" title="部署博客到 GitHub Pages"></a>部署博客到 GitHub Pages</h2><p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> 是开源协作社区 GitHub 的一个服务，将博客部署到它上面再合适不过了。</p><table><thead><tr><th>问题</th><th>解答</th></tr></thead><tbody><tr><td>为什么要部署到 GitHub Pages 上？</td><td>首先免费，其次省心，最后可以学习使用 GitHub。</td></tr><tr><td>GitHub Pages 有容量限制吗？</td><td>有，由 <a href="https://help.github.com/articles/what-is-github-pages/" target="_blank" rel="noopener">What is GitHub Pages?</a> 可知：大小限制为 1GB，一个月 100GB 流量。</td></tr><tr><td>超出限制的容量怎么办？</td><td>讲真，如果图片音乐视频等大文件都放在<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云 KODO</a>、<a href="https://www.aliyun.com/product/oss" target="_blank" rel="noopener">阿里云 OSS</a> 或其它云存储上，那么压根不用担心，因为我的博客现在<code>[2017.11.17]</code>也才用了 6.73MB <img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f605.png" alt="😅">，所以无需担心。</td></tr><tr><td>国内访问速度行不行，有必要同时部署在 <a href="https://coding.net/" target="_blank" rel="noopener">Coding</a> 上吗？</td><td>个人感觉完全没必要，自己不用梯子时，感觉访问速度可以，毕竟站点的大文件都是放在了云存储上。</td></tr><tr><td>我可以用自己的域名吗？</td><td>可以，并且原生支持 https，教程见<a href="https://io-oi.me/tech/custom-domains-on-github-pages.html" target="_blank" rel="noopener">这篇文章</a>。</td></tr></tbody></table><p>注册 GitHub 帐号和创建 Repository 请查看<a href="https://yangbingdong.com/2017/build-blog-hexo-base/#GitHub" target="_blank" rel="noopener">这篇文章</a>，之后在<strong>站点</strong>文件夹根目录，安装 Git 部署插件（以后安装插件都先到这个目录），输入下面命令回车：</p><pre><code class="shell"># 所在目录：~/blog/npm install hexo-deployer-git --save</code></pre><p>然后，打开<strong>站点</strong>文件夹根目录下的<strong>站点</strong>配置文件，编辑：</p><pre><code># 文件位置：~/blog/_config.yml# URLurl: https://reuixiy.github.io/...省略……..# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:-  type:+  type: git+  repository: https://github.com/reuixiy/reuixiy.github.io.git+  branch: master</code></pre><p>将其中的<code>reuixiy</code>改成你的 GitHub 注册的帐号名就行，然后执行下面的命令：</p><pre><code class="shell"># 所在目录：~/blog/hexo clean &amp;&amp; hexo g &amp;&amp; hexo</code></pre><p>输入你的 GitHub 的用户名和密码，成功后复制<code>https://帐号名.github.io/</code>到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！</p><p>当然，如果你不想每次都输入用户名和密码，不想每次更新时，在 GitHub 上显示<code>invalid-email-address</code>，可以按上面所提的那篇文章操作。</p><h2 id="更新提示（可以最后看）"><a href="#更新提示（可以最后看）" class="headerlink" title="更新提示（可以最后看）"></a>更新提示（可以最后看）</h2><p>更新会有不确定因素，即讨厌又麻烦，但是不更新又怎么能享受新功能呢<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f611.png" alt="😑">…</p><h3 id="其它更新"><a href="#其它更新" class="headerlink" title="其它更新"></a>其它更新</h3><p>1）npm 更新全局安装的包：</p><pre><code class="shell">npm update -g</code></pre><p>2）npm 更新<strong>站点</strong>文件夹根目录下安装的依赖包：</p><pre><code class="shell"># 所在目录：~/blog/npm update</code></pre><p>3）更新 npm 它自己：</p><pre><code class="shell">npm install npm -g</code></pre><p>4）更新 Node.js 到最新版：</p><pre><code class="shell">npm install n -gn latest</code></pre><h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><p>进入<strong>主题</strong>文件夹根目录，然后<code>git pull</code>，发现报错，怎么解决呢？可以先浏览<a href="http://www.01happy.com/git-resolve-conflicts/" target="_blank" rel="noopener">这篇文章</a>，然后参考我的操作。</p><p>先到<strong>主题</strong>文件夹根目录：</p><pre><code class="shell"># 所在目录：~/blog/themes/next/git pull</code></pre><p>会发现报错，由于我们更改了相关文件，更新不成功，所以要将本地的所有修改先暂时存储起来：</p><pre><code class="shell"># 所在目录：~/blog/themes/next/git stash</code></pre><p>然后再试一下：</p><pre><code class="shell"># 所在目录：~/blog/themes/next/git pull</code></pre><p>可以了吧，接下来还原暂时存储的内容（即保存我们的所有修改）：</p><pre><code class="shell"># 所在目录：~/blog/themes/next/git stash pop</code></pre><p>如果报<code>CONFLICT</code>，是因为 Git 无法确定一些改动，所以要我们手动解决文件中冲突的部分，这个比较麻烦，可以参考我下面的流程。</p><p>首先打开报<code>CONFLICT</code>的文件，Ctrl + F 搜索<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes</code>，查看从此处到<code>=======</code>之间保存的代码，回忆一下自己当时更改了什么，是为了达到什么功能。</p><p>然后查看<code>=======</code>到<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream</code>之间更新的代码，与下面保存的代码进行对比（也请浏览下所标出代码前后的代码）：</p><ol><li>如果改动较大，可能是主题增加了新功能，建议保留更新的代码，然后更改一下，达到自己想要在保存的代码中实现的功能，最后删除保存的代码。</li><li>如果改动较小，建议还是保留更新的代码，然后更改一下，最后删除保存的代码。</li></ol><p>注意：要是自己不确定，一定记得将<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream</code>到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes</code>之间的代码另存备份，然后进行调试，直到最后确定没有问题。</p><p>最后：</p><pre><code class="shell"># 所在目录：~/blog/themes/next/root@kali:~/blog/themes/next# git pullerror: Pulling is not possible because you have unmerged files.hint: Fix them up in the work tree, and then use &#39;git add/rm &lt;file&gt;&#39;hint: as appropriate to mark resolution and make a commit.fatal: Exiting because of an unresolved conflict.</code></pre><p>哇，又报错了<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f602.png" alt="😂"><img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f602.png" alt="😂"><img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f602.png" alt="😂">，咋办？</p><p>先查看：</p><pre><code class="shell"># 所在目录：~/blog/themes/next/root@kali:~/blog/themes/next# git statusOn branch masterYour branch is up to date with &#39;origin/master&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)    modified:   layout/_custom/header.swig    modified:   layout/_custom/sidebar.swig    modified:   layout/_layout.swig    modified:   layout/category.swig    modified:   layout/tag.swig    modified:   source/css/_common/components/post/post-meta.styl    modified:   source/css/_common/components/post/post-nav.styl    modified:   source/css/_common/scaffolding/base.styl    modified:   source/css/_custom/custom.styl    deleted:    source/images/avatar.gif    modified:   source/lib/Han/dist/han.min.cssUnmerged paths:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)    both modified:   _config.yml    both modified:   languages/zh-Hans.yml    both modified:   layout/_macro/post-copyright.swig    both modified:   layout/_macro/post.swig    both modified:   layout/_macro/sidebar.swig    both modified:   layout/_partials/footer.swig    both modified:   layout/page.swig    both modified:   source/css/_variables/base.stylUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    layout/_macro/passage-end-tag.swig    source/js/src/love.js</code></pre><p>看下面<code>Unmerged paths</code>，说<code>git reset HEAD &lt;file&gt;...</code>来取消修改（大概），<code>git add &lt;file&gt;...</code>来 mark 决定（大概），我们当然要保存这些文件的更改，所以：</p><pre><code class="shell"># 所在目录：~/blog/themes/next/root@kali:~/blog/themes/next# git add _config.yml languages/zh-Hans.yml layout/_macro/post-copyright.swig layout/_macro/post.swig layout/_macro/sidebar.swig layout/_partials/footer.swig layout/page.swig source/css/_variables/base.styl layout/_macro/passage-end-tag.swig source/js/src/love.js</code></pre><p>顺便把新加的<code>passage-end-tag.swig</code>和<code>love.js</code>也加进去，最后再来试一下吧：</p><pre><code class="shell"># 所在目录：~/blog/themes/next/root@kali:~/blog/themes/next# git pullAlready up to date.</code></pre><p>哇，成功更新主题！</p><p>注意：更新有风险，一定要谨慎处理文件中冲突的部分！另，如果更新 NexT 主题后，配置文件有些新功能不会配置，可以查看 <a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">Releases</a>（<a href="https://github.com/theme-next/hexo-theme-next/releases" target="_blank" rel="noopener">最新版</a>）页面，去里面找说明。</p><h1 id="优化-基本功能配置"><a href="#优化-基本功能配置" class="headerlink" title="优化 基本功能配置"></a>优化 基本功能配置</h1><p>通过上面的折腾，你应该能够在自己的 GitHub Pages 上看到自己的博客了，接下来就是配置和增加功能，如阅读统计、加上评论和安装插件啥的，还有就是添加一些博客的基本信息，这些配置建议在写文章之前先折腾好。</p><p>基本功能配置大部分就是改两个文件，都叫<code>_config.yml</code>，文章的<a href="https://io-oi.me/tech/hexo-next-optimization.html#%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">开头位置</a>已告诉大家。我觉得与其将两个文件中的每点都分开来解释，倒不如直接将这两个文件贴出来，然后通过注释的方式告诉大家配置的方法，所以下面我会贴出这两个文件，怎么配置看注释就好了<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f604.png" alt="😄">～</p><h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>不过还有一件事要先说一说，就是选择合适自己的主题，这是搭建好博客后最重要的一件事。默认的主题功能少，而且不太好看（个人感觉），而一些主题则有很多功能，也比较美观。</p><p>我选择的是 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a>（<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">最新版</a>），简洁且功能不少，也是在 GitHub 上<a href="https://github.com/search?o=desc&amp;q=topic%3Ahexo-theme&amp;s=stars&amp;type=Repositories" target="_blank" rel="noopener">被 Star 最多</a><code>[2017.11.17]</code>的一个 Hexo 主题。第二多的是 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>，第三多的是 <a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">hexo-theme-material</a>（还有一个很棒的 Material Design 风格主题 <a href="https://github.com/yscoder/hexo-theme-indigo/tree/card" target="_blank" rel="noopener">hexo-theme-material-indigo</a>），还有一个我感觉比较有特色的，叫 <a href="https://github.com/probberechts/cactus-dark" target="_blank" rel="noopener">Cactus Dark</a>，这几个我感觉都不错，可以点开链接看看长啥样。要是我上面说的还是没有合你胃口的<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f605.png" alt="😅">，咋办？去 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo Themes</a> 慢慢找。</p><p>至于换主题，很简单，我拿 NexT 主题举个栗子。首先在这个主题的 GitHub 页面的右上方复制链接，如下图：</p><p><img src="https://io-oi.oss-cn-shanghai.aliyuncs.com/images/hexo-next-optimization-1.png" alt="hexo-next-optimization-1.png"></p><p>然后：</p><pre><code class="shell"># 所在目录：~/blog/themes/git clone https://github.com/theme-next/hexo-theme-next.git next</code></pre><p>再在<strong>站点</strong>配置文件中修改成如下即可：</p><pre><code class="yml"># 文件位置：~/blog/_config.yml## Themes: https://hexo.io/themes/theme: next</code></pre><h2 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h2><p>请先查看 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo 官方文档</a>，再查看下面我贴出的，如果这样后你还是对有些地方比较懵，可以自行 Google。如果你的文件中没有相关内容，请勿直接添加，且所有的<code>:</code>都为英文字符，它后面都有一个空格。</p><pre><code class="yml"># [2017.11.14 更新] 文件位置：~/blog/_config.yml# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: reuixiysubtitle: Viva La Vidadescription: 易 象 辞author: reuixiylanguage: zh-CNtimezone:# URLurl: https://reuixiy.github.io/root: /# 博客文章的 URL 结构，请务必写文章之前就想好！# 详细参数请查看：https://hexo.io/docs/permalinks.html# 当然最好不要参考我的，我的太不利于 SEO 了，除非……permalink: :category/:year/:month/:day/:title.htmlpermalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: true# 代码高亮设置highlight:  enable: true  line_number: true# 代码自动高亮  auto_detect: true  tab_replace:# 关于代码高亮的更多知识，可以查看本文 6.5.2 节# Home page setting# path: Root path for your blogs index page. (default = &#39;&#39;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: &#39;&#39;  per_page: 10  order_by: -date# Category &amp; Tagdefault_category: uncategorized# URL 中的分类和标签「翻译」成英文# 见：https://github.com/hexojs/hexo/issues/1162category_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable pagination# 这个我有点懵，上面不是有啊……per_page: 10pagination_dir: page## 修改归档页面、某一分类页面、某一标签页面的显示篇数## 参考：http://theme-next.iissnan.com/faqs.html#setting-page-sizearchive_generator:  per_page: 0  yearly: false  monthly: false  daily: falsecategory_generator:  per_page: 0tag_generator:  per_page: 0# Extensions## Plugins: https://hexo.io/plugins/# RSS，要先进入站点文件夹根目录安装插件# npm install hexo-generator-feed --save 即可# 无需更多配置# 参数说明查看 README：https://github.com/hexojs/hexo-generator-feedfeed:  type: atom  path: atom.xml# 文章数，0 为全部  limit: 0  hub:# 是否包含文章内容  content: true# emoji 支持，教程见本文 6.3 节githubEmojis:  enable: true  idName: github-emoji  unicode: false  styles:  localEmojis:## Themes: https://hexo.io/themes/# 主题配置theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repository: https://github.com/reuixiy/reuixiy.github.io.git  branch: master</code></pre><h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><p>如果你的主题不是 NexT，那么请另 Google。建议先查看 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT 官方文档</a>（<a href="https://theme-next.org/docs/" target="_blank" rel="noopener">最新版</a>），写得很好，多逗留会没坏处。由于文件过长，为了保证文章阅读效果，我把文件放在了 <a href="https://github.com/reuixiy/blog-files/blob/master/_config.yml" target="_blank" rel="noopener">GitHub</a>。另外，我把我没有配置的差不多都删了，有问题可以多 Google。如果里面有些设置你还想进一步自定义，比如进一步自定义页脚文字的顺序，折腾完本文<a href="https://io-oi.me/tech/hexo-next-optimization.html#%E8%BF%9B%E9%98%B6-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">第 5 节</a>你就会了<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f609.png" alt="😉">。</p><h2 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h2><p><img src="https://io-oi.oss-cn-shanghai.aliyuncs.com/images/hexo-next-optimization-2.gif" alt="效果图"></p><p>在<strong>主题</strong>配置文件中，靠后面，改<code>canvas_nest: true</code>，想要更改颜色和数量？修改文件：</p><pre><code class="shell"># 文件位置~/blog/themes/next/source/lib/canvas-nest/canvas-nest.min.js</code></pre><p>怎么修改？参考 <a href="https://github.com/hustcc/canvas-nest.js/blob/master/README-zh.md" target="_blank" rel="noopener">README</a>。</p><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><img src="https://io-oi.oss-cn-shanghai.aliyuncs.com/images/hexo-next-optimization-footnotes.jpg" alt="Hexo 插件页面"></p><p>在 Hexo 插件搜索footnotes，发现目前有两种插件，右边的可以实现鼠标放在上面悬浮显示注释的功能，但是亲测有一个 Bug，有时对页面宽度有影响，强迫症难以忍受。我安装的是左边的，先进入站点文件夹根目录，然后：</p><pre><code class="shell"># 所在目录：~/blog/npm install hexo-footnotes --save</code></pre><p>安装后按 <a href="https://github.com/LouisBarranqueiro/hexo-footnotes" target="_blank" rel="noopener">README</a> 的介绍的语法书写，应该就可以了。注意：注脚的内容一定要放在 Markdown 文档的最后面，否则可能会有错误。</p><h1 id="优化-网页样式布局"><a href="#优化-网页样式布局" class="headerlink" title="优化 网页样式布局"></a>优化 网页样式布局</h1><p>发现页面有大量留白？颜色不合自己口味？那就 F12 开始吧，大换装开始！空白区？颜色？背景？圆角矩形？阴影？透明度？超链接样式？侧栏头像圆形并旋转？文章标题前面的竖线和颜色？只需按下 F12，改到自己想要的样式，然后 Copy 到<code>custom.styl</code>文件即可。感觉这是 NexT 主题非常棒的设计，因为这让我们能够很方便自定义博客的样式。怎么知道要修改这个文件呢？强烈推荐阅读<a href="http://www.cduyzh.com/hexo-settings-3/" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="怎么更改？"><a href="#怎么更改？" class="headerlink" title="怎么更改？"></a>怎么更改？</h2><p>浏览器按 F12 即可，建议用 <a href="http://down.tech.sina.com.cn/content/40975.html" target="_blank" rel="noopener">Google Chrome 浏览器</a>（有梯子的直接去 Google 下载<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f602.png" alt="😂">），或者<a href="http://www.firefox.com.cn/download/" target="_blank" rel="noopener">火狐浏览器</a>。如果你按下 F12 后简直特么一脸懵逼，那么别急，硬着头皮慢慢折腾吧哈哈哈嗝～</p><h3 id="bb-for-bb"><a href="#bb-for-bb" class="headerlink" title="bb - for - bb"></a>bb - for - bb</h3><p>不管你信不信，其实博主就是这样直接折腾过来的，我之前没学过 HTML 和 CSS，所以当时按下 F12 真是一脸懵逼。我一开始是 Google（关键字：<code>Hexo NexT 自定义</code>）到上面那篇文章，一点进去，卧槽！侧栏终于不是清一色的默认黑色，激动！这位大佬怎么改的啊？这篇文章一定有吧<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f60d.png" alt="😍">！？然后看下去，果然有！然后眼睛先盯着贴的<code>custom.styl</code>，久久看着少数的注释，Copy 一段到自己的<code>custom.styl</code>，保存，然后<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>（当时我还不知道可以<code>hexo s</code>后可以直接本地调试<img src="chrome-extension://cahedbegdkagmcjfolhdlechbkeaieki/images/apple/1f62d.png" alt="😭">），再去浏览器刷新自己的本地调试页面，看看效果。效果是有了，但是不是我想要的效果啊……于是去百度其中一行 CSS 代码，再回去慢慢删改调试……博主由懵逼到熟悉花了不少时间，但是我写这篇文章就是为了减少像我这样的小白折腾的时间，所以下面详细说明下按下 F12 后怎么快速由懵逼到熟悉！</p><h3 id="快速由懵逼到熟悉"><a href="#快速由懵逼到熟悉" class="headerlink" title="快速由懵逼到熟悉"></a>快速由懵逼到熟悉</h3><p>首先按下 F12 后的操作流程图，就是<a href="https://yangbingdong.com/2017/build-blog-hexo-advanced/#%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">这篇文章</a>中的三步骤，点小箭头定位元素，调试 CSS 代码，最后 Copy 到<code>custom.styl</code>。然后懵逼的地方，应该有下面两点：</p><ol><li>按下 F12 后弹出的界面是什么鬼？！</li><li>界面中的<code>{}</code>前面的和里面的英文是什么鬼？！</li></ol><p>第一点：弹出的界面是为调试设计的，如果你知道调试的是啥，也许就自然了解弹出的界面，所以我不多说，不过还是给一份 Google 官方的资料——<a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">Chrome 开发者工具</a>。第二点：<code>{}</code>前面的是 HTML 的元素名，<code>{}</code>里面的是这个元素的 CSS 样式。</p><p>社交要先有自己原则，一段代码要先声明变量，一个数学问题有前提，一篇论文要先定义名词，到这里我们也必须要先了解一些 HTML 和 CSS 的基本语法知识了，才能继续折腾下去。建议先浏览下<a href="https://qianling.pw/grammar/" target="_blank" rel="noopener">这篇文章</a>，但没必要记住里面的每一个语法知识，因为这样的记忆是不够深刻也并不高效的，只要浏览下留个印象（为了能找准元素）就行，而记忆是要在实践中记忆的。</p><h3 id="bb-for-fun"><a href="#bb-for-fun" class="headerlink" title="bb - for - fun"></a>bb - for - fun</h3><p>实践？对！就是打开自己的本地调试页面，然后用你挑剔的眼光看看，哪里让你不爽，就按 F12，定位元素，最后调试，直到改到自己满意。这不是与一开始说的三步骤一样吗，为啥现在又说一遍？不不不，想想如果你点开一个俄文网站，然后我给你个这页面上的一个俄文链接的中文翻译，让你找到这个俄文链接并点开，你会不会懵逼呢……一样的，如果我没有让先你浏览 HTML 和 CSS 的基本语法知识，那么对网页中出现的东东大脑压根就「翻译」不成 HTML 和 CSS 代码（反之一样）。对 HTML 和 CSS 的语法定义不明，就可能会找不准元素，而找不准元素不仅可能达不到预期效果，还可能会产生一些新的 bugs，所以要先浏览上面那篇文章。这也是我这个小白走过的坑中，最大的一个了，花费了我不少时间在无意义的搜索上，想达到一个效果，但是不知道输入什么搜索关键字……最后，要熟练还是要多折腾……喵？！多折腾，说好的快速呢！？快速是要有对比的，我填了定义不明这个大坑，你按我说的操作，与我的慢折腾经历相比，你的折腾当然是快速。诡辩？好吧说实话也算是谎言，不过是个善意的谎言，只为给你一种神奇的能量——Hope，这种谎言在生活中很常见，但我的缺少一个目的——钱。</p><h2 id="附上我的-custom-styl"><a href="#附上我的-custom-styl" class="headerlink" title="附上我的 custom.styl"></a>附上我的 custom.styl</h2><p>由于文件过长，为了保证文章阅读效果，我把文件放在了 <a href="https://github.com/reuixiy/blog-files/blob/master/custom.styl" target="_blank" rel="noopener">GitHub</a>。请先找对元素，不然可能会制造出新 bug，建议大家修改一个，就加个注释，方便以后调试修改。注意：一定是先 F12 找到要自定义的元素，调试成自己喜欢的值，然后再复制到<code>custom.styl</code>，而不是直接复制我给出的，我给出的仅供参考。</p><h2 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h2><p>优化了这么多，但还有一个最影响博客形象和阅读体验的项没有优化，瓦特？字体！文章字体大小可以编辑：</p><pre><code class="css"># 文件位置：~/blog/themes/next/source/css/_variables/base.styl$font-size-base = 16px</code></pre><p>如果你是一个和我一样对字体一脸懵逼的人，推荐阅读：</p><ol><li><a href="https://www.voyax.me/posts/59710/" target="_blank" rel="noopener">Web 中文字体排版指南</a></li><li><a href="https://blog.coding.net/blog/Web-Fonts" target="_blank" rel="noopener">Web 字体的选择和运用</a></li><li><a href="https://segmentfault.com/a/1190000006110417" target="_blank" rel="noopener">如何优雅的选择默认字体（font-family）</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/07/chinese_fonts.html" target="_blank" rel="noopener">中文字体网页开发指南</a></li><li><a href="https://csspod.com/using-the-system-font-in-web-content/" target="_blank" rel="noopener">在 Web 内容中使用系统字体</a></li></ol><p>首先对于汉字来说，因为其字体库太大，通常都是调用本地中文字体库。然而，不同设备有不同默认中文字体和中文字体库，想要尽可能在不同设备上有较好的显示效果，就要在调用不同设备的本地字体库中显示效果较好的中文字体。下面附上我的供大家参考：</p><pre><code class="css"># 文件位置：~/blog/themes/next/source/css/_variables/base.styl// Font families.$font-family-chinese      = -apple-system, BlinkMacSystemFont, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;STHeiti&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Droid Sans Fallback&quot;, &quot;Microsoft YaHei&quot;$font-family-base         = $font-family-chinese, sans-serif$font-family-base         = get_font_family(&#39;global&#39;), $font-family-chinese, sans-serif if get_font_family(&#39;global&#39;)$font-family-logo         = $font-family-base$font-family-logo         = get_font_family(&#39;logo&#39;), $font-family-base if get_font_family(&#39;logo&#39;)$font-family-headings     = $font-family-base$font-family-headings     = get_font_family(&#39;headings&#39;), $font-family-base if get_font_family(&#39;headings&#39;)$font-family-posts        = $font-family-base$font-family-posts        = get_font_family(&#39;posts&#39;), $font-family-base if get_font_family(&#39;posts&#39;)$font-family-monospace    = $font-family-chinese, monospace$font-family-monospace    = Menlo, Monaco, Consolas, get_font_family(&#39;codes&#39;), $font-family-chinese, monospace if get_font_family(&#39;codes&#39;)</code></pre><p>注意：要想 NexT 主题的简体中文字体配置生效，<strong>站点</strong>配置文件中的 language 必须为 zh-CN。然后对于英文字体，因为其字体库很小，所以想要个性化就简单多了。首先去 <a href="https://fonts.google.com/" target="_blank" rel="noopener">Google Fonts</a> 找自己喜欢的英文字体，然后编辑<strong>主题</strong>配置文件，可以查看一下 <a href="http://theme-next.iissnan.com/theme-settings.html#fonts-customization" target="_blank" rel="noopener">NexT 官方文档</a>（<a href="https://theme-next.org/docs/theme-settings/#Fonts-Customization" target="_blank" rel="noopener">最新版</a>）。下面附上我的供大家参考：</p><pre><code class="yml"># 文件位置：~/blog/themes/next/_config.ymlfont:  enable: true  # Uri of fonts host. E.g. //fonts.googleapis.com (Default)  # 亲测这个可用，如果不可用，自己搜索 [Google 字体 国内镜像]，找个能用的就行  host: https://fonts.loli.net  # Global font settings used on &lt;body&gt; element.  global:    # external: true will load this font family from host.    external: true    family: Lato  # Font settings for Headlines (h1, h2, h3, h4, h5, h6)  # Fallback to `global` font settings.  headings:    external: true    family: Roboto Slab  # Font settings for posts  # Fallback to `global` font settings.  posts:    external: true    family:  # Font settings for Logo  # Fallback to `global` font settings.  # The `size` option use `px` as unit  logo:    external: true    family:    size:  # Font settings for &lt;code&gt; and code blocks.  codes:    external: true    family: Roboto Mono    size:</code></pre><p>注意：本博客的字体最新设置方法请看我的<a href="https://io-oi.me/tech/noto-serif-sc-added-on-google-fonts.html" target="_blank" rel="noopener">这篇文章</a>。</p><h1 id="进阶-高级功能配置"><a href="#进阶-高级功能配置" class="headerlink" title="进阶 高级功能配置"></a>进阶 高级功能配置</h1><p>这些功能的配置，大部分都要修改 NexT 主题的一些文件，所以<code>git pull</code>升级主题的时候，会比较麻烦，解决方法见<a href="#更新主题">本文 2.3.2 节</a>。</p>]]></content>
    
    <summary type="html">
    
      Hexo+Next超详细-转载
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="转载" scheme="https://www.xiongtianci.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="Hexo" scheme="https://www.xiongtianci.com/tags/Hexo/"/>
    
      <category term="博客" scheme="https://www.xiongtianci.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Pages" scheme="https://www.xiongtianci.com/tags/Pages/"/>
    
  </entry>
  
  <entry>
    <title>git push报错：The current branch master has no upstream branch</title>
    <link href="https://www.xiongtianci.com/2019/06/12/git-push%E6%8A%A5%E9%94%99%EF%BC%9AThe-current-branch-master-has-no-upstream-branch/"/>
    <id>https://www.xiongtianci.com/2019/06/12/git-push报错：The-current-branch-master-has-no-upstream-branch/</id>
    <published>2019-06-12T06:22:18.000Z</published>
    <updated>2019-06-12T09:46:59.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>进行<code>git push</code>操作时报错：<code>fatal: The current branch master has no upstream branch.</code></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190612-git-push%E6%8A%A5%E9%94%99%EF%BC%9AThe-current-branch-master-has-no-upstream-branch/1560320619462.png" alt="1560320619462"></p><p><strong>原因：</strong>没有将本地的分支与远程仓库的分支进行关联<br>通过<code>git branch</code>查看本地分支只有<code>master</code></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190612-git-push%E6%8A%A5%E9%94%99%EF%BC%9AThe-current-branch-master-has-no-upstream-branch/1560321303707.png" alt="1560321303707"></p><p>通过<code>git branch -a</code>查看远程分支，有<code>master</code>和<code>remotes/origin/master</code>两个</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190612-git-push%E6%8A%A5%E9%94%99%EF%BC%9AThe-current-branch-master-has-no-upstream-branch/1560321309091.png" alt="1560321309091"></p><p>这时由于远程仓库太多，且分支较多。在默认情况下，<code>git push</code>时一般会上传到<code>origin</code>下的<code>master</code>分支上，然而当<code>repository</code>和<code>branch</code>过多，而又没有设置关联时，git就会产生疑问，因为它无法判断你的push目标</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>使用<code>git push --set-upstream origin master</code>命令</p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>使用<code>git push -u origin master</code>命令</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Git" scheme="https://www.xiongtianci.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>hexo常用命名汇总</title>
    <link href="https://www.xiongtianci.com/2019/06/12/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E6%B1%87%E6%80%BB/"/>
    <id>https://www.xiongtianci.com/2019/06/12/hexo常用命名汇总/</id>
    <published>2019-06-12T01:32:47.000Z</published>
    <updated>2019-06-12T01:36:07.948Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="shell"># hexo clean# hexo g# hexo d# hexo n &quot;文章名&quot;</code></pre><pre><code class="shell">hexo d -ghexo g &amp;&amp; hexo d</code></pre>]]></content>
    
    <summary type="html">
    
      hexo命令汇总
    
    </summary>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Hexo" scheme="https://www.xiongtianci.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>git常用命名汇总</title>
    <link href="https://www.xiongtianci.com/2019/06/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E6%B1%87%E6%80%BB/"/>
    <id>https://www.xiongtianci.com/2019/06/12/git常用命名汇总/</id>
    <published>2019-06-12T01:24:41.000Z</published>
    <updated>2019-06-13T03:47:26.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="将本地项目初始化"><a href="#将本地项目初始化" class="headerlink" title="将本地项目初始化"></a>将本地项目初始化</h2><pre><code class="shell"># $ git init# 给项目添加远程仓库$ git remote add origin git@github.xxx.git# 本地分支和远程分支建立联系(使用git branch -vv  可以查看本地分支和远程分支的关联关系)$ git branch --set-upstream-to=origin/远程分支 本地分支   </code></pre><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><pre><code class="shell"># 查看工作目录和暂存区的状态$ git status# 查看工作区与暂存区的差异$ git diff# 查看提交历史$ git log# 查看命令历史$ git reflog# ----分支# 查看git本地分支$ git branch# 查看git远程分支$ git branch -r# 查看所有本地分支和远程分支，远程分支为红色$ git branch -a# 查看每个本地分支的最后一次提交$ git branch -v# 查看本地分支和远程分支联系$ git branch -vv# 切换git分支$ git checkout branch-name# 创建分支$ git branch branch-name# 新建并切换git分支$ git checkout -b branch-name# 删除git分支$ git branch -d branch-name# 强制删除git分支$ git branch -D branch-name# 删除git远程分支$ git push origin -d branch-name# 本地分支和远程分支建立联系$ git branch --set-upstream-to=origin/远程分支 本地分支# 查看git 配置$ git config -l# 修改远程仓库地址$ git remote set-url origin git@github.xxx.git# 本地分支回滚到指定版本$ git reset --hard &lt;commit ID号&gt;# 强制推送到远程分支$ git push -f origin &lt;branch name&gt;</code></pre><h1 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h1><pre><code class="shell"># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p><code>git init</code>命令将当前目录转为git仓库<br>它会在当前目录下生成一个<code>.git</code>子目录，在其中写入git的配置和项目的快照</p><pre><code class="shell"># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]</code></pre><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p><code>git clone</code>命令用于克隆远程分支</p><pre><code class="shell"># 下载一个项目和它的整个代码历史$ git clone [url]# 将alpha目录（必须是git代码仓库），克隆到delta目录# bare参数表示delta目录只有仓库区，没有工作区和暂存区，即delta目录中就是.git目录的内容$ git clone alpha delta --bare</code></pre><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><pre><code class="shell"># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下，也可以在项目目录下</p><pre><code class="shell"># 显示当前的Git配置$ git config --list $ git config -l# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息# 参数# 1.系统级别：--system# 2.用户全局：--global# 3.单独一个项目：--local$ git config --global user.name &quot;xxxx&quot; #用户名$ git config --global user.email &quot;xxxx@xxx.com&quot; #邮箱$ git config --global core.editor vim #编辑器$ git config --global alias.st status #按这种方法，配置别名</code></pre><h1 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h1><pre><code class="shell"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p><code>git add</code>命令用于将变化的文件，从工作区提交到暂存区。它的作用就是告诉 Git，下一次哪些变化需要保存到仓库区。用户可以使用<code>git status</code>命令查看目前的暂存区放置了哪些文件。</p><pre><code class="shell"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区# 会把当前目录中所有有改动的文件（不包括.gitignore中要忽略的文件）都添加到git缓冲区以待提交$ git add .# 会把当前目录中所有有改动的文件（包括.gitignore中要忽略的文件）都添加到git缓冲区以待提交$ git add *        #&lt;不推荐&gt;</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>-u</code>参数表示只添加暂存区已有的文件（包括删除操作），但不添加新增的文件。</p><pre><code class="shell">$ git add -u</code></pre><p><code>-A</code>或者<code>--all</code>参数表示追踪所有操作，包括新增、修改和删除</p><blockquote><p>Git 2.0 版开始，<code>-A</code>参数成为默认，即<code>git add .</code>等同于<code>git add -A</code></p></blockquote><pre><code class="shell">$ git add -A</code></pre><p> <code>-f</code>参数表示强制添加某个文件，不管<code>.gitignore</code>是否包含了这个文件。</p><pre><code class="shell">$ git add -f &lt;fileName&gt;</code></pre><p><code>-p</code>参数表示进入交互模式，指定哪些修改需要添加到暂存区。即使是同一个文件，也可以只提交部分变动。</p><pre><code class="shell"># 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交$ git add -p</code></pre><p>注意，Git 2.0 版以前，<code>git add</code>默认不追踪删除操作。即在工作区删除一个文件后，<code>git add</code>命令不会将这个变化提交到暂存区，导致这个文件继续存在于历史中。<code>Git 2.0</code> 改变了这个行为。</p><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p><code>git rm</code>命令用于删除文件。</p><pre><code class="shell"># 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]</code></pre><h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><pre><code class="shell"># 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h1 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h1><pre><code class="shell"># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend &lt;file1&gt; &lt;file2&gt; ...</code></pre><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p><code>git commit</code>命令用于将<code>暂存区</code>中的变化提交到<code>仓库区</code>。<br><code>-m</code>参数用于指定 commit 信息，是<strong>必需</strong>的。如果省略<code>-m</code>参数，<code>git commit</code>会自动打开文本编辑器，要求输入。</p><pre><code class="shell"># 提交暂存区到仓库区$ git commit -m &quot;message&quot;# 提交暂存区的指定文件到仓库区# 将工作区中指定文件的变化，先添加到暂存区，然后再将暂存区提交到仓库区$ git commit [file1] [file2] ... -m [message]</code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><h4 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h4><p><code>-m</code>参数用于添加提交说明<br>如果没有指定提交说明，运行 commit 会直接打开默认的文本编辑器，让用户撰写提交说明</p><pre><code class="shell">$ git commit -m &quot;message&quot;</code></pre><h4 id="a"><a href="#a" class="headerlink" title="-a"></a>-a</h4><p><code>-a</code>参数用于先将所有<code>工作区</code>的变动文件，提交到<code>暂存区</code>，再运行<code>git commit</code>。<br>用了<code>-a</code>参数，就不用执行<code>git add .</code>命令了。</p><pre><code class="shell"># 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -am &quot;message&quot;</code></pre><h4 id="–allow-empty"><a href="#–allow-empty" class="headerlink" title="–allow-empty"></a>–allow-empty</h4><p><code>--allow-empty</code>参数用于没有提交信息的 commit</p><pre><code class="shell">$ git commit --allow-empty</code></pre><h4 id="–amend"><a href="#–amend" class="headerlink" title="–amend"></a>–amend</h4><p>–amend参数用于撤销上一次 commit，然后生成一个新的 commit</p><pre><code class="shell"># 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend &lt;file1&gt; &lt;file2&gt; ...</code></pre><h4 id="–fixup"><a href="#–fixup" class="headerlink" title="–fixup"></a>–fixup</h4><p><code>--fixup</code>参数的含义是，当前添加的 commit 是以前某一个 commit 的<strong>修正</strong>。<br>以后执行互动式的<code>git rebase</code>的时候，这两个 commit 将会<strong>合并</strong>成一个。</p><pre><code class="shell"># 提交说明将自动生成，即在目标 commit 的提交说明的最前面，添加&quot;fixup!&quot;这个词$ git commit --fixup &lt;commit&gt;</code></pre><h4 id="–squash"><a href="#–squash" class="headerlink" title="–squash"></a>–squash</h4><p><code>--squash</code>参数的作用与<code>--fixup</code>类似，表示当前添加的 commit 应该与以前某一个 commit 合并成一个，以后执行互动式的<code>git rebase</code>的时候，这两个 commit 将会合并成一个。</p><pre><code class="shell">$ git commit --squash &lt;commit&gt;</code></pre><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><pre><code class="shell"># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch-name]# 新建一个分支，指向指定commit$ git branch [branch-name] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch-name] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch-name] [remote-branch]# 合并指定分支到当前分支$ git merge [branch-name]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete &lt;branch-name&gt;$ git branch -dr &lt;remote/branch&gt;</code></pre><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p><code>git branch</code>是分支操作命令</p><pre><code class="shell"># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a</code></pre><h3 id="新建一个分支"><a href="#新建一个分支" class="headerlink" title="新建一个分支"></a>新建一个分支</h3><p>直接在<code>git branch</code>后面跟上分支名，就表示新建该分支</p><pre><code class="shell"># 新建一个分支，但依然停留在当前分支$ git branch branch-name</code></pre><p>新建一个分支，指向当前 commit。本质是在<code>refs/heads/</code>目录中生成一个文件，文件名为分支名，内容为当前 commit 的哈希值</p><blockquote><p>注意：创建后，还是停留在原来分支，需要用<code>git checkout</code>切换到新建分支</p></blockquote><pre><code class="shell"># 切换到指定分支，并更新工作区$ git checkout branch-name</code></pre><p>使用<code>-b</code>参数，可以新建的同时，切换到新分支</p><pre><code class="shell"># 新建一个分支，并切换到该分支$ git checkout -b NewBranch MyBranch</code></pre><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p><code>-d</code>参数用来删除一个分支，<strong>前提</strong>是该分支没有未合并的变动</p><pre><code class="shell"># 删除分支$ git branch -d &lt;branch-name分支名&gt;</code></pre><p><strong>强制删除</strong>一个分支，不管有没有未合并变化</p><pre><code class="shell">$ git branch -D &lt;branch-name分支名&gt;</code></pre><p>删除<strong>远程分支</strong></p><pre><code class="shell"># 删除远程分支$ git push origin --delete &lt;branch-name&gt;$ git branch -dr &lt;remote/branch&gt;</code></pre><h3 id="分支改名"><a href="#分支改名" class="headerlink" title="分支改名"></a>分支改名</h3><pre><code class="shell"># 新建一个分支$ git checkout -b twitter-experiment feature132# 删除原来的分支，使用新的分支，从而达到重命名操作$ git branch -d feature132</code></pre><p>另一种写法</p><pre><code class="shell"># 为当前分支改名$ git branch -m twitter-experiment# 为指定分支改名$ git branch -m feature132 twitter-experiment# 如果有重名分支，强制改名$ git branch -m feature132 twitter-experiment</code></pre><h3 id="查看-merge-情况"><a href="#查看-merge-情况" class="headerlink" title="查看 merge 情况"></a>查看 merge 情况</h3><pre><code class="shell"># 显示全部合并到当前分支的分支$ git branch --merged# 显示未合并到当前分支的分支$ git branch --no-merged</code></pre><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>合并指定分支到当前分支</p><pre><code class="shell"># 合并指定分支到当前分支$ git merge [branch]</code></pre><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p><code>git cherry-pick</code>命令”复制”一个提交节点并在当前分支做一次完全一样的新提交</p><pre><code class="shell"># 选择一个commit，合并进当前分支$ git cherry-pick [commit]</code></pre><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><pre><code class="shell"># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p><code>git tag</code>命令用于为 commit 打标签<br>Tag 分两种：普通tag和注解tag<br>只有<code>annotated tag</code>(注解tag) 才会产生 object</p><pre><code class="shell">$ git tag tmp # 生成.git/refs/tags/tmp$ git tag -a release$ git tag -a [VERSION] -m &quot;released [VERSION]&quot;</code></pre><p>上面代码表示为<strong>当前commit</strong>打上一个带注解的标签，标签名为<strong>release</strong><br>普通标签的写法</p><pre><code class="shell">$ git tag 1.0.0$ git push --tags$ git tag v0.0.1$ git push origin master --tags</code></pre><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><pre><code class="shell"># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [&lt;file&gt;]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code><br><code>git remote</code>查看远程库的信息</p><pre><code class="shell"># 下载远程仓库的所有变动$ git fetch [remote]# 查看远程库详细信息# 显示可以抓取(fetch)和推送(push)的origin的地址；如果没有推送权限，就看不到push的地址$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h1 id="查看版本改动"><a href="#查看版本改动" class="headerlink" title="查看版本改动"></a>查看版本改动</h1><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p><code>git diff</code>命令用于查看文件之间的差异</p><p>在git提交环节，存在三大部分：<strong>working tree</strong>（工作区）, <strong>index file</strong>（暂存区：stage）, <strong>commit</strong>（分支：master）</p><pre><code class="shell"># 查看工作区与暂存区的差异$ git diff# 查看某个文件的工作区与暂存区的差异$ git diff file.txt# 查看暂存区与当前 commit 的差异$ git diff --cached# 查看两个commit的差异$ git diff &lt;commitBefore&gt; &lt;commitAfter&gt;# 查看暂存区与仓库区的差异$ git diff --cached# 查看工作区与上一次commit之间的差异# 即如果执行 git commit -a，将提交的文件$ git diff HEAD# 查看工作区与某个 commit 的差异$ git diff &lt;commit&gt;# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 查看工作区与当前分支上一次提交的差异，但是局限于test文件$ git diff HEAD -- ./test# 查看当前分支上一次提交与上上一次提交之间的差异$ git diff HEAD -- ./test# 生成patch$ git format-patch master --stdout &gt; mypatch.patch</code></pre><p>比较两个分支</p><pre><code class="shell"># 查看topic分支与master分支最新提交之间的差异$ git diff topic master# 与上一条命令相同$ git diff topic..master# 查看自从topic分支建立以后，master分支发生的变化$ git diff topic...master</code></pre><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><pre><code class="shell"># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到工作区$ git checkout [commit] [file]# 恢复上一个commit的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><pre><code class="shell"># 生成一个可供发布的压缩包$ git archive</code></pre><p><code>HEAD</code>表示当前版本，也就是最新的提交。上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，<br>往上100个版本写100个<code>^</code> 比较容易数不过来，所以写成<code>HEAD~100</code>。<code>HEAD~2</code>相当于<code>HEAD^^</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰官方网站</a>、<a href="https://www.bookstack.cn/books/git-tutorial" target="_blank" rel="noopener">阮一峰 Git 教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      git命令汇总
    
    </summary>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://www.xiongtianci.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>常用正则表达式公式</title>
    <link href="https://www.xiongtianci.com/2019/06/10/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.xiongtianci.com/2019/06/10/常用正则表达式公式/</id>
    <published>2019-06-10T10:07:34.000Z</published>
    <updated>2019-06-11T11:59:22.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：艾欢欢</p><p>链接：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTY0NDU3Nw==&amp;mid=2651939156&amp;idx=1&amp;sn=79f0579d9070be0fb61bce7e503ea9be&amp;chksm=8d0f0e1aba78870ce8a2b6749b1749069946d4cba32a819c424b96d1c1b38ba0c096452fdcb1&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=c057d35eab709d25144f00cb6fa9b63212b36228878f80f4bce5a77b2439611899d707ea217205f14f3957120d4979ff78fd401ea654e0b67635d0d36e71dd4b347163fa798001e7963ac98d4cd62e50&amp;ascene=1&amp;uin=MjYxNjc3MjAzOA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=2Z5hSrTwDuopoqQqW4vKeZajl7djxXXhYMTrGA%2FC5uVIPjB09bhdrVYCqRhocWOj" target="_blank" rel="noopener">收藏一波：常用正则表达式公式总结</a></p></blockquote><h1 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h1><p>一位数字：</p><pre><code>^[0-9]\*$</code></pre><p>n位的数字：</p><pre><code>^\d{n}$</code></pre><p>至少n位的数字：</p><pre><code>^\d{n,}$</code></pre><p>m-n位的数字：</p><pre><code>^\d{m,n}$</code></pre><p>零和非零开头的数字：</p><pre><code>^(0|[1-9][0-9]\*)$</code></pre><p>非零开头的最多带两位小数的数字：</p><pre><code>^([1-9][0-9]\*)+(\.[0-9]{1,2})?$</code></pre><p>带1-2位小数的正数或负数：</p><pre><code>^(\-)?\d+(\.\d{1,2})$</code></pre><p>正数、负数、和小数：</p><pre><code>^(\-|\+)?\d+(\.\d+)?$</code></pre><p>有两位小数的正实数：</p><pre><code>^[0-9]+(\.[0-9]{2})?$</code></pre><p>有1~3位小数的正实数：</p><pre><code>^[0-9]+(\.[0-9]{1,3})?$</code></pre><p>非零的正整数：</p><pre><code>^[1-9]\d\*$或^([1-9][0-9]\*){1,3}$或^\+?[1-9][0-9]\*$</code></pre><p>非零的负整数：</p><pre><code>^\-[1-9][]0-9&quot;\*$或^-[1-9]\d\*$</code></pre><p>非负整数：</p><pre><code>^\d+$或^[1-9]\d\*|0$</code></pre><p>非正整数：</p><pre><code>^-[1-9]\d\*|0$或^((-\d+)|(0+))$</code></pre><p>非负浮点数：</p><pre><code>^\d+(\.\d+)?$或^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0$</code></pre><p>非正浮点数：</p><pre><code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$或^(-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*))|0?\.0+|0$</code></pre><p>正浮点数：</p><pre><code>^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*$或^(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*))$</code></pre><p>负浮点数：</p><pre><code>^-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*)$或^(-(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*)))$</code></pre><p>浮点数：</p><pre><code>^(-?\d+)(\.\d+)?$或^-?([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0)$</code></pre><h1 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h1><p>汉字：</p><pre><code>^[\u4e00-\u9fa5]{0,}$</code></pre><p>英文和数字：</p><pre><code>^[A-Za-z0-9]+$或^[A-Za-z0-9]{4,40}$</code></pre><p>长度为3-20的所有字符：</p><pre><code>^.{3,20}$</code></pre><p>由26个英文字母组成的字符串：</p><pre><code>^[A-Za-z]+$</code></pre><p>由26个大写英文字母组成的字符串：</p><pre><code>^[A-Z]+$</code></pre><p>由26个小写英文字母组成的字符串：</p><pre><code>^[a-z]+$</code></pre><p>由数字和26个英文字母组成的字符串：</p><pre><code>^[A-Za-z0-9]+$</code></pre><p>由数字、26个英文字母或者下划线组成的字符串：</p><pre><code>^\w+$ 或 ^\w{3,20}$</code></pre><p>中文、英文、数字包括下划线：</p><pre><code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></pre><p>中文、英文、数字但不包括下划线等符号：</p><pre><code>^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</code></pre><p>禁止输入含有~的字符：</p><pre><code>[^~\x22]+</code></pre><h1 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h1><p>Email地址：</p><pre><code>^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$</code></pre><p>域名：</p><pre><code>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</code></pre><p>InternetURL：</p><pre><code>[a-zA-z]+://[^\s]\* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]\*)?$</code></pre><p>手机号码：</p><pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</code></pre><p>国内电话号码(0511-4405222、021-87888822)：</p><pre><code>\d{3}-\d{8}|\d{4}-\d{7}</code></pre><p>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）:</p><pre><code> ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)</code></pre><p>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：</p><pre><code>(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)</code></pre><p>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：</p><pre><code>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</code></pre><p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：</p><pre><code>^[a-zA-Z]\w{5,17}$</code></pre><p>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：</p><pre><code>^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z])[a-zA-Z0-9]{8,10}$</code></pre><p>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：</p><pre><code>^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z]).{8,10}$</code></pre><p>日期格式：</p><pre><code>^\d{4}-\d{1,2}-\d{1,2}</code></pre><p>一年的12个月(01～09和1～12)：</p><pre><code>^(0?[1-9]|1[0-2])$</code></pre><p>一个月的31天(01～09和1～31)：</p><pre><code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></pre><p>xml文件：</p><pre><code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></pre><p>中文字符的正则表达式：</p><pre><code>[\u4e00-\u9fa5]</code></pre><p>空白行的正则表达式：</p><pre><code>\n\s\*\r (可以用来删除空白行)</code></pre><p>HTML标记的正则表达式：</p><pre><code>&lt;(\S\*?)[^&gt;]\*&gt;.\*?|&lt;.\*? /&gt; ( 首尾空白字符的正则表达式：^\s\*|\s\*$或(^\s\*)|(\s\*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</code></pre><p>腾讯QQ号：</p><pre><code>[1-9][0-9]{4,} (腾讯QQ号从10000开始)</code></pre><p>中国邮政编码：</p><pre><code>[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)</code></pre><p>IP地址：</p><pre><code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="转载" scheme="https://www.xiongtianci.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="正则" scheme="https://www.xiongtianci.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>致迷茫中的自己</title>
    <link href="https://www.xiongtianci.com/2019/06/10/%E8%87%B4%E8%BF%B7%E8%8C%AB%E4%B8%AD%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
    <id>https://www.xiongtianci.com/2019/06/10/致迷茫中的自己/</id>
    <published>2019-06-10T04:40:33.000Z</published>
    <updated>2019-06-10T05:02:58.749Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果感到迷茫，而且选择比较多的时候，就先都试着做做呗，大不了就累一点不睡觉嘛。</p></blockquote><p>上面这句话来自我超喜欢的一个<code>B站</code>up主–<a href="https://space.bilibili.com/60614881/" target="_blank" rel="noopener">无聊的Do君</a>5月1号的<a href="https://www.bilibili.com/video/av51058296" target="_blank" rel="noopener">视频</a></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190610-%E8%87%B4%E8%BF%B7%E8%8C%AB%E4%B8%AD%E7%9A%84%E8%87%AA%E5%B7%B1/20190610125121.jpg" alt="20190610125121"></p>]]></content>
    
    <summary type="html">
    
      如果感到迷茫，而且选择比较多的时候，就先都试着做做呗，大不了就累一点不睡觉嘛。
    
    </summary>
    
      <category term="生活" scheme="https://www.xiongtianci.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随想" scheme="https://www.xiongtianci.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="生活" scheme="https://www.xiongtianci.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>一千行MySQL学习笔记</title>
    <link href="https://www.xiongtianci.com/2019/06/05/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.xiongtianci.com/2019/06/05/一千行MySQL学习笔记/</id>
    <published>2019-06-05T09:41:17.000Z</published>
    <updated>2019-06-12T10:12:41.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jioby</p><p>链接： <a href="https://shockerli.net/post/1000-line-mysql-note/" target="_blank" rel="noopener">https://shockerli.net/post/1000-line-mysql-note/</a></p></blockquote><h1 id="Windows服务"><a href="#Windows服务" class="headerlink" title="Windows服务"></a>Windows服务</h1><pre><code class="sql">-- 启动mysqlnet start mysql-- 创建windows服务(注意：等号与值之间有空格)sc create mysql binpath= mysqld_bin_path</code></pre><h1 id="连接与断开服务器"><a href="#连接与断开服务器" class="headerlink" title="连接与断开服务器"></a>连接与断开服务器</h1><pre><code class="sql">-- 连接（地址、端口可不填，默认为localhost:3306）mysql -h 地址 -p 端口 -u 用户名 -p 密码-- 显示哪些线程正在运行show processlist-- 显示系统变量信息show variables</code></pre><h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><pre><code class="sql">-- 查看当前数据库select database();-- 显示当前时间、用户名、数据库版本select now(), user(), version();-- 创建库create database[ if not exists] 数据库名 数据库选项    -- 数据库选项：    character set charset_name    collate collation_name-- 查看已有库show databases[ like &#39;pattern&#39;]-- 查看当前库信息show create database 数据库名-- 修改库的选项信息alter database 库名 选项信息-- 删除库drop database[ if exists] 数据库名    -- 同时删除该数据库相关的目录及其目录内容</code></pre><h1 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h1><pre><code class="sql">-- 创建表create [temporary] table [if not exists] [库名.]表名 (表的结构定义) [表选项]    每个字段必须有数据类型    最后一个字段后不能有逗号    temporary 临时表，会话结束时表自动消失    对于字段的定义：        字段名 数据类型 [not null | null] [default default_value] [auto_increment] [unique [key] | [primary] key] [comment &#39;string&#39;]    -- 表选项        -- 字符集            charset = charset_name            如果表没有设定，则使用数据库字符集        -- 存储引擎            engine = engine_name            表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同            常见的引擎：innodb myisam memory/heap bdb merge example csv maxdb archive            不同的引擎在保存表的结构和数据时采用不同的方式            myisam表文件含义：.frm表定义，.myd表数据，.myi表索引            innodb表文件含义：.frm表定义，表空间数据和日志文件            show engines -- 显示存储引擎的状态信息            show engine 引擎名 {logs|status} -- 显示存储引擎的日志或状态信息        -- 自增起始数            auto_increment = 行数        -- 数据文件目录            data directory = &#39;目录&#39;        -- 索引文件目录            index directory = &#39;目录&#39;        -- 表注释            comment = &#39;string&#39;        -- 分区选项            partition by ... (详细见手册)-- 查看所有表show tables[ like &#39;pattern&#39;]show tables from 表名-- 查看表机构show create table 表名 （信息更详细）desc 表名 / describe 表名 / explain 表名 / show columns from 表名 [like &#39;pattern&#39;]show table status [from db_name] [like &#39;pattern&#39;]-- 修改表    -- 修改表本身的选项        alter table 表名 表的选项        eg: alter table 表名 engine=myisam;    -- 对表进行重命名        rename table 原表名 to 新表名        rename table 原表名 to 库名.表名 （可将表移动到另一个数据库）        -- rename可以交换两个表名    -- 修改表的字段机构（13.1.2. alter table语法）        alter table 表名 操作名        -- 操作名            add[ column] 字段定义       -- 增加字段                after 字段名          -- 表示增加在该字段名后面                first               -- 表示增加在第一个            add primary key(字段名)   -- 创建主键            add unique [索引名] (字段名)-- 创建唯一索引            add index [索引名] (字段名) -- 创建普通索引            drop[ column] 字段名      -- 删除字段            modify[ column] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)            change[ column] 原字段名 新字段名 字段属性      -- 支持对字段名修改            drop primary key    -- 删除主键(删除主键前需删除其auto_increment属性)            drop index 索引名 -- 删除索引            drop foreign key 外键    -- 删除外键-- 删除表drop table[ if exists] 表名 ...-- 清空表数据truncate [table] 表名-- 复制表结构create table 表名 like 要复制的表名-- 复制表结构和数据create table 表名 [as] select * from 要复制的表名-- 检查表是否有错误check table tbl_name [, tbl_name] ... [option] ...-- 优化表optimize [local | no_write_to_binlog] table tbl_name [, tbl_name] ...-- 修复表repair [local | no_write_to_binlog] table tbl_name [, tbl_name] ... [quick] [extended] [use_frm]-- 分析表analyze [local | no_write_to_binlog] table tbl_name [, tbl_name] ...</code></pre><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><pre><code class="sql">-- 增insert [into] 表名 [(字段列表)] values (值列表)[, (值列表), ...]    -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。    -- 可同时插入多条数据记录！    replace 与 insert 完全一样，可互换。insert [into] 表名 set 字段名=值[, 字段名=值, ...]-- 查select 字段列表 from 表名[ 其他子句]    -- 可来自多个表的多个字段    -- 其他子句可以不使用    -- 字段列表可以用*代替，表示所有字段-- 删delete from 表名[ 删除条件子句]    没有条件子句，则会删除全部-- 改update 表名 set 字段名=新值[, 字段名=新值] [更新条件]</code></pre><h1 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h1><pre><code class="sql">-- mysql、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致show variables like &#39;character_set_%&#39;   -- 查看所有字符集编码项    character_set_client        客户端向服务器发送数据时使用的编码    character_set_results       服务器端将结果返回给客户端所使用的编码    character_set_connection    连接层编码set 变量名 = 变量值    set character_set_client = gbk;    set character_set_results = gbk;    set character_set_connection = gbk;set names gbk;  -- 相当于完成以上三个设置-- 校对集    校对集用以排序    show character set [like &#39;pattern&#39;]/show charset [like &#39;pattern&#39;]   查看所有字符集    show collation [like &#39;pattern&#39;]     查看所有校对集    charset 字符集编码     设置字符集编码    collate 校对集编码     设置校对集编码</code></pre><h1 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h1><pre><code class="sql">1. 数值类型-- a. 整型 ----------    类型         字节     范围（有符号位）    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255    smallint    2字节    -32768 ~ 32767    mediumint   3字节    -8388608 ~ 8388607    int         4字节    bigint      8字节    int(m)  m表示总位数    - 默认存在符号位，unsigned 属性修改    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改        例：int(5)   插入一个数&#39;123&#39;，补填后为&#39;00123&#39;    - 在满足要求的情况下，越小越好。    - 1表示bool值真，0表示bool值假。mysql没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。-- b. 浮点型 ----------    类型             字节     范围    float(单精度)     4字节    double(双精度)    8字节    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。        不同于整型，前后均会补填0.    定义浮点型时，需指定总位数和小数位数。        float(m, d)     double(m, d)        m表示总位数，d表示小数位数。        m和d的大小会决定浮点数的范围。不同于整型的固定范围。        m既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。        支持科学计数法表示。        浮点数表示近似值。-- c. 定点数 ----------    decimal -- 可变长度    decimal(m, d)   m也表示总位数，d表示小数位数。    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。    将浮点数转换为字符串来保存，每9位数字保存为4个字节。2. 字符串类型-- a. char, varchar ----------    char    定长字符串，速度快，但浪费空间    varchar 变长字符串，速度慢，但节省空间    m表示能存储的最大长度，此长度是字符数，非字节数。    不同的编码，所占用的空间不同。    char,最多255个字符，与编码无关。    varchar,最多65535字符，与编码有关。    一条有效记录最大不能超过65535个字节。        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。    varchar 的最大有效长度由最大行大小和使用的字符集确定。    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。    例：若一个表定义为 create table tb(c1 int, c2 char(30), c3 varchar(n)) charset=utf8; 问n的最大值是多少？ 答：(65535-1-2-4-30*3)/3-- b. blob, text ----------    blob 二进制字符串（字节字符串）        tinyblob, blob, mediumblob, longblob    text 非二进制字符串（字符字符串）        tinytext, text, mediumtext, longtext    text 在定义时，不需要定义长度，也不会计算总长度。    text 类型在定义时，不可给default值-- c. binary, varbinary ----------    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。    char, varchar, text 对应 binary, varbinary, blob.3. 日期时间类型    一般用整型保存时间戳，因为php可以很方便的将时间戳进行格式化。    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59    date        3字节    日期         1000-01-01 到 9999-12-31    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07    time        3字节    时间         -838:59:59 到 838:59:59    year        1字节    年份         1901 - 2155datetime    yyyy-mm-dd hh:mm:sstimestamp   yy-mm-dd hh:mm:ss            yyyymmddhhmmss            yymmddhhmmss            yyyymmddhhmmss            yymmddhhmmssdate        yyyy-mm-dd            yy-mm-dd            yyyymmdd            yymmdd            yyyymmdd            yymmddtime        hh:mm:ss            hhmmss            hhmmssyear        yyyy            yy            yyyy            yy4. 枚举和集合-- 枚举(enum) ----------enum(val1, val2, val3...)    在已知的值中进行单选。最大数量为65535.    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。    表现为字符串类型，存储却是整型。    null值的索引是null。    空字符串错误值的索引值是0。-- 集合（set） ----------set(val1, val2, val3...)    create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );    insert into tab values (&#39;男, 女&#39;);    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。    当创建表时，set成员值的尾部空格将自动被删除。</code></pre><h1 id="选择类型"><a href="#选择类型" class="headerlink" title="选择类型"></a>选择类型</h1><pre><code class="sql">-- php角度1. 功能满足2. 存储空间尽量小，处理效率更高3. 考虑兼容问题-- ip存储 ----------1. 只需存储，可用字符串2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned    1) php函数转换        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。        利用sprintf函数格式化字符串        sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;));        然后用long2ip将整型转回ip字符串    2) mysql函数转换(无符号整型，unsigned)        inet_aton(&#39;127.0.0.1&#39;) 将ip转为整型        inet_ntoa(2130706433) 将整型转为ip</code></pre><h1 id="列属性（列约束）"><a href="#列属性（列约束）" class="headerlink" title="列属性（列约束）"></a>列属性（列约束）</h1><pre><code class="sql">1. primary 主键    - 能唯一标识记录的字段，可以作为主键。    - 一个表只能有一个主键。    - 主键具有唯一性。    - 声明字段时，用 primary key 标识。        也可以在字段列表之后声明            例：create table tab ( id int, stu varchar(10), primary key (id));    - 主键字段的值不能为null。    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. unique 唯一索引（唯一约束）    使得某字段的值也不能重复。3. null 约束    null不是数据类型，是列的一个属性。    表示当前列是否可以为null，表示什么都没有。    null, 允许为空。默认。    not null, 不允许为空。    insert into tab values (null, &#39;val&#39;);        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. default 默认值属性    当前字段的默认值。    insert into tab values (default, &#39;val&#39;);    -- 此时表示强制使用默认值。    create table tab ( add_time timestamp default current_timestamp );        -- 表示将当前时间的时间戳设为默认值。        current_date, current_time5. auto_increment 自动增长约束    自动增长必须为索引（主键或unique）    只能存在一个字段为自动增长。    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. comment 注释    例：create table tab ( id int ) comment &#39;注释内容&#39;;7. foreign key 外键约束    用于限制主表与从表数据完整性。    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);        -- 将表t1的t1_id外键关联到表t2的id字段。        -- 每个外键都有一个名字，可以通过 constraint 指定    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。    mysql中，可以对innodb引擎使用外键约束：    语法：    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。    3. restrict，拒绝父表删除和更新。    注意，外键只被innodb存储引擎所支持。其他引擎是不支持的。</code></pre><h1 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h1><pre><code class="sql">-- normal format, nf    - 每个表保存一个实体信息    - 每个具有一个id字段作为主键    - id主键 + 原子表-- 1nf, 第一范式    字段不能再分，就满足第一范式。-- 2nf, 第二范式    满足第一范式的前提下，不能出现部分依赖。    消除符合主键就可以避免部分依赖。增加单列关键字。-- 3nf, 第三范式    满足第二范式的前提下，不能出现传递依赖。    某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。    将一个实体信息的数据放在一个表内实现。</code></pre><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><pre><code class="sql">select [all|distinct] select_expr from -&gt; where -&gt; group by [合计函数] -&gt; having -&gt; order by -&gt; limita. select_expr    -- 可以用 * 表示所有字段。        select * from tb;    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）        select stu, 29+25, now() from tb;    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。        - 使用 as 关键字，也可省略 as.        select stu+10 as add10 from tb;b. from 子句    用于标识查询来源。    -- 可以为表起别名。使用as关键字。        select * from tb1 as tt, tb2 as bb;    -- from子句后，可以同时出现多个表。        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。        select * from tb1, tb2;    -- 向优化符提示如何选择索引        use index、ignore index、force index        select * from table1 use index (key1,key2) where key1=1 and key2=2 and key3=3;        select * from table1 ignore index (key3) where key1=1 and key2=2 and key3=3;c. where 子句    -- 从from获得的数据源中进行筛选。    -- 整型1表示真，0表示假。    -- 表达式由运算符和运算数组成。        -- 运算数：变量（字段）、值、函数返回值        -- 运算符：            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor            is/is not 加上ture/false/unknown，检验某个值的真假            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. group by 子句, 分组子句    group by 字段/别名 [排序方式]    分组后会进行排序。升序：asc，降序：desc    以下[合计函数]需配合 group by 使用：    count 返回不同的非null值数目  count(*)、count(字段)    sum 求和    max 求最大值    min 求最小值    avg 求平均值    group_concat 返回带有来自一个组的连接的非null值的字符串结果。组内字符串连接。e. having 子句，条件子句    与 where 功能、用法相同，执行时机不同。    where 在开始时执行检测数据，对原数据进行过滤。    having 对筛选出的结果再次进行过滤。    having 字段必须是查询出来的，where 字段必须是数据表存在的。    where 不可以使用字段的别名，having 可以。因为执行where代码时，可能尚未确定列值。    where 不可以使用合计函数。一般需用合计函数才会用 having    sql标准要求having必须引用group by子句中的列或用于合计函数中的列。f. order by 子句，排序子句    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...    升序：asc，降序：desc    支持多个字段的排序。g. limit 子句，限制结果数量子句    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。    limit 起始位置, 获取条数    省略第一个参数，表示从索引0开始。limit 获取条数h. distinct, all 选项    distinct 去除重复记录    默认为 all, 全部记录</code></pre><h1 id="union"><a href="#union" class="headerlink" title="union"></a>union</h1><pre><code class="sql">将多个select查询的结果组合成一个结果集合。select ... union [all|distinct] select ...默认 distinct 方式，即所有返回的行都是唯一的建议，对每个select查询加上小括号包裹。order by 排序时，需加上 limit 进行结合。需要各select查询的字段数量一样。每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</code></pre><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><pre><code>    - 子查询需用括号包裹。-- from型    from后要求是一个表，必须给子查询结果取个别名。    - 简化每个查询内的条件。    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。    - 子查询返回一个表，表型子查询。    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;-- where型    - 子查询返回一个值，标量子查询。    - 不需要给子查询取别名。    - where子查询内的表，不能直接用以更新。    select * from tb where money = (select max(money) from tb);    -- 列子查询        如果子查询结果返回的是一列。        使用 in 或 not in 完成查询        exists 和 not exists 条件            如果子查询返回数据，则返回1或0。常用于判断条件。            select column1 from t1 where exists (select * from t2);    -- 行子查询        查询条件是一个行。        select * from t1 where (id, gender) in (select id, gender from t2);        行构造符：(col1, col2, ...) 或 row(col1, col2, ...)        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。    -- 特殊运算符    != all()    相当于 not in    = some()    相当于 in。any 是 some 的别名    != some()   不等同于 not in，不等于其中某一个。    all, some 可以配合其他运算符一起使用。</code></pre><h1 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h1><pre><code class="sql">    将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join)    - 默认就是内连接，可省略inner。    - 只有数据存在时才能发送连接。即连接结果不能出现空行。    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）    也可用where表示连接条件。    还有 using, 但需字段名相同。 using(字段名)    -- 交叉连接 cross join        即，没有条件的内连接。        select * from tb1 cross join tb2;-- 外连接(outer join)    - 如果数据不存在，也会出现在连接结果中。    -- 左外连接 left join        如果数据不存在，左表记录会出现，而右表为null填充    -- 右外连接 right join        如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join)    自动判断连接条件完成连接。    相当于省略了using，会自动查找相同字段名。    natural join    natural left join    natural right joinselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;/* 导入导出 */ ------------------select * into outfile 文件地址 [控制格式] from 表名;   -- 导出表数据load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据    生成的数据默认的分隔符是制表符    local未指定，则数据文件必须在服务器上    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理-- 控制格式fields  控制字段格式默认：fields terminated by &#39;\t&#39; enclosed by &#39;&#39; escaped by &#39;\\&#39;    terminated by &#39;string&#39;  -- 终止    enclosed by &#39;char&#39;      -- 包裹    escaped by &#39;char&#39;       -- 转义    -- 示例：        select a,b,a+b into outfile &#39;/tmp/result.text&#39;        fields terminated by &#39;,&#39; optionally enclosed by &#39;&quot;&#39;        lines terminated by &#39;\n&#39;        from test_table;lines   控制行格式默认：lines terminated by &#39;\n&#39;    terminated by &#39;string&#39;  -- 终止</code></pre><h1 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h1><pre><code class="sql">select语句获得的数据可以用insert插入。可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。    或者使用set语法。    insert into tbl_name set field=value,...；可以一次性使用多个值，采用(), (), ();的形式。    insert into tbl_name values (), (), ();可以在列值指定时，使用表达式。    insert into tbl_name values (field_value, 10+10, now());可以使用一个特殊值 default，表示该列使用默认值。    insert into tbl_name values (field_value, default);可以通过一个查询的结果，作为需要插入的值。    insert into tbl_name select ...;可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。    insert into tbl_name values/set/select on duplicate key update 字段=值, …;</code></pre><h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><pre><code class="sql">delete from tbl_name [where where_definition] [order by ...] [limit row_count]按照条件删除。where指定删除的最多记录数。limit可以通过排序条件删除。order by + limit支持多表删除，使用类似连接语法。delete from 需要删除数据多表1，表2 using 表连接操作 条件。/* truncate */ ------------------truncate [table] tbl_name清空数据删除重建表区别：1，truncate 是删除表再创建，delete 是逐条删除2，truncate 重置auto_increment的值。而delete不会3，truncate 不知道删除了几条，而delete知道。4，当被用于带分区的表时，truncate 会保留分区</code></pre><h1 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h1><pre><code class="sql">备份，将数据的结构与表内数据保存起来。利用 mysqldump 指令完成。-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database db1 [db2 db3...]mysqldump [options] --all--database1. 导出一张表　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(d:/a.sql)2. 导出多张表　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(d:/a.sql)3. 导出所有表　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(d:/a.sql)4. 导出一个库　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(d:/a.sql)可以-w携带where条件-- 导入1. 在登录mysql的情况下：　　source  备份文件2. 在不登录的情况下　　mysql -u用户名 -p密码 库名 &lt; 备份文件</code></pre><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><pre><code class="sql">什么是视图：    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。    视图具有表结构文件，但不存在数据文件。    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。-- 创建视图create [or replace] [algorithm = {undefined | merge | temptable}] view view_name [(column_list)] as select_statement    - 视图名必须唯一，同时不能与表重名。    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。    - 可以指定视图执行的算法，通过algorithm指定。    - column_list如果存在，则数目必须等于select语句检索的列数-- 查看结构    show create view view_name-- 删除视图    - 删除视图后，数据依然存在。    - 可同时删除多个视图。    drop view [if exists] view_name ...-- 修改视图结构    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。    alter view view_name [(column_list)] as select_statement-- 视图作用    1. 简化业务逻辑    2. 对客户端隐藏真实的表结构-- 视图算法(algorithm)    merge       合并        将视图的查询语句，与外部查询需要先合并再执行！    temptable   临时表        将视图执行完毕后，形成临时表，再做外层查询！    undefined   未定义(默认)，指的是mysql自主去选择相应的算法。</code></pre><h1 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h1><pre><code class="sql">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。    - 支持连续sql的集体成功或集体撤销。    - 事务是数据库在数据晚自习方面的一个功能。    - 需要利用 innodb 或 bdb 存储引擎，对自动提交的特性支持完成。    - innodb被称为事务安全型引擎。-- 事务开启    start transaction; 或者 begin;    开启事务后，所有被执行的sql语句均被认作当前事务内的sql语句。-- 事务提交    commit;-- 事务回滚    rollback;    如果部分操作发生问题，映射到事务开启前。-- 事务的特性    1. 原子性（atomicity）        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。    2. 一致性（consistency）        事务前后数据的完整性必须保持一致。        - 事务开始和结束时，外部数据一致        - 在整个事务过程中，操作是连续的    3. 隔离性（isolation）        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。    4. 持久性（durability）        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现    1. 要求是事务支持的表类型    2. 执行一组相关的操作前开启事务    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理    利用innodb的自动提交(autocommit)特性完成。    普通的mysql执行语句后，当前的数据提交操作均可被其他客户端可见。    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意    1. 数据定义语言（ddl）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。    2. 事务不能被嵌套-- 保存点    savepoint 保存点名称 -- 设置一个事务保存点    rollback to savepoint 保存点名称 -- 回滚到保存点    release savepoint 保存点名称 -- 删除保存点-- innodb自动提交特性设置    set autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。    - 也可以关闭自动提交来开启事务。但与start transaction不同的是，        set autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)        而start transaction记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</code></pre><h1 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h1><pre><code class="sql">表锁定只用于防止其它客户端进行不正当地读取和写入myisam 支持表锁，innodb 支持行锁-- 锁定    lock tables tbl_name [as alias]-- 解锁    unlock tables</code></pre><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><pre><code class="sql">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象    监听：记录的增加、修改、删除。-- 创建触发器create trigger trigger_name trigger_time trigger_event on tbl_name for each row trigger_stmt    参数：    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。    trigger_event指明了激活触发程序的语句的类型        insert：将新行插入表时激活触发程序        update：更改某一行时激活触发程序        delete：从表中删除某一行时激活触发程序    tbl_name：监听的表，必须是永久性的表，不能将触发程序与temporary表或视图关联起来。    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用begin...end复合语句结构-- 删除drop trigger [schema_name.]trigger_name可以使用old和new代替旧的和新的数据    更新操作，更新前是old，更新后是new.    删除操作，只有old.    增加操作，只有new.-- 注意    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。-- 字符连接函数concat(str1,str2,...])concat_ws(separator,str1,str2,...)-- 分支语句if 条件 then    执行语句elseif 条件 then    执行语句else    执行语句end if;-- 修改最外层语句结束符delimiter 自定义结束符号    sql语句自定义结束符号delimiter ;     -- 修改回原来的分号-- 语句块包裹begin    语句块end-- 特殊的执行1. 只要添加记录，就会触发程序。2. insert into on duplicate key update 语法会触发：    如果没有重复记录，会触发 before insert, after insert;    如果有重复记录并更新，会触发 before insert, before update, after update;    如果有重复记录但是没有发生更新，则触发 before insert, before update3. replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</code></pre><h1 id="SQL编程"><a href="#SQL编程" class="headerlink" title="SQL编程"></a>SQL编程</h1><pre><code class="sql">--// 局部变量 ------------ 变量声明    declare var_name[,...] type [default value]    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值    使用 set 和 select into 语句为变量赋值。    - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。    -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10;    - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then    statement_list   [elseif search_condition then    statement_list]...[else    statement_list]end if;-- case语句case value when [compare-value] then result[when [compare-value] then result ...][else result]end-- while循环[begin_label:] while search_condition do    statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。    -- 退出循环        退出整个循环 leave        退出当前循环 iterate        通过退出的标签决定退出哪个循环--// 内置函数 ------------ 数值函数abs(x)          -- 绝对值 abs(-10.9) = 10format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x)         -- 向上取整 ceil(10.1) = 11floor(x)        -- 向下取整 floor (10.1) = 10round(x)        -- 四舍五入去整mod(m, n)       -- m%n m mod n 求余 10%3=1pi()            -- 获得圆周率pow(m, n)       -- m^nsqrt(x)         -- 算术平方根rand()          -- 随机数truncate(x, d)  -- 截取d位小数-- 时间日期函数now(), current_timestamp();     -- 当前日期时间current_date();                 -- 当前日期current_time();                 -- 当前时间date(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取日期部分time(&#39;yyyy-mm-dd hh:ii:ss&#39;);    -- 获取时间部分date_format(&#39;yyyy-mm-dd hh:ii:ss&#39;, &#39;%d %y %a %d %m %b %j&#39;); -- 格式化时间unix_timestamp();               -- 获得unix时间戳from_unixtime();                -- 从时间戳获得时间-- 字符串函数length(string)          -- string长度，字节char_length(string)     -- string的字符个数substring(str, position [,length])      -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_strinstr(string ,substring)    -- 返回substring首次在string中出现的位置concat(string [,...])   -- 连接字串charset(str)            -- 返回字串字符集lcase(string)           -- 转换成小写left(string, length)    -- 从string2中的左边起取length个字符load_file(file_name)    -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为lengthltrim(string)           -- 去除前端空格repeat(string, count)   -- 重复count次rpad(string, length, pad)   --在str后用pad补充,直到长度为lengthrtrim(string)           -- 去除后端空格strcmp(string1 ,string2)    -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end   多分支if(expr1,expr2,expr3)  双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();--// 存储函数，自定义函数 ------------ 新建    create function function_name (参数列表) returns 返回值类型        函数体    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。    - 多条语句应该使用 begin...end 语句块包含。    - 一定要有 return 返回值语句。-- 删除    drop function [if exists] function_name;-- 查看    show function status like &#39;partten&#39;    show create function function_name;-- 修改    alter function function_name 函数选项--// 存储过程，自定义功能 ------------ 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建create procedure sp_name (参数列表)    过程体参数列表：不同于函数的参数列表，需要指明参数类型in，表示输入型out，表示输出型inout，表示混合型注意，没有返回值。</code></pre><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><pre><code class="sql">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：call 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数in|out|inout 参数名 数据类型in      输入：在调用过程中，将数据输入到过程体内部的参数out     输出：在调用过程中，将过程体处理完的结果返回到客户端inout   输入输出：既可输入，也可输出-- 语法create procedure 过程名 (参数列表)begin    过程体end</code></pre><h1 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h1><pre><code class="sql">-- root密码重置1. 停止mysql服务2.  [linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;    [windows] mysqld --skip-grant-tables3. use mysql;4. update `user` set password=password(&quot;密码&quot;) where `user` = &quot;root&quot;;5. flush privileges;用户信息表：mysql.user-- 刷新权限flush privileges;-- 增加用户create user 用户名 identified by [password] 密码(字符串)    - 必须拥有mysql数据库的全局create user权限，或拥有insert权限。    - 只能创建用户，不能赋予权限。    - 用户名，注意引号：如 &#39;user_name&#39;@&#39;192.168.1.1&#39;    - 密码也需引号，纯数字密码也要加引号    - 要在纯文本中指定密码，需忽略password关键词。要把密码指定为由password()函数返回的混编值，需包含关键字password-- 重命名用户rename user old_user to new_user-- 设置密码set password = password(&#39;密码&#39;)  -- 为当前用户设置密码set password for 用户名 = password(&#39;密码&#39;) -- 为指定用户设置密码-- 删除用户drop user 用户名-- 分配权限/添加用户grant 权限列表 on 表名 to 用户名 [identified by [password] &#39;password&#39;]    - all privileges 表示所有权限    - *.* 表示所有库的所有表    - 库名.表名 表示某库下面的某表    grant all privileges on `pms`.* to &#39;pms&#39;@&#39;%&#39; identified by &#39;pms0817&#39;;-- 查看权限show grants for 用户名    -- 查看当前用户权限    show grants; 或 show grants for current_user; 或 show grants for current_user();-- 撤消权限revoke 权限列表 on 表名 from 用户名revoke all privileges, grant option from 用户名   -- 撤销所有权限-- 权限层级-- 要使用grant或revoke，您必须拥有grant option权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user    grant all on *.*和 revoke all on *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host    grant all on db_name.*和revoke all on db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv    grant all on db_name.tbl_name和revoke all on db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv    当使用revoke时，您必须指定与被授权列相同的列。-- 权限列表all [privileges]    -- 设置除grant option之外的所有简单权限alter   -- 允许使用alter tablealter routine   -- 更改或取消已存储的子程序create  -- 允许使用create tablecreate routine  -- 创建已存储的子程序create temporary tables     -- 允许使用create temporary tablecreate user     -- 允许使用create user, drop user, rename user和revoke all privileges。create view     -- 允许使用create viewdelete  -- 允许使用deletedrop    -- 允许使用drop tableexecute     -- 允许用户运行已存储的子程序file    -- 允许使用select...into outfile和load data infileindex   -- 允许使用create index和drop indexinsert  -- 允许使用insertlock tables     -- 允许对您拥有select权限的表使用lock tablesprocess     -- 允许使用show full processlistreferences  -- 未被实施reload  -- 允许使用flushreplication client  -- 允许用户询问从属服务器或主服务器的地址replication slave   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）select  -- 允许使用selectshow databases  -- 显示所有数据库show view   -- 允许使用show create viewshutdown    -- 允许使用mysqladmin shutdownsuper   -- 允许使用change master, kill, purge master logs和set global语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。update  -- 允许使用updateusage   -- “无权限”的同义词grant option    -- 允许授予权限</code></pre><h1 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h1><pre><code class="sql">-- 分析和存储表的关键字分布analyze [local | no_write_to_binlog] table 表名 ...-- 检查一个或多个表是否有错误check table tbl_name [, tbl_name] ... [option] ...option = {quick | fast | medium | extended | changed}-- 整理数据文件的碎片optimize [local | no_write_to_binlog] table tbl_name [, tbl_name] ...</code></pre><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><pre><code class="sql">1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！2. 每个库目录存在一个保存当前数据库的选项文件db.opt。3. 注释：    单行注释 # 注释内容    多行注释 /* 注释内容 */    单行注释 -- 注释内容     (标准sql注释风格，要求双破折号后加一空格符（空格、tab、换行等）)4. 模式通配符：    _   任意单个字符    %   任意多个字符，甚至包括零字符    单引号需要进行转义 \&#39;5. cmd命令行内的语句结束符可以为 &quot;;&quot;, &quot;\g&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。6. sql对大小写不敏感7. 清除已有语句：\c</code></pre>]]></content>
    
    <summary type="html">
    
      SQL笔记
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="转载" scheme="https://www.xiongtianci.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>npm install hexo-renderer-sass时报错</title>
    <link href="https://www.xiongtianci.com/2019/05/20/npm-install-hexo-renderer-sass%E6%97%B6%E6%8A%A5%E9%94%99/"/>
    <id>https://www.xiongtianci.com/2019/05/20/npm-install-hexo-renderer-sass时报错/</id>
    <published>2019-05-20T15:37:42.000Z</published>
    <updated>2019-06-12T10:12:07.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用<code>hexo</code>搭建博客时，需安装<code>hexo-renderer-sass</code>：</p><pre><code class="shell">$ npm install hexo-renderer-sass</code></pre><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>改用淘宝镜像：</p><pre><code class="shell">$ npm install -g cnpm --registry=https://registry.npm.taobao.org$ npm config set registry https://registry.npm.taobao.org</code></pre><p>再次安装：</p><pre><code class="shell">$ cnpm install hexo-renderer-sass --save</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://www.xiongtianci.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>重新搭建博客</title>
    <link href="https://www.xiongtianci.com/2019/05/20/%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://www.xiongtianci.com/2019/05/20/重新搭建博客/</id>
    <published>2019-05-20T12:49:00.000Z</published>
    <updated>2019-06-12T10:12:15.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>3月份初，许久没写博客（主要就是懒）的博主在莫一天心血来潮写好一篇文章后，使用<code>hexo d</code>部署博客文章时，发现<code>hexo</code>抛出各种错误。但由于当时准备面试的面试题（主要就是懒），然后就放着没管它。紧接着面试实习岗位，工作后也一直没有闲下来。<br>最近终于抽出时间来重构博客，写下这篇文章，记录一下重构博客的过程~</p><h2 id="博客目录介绍"><a href="#博客目录介绍" class="headerlink" title="博客目录介绍"></a>博客目录介绍</h2><pre><code>.├── .deploy├── public├── scaffolds├── scripts├── source|   ├── _drafts|   └── _posts├── themes├── _config.yml└── package.json</code></pre><ul><li>.deploy：执行hexo deploy命令部署到GitHub上的内容目录</li><li>public：执行hexo generate命令，输出的静态网页内容目录</li><li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li><li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li><li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</li><li>_drafts：草稿文章</li><li>_posts：发布文章</li><li>themes：主题文件目录</li><li>_config.yml：全局配置文件，大多数的设置都在这里</li><li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的 关于 按钮</li></ul><p>接下来是重头戏 _config.yml ，做个简单说明：</p><pre><code class="yml"># Hexo Configuration## Docs: http://zespia.tw/hexo/docs/configure.html## Source: https://github.com/tommy351/hexo/# Site #整站的基本信息title: 不如 #网站标题subtitle: 码农，程序猿，未来的昏析师 #网站副标题description: bruce sha&#39;s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到author: bruce #网站作者，在下方显示email: bu.ru@qq.com #联系邮箱language: zh-CN #语言# URL #域名和文件结构## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://ibruce.info #你的域名root: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code# Writing #写文章选项new_post_name: :title.md # File name of new postsdefault_layout: post #默认layout方式auto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabmax_open_file: 100multi_thread: truefilename_case: 0render_drafts: falsehighlight: #代码高亮  enable: true #是否启用  line_number: false #是否显示行号  tab_replace:# Category &amp; Tag #分类与标签default_category: uncategorized # defaultcategory_map:tag_map:# Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server #本地服务参数## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: truelogger_format:# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination #分页设置## Set per_page to 0 to disable paginationper_page: 10 #每页10篇文章pagination_dir: page# Disqus #社会化评论disqus，我使用多说，在主题中配置disqus_shortname:# Extensions #插件，暂时未安装插件## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themes## 主题theme: modernist # raytaylorism # pacman # modernist # lightexclude_generator:# Deployment #部署## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy:  type: github  repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库</code></pre><h2 id="主题目录介绍"><a href="#主题目录介绍" class="headerlink" title="主题目录介绍"></a>主题目录介绍</h2><pre><code>.├── languages          #多语言|   ├── default.yml    #默认语言|   └── zh-CN.yml      #中文语言├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制|   ├── _partial       #局部的布局，此目录下的*.ejs是对头尾等局部的控制|   └── _widget        #小挂件的布局，页面下方小挂件的控制├── source             #源码|   ├── css            #css源码 |   |   ├── _base      #*.styl基础css|   |   ├── _partial   #*.styl局部css|   |   ├── fonts      #字体|   |   ├── images     #图片|   |   └── style.styl #*.styl引入需要的css源码|   ├── fancybox       #fancybox效果源码|   └── js             #javascript源代码├── _config.yml        #主题配置文件└── README.md          #用GitHub的都知道</code></pre><p>如果你需要修改头部，直接修改 <code>hexo\themes\modernist\layout\_partial\header.ejs</code> ，比如头上加个搜索框：</p><pre><code class="ejs">&lt;div&gt;&lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\/\//, &#39;&#39;) %&gt;&quot;&gt;&lt;/form&gt;&lt;/div&gt;</code></pre><p>将如上代码加入即可，您需要修改css以便这个搜索框比较美观。<br>再如，你要修改页脚版权信息，直接编辑 <code>hexo\themes\modernist\layout\_partial\footer.ejs</code>。同理，你需要修改css，直接去修改对应位置的styl文件。</p><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><blockquote><p><a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">https://www.haomwei.com/technology/maupassant-hexo.html</a></p></blockquote><pre><code class="shell">$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save</code></pre><blockquote><p><code>npm install hexo-renderer-pug --save</code>安装时可能会报错，以下是解决方案：<br>改用cnpm来安装软件</p><blockquote><p>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>目的是直接改npm为淘宝的npm，也为防止某些依赖直接用npm来安装，导致无法顺利安装完成<br>$ npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></blockquote></blockquote><p>编辑Hexo目录下的 <code>_config.yml</code>，将<code>theme</code>的值改为<code>maupassant</code></p><pre><code class="yml">theme: matery</code></pre><h1 id="功能配置"><a href="#功能配置" class="headerlink" title="功能配置"></a>功能配置</h1><pre><code class="yml"># 是否启用Fancybox图片灯箱效果# Disqus评论 shortnamdisqus: # 友言评论 iduyan: # 来必力评论 data-uidlivere: # 畅言评论 appidchangyan: changyan_conf: ## Your changyan conf, e.g. prod_d8a508c2825ab57eeb43e7c69bba0e8b# Gitment评论相关参数gitment:  enable: false  owner:   repo:   client_id:   client_secret: # Gitalk评论相关参数gitalk:  enable: false   owner:    repo:   client_id:    client_secret:    admin:  # Valine评论相关参数valine:   enable: false   appid:   appkey:   notify: false # 评论系统中的邮件提醒设置  verify: false ## Validation code.  placeholder: Just so so   avatar: &#39;mm&#39;   pageSize: 10  guest_info: nick,mail,link# 默认使用Google搜索引擎google_search: true# 若想使用百度搜索，将其设定为 truebaidu_search: false# Swiftype 站内搜索keyswiftype: # 微搜索 keytinysou: # 基于jQuery的本地搜索引擎，需要安装hexo-generator-search插件使用self_search: false# Google Analytics 跟踪IDgoogle_analytics: # 百度统计 跟踪IDbaidu_analytics: # fancybox: true ## If you want to use fancybox please set the value to true.# 是否显示侧边栏分类数目show_category_count: false# 是否显示文章中目录列表自动编号toc_number: true#  是否使用分享按鈕，需要安装hexo-helper-qrcode插件使用shareto: false#  是否使用不蒜子页面访问计数busuanzi: false# wordcount: false ## If you want to display the word counter and the reading time expected to spend of each post please set the value to true, and you must have hexo-wordcount installed.# 是否在移动设备屏幕底部显示侧边栏widgets_on_small_screens: false ## Set to true to enable widgets on small screens.# 是否使用canvas动态背景canvas_nest:  enable: false  color: ## RGB value of the color, e.g. &quot;100,99,98&quot;  opacity: ## Transparency of lines, e.g. &quot;0.7&quot;  zIndex: ## The z-index property of the background, e.g. &quot;-1&quot;  count: ## Quantity of lines, e.g. &quot;150&quot;# 是否启用捐赠按钮donate:  enable: false  github: ## GitHub URL, e.g. https://github.com/Kaiyuan/donate-page  alipay_qr: ## Path of Alipay QRcode image, e.g. /img/AliPayQR.png  wechat_qr: ## Path of Wechat QRcode image, e.g. /img/WeChatQR.png  btc_qr: ## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png  btc_key: ## Bitcoin key, e.g. 1KuK5eK2BLsqpsFVXXSBG5wbSAwZVadt6L  paypal_url: ## Paypal URL, e.g. https://www.paypal.me/tufu9441post_copyright:  enable: false ## If you want to display the copyright info after each post, please set the value to true and fill the following items on your need.  author: ## Your author name, e.g. tufu9441  copyright_text: ## Your copyright text, e.g. The author owns the copyright, please indicate the source reproduced.# 自定义页面及菜单，依照已有格式填写。# 填写后请在source目录下建立相应名称的文件夹，并包含index.md文件，以正确显示页面。# 导航菜单中集成了FontAwesome图标字体，可以在这里选择新的图标，并按照相关说明使用。menu:  - page: home    directory: .    icon: fa-home  - page: archive    directory: archives/    icon: fa-archive  - page: about    directory: about/    icon: fa-user  - page: rss    directory: atom.xml    icon: fa-rss# 选择和排列希望使用的侧边栏小工具widgets: ## Six widgets in sidebar provided: search, category, tag, recent_posts, rencent_comments and links.  - search  - category  - tag  - recent_posts  - recent_comments  - links# 友情链接，请依照格式填写links:  - title: site-name1    url: http://www.example1.com/  - title: site-name2    url: http://www.example2.com/  - title: site-name3    url: http://www.example3.com/# 网站历史时间线，在页面front-matter中设置layout: timeline可显示timeline:  - num: 1    word: 2014/06/12-Start  - num: 2    word: 2014/11/29-XXX  - num: 3    word: 2015/02/18-DDD  - num: 4    word: More# Static files# 静态文件存储路径，方便设置CDN缓存js: jscss: css# Theme version# 主题版本，便于静态文件更新后刷新CDN缓存version: 0.0.0</code></pre><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><h3 id="Disqus配置使用"><a href="#Disqus配置使用" class="headerlink" title="Disqus配置使用"></a>Disqus配置使用</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><blockquote><p><a href="https://link.jianshu.com/?t=https://disqus.com/" target="_blank" rel="noopener">https://disqus.com/</a></p></blockquote><h1 id="主题特性"><a href="#主题特性" class="headerlink" title="主题特性"></a>主题特性</h1><h2 id="主题目录结构"><a href="#主题目录结构" class="headerlink" title="主题目录结构"></a>主题目录结构</h2><pre><code>-maupassant|-languages</code></pre><h2 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h2><p>网站Favicon：<code>/blog/source/favicon.ico</code>，建议的大小：<code>32px*32px</code>。</p>]]></content>
    
    <summary type="html">
    
      记录一次重构个人博客
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="生活" scheme="https://www.xiongtianci.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Hexo" scheme="https://www.xiongtianci.com/tags/Hexo/"/>
    
      <category term="博客" scheme="https://www.xiongtianci.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>hexo d命令报错：ERROR Deployer not found: git</title>
    <link href="https://www.xiongtianci.com/2019/05/15/hexo-d%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99%EF%BC%9AERROR-Deployer-not-found-git/"/>
    <id>https://www.xiongtianci.com/2019/05/15/hexo-d命令报错：ERROR-Deployer-not-found-git/</id>
    <published>2019-05-15T06:30:17.000Z</published>
    <updated>2019-06-11T07:28:09.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>使用<code>hexo d</code>或<code>hexo deploy</code>命令时报错：</p><blockquote><p>ERROR Deployer not found: git</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>安装<code>hexo-deployer-git</code>：</p><pre><code class="shell">npm install --save hexo-deployer-git</code></pre><p>在<code>_config.yml</code>配置中将<code>deploy</code>的<code>type</code>由<code>github</code>改为<code>git</code>：</p><pre><code class="yml">deploy  type: git  repository: git@github.com:YOUR_ID/YOUR_ID.github.io.git  branch: master</code></pre><blockquote><p>将其中的<code>YOUR_ID</code>改成你自己的GitHub账号</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://www.xiongtianci.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示</title>
    <link href="https://www.xiongtianci.com/2019/05/09/%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/"/>
    <id>https://www.xiongtianci.com/2019/05/09/彻底禁用Chrome的“请停用以开发者模式运行的扩展程序”提示/</id>
    <published>2019-05-09T12:17:52.000Z</published>
    <updated>2019-06-12T10:11:15.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Chrome勾选<code>开发者模式</code>安装插件后，每次启动都会弹出<code>请停用以开发者模式运行的扩展程序</code>的提示，最为一枚具有强迫症的程序员，这个绝对不能忍~~</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509200546595.png" alt="20190509200546595.png"></p><blockquote><p>Chrome版本：74.0.3729.131</p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方案一：反编译修改chrome-dll文件"><a href="#方案一：反编译修改chrome-dll文件" class="headerlink" title="方案一：反编译修改chrome.dll文件"></a>方案一：反编译修改chrome.dll文件</h2><h3 id="1-1-下载x64dbg"><a href="#1-1-下载x64dbg" class="headerlink" title="1.1 下载x64dbg"></a>1.1 下载x64dbg</h3><p>下载地址：<a href="https://github.com/x64dbg/x64dbg/releases" target="_blank" rel="noopener">https://github.com/x64dbg/x64dbg/releases</a><br>选择最新版本进行下载：<img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509200649190.png" alt="20190509200649190.png"><br>下载好之后，解压打开<code>release</code>，可以点击<code>x96dbg</code>选择<code>x64dbg</code>，也可以直接选择<code>x64</code>文件夹中的<code>x64dbg</code>，如果你是<code>32位</code>的系统还可以选择<code>x32dbg</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509200733234.png" alt="在这里插入图片描述"></p><h3 id="1-2-反编译chrome-dll"><a href="#1-2-反编译chrome-dll" class="headerlink" title="1.2 反编译chrome.dll"></a>1.2 反编译chrome.dll</h3><p>通过 <code>右键chrome图标</code> –&gt; <code>属性</code> –&gt; <code>打开文件的所在位置</code> 找到<code>chrome.dll</code>文件<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/2019050920091629.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509200924590.png" alt="在这里插入图片描述"><br>将<code>chrome.dll</code>文件拖入<code>x64.dbg</code>，会出现两个弹窗，其中黑色命令行弹窗不要关掉。如图：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201022963.png" alt="在这里插入图片描述">然后连续多次点击<code>运行到用户代码</code>按钮（我这里是连续点击6下），直至窗口标题处的模块变成<code>chrome.dll</code>：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201142813.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201224765.png" alt="在这里插入图片描述"><br>然后在主面板右键依次选择 <code>搜索</code>  –&gt; <code>当前模块</code> –&gt; <code>字符串</code>：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201307958.png" alt="在这里插入图片描述"><br>然后会打开一个搜索界面，等待模块搜索进度条<code>100%</code>也就是加载完毕：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201331276.png" alt="在这里插入图片描述"><br>在<code>搜索</code>框输入<code>ExtensionDeveloperModeWarning</code>进行搜索，会搜到2条结果，双击第1个，跳转到反汇编界面，往上翻一点，找到<code>cmp eax,2</code>（也有可能是 cmp eax,3 ）：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/201905092013524.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201416572.png" alt="在这里插入图片描述"><br>双击打开编辑页面，修改成<code>cmp eax,9</code>，然后点击<code>确定</code>，注意只需要<code>点击一次确定</code>即可，点击确定后它还是会继续弹出其它行的编辑界面，此时直接关闭对话框即可：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201440897.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201502878.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/20190509201514611.png" alt="在这里插入图片描述"><br>修改完之后<code>Ctrl+P</code>导出修改过的dll文件（点击修补文件按钮就是导出dll文件）：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190509-%E5%BD%BB%E5%BA%95%E7%A6%81%E7%94%A8Chrome%E7%9A%84%E2%80%9C%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E2%80%9D%E6%8F%90%E7%A4%BA/2019050920153199.png" alt="在这里插入图片描述"><br>然后把dll文件导出到任意其他位置，然后把原始<code>chrome.dll</code>文件==<strong>备份</strong>==（以免操作失误，否则只能重装Chrome），先关掉<code>x64dbg</code>，将刚刚导出的修补文件以<code>chrome.dll</code>命名然后覆盖原来的<code>chrome.dll</code>文件，重启Chrome，发现整个世界都清净了~~</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Chrome" scheme="https://www.xiongtianci.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>黑马乐优商城</title>
    <link href="https://www.xiongtianci.com/2019/05/07/%E9%BB%91%E9%A9%AC%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"/>
    <id>https://www.xiongtianci.com/2019/05/07/黑马乐优商城/</id>
    <published>2019-05-07T03:50:27.000Z</published>
    <updated>2019-06-11T07:29:00.935Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1xL-A9YPPMX6AzZjVPx-_vA" target="_blank ">乐优商城（19 天+资料+源码+笔记）</a><br>密码：<code>java</code></p><blockquote><p>本资源是博主在网上寻找乐优商城资料时，一位好人所赠</p><font color="hotpink">注意：找乐优商城资料的同学应该知道，乐优商城的视频有win和mac版本之分，此资源中的视频是mac版本。资料中的课件是完整的，但是与视频会有所出入</font></blockquote><blockquote><p><font color="red">PS：如果链接失效，可通过左侧联系博主</font></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="资源" scheme="https://www.xiongtianci.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="黑马" scheme="https://www.xiongtianci.com/tags/%E9%BB%91%E9%A9%AC/"/>
    
      <category term="乐优商城" scheme="https://www.xiongtianci.com/tags/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>navicat操作mysql的时候，如何输入null值？</title>
    <link href="https://www.xiongtianci.com/2019/05/05/navicat%E6%93%8D%E4%BD%9Cmysql%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5null%E5%80%BC%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2019/05/05/navicat操作mysql的时候，如何输入null值？/</id>
    <published>2019-05-05T03:47:07.000Z</published>
    <updated>2019-06-11T07:29:20.622Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190505-navicat%E6%93%8D%E4%BD%9Cmysql%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5null%E5%80%BC%EF%BC%9F/2019050511402255.png" alt="在这里插入图片描述"><br>使用<code>右键</code>或菜单栏中的<code>编辑</code>可以设置<code>NULL值</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190505-navicat%E6%93%8D%E4%BD%9Cmysql%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5null%E5%80%BC%EF%BC%9F/20190505114522257.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190505-navicat%E6%93%8D%E4%BD%9Cmysql%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5null%E5%80%BC%EF%BC%9F/20190505114636410.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mysql" scheme="https://www.xiongtianci.com/tags/Mysql/"/>
    
      <category term="Navicat" scheme="https://www.xiongtianci.com/tags/Navicat/"/>
    
  </entry>
  
  <entry>
    <title>POI导入Excel异常Cannot get a text value from a numeric cell</title>
    <link href="https://www.xiongtianci.com/2019/04/23/POI%E5%AF%BC%E5%85%A5Excel%E5%BC%82%E5%B8%B8Cannot-get-a-text-value-from-a-numeric-cell/"/>
    <id>https://www.xiongtianci.com/2019/04/23/POI导入Excel异常Cannot-get-a-text-value-from-a-numeric-cell/</id>
    <published>2019-04-23T09:37:03.000Z</published>
    <updated>2019-06-11T07:29:36.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><code>POI</code>操作<code>Excel</code>时偶尔会出现<code>Cannot get a text value from a numeric cell</code>的异常错误</p><blockquote><p>java.lang.IllegalStateException: Cannot get a text value from a numeric cell</p></blockquote><p>异常原因：Excel数据cell有不同的类型，当我们试图从一个数字类型的Cell读取出一个字符串并写入数据库时，就会出现Cannot get a text value from a numeric cell的异常错误。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>通过<code>setCellType()</code>设置<code>cell</code>类型，统一设置成String类型，然后再获取</p><pre><code class="java">Row row = sheet.getRow(i);for (int j = 0; j &lt; row.getPhysicalNumberOfCells(); j++) {    //     row.getCell(j).setCellType(Cell.CELL_TYPE_STRING);    //     String cellValue = row.getCell(j).getStringCellValue();    System.out.println(cellValue);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="POI" scheme="https://www.xiongtianci.com/tags/POI/"/>
    
      <category term="Excel" scheme="https://www.xiongtianci.com/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>电脑开机后弹窗提示下载名称是cc.png，来源是s3.amazonaws.com的文件</title>
    <link href="https://www.xiongtianci.com/2019/04/19/%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E5%90%8E%E5%BC%B9%E7%AA%97%E6%8F%90%E7%A4%BA%E4%B8%8B%E8%BD%BD%E5%90%8D%E7%A7%B0%E6%98%AFcc-png%EF%BC%8C%E6%9D%A5%E6%BA%90%E6%98%AFs3-amazonaws-com%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>https://www.xiongtianci.com/2019/04/19/电脑开机后弹窗提示下载名称是cc-png，来源是s3-amazonaws-com的文件/</id>
    <published>2019-04-19T01:27:45.000Z</published>
    <updated>2019-06-12T10:10:52.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>电脑开机之后会自动弹窗提示让下载一个名称是<code>cc.png</code>，来源是<code>s3.amazonaws.com</code>的文件<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190419-%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E5%90%8E%E5%BC%B9%E7%AA%97%E6%8F%90%E7%A4%BA%E4%B8%8B%E8%BD%BD%E5%90%8D%E7%A7%B0%E6%98%AFcc-png%EF%BC%8C%E6%9D%A5%E6%BA%90%E6%98%AFs3-amazonaws-com%E7%9A%84%E6%96%87%E4%BB%B6/20190419091835627.png" alt="在这里插入图片描述"></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>网上查询后，了解到是因为我最近下载了<code>Adobe Premiere</code>，而破解工具有瑕疵的原因。网上的解决方案是将<code>Adobe Creative Cloud</code>的默认开机启动改成<code>禁用</code>即可，下面是解决步骤：</p><blockquote><p>1、使用快捷键<code>Ctrl + Shift + Esc</code>打开<code>任务管理器</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190419-%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E5%90%8E%E5%BC%B9%E7%AA%97%E6%8F%90%E7%A4%BA%E4%B8%8B%E8%BD%BD%E5%90%8D%E7%A7%B0%E6%98%AFcc-png%EF%BC%8C%E6%9D%A5%E6%BA%90%E6%98%AFs3-amazonaws-com%E7%9A%84%E6%96%87%E4%BB%B6/20190419092336589.png" alt="在这里插入图片描述"><br>2、在<code>启动</code>中找到<code>Adobe Creative Cloud</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190419-%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E5%90%8E%E5%BC%B9%E7%AA%97%E6%8F%90%E7%A4%BA%E4%B8%8B%E8%BD%BD%E5%90%8D%E7%A7%B0%E6%98%AFcc-png%EF%BC%8C%E6%9D%A5%E6%BA%90%E6%98%AFs3-amazonaws-com%E7%9A%84%E6%96%87%E4%BB%B6/20190419092453410.png" alt="在这里插入图片描述"><br>3、右键，将其改为<code>禁用</code>即可<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190419-%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E5%90%8E%E5%BC%B9%E7%AA%97%E6%8F%90%E7%A4%BA%E4%B8%8B%E8%BD%BD%E5%90%8D%E7%A7%B0%E6%98%AFcc-png%EF%BC%8C%E6%9D%A5%E6%BA%90%E6%98%AFs3-amazonaws-com%E7%9A%84%E6%96%87%E4%BB%B6/20190419092604757.png" alt="在这里插入图片描述"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="cc.png" scheme="https://www.xiongtianci.com/tags/cc-png/"/>
    
  </entry>
  
  <entry>
    <title>IDEA运行SpringBoot项目控制台输出颜色高亮的日志</title>
    <link href="https://www.xiongtianci.com/2019/04/16/IDEA%E8%BF%90%E8%A1%8CSpringBoot%E9%A1%B9%E7%9B%AE%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2%E9%AB%98%E4%BA%AE%E7%9A%84%E6%97%A5%E5%BF%97/"/>
    <id>https://www.xiongtianci.com/2019/04/16/IDEA运行SpringBoot项目控制台输出颜色高亮的日志/</id>
    <published>2019-04-16T08:43:18.000Z</published>
    <updated>2019-06-11T07:30:58.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有时IDEA运行SpringBoot项目，控制台<code>Console</code>输出的日志颜色为白色的</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>配置启动类<code>application</code>的相关参数，添加：<code>-Dspring.output.ansi.enabled=ALWAYS</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190416-IDEA%E8%BF%90%E8%A1%8CSpringBoot%E9%A1%B9%E7%9B%AE%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2%E9%AB%98%E4%BA%AE%E7%9A%84%E6%97%A5%E5%BF%97/20190416160105555.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="IDEA" scheme="https://www.xiongtianci.com/tags/IDEA/"/>
    
      <category term="SpringBoot" scheme="https://www.xiongtianci.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>win10日语输入法切换平片假名</title>
    <link href="https://www.xiongtianci.com/2019/04/16/win10%E6%97%A5%E8%AF%AD%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2%E5%B9%B3%E7%89%87%E5%81%87%E5%90%8D/"/>
    <id>https://www.xiongtianci.com/2019/04/16/win10日语输入法切换平片假名/</id>
    <published>2019-04-16T07:45:21.000Z</published>
    <updated>2019-06-11T07:30:41.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-切换平假名"><a href="#1-切换平假名" class="headerlink" title="1.切换平假名"></a>1.切换平假名</h3><p>使用<code>Ctrl + CapsLock</code>切换至<code>平假名输入</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190416-win10%E6%97%A5%E8%AF%AD%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2%E5%B9%B3%E7%89%87%E5%81%87%E5%90%8D/20190416154213323.png" alt="在这里插入图片描述"></p><h3 id="2-切换片假名"><a href="#2-切换片假名" class="headerlink" title="2.切换片假名"></a>2.切换片假名</h3><p>使用<code>Alt + CapsLock</code>切换至<code>片假名输入</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190416-win10%E6%97%A5%E8%AF%AD%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2%E5%B9%B3%E7%89%87%E5%81%87%E5%90%8D/20190416154232520.png" alt="在这里插入图片描述"></p><h3 id="3-切换英文输入"><a href="#3-切换英文输入" class="headerlink" title="3.切换英文输入"></a>3.切换英文输入</h3><p>使用<code>Shift + CapsLock</code>或<code>Alt + ~</code>切换至<code>英文输入</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190416-win10%E6%97%A5%E8%AF%AD%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2%E5%B9%B3%E7%89%87%E5%81%87%E5%90%8D/20190416154245677.png" alt="在这里插入图片描述"></p><h3 id="4-语言切换"><a href="#4-语言切换" class="headerlink" title="4.语言切换"></a>4.语言切换</h3><p>使用<code>win徽标键 + 空格</code>在不同的输入法中切换<br>使用<code>Alt + Shift</code>在输入语言之间切换</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="生活" scheme="https://www.xiongtianci.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="win10" scheme="https://www.xiongtianci.com/tags/win10/"/>
    
      <category term="日语" scheme="https://www.xiongtianci.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Chrome历史版本下载</title>
    <link href="https://www.xiongtianci.com/2019/04/01/Chrome%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/"/>
    <id>https://www.xiongtianci.com/2019/04/01/Chrome历史版本下载/</id>
    <published>2019-04-01T02:23:02.000Z</published>
    <updated>2019-06-12T10:10:30.091Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.chromedownloads.net/chrome64linux/" target="_blank" rel="noopener">Chrome历史版本</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Chrome" scheme="https://www.xiongtianci.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>使用Twitter的Snowflake设置分布式自增长ID</title>
    <link href="https://www.xiongtianci.com/2019/03/29/%E4%BD%BF%E7%94%A8Twitter%E7%9A%84Snowflake%E8%AE%BE%E7%BD%AE%E5%88%86%E5%B8%83%E5%BC%8F%E8%87%AA%E5%A2%9E%E9%95%BFID/"/>
    <id>https://www.xiongtianci.com/2019/03/29/使用Twitter的Snowflake设置分布式自增长ID/</id>
    <published>2019-03-29T06:44:44.000Z</published>
    <updated>2019-06-11T07:31:33.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>十次方项目工具类<code>IdWorker.java</code><br>描述：使用<code>Twitter</code>的<code>Snowflake</code>雪花算法设置分布式自增长ID</p></blockquote><pre><code class="java">import java.lang.management.ManagementFactory;import java.net.InetAddress;import java.net.NetworkInterface;/** * &lt;p&gt;名称：IdWorker.java&lt;/p&gt; * &lt;p&gt;描述：分布式自增长ID&lt;/p&gt; * &lt;pre&gt; *     Twitter的 Snowflake　JAVA实现方案 * &lt;/pre&gt; * 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用： * 1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000 * 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间， * 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识）， * 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。 * 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， * 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 * &lt;p&gt; * 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加)) * * @author Polim */public class IdWorker {    // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动）    private final static long twepoch = 1288834974657L;    // 机器标识位数    private final static long workerIdBits = 5L;    // 数据中心标识位数    private final static long datacenterIdBits = 5L;    // 机器ID最大值    private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);    // 数据中心ID最大值    private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);    // 毫秒内自增位    private final static long sequenceBits = 12L;    // 机器ID偏左移12位    private final static long workerIdShift = sequenceBits;    // 数据中心ID左移17位    private final static long datacenterIdShift = sequenceBits + workerIdBits;    // 时间毫秒左移22位    private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;    private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);    /* 上次生产id时间戳 */    private static long lastTimestamp = -1L;    // 0，并发控制    private long sequence = 0L;    private final long workerId;    // 数据标识id部分    private final long datacenterId;    public IdWorker() {        this.datacenterId = getDatacenterId(maxDatacenterId);        this.workerId = getMaxWorkerId(datacenterId, maxWorkerId);    }    /**     * @param workerId     工作机器ID     * @param datacenterId 序列号     */    public IdWorker(long workerId, long datacenterId) {        if (workerId &gt; maxWorkerId || workerId &lt; 0) {            throw new IllegalArgumentException(String.format(&quot;worker Id can&#39;t be greater than %d or less than 0&quot;, maxWorkerId));        }        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) {            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#39;t be greater than %d or less than 0&quot;, maxDatacenterId));        }        this.workerId = workerId;        this.datacenterId = datacenterId;    }    /**     * 获取下一个ID     *     * @return     */    public synchronized long nextId() {        long timestamp = timeGen();        if (timestamp &lt; lastTimestamp) {            throw new RuntimeException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));        }        if (lastTimestamp == timestamp) {            // 当前毫秒内，则+1            sequence = (sequence + 1) &amp; sequenceMask;            if (sequence == 0) {                // 当前毫秒内计数满了，则等待下一秒                timestamp = tilNextMillis(lastTimestamp);            }        } else {            sequence = 0L;        }        lastTimestamp = timestamp;        // ID偏移组合生成最终的ID，并返回ID        long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift)                | (datacenterId &lt;&lt; datacenterIdShift)                | (workerId &lt;&lt; workerIdShift) | sequence;        return nextId;    }    private long tilNextMillis(final long lastTimestamp) {        long timestamp = this.timeGen();        while (timestamp &lt;= lastTimestamp) {            timestamp = this.timeGen();        }        return timestamp;    }    private long timeGen() {        return System.currentTimeMillis();    }    /**     * &lt;p&gt;     * 获取 maxWorkerId     * &lt;/p&gt;     */    protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) {        StringBuffer mpid = new StringBuffer();        mpid.append(datacenterId);        String name = ManagementFactory.getRuntimeMXBean().getName();        if (!name.isEmpty()) {            /*             * GET jvmPid             */            mpid.append(name.split(&quot;@&quot;)[0]);        }        /*         * MAC + PID 的 hashcode 获取16个低位         */        return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1);    }    /**     * &lt;p&gt;     * 数据标识id部分     * &lt;/p&gt;     */    protected static long getDatacenterId(long maxDatacenterId) {        long id = 0L;        try {            InetAddress ip = InetAddress.getLocalHost();            NetworkInterface network = NetworkInterface.getByInetAddress(ip);            if (network == null) {                id = 1L;            } else {                byte[] mac = network.getHardwareAddress();                id = ((0x000000FF &amp; (long) mac[mac.length - 1])                        | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6;                id = id % (maxDatacenterId + 1);            }        } catch (Exception e) {            System.out.println(&quot; getDatacenterId: &quot; + e.getMessage());        }        return id;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Snowflake" scheme="https://www.xiongtianci.com/tags/Snowflake/"/>
    
      <category term="自增ID" scheme="https://www.xiongtianci.com/tags/%E8%87%AA%E5%A2%9EID/"/>
    
  </entry>
  
  <entry>
    <title>bat脚本中以管理员权限执行命令</title>
    <link href="https://www.xiongtianci.com/2019/03/29/bat%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.xiongtianci.com/2019/03/29/bat脚本中以管理员权限执行命令/</id>
    <published>2019-03-29T06:30:05.000Z</published>
    <updated>2019-06-11T07:31:58.371Z</updated>
    
    <content type="html"><![CDATA[<p>在bat脚本文件<code>第一行</code>加上下面命令：</p><blockquote><p>%1 mshta vbscript:CreateObject(“Shell.Application”).ShellExecute(“cmd.exe”,”/c %~s0 ::”,””,”runas”,1)(window.close)&amp;&amp;exit</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bat" scheme="https://www.xiongtianci.com/tags/bat/"/>
    
      <category term="脚本" scheme="https://www.xiongtianci.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>win10开机运行脚本文件</title>
    <link href="https://www.xiongtianci.com/2019/03/29/win10%E5%BC%80%E6%9C%BA%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/"/>
    <id>https://www.xiongtianci.com/2019/03/29/win10开机运行脚本文件/</id>
    <published>2019-03-29T06:24:21.000Z</published>
    <updated>2019-06-11T07:31:46.156Z</updated>
    
    <content type="html"><![CDATA[<h6 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h6><blockquote><p>有个bat脚本，希望电脑开机时自动执行此脚本</p></blockquote><h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>1、打开电脑目录：<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190329-win10%E5%BC%80%E6%9C%BA%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/20190329142339956.png" alt="在这里插入图片描述"><br>2、将需要开机启动就执行的脚本放入此目录下<br>3、重启电脑</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="win10" scheme="https://www.xiongtianci.com/tags/win10/"/>
    
      <category term="脚本" scheme="https://www.xiongtianci.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC注解@CrossOrigin解决跨域问题</title>
    <link href="https://www.xiongtianci.com/2019/03/27/SpringMVC%E6%B3%A8%E8%A7%A3@CrossOrigin%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://www.xiongtianci.com/2019/03/27/SpringMVC注解@CrossOrigin解决跨域问题/</id>
    <published>2019-03-27T01:51:27.000Z</published>
    <updated>2019-06-11T07:49:22.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一般的，只要网站的【协议名protocol】、【主机host】、【端口号port】这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用<br>跨域：浏览同源策略的造成，是浏览器对JavaScript施加的安全限制<br>CORS是一种可以解决跨域问题的技术</p></blockquote><h3 id="SprinMVC通过-CrossOrigin注解解决跨域"><a href="#SprinMVC通过-CrossOrigin注解解决跨域" class="headerlink" title="SprinMVC通过@CrossOrigin注解解决跨域"></a>SprinMVC通过@CrossOrigin注解解决跨域</h3><blockquote><p>在Spring MVC<code>4.2</code>之后推出了<code>@CrossOrigin</code>注解来解决跨域问题，而在4.2之前我们都是通过定义注册<code>过滤器</code>的方式来解决跨域问题的</p></blockquote><p><strong>@CrossOrigin的参数：</strong><br>1、origins：允许可访问的域列表；*表示可以是任何来源<br>2、maxAge：准备响应前的缓存持续的最大时间（单位：秒）</p><p><strong>@CrossOrigin使用在Controller层：</strong><br>1、类上，此类中所有方法启用跨域支持</p><pre><code class="java">// 开启跨域支持@CrossOrigin@RestController@RequestMapping(&quot;/user&quot;)public class UserController {}</code></pre><p>2、方法上，仅此方法启用跨域支持</p><pre><code class="java">// 开启跨域支持@CrossOrigin@RequestMapping(value = &quot;/findAll&quot;, method = RequestMethod.GET)public List&lt;User&gt; findAll(){    return userService.findAll();}</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1、注解失效问题：此时Controlle的方法上<code>@RequestMapping</code>注解中需要声明<code>请求方式</code>即增加<code>method=RequestMethod.XXX</code></p><p>2、添加注解后session失效问题：此时对的ajax请求中需要添加<code>xhrFields:{withCredentials:true}</code>（每个ajax中都需要加此属性，以保证session一致）</p><pre><code class="js">$.ajax({    type: &quot;post&quot;,    url: &#39;/user/login&#39;,    xhrFields: {withCredentials: true},    data: {        username: username,        password: password    },    success: function (msg) {        console.log(&#39;登录成功&#39;);    },    error: function (msg) {        console.log(&#39;请求报错！&#39;);    }})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringMVC" scheme="https://www.xiongtianci.com/tags/SpringMVC/"/>
    
      <category term="CrossOrigin" scheme="https://www.xiongtianci.com/tags/CrossOrigin/"/>
    
      <category term="跨域" scheme="https://www.xiongtianci.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>win系统查看连接过的WIFI密码</title>
    <link href="https://www.xiongtianci.com/2019/03/26/win%E7%B3%BB%E7%BB%9F%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WIFI%E5%AF%86%E7%A0%81/"/>
    <id>https://www.xiongtianci.com/2019/03/26/win系统查看连接过的WIFI密码/</id>
    <published>2019-03-26T10:22:36.000Z</published>
    <updated>2019-06-11T07:32:36.025Z</updated>
    
    <content type="html"><![CDATA[<h6 id="1-win-R，输入cmd回车打开cmd窗口"><a href="#1-win-R，输入cmd回车打开cmd窗口" class="headerlink" title="1. win+R，输入cmd回车打开cmd窗口"></a>1. <code>win+R</code>，输入<code>cmd</code>回车打开cmd窗口</h6><h6 id="2-输入下面命令显示电脑连接过的所有WIFI名："><a href="#2-输入下面命令显示电脑连接过的所有WIFI名：" class="headerlink" title="2. 输入下面命令显示电脑连接过的所有WIFI名："></a>2. 输入下面命令显示电脑连接过的所有WIFI名：</h6><pre><code class="command">netsh wlan show profiles</code></pre><blockquote><p>在cmd中鼠标右键是粘贴</p></blockquote><h6 id="3-输入下面命令查看WIFI密码："><a href="#3-输入下面命令查看WIFI密码：" class="headerlink" title="3. 输入下面命令查看WIFI密码："></a>3. 输入下面命令查看WIFI密码：</h6><pre><code>netsh wlan show profile name=&quot;WIFI名&quot; key=clear</code></pre><blockquote><p>“WIFI名称”：使用英文状态下的双引号</p></blockquote><p>在显示的内容中找到<code>安全设置</code>下的<code>关键内容</code>，即为WIFI密码<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190326-win%E7%B3%BB%E7%BB%9F%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WIFI%E5%AF%86%E7%A0%81/20190326180330559.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="win10" scheme="https://www.xiongtianci.com/tags/win10/"/>
    
      <category term="WIFI密码" scheme="https://www.xiongtianci.com/tags/WIFI%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Swagger异常：java.lang.NumberFormatException: For input string: </title>
    <link href="https://www.xiongtianci.com/2019/03/25/Swagger%E5%BC%82%E5%B8%B8%EF%BC%9Ajava-lang-NumberFormatException-For-input-string/"/>
    <id>https://www.xiongtianci.com/2019/03/25/Swagger异常：java-lang-NumberFormatException-For-input-string/</id>
    <published>2019-03-25T06:36:14.000Z</published>
    <updated>2019-06-11T07:33:05.459Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>项目整合<code>Swagger</code>，访问<code>Swagger</code>首页时后台抛出下面异常：</p><blockquote><p>i.s.m.p.AbstractSerializableParameter    : Illegal DefaultValue null for parameter type integer<br>java.lang.NumberFormatException: For input string: “”</p></blockquote><p>原因好像是说<code>swagger2</code>本身引用的<code>swagger-models-1.5.20.jar</code>有<code>bug</code><br><br></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>导入下面的<code>maven</code>坐标：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.9.2&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;io.swagger&lt;/groupId&gt;            &lt;artifactId&gt;swagger-models&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.swagger&lt;/groupId&gt;    &lt;artifactId&gt;swagger-models&lt;/artifactId&gt;    &lt;version&gt;1.5.21&lt;/version&gt;&lt;/dependency&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Swagger" scheme="https://www.xiongtianci.com/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>上传图片415异常：&quot;Content type &#39;multipart/form-data;&#39; .... not supported&quot;</title>
    <link href="https://www.xiongtianci.com/2019/03/25/%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87415%E5%BC%82%E5%B8%B8%EF%BC%9AContent%20type%20&#39;multipartform-data;&#39;%20~not%20supported/"/>
    <id>https://www.xiongtianci.com/2019/03/25/上传图片415异常：Content type &#39;multipartform-data;&#39; ~not supported/</id>
    <published>2019-03-25T02:23:04.000Z</published>
    <updated>2019-06-11T07:32:49.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>上传图片时报错：<br>Content type ‘multipart/form-data;boundary=—-WebKitFormBoundarypOpfYxCGU6Q4sciA;charset=UTF-8’ not supported</p></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190325-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87415%E5%BC%82%E5%B8%B8%EF%BC%9AContent%20type%20&#39;multipartform-data%3B&#39;%20~not%20supported/20190325101824685.png" alt="在这里插入图片描述"><br>Controller层：</p><pre><code class="java">@PostMapping(path = &quot;/uploadRotationImg&quot;)public ResponseEntity&lt;String&gt; uploadRotationImg(@RequestParam(&quot;photos&quot;) MultipartFile file, @RequestBody ImgRotation imgRotation) {    try {        // 进行上传操作        return imgRotationService.uploadRotationImg(file, imgRotation);    } catch (Exception e) {        // 上传失败        e.printStackTrace();        return new ResponseEntity&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);    }}</code></pre><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>去掉<code>@RequestBody</code>注解就行了</p><pre><code class="java">@PostMapping(path = &quot;/uploadRotationImg&quot;)public ResponseEntity&lt;String&gt; uploadRotationImg(@RequestParam(&quot;photos&quot;) MultipartFile file, ImgRotation imgRotation) {    try {        // 进行上传操作        return imgRotationService.uploadRotationImg(file, imgRotation);    } catch (Exception e) {        // 上传失败        e.printStackTrace();        return new ResponseEntity&lt;&gt;(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="415" scheme="https://www.xiongtianci.com/tags/415/"/>
    
  </entry>
  
  <entry>
    <title>@RequestParam和@RequestBody</title>
    <link href="https://www.xiongtianci.com/2019/03/22/@RequestParam%E5%92%8C@RequestBody/"/>
    <id>https://www.xiongtianci.com/2019/03/22/@RequestParam和@RequestBody/</id>
    <published>2019-03-22T07:51:52.000Z</published>
    <updated>2019-06-11T07:46:52.899Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-RequestParam"><a href="#一、-RequestParam" class="headerlink" title="一、@RequestParam"></a>一、@RequestParam</h3><blockquote><p>GET和POST请求传的参数会自动转换赋值到<code>@RequestParam</code>所注解的变量上</p></blockquote><pre><code class="html">&lt;form action=&quot;/requestParamDemo&quot; method=&quot;get&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    用户昵称：&lt;input type=&quot;text&quot; name=&quot;usernick&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre><pre><code class="java">@RequestMapping(value = &quot;/requestParamDemo&quot;, method = RequestMethod.GET)public void requestParamDemo(@RequestParam(value = &quot;username&quot;) String userName, @RequestParam(value = &quot;usernick&quot;) String userNick) {    System.out.println(&quot;username: &quot; + userName);    System.out.println(&quot;usernick: &quot; + userNick);}</code></pre><h3 id="二、-RequestBody"><a href="#二、-RequestBody" class="headerlink" title="二、@RequestBody"></a>二、@RequestBody</h3><blockquote><p><code>@RequestBody</code>注解可以接收<code>json</code>格式的数据，并将其转换成对应的数据类型</p></blockquote><pre><code class="json">// 通过ajax发送json数据{    &quot;id&quot;:1,    &quot;username&quot;:&quot;jack&quot;,    &quot;password&quot;:&quot;1234&quot;}</code></pre><pre><code class="java">@RequestMapping(value=&quot;/requestBodyDemo&quot;, method = RequestMethod.POST)public void requestBodyDemo(@RequestBody User user){    System.out.println(&quot;id: &quot; + user.getId());    System.out.println(&quot;name: &quot; + user.getName());    System.out.println(&quot;password: &quot; + user.getPassword());}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="RequestParam" scheme="https://www.xiongtianci.com/tags/RequestParam/"/>
    
      <category term="RequestBody" scheme="https://www.xiongtianci.com/tags/RequestBody/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中datetime类型的字段与JavaBean对应的类型</title>
    <link href="https://www.xiongtianci.com/2019/03/22/MySQL%E4%B8%ADdatetime%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8EJavaBean%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.xiongtianci.com/2019/03/22/MySQL中datetime类型的字段与JavaBean对应的类型/</id>
    <published>2019-03-22T03:50:18.000Z</published>
    <updated>2019-06-11T07:33:25.952Z</updated>
    
    <content type="html"><![CDATA[<h6 id="MySQL数据库中时间格式为datetime类型的字段："><a href="#MySQL数据库中时间格式为datetime类型的字段：" class="headerlink" title="MySQL数据库中时间格式为datetime类型的字段："></a>MySQL数据库中时间格式为<code>datetime</code>类型的字段：</h6><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190322-MySQL%E4%B8%ADdatetime%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8EJavaBean%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B/20190322113812741.png" alt="在这里插入图片描述"></p><h6 id="JavaBean中对应字段的类型："><a href="#JavaBean中对应字段的类型：" class="headerlink" title="JavaBean中对应字段的类型："></a>JavaBean中对应字段的类型：</h6><pre><code class="java">import com.fasterxml.jackson.annotation.JsonFormat;import org.springframework.format.annotation.DateTimeFormat;// 如果到的是sql下的包(java.sql.Date)，get操作时封装的结果为null、put/post操作时会抛415异常import java.util.Date;@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone=&quot;GMT+8&quot;)@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)@ApiModelProperty(&quot;创建时间，格式：yyyy-MM-dd HH:mm:ss&quot;)private Date ctime;</code></pre><p>or</p><pre><code class="java">import com.fasterxml.jackson.annotation.JsonFormat;import org.springframework.format.annotation.DateTimeFormat;@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone=&quot;GMT+8&quot;)@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)@ApiModelProperty(&quot;创建时间，格式：yyyy-MM-dd HH:mm:ss&quot;)private String ctime;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
      <category term="datetime" scheme="https://www.xiongtianci.com/tags/datetime/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中MyBatis属性映射之开启驼峰命名</title>
    <link href="https://www.xiongtianci.com/2019/03/20/SpringBoot%E4%B8%ADMyBatis%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84%E4%B9%8B%E5%BC%80%E5%90%AF%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/"/>
    <id>https://www.xiongtianci.com/2019/03/20/SpringBoot中MyBatis属性映射之开启驼峰命名/</id>
    <published>2019-03-20T06:43:26.000Z</published>
    <updated>2019-06-11T07:34:15.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天使用<code>SpringBoot</code>整合<code>MyBatis</code>开发时，发现从数据库中查询到的结果封装到<code>javabean</code>中，只要表中有<strong>下划线的字段</strong>，就会出现<code>null</code>值</p></blockquote><p>MyBatis默认是属性名和数据库字段名一一对应的，即<br>数据库表列：user_name<br>实体类属性：user_name</p><p>但是java中一般使用驼峰命名<br>数据库表列：user_name<br>实体类属性：userName</p><p>在<code>SpringBoot</code>中，可以通过设置<code>map-underscore-to-camel-case</code>属性为<code>true</code>来开启驼峰功能：</p><pre><code class="yml">mybatis:  configuration:    map-underscore-to-camel-case: true  # 开启驼峰命名</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MyBatis" scheme="https://www.xiongtianci.com/tags/MyBatis/"/>
    
      <category term="SpringBoot" scheme="https://www.xiongtianci.com/tags/SpringBoot/"/>
    
      <category term="驼峰命名" scheme="https://www.xiongtianci.com/tags/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>原生js修改textarea的值</title>
    <link href="https://www.xiongtianci.com/2019/03/19/%E5%8E%9F%E7%94%9Fjs%E4%BF%AE%E6%94%B9textarea%E7%9A%84%E5%80%BC/"/>
    <id>https://www.xiongtianci.com/2019/03/19/原生js修改textarea的值/</id>
    <published>2019-03-19T07:56:17.000Z</published>
    <updated>2019-06-11T07:34:32.209Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="js">// 设置textarea的值document.getElementById(&quot;goodstext_id&quot;).value = &quot;值&quot;;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="https://www.xiongtianci.com/tags/js/"/>
    
      <category term="textarea" scheme="https://www.xiongtianci.com/tags/textarea/"/>
    
  </entry>
  
  <entry>
    <title>js获取ModelAndView中的数据</title>
    <link href="https://www.xiongtianci.com/2019/03/19/js%E8%8E%B7%E5%8F%96ModelAndView%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>https://www.xiongtianci.com/2019/03/19/js获取ModelAndView中的数据/</id>
    <published>2019-03-19T07:47:05.000Z</published>
    <updated>2019-06-12T10:09:59.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>后台封装：</strong></p><pre><code class="java">@GetMapping(&quot;/findById/{id}&quot;)public ModelAndView findById(@PathVariable(&quot;id&quot;) Integer id) {    // 通过id查询商品    Goods dbgoods = goodsService.findById(id);    // 创建ModelAndView对象    ModelAndView mv = new ModelAndView();    // 跳转到goods_editor.html页面    mv.setViewName(&quot;/goods/goods_editor&quot;);    // 封装查询结果    mv.addObject(&quot;dbgoods&quot;,dbgoods);    //    return mv;}</code></pre><p><br></p><p><strong>前端获取：</strong></p><pre><code class="html">&lt;script th:inline=&quot;javascript&quot;&gt; // 需要添加 th:inline 才能访问 model 中的属性    window.onload = function () {        console.log(&quot;页面加载完成&quot;);        // 获取ModelAndView中的dbgoods对象        var dbgoods = [[${dbgoods}]];        // 打印        console.log(dbgoods);    }&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="https://www.xiongtianci.com/tags/js/"/>
    
      <category term="ModelAndView" scheme="https://www.xiongtianci.com/tags/ModelAndView/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot使用 thymeleaf+@RestController 跳转页面</title>
    <link href="https://www.xiongtianci.com/2019/03/19/SpringBoot%E4%BD%BF%E7%94%A8-thymeleaf-RestController-%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2/"/>
    <id>https://www.xiongtianci.com/2019/03/19/SpringBoot使用-thymeleaf-RestController-跳转页面/</id>
    <published>2019-03-19T02:19:37.000Z</published>
    <updated>2019-06-11T07:49:58.417Z</updated>
    
    <content type="html"><![CDATA[<p><code>thymeleaf</code>推荐使用<code>@Controller</code>进行页面跳转<br>如果用<code>@RestController</code>，则可以通过<code>ModelAndView</code>进行页面跳转<br>eg</p><pre><code class="java">/** * 跳转到goods_editor.html页面 * @return */@GetMapping(&quot;/goodsEditor&quot;)public ModelAndView goodsEditor(){    ModelAndView mv = new ModelAndView();    mv.setViewName(&quot;/goods/goods_editor&quot;);    return mv;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://www.xiongtianci.com/tags/SpringBoot/"/>
    
      <category term="thymeleaf" scheme="https://www.xiongtianci.com/tags/thymeleaf/"/>
    
      <category term="RestController" scheme="https://www.xiongtianci.com/tags/RestController/"/>
    
  </entry>
  
  <entry>
    <title>org.xml.sax.SAXParseException: 元素类型 &quot;link&quot; 必须由匹配的结束标记 &quot;&lt;/link&gt;&quot; 终止</title>
    <link href="https://www.xiongtianci.com/2019/03/19/org-xml-sax-SAXParseException-%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8Blink%E5%BF%85%E9%A1%BB%E7%94%B1%E5%8C%B9%E9%85%8D%E7%9A%84%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0link%E7%BB%88%E6%AD%A2/"/>
    <id>https://www.xiongtianci.com/2019/03/19/org-xml-sax-SAXParseException-元素类型link必须由匹配的结束标记link终止/</id>
    <published>2019-03-19T02:02:05.000Z</published>
    <updated>2019-06-11T07:35:46.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><code>SpringBoot</code>使用<code>thymeleaf</code>模板引擎时报错：</p><blockquote><p>org.xml.sax.SAXParseException: 元素类型 “link” 必须由匹配的结束标记 “&lt;&#47;link&gt;” 终止</p></blockquote><p>or</p><blockquote><p>org.xml.sax.SAXParseException: 元素类型 “meta” 必须由匹配的结束标记 “&lt;&#47;meta&gt;” 终止</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>解决方法是在<code>pom.xml</code>文件中指定具体的<code>thymeleaf</code>版本具体如下</p><pre><code class="xml">&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;!--添加下面两项指定thymeleaf的版本--&gt;    &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt;    &lt;thymeleaf-layout-dialect.version&gt;2.0.5&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>通过MyBatis向MySQL中插入数据时中文乱码</title>
    <link href="https://www.xiongtianci.com/2019/03/18/%E9%80%9A%E8%BF%87MyBatis%E5%90%91MySQL%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>https://www.xiongtianci.com/2019/03/18/通过MyBatis向MySQL中插入数据时中文乱码/</id>
    <published>2019-03-18T06:20:50.000Z</published>
    <updated>2019-06-11T07:36:29.883Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong><br>通过MyBatis向MySQL中插入或更新操作时，中文会显示成<code>???</code></p><p><strong>解决：</strong><br>在配置文件<code>application.yml</code>中连接数据库的地址<code>url</code>后面加上<code>characterEncoding=utf8</code>即可</p><pre><code class="yml">spring:  application:    name: server # 服务名称  datasource:    driverClassName: com.mysql.jdbc.Driver    url: jdbc:mysql://localhost:3306/db?characterEncoding=utf8    username: root # 数据库账号    password: root # 数据库密码</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="MyBatis" scheme="https://www.xiongtianci.com/tags/MyBatis/"/>
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
      <category term="乱码" scheme="https://www.xiongtianci.com/tags/%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>A component required a bean of type &#39;com.renqijie.dao.SellerMapper&#39; that could not be found.</title>
    <link href="https://www.xiongtianci.com/2019/03/14/A-component-required-a-bean-of-type-com-renqijie-dao-SellerMapper-that-could-not-be-found/"/>
    <id>https://www.xiongtianci.com/2019/03/14/A-component-required-a-bean-of-type-com-renqijie-dao-SellerMapper-that-could-not-be-found/</id>
    <published>2019-03-14T09:53:11.000Z</published>
    <updated>2019-06-11T07:36:59.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异常：<br>Description:<br>A component required a bean of type ‘com.renqijie.dao.SellerMapper’ that could not be found.</p></blockquote><p><strong>原因：</strong><br>dao层接口<code>SellerMapper</code>未加注解<a href="mailto:`@org.apache.ibatis.annotations.Mapper" target="_blank" rel="noopener">`@org.apache.ibatis.annotations.Mapper</a>`</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON</title>
    <link href="https://www.xiongtianci.com/2019/03/14/org-springframework-http-converter-HttpMessageNotWritableException-Could-not-write-JSON/"/>
    <id>https://www.xiongtianci.com/2019/03/14/org-springframework-http-converter-HttpMessageNotWritableException-Could-not-write-JSON/</id>
    <published>2019-03-14T03:52:15.000Z</published>
    <updated>2019-06-11T07:36:47.113Z</updated>
    
    <content type="html"><![CDATA[<p>记一次踩坑经历：<br><code>Resolved [org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: (was java.lang.NullPointerException); nested exception is com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: com.renqijie.pojo.vo.IndexBean[&quot;images&quot;]-&gt;java.util.ArrayList[0]-&gt;com.renqijie.pojo.Image[&quot;id&quot;])]</code></p><blockquote><p>原因：<br>JavaBean类<code>Image</code>中有一个属性类型刚开始设置成<code>int</code>类型，生成<code>getter/setter</code>方法后，又将其改成了<code>Integer</code>类型，结果就出现了上述情况</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>小程序用户表wx_user设计</title>
    <link href="https://www.xiongtianci.com/2019/03/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%A8%E6%88%B7%E8%A1%A8wx-user%E8%AE%BE%E8%AE%A1/"/>
    <id>https://www.xiongtianci.com/2019/03/13/小程序用户表wx-user设计/</id>
    <published>2019-03-13T02:07:05.000Z</published>
    <updated>2019-06-11T07:37:13.360Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="sql">CREATE TABLE `wx_user` (  `id` int(20) NOT NULL AUTO_INCREMENT,  `openid` varchar(28) DEFAULT NULL COMMENT &#39;小程序用户的openid&#39;,  `nickname` varchar(100) DEFAULT NULL COMMENT &#39;用户头像&#39;,  `avatarurl` varchar(100) DEFAULT NULL COMMENT &#39;用户头像&#39;,  `gender` tinyint(1) DEFAULT NULL COMMENT &#39;性别  0-男、1-女&#39;,  `country` varchar(100) DEFAULT NULL COMMENT &#39;所在国家&#39;,  `province` varchar(100) DEFAULT NULL COMMENT &#39;省份&#39;,  `city` varchar(100) DEFAULT NULL COMMENT &#39;城市&#39;,  `language` varchar(100) DEFAULT NULL COMMENT &#39;语种&#39;,  `ctime` datetime DEFAULT NULL COMMENT &#39;创建/注册时间&#39;,  `mobile` varchar(50) DEFAULT NULL COMMENT &#39;手机号码&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;小程序用户表&#39;;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="小程序" scheme="https://www.xiongtianci.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>查看CentOS版本信息</title>
    <link href="https://www.xiongtianci.com/2019/03/12/%E6%9F%A5%E7%9C%8BCentOS%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/"/>
    <id>https://www.xiongtianci.com/2019/03/12/查看CentOS版本信息/</id>
    <published>2019-03-12T02:37:43.000Z</published>
    <updated>2019-06-11T07:37:23.572Z</updated>
    
    <content type="html"><![CDATA[<p>指令：<code>cat /etc/redhat-release</code></p><pre><code class="shell">CentOS Linux release 7.5.1804 (Core) </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CentOS" scheme="https://www.xiongtianci.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Java操作MongoDB之mongodb-driver</title>
    <link href="https://www.xiongtianci.com/2019/02/27/Java%E6%93%8D%E4%BD%9CMongoDB%E4%B9%8Bmongodb-driver/"/>
    <id>https://www.xiongtianci.com/2019/02/27/Java操作MongoDB之mongodb-driver/</id>
    <published>2019-02-27T13:11:45.000Z</published>
    <updated>2019-06-12T10:04:03.155Z</updated>
    
    <content type="html"><![CDATA[<p><code>mongodb-driver</code>是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。<br>通过一个入门的案例来了解<code>mongodb-driver</code>的基本使用：</p><h3 id="1、查询全部记录"><a href="#1、查询全部记录" class="headerlink" title="1、查询全部记录"></a>1、查询全部记录</h3><h4 id="1-1、创建工程mongoDemo，引入依赖"><a href="#1-1、创建工程mongoDemo，引入依赖" class="headerlink" title="1.1、创建工程mongoDemo，引入依赖"></a>1.1、创建工程mongoDemo，引入依赖</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;    &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;    &lt;version&gt;3.6.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="1-2、创建测试类"><a href="#1-2、创建测试类" class="headerlink" title="1.2、创建测试类"></a>1.2、创建测试类</h4><pre><code class="java">public class MongoDemo1 {    public static void main(String[] args) {        // 创建连接        MongoClient client = new MongoClient(&quot;192.168.206.128&quot;);        // 打开数据库spitdb        MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;);        // 获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        // 查询记录，获取文档集        FindIterable&lt;Document&gt; documents = spit.find();        // 循环遍历        for (Document document : documents) {            System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;));            System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;));            System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;));        }        // 关闭连接        client.close();    }}</code></pre><h3 id="2、条件查询"><a href="#2、条件查询" class="headerlink" title="2、条件查询"></a>2、条件查询</h3><p><code>BasicDBObject</code>对象：表示一个具体的记录，BasicDBObject实现了DBObject，是<code>key/value</code>的数据结构，用起来和HashMap是基本一致的。</p><h4 id="2-1、查询userid为1013的记录"><a href="#2-1、查询userid为1013的记录" class="headerlink" title="2.1、查询userid为1013的记录"></a>2.1、查询userid为1013的记录</h4><pre><code class="java">public class MongoDemo1 {    public static void main(String[] args) {        // 创建连接        MongoClient client = new MongoClient(&quot;192.168.206.128&quot;);        // 打开数据库spitdb        MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;);        // 获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        // 构建查询条件，通过userid进行查询        BasicDBObject bson = new BasicDBObject(&quot;userid&quot;, &quot;1013&quot;);        // 通过userid查询记录获取文档集        FindIterable&lt;Document&gt; documents = spit.find(bson);        // 循环遍历        for (Document document : documents) {            System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;));            System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;));            System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;));        }        // 关闭连接        client.close();    }}</code></pre><h4 id="2-2、查询浏览量大于1000的记录"><a href="#2-2、查询浏览量大于1000的记录" class="headerlink" title="2.2、查询浏览量大于1000的记录"></a>2.2、查询浏览量大于1000的记录</h4><pre><code class="java">public class MongoDemo2 {    public static void main(String[] args) {        // 创建连接        MongoClient client = new MongoClient(&quot;192.168.206.128&quot;);        // 打开数据库spitdb        MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;);        // 获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        // 构建查询条件，查询visits大于1000的结果        BasicDBObject bson = new BasicDBObject(&quot;visits&quot;, new BasicDBObject(&quot;$gt&quot;, 1000));        // 通过userid查询记录获取文档集        FindIterable&lt;Document&gt; documents = spit.find(bson);        // 循环遍历        for (Document document : documents) {            System.out.println(&quot;内容：&quot; + document.getString(&quot;content&quot;));            System.out.println(&quot;用户ID：&quot; + document.getString(&quot;userid&quot;));            System.out.println(&quot;浏览量：&quot; + document.getInteger(&quot;visits&quot;));        }        // 关闭连接        client.close();    }}</code></pre><h3 id="3、插入数据"><a href="#3、插入数据" class="headerlink" title="3、插入数据"></a>3、插入数据</h3><pre><code class="java">public class MongoDemo3 {    public static void main(String[] args) {        // 创建连接        MongoClient client = new MongoClient(&quot;192.168.206.128&quot;);        // 打开数据库spitdb        MongoDatabase spitdb = client.getDatabase(&quot;spitdb&quot;);        // 获取集合        MongoCollection&lt;Document&gt; spit = spitdb.getCollection(&quot;spit&quot;);        // 准备数据        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;content&quot;, &quot;我要吐槽&quot;);        map.put(&quot;userid&quot;, &quot;9999&quot;);        map.put(&quot;visits&quot;, 123);        map.put(&quot;publishtime&quot;, new Date());        //        Document document = new Document(map);        // 插入一条数据        spit.insertOne(document);        // 关闭连接        client.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MongoDB" scheme="https://www.xiongtianci.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>使用SpringCache进行缓存数据库查询</title>
    <link href="https://www.xiongtianci.com/2019/02/26/%E4%BD%BF%E7%94%A8SpringCache%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2/"/>
    <id>https://www.xiongtianci.com/2019/02/26/使用SpringCache进行缓存数据库查询/</id>
    <published>2019-02-26T10:14:18.000Z</published>
    <updated>2019-06-12T10:03:42.414Z</updated>
    
    <content type="html"><![CDATA[<p>1、在SpringBoot的启动类上添加注解<code>@EnableCaching</code>，开启SpringCache缓存支持</p><pre><code class="java">@SpringBootApplication// 开启SpringCache缓存支持@EnableCachingpublic class GatheringApplication {    public static void main(String[] args) {        SpringApplication.run(GatheringApplication.class, args);    }}</code></pre><p>2、在service的方法上添加对应的注解</p><pre><code class="java">/** * 根据ID查询 * * @param id * @return */// 使用SpringCache进行缓存数据库查询@Cacheable(value = &quot;gathering&quot;, key = &quot;#id&quot;)public Gathering findById(String id) {    return gatheringDao.findById(id).get();}</code></pre><pre><code class="java">/** * 修改 * * @param gathering */// 修改数据库数据后需要删除redis中的缓存@CacheEvict(value = &quot;gathering&quot;, key = &quot;#gathering.id&quot;)public void update(Gathering gathering) {    gatheringDao.save(gathering);}/** * 删除 * * @param id */// 删除数据库数据后需要删除redis中的缓存@CacheEvict(value = &quot;gathering&quot;, key = &quot;#id&quot;)public void deleteById(String id) {    gatheringDao.deleteById(id);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="缓存" scheme="https://www.xiongtianci.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="SpringCache" scheme="https://www.xiongtianci.com/tags/SpringCache/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL:WARN: Establishing SSL connection without server&#39;s identity verification is not recommended.</title>
    <link href="https://www.xiongtianci.com/2019/02/26/MYSQL-WARN-Establishing-SSL-connection-without-server-s-identity-verification-is-not-recommended/"/>
    <id>https://www.xiongtianci.com/2019/02/26/MYSQL-WARN-Establishing-SSL-connection-without-server-s-identity-verification-is-not-recommended/</id>
    <published>2019-02-26T09:46:40.000Z</published>
    <updated>2019-06-12T08:39:09.819Z</updated>
    
    <content type="html"><![CDATA[<p>连接MySQL数据库时抛出警告：<br><code>Tue Feb 26 17:38:27 CST 2019 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</code><br>这是Mysql数据库的SSL连接问题，提示警告不建议使用没有带服务器身份验证的SSL连接，是在MYSQL5.5.45+, 5.6.26+ and 5.7.6+版本中才有的这个问题</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>在配置文件application.yml中连接数据库的<code>url</code>后添加<code>useSSL=false</code>即可</p><pre><code class="yml">spring  datasource:      driverClassName: com.mysql.jdbc.Driver    url: jdbc:mysql://192.168.206.128:3306/tensquare_article?characterEncoding=utf8&amp;useSSL=false    username: root    password: ....</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SpringDataRedis常用方法</title>
    <link href="https://www.xiongtianci.com/2019/02/26/SpringDataRedis%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://www.xiongtianci.com/2019/02/26/SpringDataRedis常用方法/</id>
    <published>2019-02-26T09:30:15.000Z</published>
    <updated>2019-06-12T08:37:40.976Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="java">// 向redis里存入数据和设置缓存时间stringRedisTemplate.opsForValue().set(&quot;test&quot;, &quot;100&quot;, 60 * 10, TimeUnit.SECONDS);// 根据key获取缓存中的valstringRedisTemplate.opsForValue().get(&quot;test&quot;);// val做-1操作stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(-1);// val +1stringRedisTemplate.boundValueOps(&quot;test&quot;).increment(1);// 根据key获取过期时间stringRedisTemplate.getExpire(&quot;test&quot;);// 根据key获取过期时间并换算成指定单位stringRedisTemplate.getExpire(&quot;test&quot;, TimeUnit.SECONDS);// 根据key删除缓存stringRedisTemplate.delete(&quot;test&quot;);// 检查key是否存在，返回boolean值stringRedisTemplate.hasKey(&quot;546545&quot;);// 设置过期时间stringRedisTemplate.expire(&quot;red_123&quot;, 1000, TimeUnit.MILLISECONDS);// 向指定key中存放set集合stringRedisTemplate.opsForSet().add(&quot;red_123&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;);// 根据key查看集合中是否存在指定数据stringRedisTemplate.opsForSet().isMember(&quot;red_123&quot;, &quot;1&quot;);// 根据key获取set集合stringRedisTemplate.opsForSet().members(&quot;red_123&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringDataRedis" scheme="https://www.xiongtianci.com/tags/SpringDataRedis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis进行缓存数据库查询</title>
    <link href="https://www.xiongtianci.com/2019/02/26/SpringBoot%E6%95%B4%E5%90%88Redis%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2/"/>
    <id>https://www.xiongtianci.com/2019/02/26/SpringBoot整合Redis进行缓存数据库查询/</id>
    <published>2019-02-26T08:30:10.000Z</published>
    <updated>2019-06-12T08:38:29.664Z</updated>
    
    <content type="html"><![CDATA[<p>1、导入redis的启动器</p><pre><code class="xml">&lt;!--redis启动器--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2、在yml配置文件中配置redis连接信息</p><pre><code class="yml">spring:  redis:    host: 192.168.206.128</code></pre><p>3、在service中通过RedisTemplate操作redis，使用redis进行缓存数据库查询</p><pre><code class="java">/** * 根据ID查询 * * @param id * @return */public Article findById(String id) {    // 从redis缓存中提取数据    Article article = (Article) redisTemplate.opsForValue().get(&quot;article_&quot; + id);    // 如果缓存中没有，则从数据库中查询并放入缓存中    if(article == null){        article = articleDao.findById(id).get();        redisTemplate.opsForValue().set(&quot;article_&quot; + id, article);    }    // 返回从redis缓存中获得的数据    return article;}</code></pre><p>4、对数据库进行删除或修改后删除redis中的缓存</p><pre><code class="java">/** * 修改 * * @param article */public void update(Article article) {    // 删除redis中的缓存    redisTemplate.delete(&quot;article_&quot; + article.getId());    // 修改操作    articleDao.save(article);}/** * 删除 * * @param id */public void deleteById(String id) {    // 删除redis缓存数据    redisTemplate.delete(&quot;article_&quot; + id);    // 删除操作    articleDao.deleteById(id);}</code></pre><p>5、缓存过期处理</p><pre><code class="java">// 设置缓存过期时间为1天redisTemplate.opsForValue().set(&quot;article_&quot; + id, article, 1, TimeUnit.DAYS);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://www.xiongtianci.com/tags/SpringBoot/"/>
    
      <category term="Redis" scheme="https://www.xiongtianci.com/tags/Redis/"/>
    
      <category term="缓存" scheme="https://www.xiongtianci.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Data JPA报错：javax.persistence.TransactionRequiredException: Executing an update/delete query</title>
    <link href="https://www.xiongtianci.com/2019/02/26/%E4%BD%BF%E7%94%A8Spring-Data-JPA%E6%8A%A5%E9%94%99%EF%BC%9Ajavax-persistence-TransactionRequiredException-Executing-an-update-delete-query/"/>
    <id>https://www.xiongtianci.com/2019/02/26/使用Spring-Data-JPA报错：javax-persistence-TransactionRequiredException-Executing-an-update-delete-query/</id>
    <published>2019-02-26T06:18:54.000Z</published>
    <updated>2019-06-12T10:03:05.883Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Caused by: javax.persistence.TransactionRequiredException: Executing an update/delete query    at org.hibernate.query.internal.AbstractProducedQuery.executeUpdate(AbstractProducedQuery.java:1496)</code></pre><p>1、 报错原因：SpringData JPA事务导致的异常<br>2、解决：在Service层添加注解<code>@Transactional</code>进行事务管理<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190226-%E4%BD%BF%E7%94%A8Spring-Data-JPA%E6%8A%A5%E9%94%99%EF%BC%9Ajavax-persistence-TransactionRequiredException-Executing-an-update-delete-query/20190226115939325.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="JPA" scheme="https://www.xiongtianci.com/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>服务器重启后，Docker安装的mysql怎么重启？</title>
    <link href="https://www.xiongtianci.com/2019/02/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%90%AF%E5%90%8E%EF%BC%8CDocker%E5%AE%89%E8%A3%85%E7%9A%84mysql%E6%80%8E%E4%B9%88%E9%87%8D%E5%90%AF%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2019/02/26/服务器重启后，Docker安装的mysql怎么重启？/</id>
    <published>2019-02-26T00:51:59.000Z</published>
    <updated>2019-06-12T10:01:41.148Z</updated>
    
    <content type="html"><![CDATA[<p>1、重启Docker</p><pre><code class="shell">[root@pinyoyougou-docker ~]# sudo systemctl start docker</code></pre><p>2、列出Docker中创建的容器</p><pre><code class="shell">[root@pinyoyougou-docker ~]# docker ps -a</code></pre><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190226-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%90%AF%E5%90%8E%EF%BC%8CDocker%E5%AE%89%E8%A3%85%E7%9A%84mysql%E6%80%8E%E4%B9%88%E9%87%8D%E5%90%AF%EF%BC%9F/2019022608493286.png" alt="在这里插入图片描述"></p><p>3、启动mysql</p><pre><code class="shell">[root@pinyoyougou-docker ~]# docker restart 3815a718c8b5</code></pre><p>4、查看是否启动成功</p><pre><code class="shell">[root@pinyoyougou-docker ~]# docker ps</code></pre><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190226-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%90%AF%E5%90%8E%EF%BC%8CDocker%E5%AE%89%E8%A3%85%E7%9A%84mysql%E6%80%8E%E4%B9%88%E9%87%8D%E5%90%AF%EF%BC%9F/20190226085103514.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://www.xiongtianci.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>IDEA开启Run Dashboard的配置</title>
    <link href="https://www.xiongtianci.com/2019/02/25/IDEA%E5%BC%80%E5%90%AFRun%20Dashboard%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.xiongtianci.com/2019/02/25/IDEA开启Run Dashboard的配置/</id>
    <published>2019-02-25T01:52:08.000Z</published>
    <updated>2019-06-12T08:44:48.567Z</updated>
    
    <content type="html"><![CDATA[<p>Run Dashboard面板：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190225-IDEA%E5%BC%80%E5%90%AFRun%20Dashboard%E7%9A%84%E9%85%8D%E7%BD%AE/20190225094527956.png" alt="在这里插入图片描述"><br>IDEA升级到 2017.3.1 版本后，发现找不到Run Dashboard面板了。通过下面步骤教你找回Run Dashboard：</p><h5 id="1-找到-idea文件下的workspace-xml，通过Ctrl-F搜索RunDashboard"><a href="#1-找到-idea文件下的workspace-xml，通过Ctrl-F搜索RunDashboard" class="headerlink" title="1. 找到.idea文件下的workspace.xml，通过Ctrl+F搜索RunDashboard"></a>1. 找到<code>.idea</code>文件下的<code>workspace.xml</code>，通过<code>Ctrl+F</code>搜索<code>RunDashboard</code></h5><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190225-IDEA%E5%BC%80%E5%90%AFRun%20Dashboard%E7%9A%84%E9%85%8D%E7%BD%AE/20190225094806232.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190225-IDEA%E5%BC%80%E5%90%AFRun%20Dashboard%E7%9A%84%E9%85%8D%E7%BD%AE/20190225094912778.png" alt="在这里插入图片描述"></p><h5 id="2-加入如下配置，重启服务，Run-Dashboard就自动就弹出来了"><a href="#2-加入如下配置，重启服务，Run-Dashboard就自动就弹出来了" class="headerlink" title="2. 加入如下配置，重启服务，Run Dashboard就自动就弹出来了"></a>2. 加入如下配置，重启服务，Run Dashboard就自动就弹出来了</h5><pre><code class="xml">&lt;option name=&quot;configurationTypes&quot;&gt;    &lt;set&gt;        &lt;option value=&quot;SpringBootApplicationConfigurationType&quot;/&gt;    &lt;/set&gt;&lt;/option&gt;</code></pre><h5 id="3-最终配置如下：最终配置如下："><a href="#3-最终配置如下：最终配置如下：" class="headerlink" title="3. 最终配置如下：最终配置如下："></a>3. 最终配置如下：最终配置如下：</h5><pre><code class="xml">&lt;component name=&quot;RunDashboard&quot;&gt;  &lt;option name=&quot;configurationTypes&quot;&gt;    &lt;set&gt;      &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;    &lt;/set&gt;  &lt;/option&gt;  &lt;option name=&quot;ruleStates&quot;&gt;    &lt;list&gt;      &lt;RuleState&gt;        &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt;      &lt;/RuleState&gt;      &lt;RuleState&gt;        &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt;      &lt;/RuleState&gt;    &lt;/list&gt;  &lt;/option&gt;  &lt;option name=&quot;contentProportion&quot; value=&quot;0.20013662&quot; /&gt;&lt;/component&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="IDEA" scheme="https://www.xiongtianci.com/tags/IDEA/"/>
    
      <category term="工具" scheme="https://www.xiongtianci.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="RunDashboard" scheme="https://www.xiongtianci.com/tags/RunDashboard/"/>
    
  </entry>
  
  <entry>
    <title>Java中List集合去重的几种方式</title>
    <link href="https://www.xiongtianci.com/2019/02/19/Java%E4%B8%ADList%E9%9B%86%E5%90%88%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.xiongtianci.com/2019/02/19/Java中List集合去重的几种方式/</id>
    <published>2019-02-19T00:52:35.000Z</published>
    <updated>2019-06-12T08:45:32.849Z</updated>
    
    <content type="html"><![CDATA[<p>准备数据：</p><pre><code class="java">// 准备数据List&lt;String&gt; list = new ArrayList();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);list.add(&quot;c&quot;);list.add(&quot;b&quot;);list.add(&quot;a&quot;);</code></pre><h3 id="1-利用HashSet去重"><a href="#1-利用HashSet去重" class="headerlink" title="1. 利用HashSet去重"></a>1. 利用HashSet去重</h3><pre><code class="java">// 利用list中的元素创建HashSet集合，此时set中进行了去重操作HashSet set = new HashSet(list);// 清空list集合list.clear();// 将去重后的元素重新添加到list中list.addAll(set);</code></pre><h3 id="2-通过List的contains-方法去重"><a href="#2-通过List的contains-方法去重" class="headerlink" title="2. 通过List的contains()方法去重"></a>2. 通过List的contains()方法去重</h3><pre><code class="java">// 创建一个新的list集合，用于存储去重后的元素List listTemp = new ArrayList();// 遍历list集合for (int i = 0; i &lt; list.size(); i++) {    // 判断listTemp集合中是否包含list中的元素    if (!listTemp.contains(list.get(i))) {        // 将未包含的元素添加进listTemp集合中        listTemp.add(list.get(i));    }}</code></pre><h3 id="3-循环List进行去重"><a href="#3-循环List进行去重" class="headerlink" title="3. 循环List进行去重"></a>3. 循环List进行去重</h3><pre><code class="java">// 从list中索引为0开始往后遍历for (int i = 0; i &lt; list.size() - 1; i++) {    // 从list中索引为 list.size()-1 开始往前遍历    for (int j = list.size() - 1; j &gt; i; j--) {        // 进行比较        if (list.get(j).equals(list.get(i))) {            // 去重            list.remove(j);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="List" scheme="https://www.xiongtianci.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>关闭迅雷更新到新版本的提示</title>
    <link href="https://www.xiongtianci.com/2019/01/17/%E5%85%B3%E9%97%AD%E8%BF%85%E9%9B%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%8F%90%E7%A4%BA/"/>
    <id>https://www.xiongtianci.com/2019/01/17/关闭迅雷更新到新版本的提示/</id>
    <published>2019-01-17T00:36:39.000Z</published>
    <updated>2019-06-12T08:49:12.141Z</updated>
    
    <content type="html"><![CDATA[<p>每次打开迅雷都会自动检查是否是最新版本，如果不是最新版本，迅雷会一直重复弹窗弹出<strong>更新到新版本</strong>的提示：<img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190117-%E5%85%B3%E9%97%AD%E8%BF%85%E9%9B%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%8F%90%E7%A4%BA/20190117081555322.png" alt="在这里插入图片描述"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>简介：迅雷提示升级是因为每次迅雷主程序启动时都会同时启动一个叫<code>XLLiveUD.exe</code>的程序，这个程序会检查更新，所以如果不想让他检查更新，就只需要把他替换掉就可以了（因为如果删除它，每次迅雷启动时都会弹出一个错误对话框，提示找不到文件<code>XLLiveUD.exe</code>）</p><hr><ol><li><p>进入迅雷安装目录，找到<code>XLLiveUD.exe</code>( 可直接在迅雷安装目录中搜索这个文件 )，将其删除。这个就是自动升级的程序，但是删除之后下次开启迅雷会提示该文件丢失。<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190117-%E5%85%B3%E9%97%AD%E8%BF%85%E9%9B%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%8F%90%E7%A4%BA/20190117082613245.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190117-%E5%85%B3%E9%97%AD%E8%BF%85%E9%9B%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%8F%90%E7%A4%BA/20190117082638473.png" alt="在这里插入图片描述"></p></li><li><p>在同一个目录找到迅雷执行程序文件<code>Thunder.exe</code>，这个是就是迅雷桌面快捷方式指到的程序也就是迅雷开启程序。然后复制拷贝<code>Thunder.exe</code>副本，然后将副本文件名更改为迅雷更新执行程序名：<strong>XLLiveUD.exe</strong><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190117-%E5%85%B3%E9%97%AD%E8%BF%85%E9%9B%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%8F%90%E7%A4%BA/20190117082959128.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190117-%E5%85%B3%E9%97%AD%E8%BF%85%E9%9B%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%8F%90%E7%A4%BA/20190117083307505.gif" alt="在这里插入图片描述"></p></li><li><p>当迅雷程序调用检查更新的执行文件时，实际上相当于重复点击打开迅雷，而迅雷本身不允许重复打开。这样既不会报错也不会造成重复弹屏的问题。从而算是比较完美的解决了<strong>关闭迅雷更新到新版本提示</strong>的问题(❁´◡`❁)<em>✲ﾟ</em></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="迅雷" scheme="https://www.xiongtianci.com/tags/%E8%BF%85%E9%9B%B7/"/>
    
  </entry>
  
  <entry>
    <title>XMind8 破解激活教程（win系统）</title>
    <link href="https://www.xiongtianci.com/2019/01/12/XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/"/>
    <id>https://www.xiongtianci.com/2019/01/12/XMind8-破解激活教程（win系统）/</id>
    <published>2019-01-12T05:08:50.000Z</published>
    <updated>2019-06-12T08:48:50.548Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h3><p>链接：<a href="https://pan.baidu.com/s/1yA9OkiPwkImDlnIS_NoxUg" target="_Blank">XMind8+破解补丁</a><br>密码：<code>6666</code></p><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><p>安装好XMind8后，接下来进行破解</p><ol><li><p>将<strong>破解补丁</strong>中的<code>XMindCrack.jar</code>拷贝到一个目录下( 注意：这个位置要是一个不会移动的位置，我就复制在XMind的安装目录下 )，如图 ：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190112-XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20190112113708377.png" alt="在这里插入图片描述"></p></li><li><p>修改XMind的配置文件<br>打开XMind的配置文件<code>XMind.ini</code>，增加内容：<code>-javaagent:刚刚XMindCrack.jar放置的位置</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190112-XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20190112113935256.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190112-XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20190112114234667.png" alt="在这里插入图片描述"></p></li><li><p>修改电脑的<code>hosts</code>文件，切断Xmind访问网络<br><code>hosts</code>文件目录：<code>C:\Windows\System32\drivers\etc</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190112-XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20190112114632247.png" alt="在这里插入图片描述"><br>添加内容：<code>0.0.0.0 www.xmind.net</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190112-XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20190112114747686.png" alt="在这里插入图片描述"></p></li><li><p>添加序列号<br>启动XMind，在<strong>帮助</strong>里面找到<strong>序列号</strong>，填写序列号<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190112-XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20190112115023565.png" alt="在这里插入图片描述"><br>邮箱任意，将<strong>破解补丁</strong>内<strong>序列号.txt</strong>文件中的内容复制到<strong>序列号</strong>中，点击验证<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190112-XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20190112115122390.png" alt="在这里插入图片描述"><br>出现下面内容证明激活成功了<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190112-XMind8-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/2019011211523843.png" alt="在这里插入图片描述"><br>ヾ(๑╹◡╹)ﾉ”ヾ(●´∀｀●) </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="XMind" scheme="https://www.xiongtianci.com/tags/XMind/"/>
    
  </entry>
  
  <entry>
    <title>连接Oracle报错 ORA-12638: 身份证明检索失败</title>
    <link href="https://www.xiongtianci.com/2019/01/08/%E8%BF%9E%E6%8E%A5Oracle%E6%8A%A5%E9%94%99-ORA-12638-%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%E6%A3%80%E7%B4%A2%E5%A4%B1%E8%B4%A5/"/>
    <id>https://www.xiongtianci.com/2019/01/08/连接Oracle报错-ORA-12638-身份证明检索失败/</id>
    <published>2019-01-08T01:26:18.000Z</published>
    <updated>2019-06-12T08:50:29.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>连接Oracle数据库时报错：<code>ORA-12638: 身份证明检索失败</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190108-%E8%BF%9E%E6%8E%A5Oracle%E6%8A%A5%E9%94%99-ORA-12638-%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%E6%A3%80%E7%B4%A2%E5%A4%B1%E8%B4%A5/20190108091444890.png" alt="在这里插入图片描述"></p><pre><code class="cmd">C:\Users\***&gt;sqlplus scott/tiger@192.168.56.103:1521/orclSQL*Plus: Release 10.2.0.1.0 - Production on 星期二 1月 8 09:13:18 2019Copyright (c) 1982, 2005, Oracle.  All rights reserved.ERROR:ORA-12638: 身份证明检索失败</code></pre><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>将oracle安装路径<code>oracle\product\10.2.0\db_1\NETWORK\ADMIN\sqlnet.ora</code> 文件修改一下<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20190108-%E8%BF%9E%E6%8E%A5Oracle%E6%8A%A5%E9%94%99-ORA-12638-%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%E6%A3%80%E7%B4%A2%E5%A4%B1%E8%B4%A5/20190108091632740.png" alt="在这里插入图片描述"><br>把文件中的：<br><code>SQLNET.AUTHENTICATION_SERVICES= (NTS)</code><br>修改为：<br><code>SQLNET.AUTHENTICATION_SERVICES= (BEQ,NONE)</code></p><p><strong>修改前：</strong></p><pre><code># sqlnet.ora Network Configuration File: C:\oracle\product\10.2.0\db_1\network\admin\sqlnet.ora# Generated by Oracle configuration tools.# This file is actually generated by netca. But if customers choose to # install &quot;Software Only&quot;, this file wont exist and without the native # authentication, they will not be able to connect to the database on NT.SQLNET.AUTHENTICATION_SERVICES= (NTS)NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)</code></pre><p><strong>修改后：</strong></p><pre><code># sqlnet.ora Network Configuration File: C:\oracle\product\10.2.0\db_1\network\admin\sqlnet.ora# Generated by Oracle configuration tools.# This file is actually generated by netca. But if customers choose to # install &quot;Software Only&quot;, this file wont exist and without the native # authentication, they will not be able to connect to the database on NT.SQLNET.AUTHENTICATION_SERVICES= (BEQ,NONE)NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Oracle" scheme="https://www.xiongtianci.com/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>try和finally中都有return语句，执行哪一个return？</title>
    <link href="https://www.xiongtianci.com/2019/01/07/try%E5%92%8Cfinally%E4%B8%AD%E9%83%BD%E6%9C%89return%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%93%AA%E4%B8%80%E4%B8%AAreturn%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2019/01/07/try和finally中都有return语句，执行哪一个return？/</id>
    <published>2019-01-07T09:51:07.000Z</published>
    <updated>2019-06-12T08:51:32.859Z</updated>
    
    <content type="html"><![CDATA[<p>try 中的 return 语句调用的函数先于 finally 中调用的函数执行，也就是说 try 中的 return 语句先执行，finally 语句后执行，但try中的 return 并不是让函数马上返回结果，而是 return 语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行 finally 语句后才真正开始返回。但此时会出现两种情况：<br>① 如果finally中也有return，则会直接返回finally中的return结果，并终止程序，函数栈中的return不会被完成<br>② 如果finally中没有return，则在执行完finally中的代码之后，会将函数栈中保存的try return的内容返回并终止程序</p><p>注意：</p><blockquote><p>1、不管有没有出现异常，finally块中代码都会执行<br>2、当try和catch中有return时，finally仍然会执行<br>3、finally是在try中return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>try{ return }finally{}中的return</title>
    <link href="https://www.xiongtianci.com/2019/01/07/try%7Breturn%7Dfinally%7B%7D%E4%B8%AD%E7%9A%84return/"/>
    <id>https://www.xiongtianci.com/2019/01/07/try{return}finally{}中的return/</id>
    <published>2019-01-07T08:57:57.000Z</published>
    <updated>2019-06-12T08:52:04.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>try 中的 return 语句调用的函数先于 finally 中调用的函数执行，也就是说 return 语句先执行，finally 语句后执行，但 return 并不是让函数马上返回结果，而是 return 语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回结果，它要执行 finally 语句后才真正开始返回，，但此时finally块中的代码已经影响不了return返回的值了</p></blockquote><pre><code class="java">public class Demo {    public static void main(String[] args) {        System.out.println(num());    }    public static int num(){        int i = 0;        try {            i = 1;            return i;        }catch (Exception e){        }finally {            i = 2;        }        return i;    }}</code></pre><pre><code>打印结果：1</code></pre><p>返回的是基本数据类型，直接返回值<br><br></p><pre><code class="java">public class Demo {    public static void main(String[] args) {        System.out.println(num().getI());    }    public static Test num() {        Test t = new Test();        try {            t.setI(1);            return t;        } catch (Exception e) {        } finally {            t.setI(2);        }        return t;    }}class Test{    private int i ;    public int getI() {        return i;    }    public void setI(int i) {        this.i = i;    }}</code></pre><pre><code>打印结果：2</code></pre><p>返回的是对象的引用</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？</title>
    <link href="https://www.xiongtianci.com/2019/01/07/%E4%BB%80%E4%B9%88%E6%98%AFJava%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Java%E2%80%9C%E8%A2%AB%E7%A7%B0%E4%BD%9C%E6%98%AF%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%9D%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2019/01/07/什么是Java虚拟机？为什么Java“被称作是平台无关的编程语言”？/</id>
    <published>2019-01-07T07:43:22.000Z</published>
    <updated>2019-06-12T08:50:57.416Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、什么是java虚拟机？"><a href="#一、什么是java虚拟机？" class="headerlink" title="一、什么是java虚拟机？"></a>一、什么是java虚拟机？</h4><p>java虚拟机(Java Virtual Machine 即 JVM)是执行字节码文件(.class)的虚拟机进程。<br>java源程序(.java)被编译器编译成字节码文件(.class)。然后字节码文件，将由java虚拟机，解释成机器码(不同平台的机器码不同)。利用机器码操作硬件和操作系统</p><h4 id="二、为什么java被称为平台无关的编程语言？"><a href="#二、为什么java被称为平台无关的编程语言？" class="headerlink" title="二、为什么java被称为平台无关的编程语言？"></a>二、为什么java被称为平台无关的编程语言？</h4><p>因为不同的平台装有不同的JVM，它们能够将相同的.class文件，解释成不同平台所需要的机器码。正是因为有JVM的存在，java被称为平台无关的编程语言</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="虚拟机" scheme="https://www.xiongtianci.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎</title>
    <link href="https://www.xiongtianci.com/2019/01/07/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://www.xiongtianci.com/2019/01/07/MySQL存储引擎/</id>
    <published>2019-01-07T06:47:36.000Z</published>
    <updated>2019-06-12T08:52:50.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h1><p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。例如，如果你在研究大量的临时数据，你也许需要使用内存MySQL存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。这些不同的技术以及配套的相关功能在 MySQL中被称作<strong>存储引擎</strong>(也称作表类型)。<br>MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活性。</p><h1 id="MySQL存储引擎种类"><a href="#MySQL存储引擎种类" class="headerlink" title="MySQL存储引擎种类"></a>MySQL存储引擎种类</h1><table border="1" style="text-align: center;"><br>    <thead><br>        <tr><br>            <th>存储引擎</th><br>            <th>特点</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td><font color="hotpink">InnoDB</font></td><br>            <td>5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢</td><br>        </tr><br>        <tr><br>            <td><font color="hotpink">MyISAM</font></td><br>            <td>高速引擎，拥有较高的插入，查询速度，但不支持事务</td><br>        </tr><br>        <tr><br>            <td>Memory</td><br>            <td>内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失</td><br>        </tr><br>        <tr><br>            <td>Falcon</td><br>            <td>一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者</td><br>        </tr><br>        <tr><br>            <td>Archive</td><br>            <td>将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作</td><br>        </tr><br>        <tr><br>            <td>CSV</td><br>            <td>CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换)</td><br>        </tr><br>    </tbody><br></table>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如何控制多线程执行顺序</title>
    <link href="https://www.xiongtianci.com/2019/01/05/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://www.xiongtianci.com/2019/01/05/如何控制多线程执行顺序/</id>
    <published>2019-01-05T03:03:06.000Z</published>
    <updated>2019-06-12T08:53:35.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><pre><code class="java">public class Test02 {    static Thread thread1 = new Thread(new Runnable() {        @Override        public void run() {            System.out.println(&quot;thread1&quot;);        }    });    static Thread thread2 = new Thread(new Runnable() {        @Override        public void run() {            System.out.println(&quot;thread2&quot;);        }    });    static Thread thread3 = new Thread(new Runnable() {        @Override        public void run() {            System.out.println(&quot;thread3&quot;);        }    });    public static void main(String[] args) {        thread1.start();        thread2.start();        thread3.start();    }}</code></pre><p>上面的代码执行结果：</p><pre><code class="java">// 线程执行顺序是随机的thread1thread3thread2</code></pre><blockquote><p>原因：start()方法只是让子线程处于就绪状态，最终执行状态是不可控的</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：使用join控制多线程执行顺序"><a href="#方案一：使用join控制多线程执行顺序" class="headerlink" title="方案一：使用join控制多线程执行顺序"></a>方案一：使用join控制多线程执行顺序</h3><blockquote><p>join()：让主线程等待子线程结束以后才能继续运行</p></blockquote><pre><code class="java">public static void main(String[] args) throws Exception {    thread1.start();    thread1.join();  // 让主线程放弃cpu执行权，让给子线程执行    thread2.start();    thread2.join();    thread3.start();}</code></pre><p>结果：</p><pre><code>thread1thread2thread3</code></pre><p>join方法的原理就是调用相应线程的<code>wait</code>方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll( 调用了JVM底层lock.notify_all(thread)方法来唤醒 )方法唤醒A线程，从而达到同步的目的</p><p>jion()源码：</p><pre><code class="java">public final synchronized void join(long millis)throws InterruptedException {    long base = System.currentTimeMillis();    long now = 0;    if (millis &lt; 0) {        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);    }    if (millis == 0) {        while (isAlive()) {            wait(0);        }    } else {        while (isAlive()) {            long delay = millis - now;            if (delay &lt;= 0) {                break;            }            wait(delay);            now = System.currentTimeMillis() - base;        }    }}</code></pre><p>最终是调用object的wait方法</p><pre><code class="java">public final native void wait(long timeout) throws InterruptedException;</code></pre><p>join()的调用位于main Thread的main()中，所以这里当然就是阻塞main Thread了。所以thread1.join()调用后，main Thread会阻塞起来。</p><h3 id="方案二：利用单线程化线程池-newSingleThreadExecutor-串行执行所有任务"><a href="#方案二：利用单线程化线程池-newSingleThreadExecutor-串行执行所有任务" class="headerlink" title="方案二：利用单线程化线程池(newSingleThreadExecutor)串行执行所有任务"></a>方案二：利用单线程化线程池(newSingleThreadExecutor)串行执行所有任务</h3><p>利用并发包里的<code>Excutors</code>的<code>newSingleThreadExecuto</code>产生一个单线程的线程池，而这个线程池的底层原理就是一个先进先出（FIFO）的队列。代码中<code>executor.submit</code>依次添加了123线程，按照FIFO的特性，执行顺序也就是123的执行结果，从而保证了执行顺序</p><pre><code class="java">static ExecutorService executorService = Executors.newSingleThreadExecutor();public static void main(String[] args) throws Exception {    executorService.submit(thread1);    executorService.submit(thread2);    executorService.submit(thread3);    executorService.shutdown();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="多线程" scheme="https://www.xiongtianci.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么 1000==1000 返回为false，而 100==100 会返回为true</title>
    <link href="https://www.xiongtianci.com/2019/01/05/%E4%B8%BA%E4%BB%80%E4%B9%881000==1000%E8%BF%94%E5%9B%9E%E4%B8%BAfalse%EF%BC%8C%E8%80%8C100==100%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%BAtrue/"/>
    <id>https://www.xiongtianci.com/2019/01/05/为什么1000==1000返回为false，而100==100会返回为true/</id>
    <published>2019-01-05T01:39:06.000Z</published>
    <updated>2019-06-12T08:53:09.102Z</updated>
    
    <content type="html"><![CDATA[<h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><pre><code class="java">Integer a = 1000, b = 1000;System.out.println(a == b);//falseInteger c = 100, d = 100;System.out.println(c == d);//true</code></pre><blockquote><p>=<strong> 运算比较的不是值而是</strong>引用**</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><blockquote><p>其实正常情况Integer类型与int是不可能相等的，一个是对象类型（Integer ），一个是基础数据类型（int）。只是Java搞了自动装箱和拆箱机制，会将int转换成Integer，反之亦然。但是转换时正常情况下，装箱与拆箱的对象的内存地址应该是不同的，应该仍然不等才对，但是JVM让对应的<code>-128~127</code>的装箱对象都缓存起来了，这意味着每次装箱在这个范围的，直接从缓存取，不会new，通过这个trick让其相等 但是超出这个范围的默认还是一般原理就不相等了</p></blockquote><p>当我们给一个Integer 对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf 的源代码就知道发生了什么：</p><pre><code class="java">public static Integer valueOf(int i) {  if (i &gt;= IntegerCache.low &amp;&amp; i      return IntegerCache.cache[i + (-IntegerCache.low)];  return new Integer(i);}</code></pre><p>IntegerCache 是Integer 的内部类，其代码如下所示：</p><pre><code class="java">/**     * Cache to support the object identity semantics of autoboxing for values between     * -128 and 127 (inclusive) as required by JLS.     *     * The cache is initialized on first usage.  The size of the cache     * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.     * During VM initialization, java.lang.Integer.IntegerCache.high property     * may be set and saved in the private system properties in the     * sun.misc.VM class.     */    private static class IntegerCache {        static final int low = -128;        static final int high;        static final Integer cache[];        static {            // high value may be configured by property            int h = 127;            String integerCacheHighPropValue =                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);            if (integerCacheHighPropValue != null) {                try {                    int i = parseInt(integerCacheHighPropValue);                    i = Math.max(i, 127);                    // Maximum array size is Integer.MAX_VALUE                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);                } catch( NumberFormatException nfe) {                    // If the property cannot be parsed into an int, ignore it.                }            }            high = h;            cache = new Integer[(high - low) + 1];            int j = low;            for(int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);            // range [-128, 127] must be interned (JLS7 5.1.7)            assert IntegerCache.high &gt;= 127;        }        private IntegerCache() {}    }</code></pre><p>简单的说，如果整型字面量的值在<code>-128 ~ 127</code>之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以才会出现上面的现象</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和HashTable的区别</title>
    <link href="https://www.xiongtianci.com/2019/01/05/HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.xiongtianci.com/2019/01/05/HashMap和HashTable的区别/</id>
    <published>2019-01-05T01:23:58.000Z</published>
    <updated>2019-06-12T08:53:50.915Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h4><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p><blockquote><p>HashMap是非线程安全的，HashTable是线程安全的<br>HashMap的键和值都允许有null值存在，而HashTable则不行<br>因为线程安全的问题，HashMap效率比HashTable的要高</p></blockquote><p>1、HashMap几乎可以等价于HashTable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而HashTable则不行)。<br>2、HashMap是非synchronized，而HashTable是synchronized，这意味着HashTable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。<br>3、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。<br>4、由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。<br>5、HashMap不能保证随着时间的推移Map中的元素次序是不变的。</p><blockquote><p><strong>注意：</strong><br>1、 sychronized意味着在一次仅有一个线程能够更改HashTable。就是说任何线程要更新HashTable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新HashTable。<br>2、Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。<br>3、结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p></blockquote><h4 id="我们能否让HashMap同步？"><a href="#我们能否让HashMap同步？" class="headerlink" title="我们能否让HashMap同步？"></a>我们能否让HashMap同步？</h4><p>HashMap可以通过下面的语句进行同步：</p><pre><code class="java">Map map = Collections.synchronizeMap(hashMap);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>打印昨天的当前时刻</title>
    <link href="https://www.xiongtianci.com/2019/01/04/%E6%89%93%E5%8D%B0%E6%98%A8%E5%A4%A9%E7%9A%84%E5%BD%93%E5%89%8D%E6%97%B6%E5%88%BB/"/>
    <id>https://www.xiongtianci.com/2019/01/04/打印昨天的当前时刻/</id>
    <published>2019-01-04T08:15:38.000Z</published>
    <updated>2019-06-12T08:54:30.937Z</updated>
    
    <content type="html"><![CDATA[<h4 id="方式一：通过Calendar实现"><a href="#方式一：通过Calendar实现" class="headerlink" title="方式一：通过Calendar实现"></a>方式一：通过Calendar实现</h4><pre><code class="java">Calendar cal = Calendar.getInstance();cal.add(Calendar.DATE,-1);System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(cal.getTime()));</code></pre><h4 id="方式二：通过Date实现"><a href="#方式二：通过Date实现" class="headerlink" title="方式二：通过Date实现"></a>方式二：通过Date实现</h4><pre><code class="java">// 1天的时间 = 24小时 x 60分钟 x 60秒 x 1000毫秒 单位是LDate yesterday = new Date(new Date().getTime() - 24 * 60 * 60 * 1000);System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(yesterday));</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</title>
    <link href="https://www.xiongtianci.com/2019/01/04/%E6%80%8E%E6%A0%B7%E5%B0%86GB2312%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BAISO-8859-1%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2019/01/04/怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？/</id>
    <published>2019-01-04T08:05:49.000Z</published>
    <updated>2019-06-12T08:54:10.300Z</updated>
    
    <content type="html"><![CDATA[<p>使用的函数：</p><pre><code class="java">public String(byte bytes[], String charsetName)            throws UnsupportedEncodingException {    this(bytes, 0, bytes.length, charsetName);}</code></pre><p>代码：</p><pre><code class="java">String s1 = &quot;你好&quot;;String s2 = new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中 # 和 $ 的区别？</title>
    <link href="https://www.xiongtianci.com/2019/01/03/MyBatis%E4%B8%AD#%E5%92%8C$%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2019/01/03/MyBatis中#和$的区别？/</id>
    <published>2019-01-03T09:20:00.000Z</published>
    <updated>2019-06-12T08:57:48.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>#相当于对数据加上双引号，$相当于直接显示数据</p></blockquote><ol><li>&#35;将传入的数据都当成一个<strong>字符串</strong>，会对自动传入的数据<strong>加一个双引号</strong>。如：order by &#35;user_id&#35;，如果传入的值是111，那么解析成sq 时的值为：order by “111”；如果传入的值是id，则解析成的sql为：order by “id”</li><li>&#36;将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111，那么解析成sql 时的值为：order by user_id,；如果传入的值是id，则解析成的sql为：order by id</li><li>&#35;方式能够很大程度防止sql 注入</li><li>&#36;方式无法防止sql注入</li><li>&#36;方式一般用于传入数据库对象，例如传入表名</li><li>一般能用&#35;的就别用&#36;</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL中limit的用法</title>
    <link href="https://www.xiongtianci.com/2019/01/03/SQL%E4%B8%ADlimit%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://www.xiongtianci.com/2019/01/03/SQL中limit的用法/</id>
    <published>2019-01-03T08:01:40.000Z</published>
    <updated>2019-06-12T08:55:17.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>limit子句用于限制查询结果返回的数量</p></blockquote><p><strong>格式：</strong></p><pre><code class="sql">select * from tableName limit i,n# tableName：表名# i：为查询结果的索引值(默认从0开始)，当i=0时可省略i# n：为查询结果返回的数量# i与n之间使用英文逗号&quot;,&quot;隔开</code></pre><p>栗子：</p><pre><code class="sql">select * from Customer LIMIT 10;# 检索前10行数据，显示1-10条数据select * from Customer LIMIT 1,10;# 检索从第2行开始，累加10条id记录，共显示id为2....11select * from Customer limit 5,10;# 检索从第6行开始向前加10条数据，共显示id为6,7....15select * from Customer limit 6,10;# 检索从第7行开始向前加10条记录，显示id为7,8...16</code></pre><p>注意：</p><blockquote><p>limit n 等同于 limit 0,n</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="SQL" scheme="https://www.xiongtianci.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>事务的基本要素（ACID）</title>
    <link href="https://www.xiongtianci.com/2019/01/03/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0%EF%BC%88ACID%EF%BC%89/"/>
    <id>https://www.xiongtianci.com/2019/01/03/事务的基本要素（ACID）/</id>
    <published>2019-01-03T07:11:01.000Z</published>
    <updated>2019-06-12T08:54:58.729Z</updated>
    
    <content type="html"><![CDATA[<p>数据库事务(Transanction)正确执行的四个基本要素：<br>1、<strong>原子性（Atomicity）</strong>：事务开始后所有操作，要么全部完成，要么全部不完成，不可能停滞在中间环节。事务执行过程中出错，会回滚（Rollback）到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位<br>2、<strong>一致性（Consistency）</strong>：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到<br>3、<strong>隔离性（Isolation）</strong>：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账<br>4、<strong>持久性（Durability）</strong>：事务完成后，该事务所对数据库所作的更改将被保存到数据库之中，不能回滚</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
      <category term="事务" scheme="https://www.xiongtianci.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的四种隔离级别</title>
    <link href="https://www.xiongtianci.com/2019/01/03/Mysql%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://www.xiongtianci.com/2019/01/03/Mysql的四种隔离级别/</id>
    <published>2019-01-03T06:56:10.000Z</published>
    <updated>2019-06-12T08:55:37.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、MySQL事务隔离级别"><a href="#一、MySQL事务隔离级别" class="headerlink" title="一、MySQL事务隔离级别"></a>一、MySQL事务隔离级别</h3><table border="1" style="text-align: center;"><br>    <thead><br>        <tr><br>            <th>隔离级别</th><br>            <th>脏读</th><br>            <th>不可重复读</th><br>            <th>幻读</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>读未提交</td><br>            <td>是</td><br>            <td>是</td><br>            <td>是</td><br>        </tr><br>        <tr><br>            <td>读已提交</td><br>            <td>否</td><br>            <td>是</td><br>            <td>是</td><br>        </tr><br>        <tr><br>            <td>可重复读</td><br>            <td>否</td><br>            <td>否</td><br>            <td>是</td><br>        </tr><br>        <tr><br>            <td>串行化</td><br>            <td>否</td><br>            <td>否</td><br>            <td>否</td><br>        </tr><br>    </tbody><br></table><p>在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p><p><strong>未提交读（Read uncommitted）</strong>：在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上来说，未提交读不会比其他的级别好太多，但是缺乏其他级别的很多好处，在实际应用中一般很少使用。<br><strong>读已提交（Read committed）</strong>：大多数数据库系统的默认隔离级别都是读已提交（但Mysql不是）。读已提交满足隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。<br><strong>可重复读（Repeatable read）</strong>：可重复读解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom read）问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务中又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom row）。可重复读是MySQL的默认事务隔离级别。<br><strong>可串行化（Serializable）</strong>：可串行化是最高的隔离级别。它通过强制事务串行执行，避免了前面所说的幻读问题。简单来说，可串行化会在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑用该级别。</p><h3 id="二、事务的并发问题"><a href="#二、事务的并发问题" class="headerlink" title="二、事务的并发问题"></a>二、事务的并发问题</h3><p>1、<strong>脏读</strong>：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p>2、<strong>不可重复读</strong>：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p><p>3、<strong>幻读</strong>：系统管理员1将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员2就在这个时候插入了一条具体分数的记录，当系统管理员1操作结束后发现还有一条记录(2插入的那条)没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL面试题</title>
    <link href="https://www.xiongtianci.com/2019/01/02/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://www.xiongtianci.com/2019/01/02/MySQL面试题/</id>
    <published>2019-01-02T12:05:58.000Z</published>
    <updated>2019-06-12T08:58:18.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-主键-超键-候选键-外键"><a href="#1-主键-超键-候选键-外键" class="headerlink" title="1. 主键 超键 候选键 外键"></a>1. 主键 超键 候选键 外键</h1><p><strong>主 键：</strong></p><pre><code>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）</code></pre><p><strong>超 键：</strong></p><pre><code>在关系中能唯一标识元组的属性集称为关系模式的超键一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键超键包含候选键和主键。</code></pre><p><strong>候选键：</strong></p><pre><code>是最小超键，即没有冗余元素的超键。</code></pre><p><strong>外 键：</strong></p><pre><code>在一个表中存在的另一个表的主键称此表的外键</code></pre><h1 id="2-数据库事务的四个特性及含义"><a href="#2-数据库事务的四个特性及含义" class="headerlink" title="2.数据库事务的四个特性及含义"></a>2.数据库事务的四个特性及含义</h1><blockquote><p>数据库事务( transanction )正确执行的四个基本要素( ACID )：原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p></blockquote><p><strong>原子性</strong>：</p><pre><code>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</code></pre><p><strong>一致性</strong>：</p><pre><code>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</code></pre><p><strong>隔离性</strong>：</p><pre><code>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</code></pre><p><strong>持久性</strong>：</p><pre><code>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</code></pre><h1 id="3-drop-delete与truncate的区别"><a href="#3-drop-delete与truncate的区别" class="headerlink" title="3.drop,delete与truncate的区别"></a>3.drop,delete与truncate的区别</h1><blockquote><p>drop直接删掉表<br>delete删除表中数据，可以加where字句<br>truncate删除表中数据，再插入时自增长id又从1开始</p></blockquote><pre><code>1、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除的数据是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。2、表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。3、一般而言，drop &gt; truncate &gt; delete4、应用范围。truncate 只能对 table；delete 可以是table和view5、truncate 和 DELETE 只删除数据，而DROP则删除整个表（结构和数据）。6、truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。7、delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。8、truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚9、在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。10、Truncate table 表名 速度快,而且效率高,因为:truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。11、TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。12、对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</code></pre><h1 id="4-索引的工作原理及其种类"><a href="#4-索引的工作原理及其种类" class="headerlink" title="4.索引的工作原理及其种类"></a>4.索引的工作原理及其种类</h1><blockquote><p><strong>数据库索引</strong>：是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。<strong>索引的实现通常使用B树及其变种B+树</strong>。<br>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是<strong>索引</strong>。</p></blockquote><p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><p><img src="img/1546432394934.png" alt="1546432394934"></p><p>图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O($log_2n$)的复杂度内获取到相应数据。</p><p>创建索引可以大大提高系统的性能。</p><p>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p><p>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。<strong>一般来说，应该在这些列上创建索引：</strong>在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p>同样，对于有些列不应该创建索引。<strong>一般来说，不应该创建索引的的这些列具有下列特点：</strong></p><p>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p><p>根据数据库的功能，可以在<a href="http://www.2cto.com/database/" target="_blank" rel="noopener">数据库设计</a>器中创建三种索引：<strong>唯一索引、主键索引和聚集索引</strong>。</p><p><strong>唯一索引</strong></p><p>唯一索引是不允许其中任何两行具有相同索引值的索引。</p><p>当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 <strong>主键索引</strong> 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 <strong>聚集索引</strong> 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。<strong>一个表只能包含一个聚集索引。</strong></p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。<strong>与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</strong></p>]]></content>
    
    <summary type="html">
    
      MySQL面试题
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="MySQL" scheme="https://www.xiongtianci.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Google Chrome快捷键</title>
    <link href="https://www.xiongtianci.com/2018/12/27/Google-Chrome%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://www.xiongtianci.com/2018/12/27/Google-Chrome快捷键/</id>
    <published>2018-12-27T06:15:42.000Z</published>
    <updated>2019-06-12T08:58:53.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标签页和窗口快捷键">标签页和窗口快捷键</h2><table><br>    <thead><br>    <tr><br>        <th>操作</th><br>        <th>快捷键</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>        <td>打开新窗口</td><br>        <td><font color="hotpink">Ctrl + N</font></td><br>    </tr><br>    <tr><br>        <td>在无痕模式下打开新窗口</td><br>        <td><font color="hotpink">Ctrl + Shift + N</font></td><br>    </tr><br>    <tr><br>        <td>打开新的标签页，并跳转到该标签页</td><br>        <td><font color="hotpink">Ctrl + T</font></td><br>    </tr><br>    <tr><br>        <td>重新打开最后关闭的标签页，并跳转到该标签页</td><br>        <td><font color="hotpink">Ctrl + Shift + T</font></td><br>    </tr><br>    <tr><br>        <td>跳转到下一个打开的标签页</td><br>        <td>Ctrl + Tab 或 Ctrl + PgDn</td><br>    </tr><br>    <tr><br>        <td>跳转到上一个打开的标签页</td><br>        <td>Ctrl + Shift + Tab 或 Ctrl + PgUp</td><br>    </tr><br>    <tr><br>        <td>跳转到特定标签页</td><br>        <td>Ctrl + 1 到 Ctrl + 8</td><br>    </tr><br>    <tr><br>        <td>跳转到最后一个标签页</td><br>        <td>Ctrl + 9</td><br>    </tr><br>    <tr><br>        <td>在当前标签页中打开主页</td><br>        <td>Alt + Home</td><br>    </tr><br>    <tr><br>        <td>打开当前标签页浏览记录中记录的上一个页面</td><br>        <td>Alt + 向左箭头键</td><br>    </tr><br>    <tr><br>        <td>打开当前标签页浏览记录中记录的下一个页面</td><br>        <td>Alt + 向右箭头键</td><br>    </tr><br>    <tr><br>        <td>关闭当前标签页</td><br>        <td><font color="hotpink">Ctrl + W 或 Ctrl + F4</font></td><br>    </tr><br>    <tr><br>        <td>关闭所有打开的标签页和浏览器</td><br>        <td>Ctrl + Shift + W</td><br>    </tr><br>    <tr><br>        <td>最小化当前窗口</td><br>        <td>Alt + 空格键 + N</td><br>    </tr><br>    <tr><br>        <td>最大化当前窗口</td><br>        <td>Alt + 空格键 + X</td><br>    </tr><br>    <tr><br>        <td>关闭当前窗口</td><br>        <td><font color="hotpink">Alt + F4</font></td><br>    </tr><br>    <tr><br>        <td>退出 Google Chrome</td><br>        <td>Ctrl + Shift + q</td><br>    </tr><br>    </tbody><br></table><h2 id="google-chrome-功能快捷键">Google Chrome 功能快捷键</h2><table><br>    <thead><br>    <tr><br>        <th>操作</th><br>        <th>快捷键</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>        <td>打开 Chrome 菜单</td><br>        <td>Alt + F、Alt + E 或 F10</td><br>    </tr><br>    <tr><br>        <td>显示或隐藏书签栏</td><br>        <td>Ctrl + Shift + B</td><br>    </tr><br>    <tr><br>        <td>打开书签管理器</td><br>        <td><font color="hotpink">Ctrl + Shift + O</font></td><br>    </tr><br>    <tr><br>        <td>在新标签页中打开“历史记录”页</td><br>        <td>Ctrl + H</td><br>    </tr><br>    <tr><br>        <td>在新标签页中打开“下载内容”页</td><br>        <td>Ctrl + J</td><br>    </tr><br>    <tr><br>        <td>打开 Chrome 任务管理器</td><br>        <td>Shift + Esc</td><br>    </tr><br>    <tr><br>        <td>将焦点放置在 Chrome 工具栏中的第一项上</td><br>        <td>Shift + Alt + T</td><br>    </tr><br>    <tr><br>        <td>在地址栏、书签栏（若显示）和页面内容之间向前切换焦点</td><br>        <td>F6</td><br>    </tr><br>    <tr><br>        <td>在地址栏、书签栏（若显示）和页面内容之间向后切换焦点</td><br>        <td>Shift + F6</td><br>    </tr><br>    <tr><br>        <td>打开查找栏搜索当前网页</td><br>        <td>Ctrl + F 或 F3</td><br>    </tr><br>    <tr><br>        <td>跳转到与查找栏中搜索字词相匹配的下一条内容</td><br>        <td>Ctrl + G</td><br>    </tr><br>    <tr><br>        <td>跳转到与查找栏中搜索字词相匹配的上一条内容</td><br>        <td>Ctrl + Shift + G</td><br>    </tr><br>    <tr><br>        <td>打开“开发者工具”</td><br>        <td>Ctrl + Shift + j 或 F12</td><br>    </tr><br>    <tr><br>        <td>打开“清除浏览数据”选项</td><br>        <td>Ctrl + Shift + Delete</td><br>    </tr><br>    <tr><br>        <td>在新标签页中打开 Chrome 帮助中心</td><br>        <td>F1</td><br>    </tr><br>    <tr><br>        <td>使用其他帐号登录或以访客身份浏览</td><br>        <td>Ctrl + Shift + m</td><br>    </tr><br>    <tr><br>        <td>打开反馈表单</td><br>        <td>Alt + Shift + i</td><br>    </tr><br>    </tbody><br></table><h2 id="地址栏快捷键">地址栏快捷键</h2><table><br>    <thead><br>    <tr><br>        <th>操作</th><br>        <th>快捷键</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>        <td>使用默认搜索引擎进行搜索</td><br>        <td>输入搜索字词并按 Enter 键</td><br>    </tr><br>    <tr><br>        <td>使用其他搜索引擎进行搜索</td><br>        <td>输入搜索引擎名称并按 Tab 键</td><br>    </tr><br>    <tr><br>        <td>为网站名称添加 www. 和 .com，并在当前标签页中打开该网站</td><br>        <td>输入网站名称并按 Ctrl + Enter</td><br>    </tr><br>    <tr><br>        <td>打开新的标签页并执行 Google 搜索</td><br>        <td>输入搜索字词并按 Alt + Enter 键</td><br>    </tr><br>    <tr><br>        <td>跳转到地址栏</td><br>        <td>Ctrl + l、Alt + d 或 F6</td><br>    </tr><br>    <tr><br>        <td>从页面中的任意位置搜索</td><br>        <td>Ctrl + k 或 Ctrl + e</td><br>    </tr><br>    <tr><br>        <td>从地址栏中移除联想查询内容</td><br>        <td>按向下箭头键以突出显示相应内容，然后按 Shift + Delete</td><br>    </tr><br>    </tbody><br></table><h2 id="网页快捷键">网页快捷键</h2><table><br>    <thead><br>    <tr><br>        <th>操作</th><br>        <th>快捷键</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>        <td>打开选项以打印当前网页</td><br>        <td>Ctrl + p</td><br>    </tr><br>    <tr><br>        <td>打开选项以保存当前网页</td><br>        <td>Ctrl + s</td><br>    </tr><br>    <tr><br>        <td>重新加载当前网页</td><br>        <td>F5 或 Ctrl + r</td><br>    </tr><br>    <tr><br>        <td>重新加载当前网页（忽略缓存的内容）</td><br>        <td>Shift + F5 或 Ctrl + Shift + r</td><br>    </tr><br>    <tr><br>        <td>停止加载网页</td><br>        <td>Esc</td><br>    </tr><br>    <tr><br>        <td>浏览下一个可点击项</td><br>        <td>Tab</td><br>    </tr><br>    <tr><br>        <td>浏览上一个可点击项</td><br>        <td>Shift + Tab</td><br>    </tr><br>    <tr><br>        <td>使用 Chrome 打开计算机中的文件</td><br>        <td>按住 Ctrl + o 键并选择文件</td><br>    </tr><br>    <tr><br>        <td>显示当前网页的 HTML 源代码（不可修改）</td><br>        <td>Ctrl + u</td><br>    </tr><br>    <tr><br>        <td>将当前网页保存为书签</td><br>        <td>Ctrl + d</td><br>    </tr><br>    <tr><br>        <td>将所有打开的标签页以书签的形式保存在新文件夹中</td><br>        <td>Ctrl + Shift + d</td><br>    </tr><br>    <tr><br>        <td>开启或关闭全屏模式</td><br>        <td>F11</td><br>    </tr><br>    <tr><br>        <td>放大网页上的所有内容</td><br>        <td>Ctrl 和 +</td><br>    </tr><br>    <tr><br>        <td>缩小网页上的所有内容</td><br>        <td>Ctrl 和 -</td><br>    </tr><br>    <tr><br>        <td>将网页上的所有内容恢复到默认大小</td><br>        <td>Ctrl + 0</td><br>    </tr><br>    <tr><br>        <td>向下滚动网页，一次一个屏幕</td><br>        <td>空格键或 PgDn</td><br>    </tr><br>    <tr><br>        <td>向上滚动网页，一次一个屏幕</td><br>        <td>Shift + 空格键或 PgUp</td><br>    </tr><br>    <tr><br>        <td>转到网页顶部</td><br>        <td>首页</td><br>    </tr><br>    <tr><br>        <td>转到网页底部</td><br>        <td>末尾</td><br>    </tr><br>    <tr><br>        <td>在网页上水平滚动</td><br>        <td>按住 Shift 键并滚动鼠标滚轮</td><br>    </tr><br>    <tr><br>        <td>将光标移到文本字段中的上一个字词前面</td><br>        <td>Ctrl + 向左箭头键</td><br>    </tr><br>    <tr><br>        <td>将光标移到文本字段中的上一个字词后面</td><br>        <td>Ctrl + 向右箭头键</td><br>    </tr><br>    <tr><br>        <td>删除文本字段中的上一个字词</td><br>        <td>Ctrl + Backspace</td><br>    </tr><br>    <tr><br>        <td>将焦点移到通知上</td><br>        <td>Alt + n</td><br>    </tr><br>    <tr><br>        <td>在通知中允许</td><br>        <td>Alt + Shift + a</td><br>    </tr><br>    <tr><br>        <td>在通知中拒绝</td><br>        <td>Alt + Shift + d</td><br>    </tr><br>    <tr><br>        <td>在当前标签页中打开主页</td><br>        <td>Alt + Home</td><br>    </tr><br>    </tbody><br></table><h2 id="鼠标快捷键">鼠标快捷键</h2><table><br>    <thead><br>    <tr><br>        <th>操作</th><br>        <th>快捷键</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>        <td>在当前标签页中打开链接（仅限鼠标）</td><br>        <td>将链接拖到标签页中</td><br>    </tr><br>    <tr><br>        <td>在新的后台标签页中打开链接</td><br>        <td>按住 Ctrl 键的同时点击链接</td><br>    </tr><br>    <tr><br>        <td>打开链接，并跳转到该链接</td><br>        <td>按住 Ctrl + Shift 键的同时点击链接</td><br>    </tr><br>    <tr><br>        <td>打开链接，并跳转到该链接（仅使用鼠标）</td><br>        <td>将链接拖到标签栏的空白区域</td><br>    </tr><br>    <tr><br>        <td>在新窗口中打开链接</td><br>        <td>按住 Shift 键的同时点击链接</td><br>    </tr><br>    <tr><br>        <td>在新窗口中打开标签页（仅使用鼠标）</td><br>        <td>将标签页拖出标签栏</td><br>    </tr><br>    <tr><br>        <td>将标签页移至当前窗口（仅限鼠标）</td><br>        <td>将标签页拖到现有窗口中</td><br>    </tr><br>    <tr><br>        <td>将标签页移回其原始位置</td><br>        <td>拖动标签页的同时按 Esc</td><br>    </tr><br>    <tr><br>        <td>将当前网页保存为书签</td><br>        <td>将相应网址拖动到书签栏中</td><br>    </tr><br>    <tr><br>        <td>下载链接目标</td><br>        <td>按住 Alt 键的同时点击链接</td><br>    </tr><br>    <tr><br>        <td>显示浏览记录</td><br>        <td>右键点击“后退”箭头 返回 或“前进”箭头 下一个，或者左键点击（并按住鼠标左键</td><br>    </tr><br>    <tr><br>        <td>在最大化模式和窗口模式间切换</td><br>        <td>双击标签栏的空白区域</td><br>    </tr><br>    <tr><br>        <td>放大网页上的所有内容</td><br>        <td>按住 Ctrl 键的同时向上滚动鼠标滚轮</td><br>    </tr><br>    <tr><br>        <td>缩小网页上的所有内容</td><br>        <td>按住 Ctrl 键的同时向下滚动鼠标滚轮</td><br>    </tr><br>    </tbody><br></table>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Chrome" scheme="https://www.xiongtianci.com/tags/Chrome/"/>
    
      <category term="快捷键" scheme="https://www.xiongtianci.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 常用注解</title>
    <link href="https://www.xiongtianci.com/2018/12/26/SpringMVC-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://www.xiongtianci.com/2018/12/26/SpringMVC-常用注解/</id>
    <published>2018-12-26T10:22:15.000Z</published>
    <updated>2019-06-12T09:02:21.173Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、-RequestMapping"><a href="#1、-RequestMapping" class="headerlink" title="1、@RequestMapping"></a>1、@RequestMapping</h4><blockquote><p>@RequestMapping：用于处理请求url映射，可以作用于类和方法上</p><ul><li><strong>value</strong>：定义request请求的映射地址(默认)</li><li><strong>method</strong>：定义地request址请求的方式，包括【GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.】默认接受get请求，如果请求方式和定义的方式不一样则请求无法成功</li><li><strong>params</strong>：定义request请求中必须包含的参数值。</li><li><strong>headers</strong>：定义request请求中必须包含某些指定的请求头，如：RequestMapping(value = “/something”, headers = “content-type=text/*”)说明请求中必须要包含”text/html”, “text/plain”这中类型的Content-type头，才是一个匹配的请求。</li><li><strong>consumes</strong>：定义请求提交内容的类型。</li><li><strong>produces</strong>：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</li></ul></blockquote><h4 id="2、-RequestParam"><a href="#2、-RequestParam" class="headerlink" title="2、@RequestParam"></a>2、@RequestParam</h4><blockquote><p>用于<code>Controller</code>层，获取请求的参数。类似于：request.getParameter(“name”)</p></blockquote><h4 id="3、-RequestBody"><a href="#3、-RequestBody" class="headerlink" title="3、@RequestBody"></a>3、@RequestBody</h4><blockquote><p>用于<code>Controller</code>层，将请求中的<code>json</code>格式的数据转换成<code>java对象</code></p></blockquote><h4 id="4、-ResponseBody"><a href="#4、-ResponseBody" class="headerlink" title="4、@ResponseBody"></a>4、@ResponseBody</h4><blockquote><p>用于<code>Controller</code>层，将返回的对象转换成<code>json</code>格式</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="SpringMVC" scheme="https://www.xiongtianci.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Typora侧边栏的大纲视图折叠( win系统 )</title>
    <link href="https://www.xiongtianci.com/2018/12/26/Typora%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E5%A4%A7%E7%BA%B2%E8%A7%86%E5%9B%BE%E6%8A%98%E5%8F%A0-win%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.xiongtianci.com/2018/12/26/Typora侧边栏的大纲视图折叠-win系统/</id>
    <published>2018-12-26T02:11:23.000Z</published>
    <updated>2019-06-12T09:01:40.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181226-Typora%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E5%A4%A7%E7%BA%B2%E8%A7%86%E5%9B%BE%E6%8A%98%E5%8F%A0-win%E7%B3%BB%E7%BB%9F/20181226094905721.gif" alt="在这里插入图片描述"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>文件 &rArr; 偏好设置 &rArr; 勾选”侧边栏”<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181226-Typora%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E5%A4%A7%E7%BA%B2%E8%A7%86%E5%9B%BE%E6%8A%98%E5%8F%A0-win%E7%B3%BB%E7%BB%9F/20181226093929134.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181226-Typora%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E5%A4%A7%E7%BA%B2%E8%A7%86%E5%9B%BE%E6%8A%98%E5%8F%A0-win%E7%B3%BB%E7%BB%9F/20181226093934973.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181226-Typora%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%9A%84%E5%A4%A7%E7%BA%B2%E8%A7%86%E5%9B%BE%E6%8A%98%E5%8F%A0-win%E7%B3%BB%E7%BB%9F/20181226101055865.gif" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Typora" scheme="https://www.xiongtianci.com/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中通用Mapper接口以及Example的方法解析</title>
    <link href="https://www.xiongtianci.com/2018/12/25/MyBatis%E4%B8%AD%E9%80%9A%E7%94%A8Mapper%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8AExample%E7%9A%84%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.xiongtianci.com/2018/12/25/MyBatis中通用Mapper接口以及Example的方法解析/</id>
    <published>2018-12-25T03:04:39.000Z</published>
    <updated>2019-06-12T09:05:09.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、通用Mapper中的方法解析"><a href="#一、通用Mapper中的方法解析" class="headerlink" title="一、通用Mapper中的方法解析"></a>一、通用Mapper中的方法解析</h3><table><br>    <thead><br>    <tr><br>        <th>方法</th><br>        <th>功能说明</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>        <td>int countByExample(UserExample example) thorws SQLException</td><br>        <td>按条件计数</td><br>    </tr><br>    <tr><br>        <td>int <font color="hotpink">deleteByPrimaryKey</font>(Integer id) thorws SQLException</td><br>        <td>按主键删除</td><br>    </tr><br>    <tr><br>        <td>int <font color="hotpink">deleteByExample</font>(UserExample example) thorws SQLException</td><br>        <td>按条件查询</td><br>    </tr><br>    <tr><br>        <td>String/Integer <font color="hotpink">insert</font>(User record) thorws SQLException</td><br>        <td>插入数据（返回值为ID）</td><br>    </tr><br>    <tr><br>        <td>User <font color="hotpink">selectByPrimaryKey</font>(Integer id) thorws SQLException</td><br>        <td>按主键查询</td><br>    </tr><br>    <tr><br>        <td>List <font color="hotpink">selectByExample</font>(UserExample example) thorws SQLException</td><br>        <td>按条件查询</td><br>    </tr><br>    <tr><br>        <td>List selectByExampleWithBLOGs(UserExample example) thorws SQLException</td><br>        <td>按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。</td><br>    </tr><br>    <tr><br>        <td>int <font color="hotpink">updateByPrimaryKey</font>(User record) thorws SQLException</td><br>        <td>按主键更新</td><br>    </tr><br>    <tr><br>        <td>int updateByPrimaryKeySelective(User record) thorws SQLException</td><br>        <td>按主键更新值不为null的字段</td><br>    </tr><br>    <tr><br>        <td>int <font color="hotpink">updateByExample</font>(User record, UserExample example) thorws SQLException</td><br>        <td>按条件更新</td><br>    </tr><br>    <tr><br>        <td>int updateByExampleSelective(User record, UserExample example) thorws SQLException</td><br>        <td>按条件更新值不为null的字段</td><br>    </tr><br>    </tbody><br></table><br><br><br><br>### 二、Example实例解析<br>mybatis的逆向工程中会生成实例及实例对应的example，example用于添加条件，相当where后面的部分<br><br><code>javaimport tk.mybatis.mapper.entity.Example;Example example = new Example(JavaBean.class);Example.Criteria criteria = example.createCriteria();</code><br><table><br>    <thead><br>    <tr><br>        <th>方法</th><br>        <th>说明</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>        <td>example.setOrderByClause(“字段名 ASC”);</td><br>        <td>添加升序排列条件，DESC为降序</td><br>    </tr><br>    <tr><br>        <td>example.setDistinct(false)</td><br>        <td>去除重复，boolean型，true为选择不重复的记录。</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxIsNull</td><br>        <td>添加字段xxx为null的条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxIsNotNull</td><br>        <td>添加字段xxx不为null的条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxEqualTo(value)</td><br>        <td>添加xxx字段等于value条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxNotEqualTo(value)</td><br>        <td>添加xxx字段不等于value条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxGreaterThan(value)</td><br>        <td>添加xxx字段大于value条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxGreaterThanOrEqualTo(value)</td><br>        <td>添加xxx字段大于等于value条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxLessThan(value)</td><br>        <td>添加xxx字段小于value条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxLessThanOrEqualTo(value)</td><br>        <td>添加xxx字段小于等于value条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxIn(List&lt;？&gt;)</td><br>        <td>添加xxx字段值在List&lt;？&gt;条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxNotIn(List&lt;？&gt;)</td><br>        <td>添加xxx字段值不在List&lt;？&gt;条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxLike(“%”+value+”%”)</td><br>        <td>添加xxx字段值为value的模糊查询条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxNotLike(“%”+value+”%”)</td><br>        <td>添加xxx字段值不为value的模糊查询条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxBetween(value1,value2)</td><br>        <td>添加xxx字段值在value1和value2之间条件</td><br>    </tr><br>    <tr><br>        <td>criteria.andXxxNotBetween(value1,value2)</td><br>        <td>添加xxx字段值不在value1和value2之间条件</td><br>    </tr><br>    </tbody><br></table><h3 id="三、使用案例"><a href="#三、使用案例" class="headerlink" title="三、使用案例"></a>三、使用案例</h3><h4 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h4><p>① selectByPrimaryKey() 按主键查询</p><pre><code class="java">//相当于：select * from user where id = 100;User user = UserMapper.selectByPrimaryKey(100); </code></pre><p>② selectByExample() 和 selectByExampleWithBLOGs()</p><pre><code class="java">//相当于：select * from user where username = &#39;wyw&#39; // and  username is null order by username asc,email descUserExample example = new UserExample();Criteria criteria = example.createCriteria();criteria.andUsernameEqualTo(&quot;wyw&quot;);criteria.andUsernameIsNull();example.setOrderByClause(&quot;username asc,email desc&quot;);List&lt;?&gt;list = XxxMapper.selectByExample(example);</code></pre><h4 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2.插入数据"></a>2.插入数据</h4><p>①insert()</p><pre><code class="java">//相当于：insert into user(ID,username,password,email) values //(&#39;dsfgsdfgdsfgds&#39;,&#39;jack&#39;,&#39;1234&#39;,&#39;hello@126.com&#39;);User user = new User();user.setId(&quot;dsfgsdfgdsfgds&quot;);user.setUsername(&quot;jack&quot;);user.setPassword(&quot;1234&quot;)user.setEmail(&quot;hello@163.com&quot;);XxxMapper.insert(user);</code></pre><h4 id="3-更新数据"><a href="#3-更新数据" class="headerlink" title="3.更新数据"></a>3.更新数据</h4><p>①updateByPrimaryKey()</p><pre><code class="java">//相当于：update user set username=&#39;rose&#39;, password=&#39;5678&#39;, //email=&#39;hello@163.com&#39; where id=&#39;a01&#39;User user =new User();user.setId(&quot;a01&quot;);user.setUsername(&quot;rose&quot;);user.setPassword(&quot;5678&quot;);user.setEmail(&quot;hello@163.com&quot;);XxxMapper.updateByPrimaryKey(user);</code></pre><p>②updateByPrimaryKeySelective()</p><pre><code class="java">//相当于：update user set password=&#39;7890&#39; where id=&#39;a01&#39;User user = new User();user.setId(&quot;a01&quot;);user.setPassword(&quot;7890&quot;);XxxMapper.updateByPrimaryKey(user);</code></pre><p>③ updateByExample() 和 updateByExampleSelective()</p><pre><code class="java">//相当于：update user set password=&#39;6666&#39; where username=&#39;jack&#39;UserExample example = new UserExample();Criteria criteria = example.createCriteria();criteria.andUsernameEqualTo(&quot;jack&quot;);User user = new User();user.setPassword(&quot;6666&quot;);XxxMapper.updateByPrimaryKeySelective(user,example);</code></pre><blockquote><p>updateByExample()更新所有的字段，包括字段为null的也更新<br>建议使用 updateByExampleSelective()更新想更新的字段</p></blockquote><h4 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4.删除数据"></a>4.删除数据</h4><p>①deleteByPrimaryKey()</p><pre><code class="java">//相当于：delete from user where id=1XxxMapper.deleteByPrimaryKey(1);  </code></pre><p>②deleteByExample()</p><pre><code class="java">//相当于：delete from user where username=&#39;jack&#39;UserExample example = new UserExample();Criteria criteria = example.createCriteria();criteria.andUsernameEqualTo(&quot;jack&quot;);XxxMapper.deleteByExample(example);</code></pre><h4 id="5-查询数据数量"><a href="#5-查询数据数量" class="headerlink" title="5.查询数据数量"></a>5.查询数据数量</h4><p>①countByExample()</p><pre><code class="java">//相当于：select count(*) from user where username=&#39;jack&#39;UserExample example = new UserExample();Criteria criteria = example.createCriteria();criteria.andUsernameEqualTo(&quot;jack&quot;);int count = XxxMapper.countByExample(example);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MyBatis" scheme="https://www.xiongtianci.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>抽象类和接口有什么不同点？</title>
    <link href="https://www.xiongtianci.com/2018/12/25/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2018/12/25/抽象类和接口有什么不同点？/</id>
    <published>2018-12-25T01:31:16.000Z</published>
    <updated>2019-06-12T09:03:08.235Z</updated>
    
    <content type="html"><![CDATA[<table border="1" style="text-align: center;"><br>    <thead><br>        <tr><br>            <th>参数</th><br>            <th>抽象类</th><br>            <th>接口</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <th>默认的方法实现</th><br>            <td>它可以有默认的方法实现</td><br>            <td>接口完全是抽象的。它根本不存在方法的实</td><br>        </tr><br>        <tr><br>            <th>实现</th><br>            <td>子类使用 <font color="hotpink">extends</font> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><br>            <td>子类使用关键字 <font color="hotpink">implements</font> 来实现接口。它需要提供接口中所有声明的方法的实现</td><br>        </tr><br>        <tr><br>            <th>构造器</th><br>            <td>抽象类可以有构造器</td><br>            <td>接口不能有构造器</td><br>        </tr><br>        <tr><br>            <th>与正常Java类的区别</th><br>            <td>除了你不能实例化抽象类之外，它和普通<br>Java 类没有任何区别</td><br>            <td>接口是完全不同的类型</td><br>        </tr><br>        <tr><br>            <th>访问修饰符</th><br>            <td>抽象方法可以有 <font color="hotpink">public</font>、<font color="hotpink">protected</font> 和 <font color="hotpink">default</font> 这些修饰符</td><br>            <td>接口方法默认修饰符是 <font color="hotpink">public</font>。你不可以使用其它修饰符</td><br>        </tr><br>        <tr><br>            <th>main 方法</th><br>            <td>抽象方法可以有main 方法并且我们可以运行它</td><br>            <td>接口没有main 方法，因此我们不能运行它</td><br>        </tr><br>        <tr><br>            <th>多继承</th><br>            <td>抽象方法可以继承一个类和实现多个接口</td><br>            <td>接口只可以继承一个或多个其它接口</td><br>        </tr><br>        <tr><br>            <th>速度</th><br>            <td>它比接口速度要快</td><br>            <td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td><br>        </tr><br>        <tr><br>            <th>添加新方法</th><br>            <td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码</td><br>            <td>如果你往接口中添加方法，那么你必须改变实现该接口的类</td><br>        </tr><br>    </tbody><br></table>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题：说下原生jdbc 操作数据库流程？</title>
    <link href="https://www.xiongtianci.com/2018/12/25/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%AF%B4%E4%B8%8B%E5%8E%9F%E7%94%9Fjdbc-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%81%E7%A8%8B%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2018/12/25/面试题：说下原生jdbc-操作数据库流程？/</id>
    <published>2018-12-25T00:25:40.000Z</published>
    <updated>2019-06-12T09:02:43.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原生的jdbc操作数据库流程：<br>1.注册驱动程序：Class.forName(“com.mysql.jdbc.Driver”);<br>2.使用驱动管理类来获取数据连接对象：conn = DriverManager.getConnection(…);<br>3.获取数据库操作对象：Statement stmt = conn.createStatement();<br>4.定义操作的SQL语句<br>5.执行SQL：stmt.executeQuery(sql);<br>6.处理结果集：ResultSet，如果SQL前有参数值就设置参数值setXXX()<br>7.关闭对象，回收数据库资源（关闭结果集–&gt;关闭数据库操作对象–&gt;关闭连接）</p></blockquote><pre><code class="java">public class JDBCTest {    /**     * 使用JDBC连接并操作mysql数据库     */    public static void main(String[] args) {        // 数据库驱动类名的字符串        String driver = &quot;com.mysql.jdbc.Driver&quot;;        // 数据库连接串        String url = &quot;jdbc:mysql://127.0.0.1:3306/jdbctest&quot;;        // 用户名        String username = &quot;root&quot;;        // 密码        String password = &quot;1234&quot;;        Connection conn = null;        Statement stmt = null;        ResultSet rs = null;        try {            // 1、加载数据库驱动（ 成功加载后，会将Driver类的实例注册到DriverManager类中）            Class.forName(driver);            // 2、获取数据库连接            conn = DriverManager.getConnection(url, username, password);            // 3、获取数据库操作对象            stmt = conn.createStatement();            // 4、定义操作的SQL语句            String sql = &quot;select * from user where id = 100&quot;;            // 5、执行数据库操作            rs = stmt.executeQuery(sql);            // 6、获取并操作结果集            while (rs.next()) {                System.out.println(rs.getInt(&quot;id&quot;));                System.out.println(rs.getString(&quot;name&quot;));            }        } catch (Exception e) {            e.printStackTrace();        } finally {            // 7、关闭对象，回收数据库资源            if (rs != null) { //关闭结果集对象                try {                    rs.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }            if (stmt != null) { // 关闭数据库操作对象                try {                    stmt.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }            if (conn != null) { // 关闭数据库连接对象                try {                    if (!conn.isClosed()) {                        conn.close();                    }                } catch (SQLException e) {                    e.printStackTrace();                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="JDBC" scheme="https://www.xiongtianci.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题&amp;cors解决跨域</title>
    <link href="https://www.xiongtianci.com/2018/12/21/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-cors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/"/>
    <id>https://www.xiongtianci.com/2018/12/21/跨域问题-cors解决跨域/</id>
    <published>2018-12-21T00:42:19.000Z</published>
    <updated>2019-06-12T09:05:28.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><blockquote><p>跨域：浏览器对于javascript的同源策略的限制 。</p></blockquote><p>以下情况都属于跨域：<br>| 跨域原因说明    | 示例                                    |<br>| ——— | ————————————- |<br>| 域名不同      | <code>www.jd.com</code> 与 <code>www.taobao.com</code>       |<br>| 域名相同，端口不同 | <code>www.jd.com:8080</code> 与 <code>www.jd.com:8081</code> |<br>| 二级域名不同    | <code>item.jd.com</code> 与 <code>miaosha.jd.com</code>      |</p><p>如果<strong>域名和端口都相同，但是请求路径不同</strong>，不属于跨域，如：</p><ul><li><code>www.jd.com/item</code> </li><li><code>www.jd.com/goods</code></li></ul><p>而我们刚才是从<code>manage.leyou.com</code>去访问<code>api.leyou.com</code>，这属于二级域名不同，跨域了。</p><h2 id="为什么有跨域问题？"><a href="#为什么有跨域问题？" class="headerlink" title="为什么有跨域问题？"></a>为什么有跨域问题？</h2><p>跨域不一定会有跨域问题。</p><p>因为跨域问题是浏览器对于ajax请求的一种安全限制：<strong>一个页面发起的ajax请求，只能是与当前页域名相同的路径</strong>，这能有效的阻止跨站攻击。</p><p>因此：<strong>跨域问题 是针对ajax的一种限制</strong>。</p><p>但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？</p><h2 id="解决跨域问题的方案"><a href="#解决跨域问题的方案" class="headerlink" title="解决跨域问题的方案"></a>解决跨域问题的方案</h2><p>目前比较常用的跨域解决方案有3种：</p><ul><li><p>Jsonp<br>最早的解决方案，利用script标签可以跨域的原理实现。<br>限制：</p><ul><li>需要服务的支持</li><li>只能发起GET请求</li></ul></li><li><p>nginx反向代理<br>思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式<br>缺点：需要在nginx进行额外配置，语义不清晰</p></li><li><p>CORS<br>规范化的跨域请求解决方案，安全可靠。<br>优势：</p><ul><li>在服务端进行控制是否允许跨域，可自定义规则</li><li>支持各种请求方式</li></ul><p>缺点：</p><ul><li>会产生额外的请求</li></ul></li></ul><p>我们这里会采用<strong>cors的跨域方案</strong>。</p><h2 id="cors解决跨域"><a href="#cors解决跨域" class="headerlink" title="cors解决跨域"></a>cors解决跨域</h2><h3 id="1-什么是cors"><a href="#1-什么是cors" class="headerlink" title="1.什么是cors"></a>1.什么是cors</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><ul><li><p>浏览器端：</p><p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。</p></li><li><p>服务端：</p><p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p></li></ul><h3 id="2-原理有点复杂"><a href="#2-原理有点复杂" class="headerlink" title="2.原理有点复杂"></a>2.原理有点复杂</h3><p>浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。</p><h4 id="2-1-简单请求"><a href="#2-1-简单请求" class="headerlink" title="2.1.简单请求"></a>2.1.简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。：</p><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><p>当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：Origin.<br><img src="https://img-blog.csdnimg.cn/20181221083052688.png" alt="在这里插入图片描述"><br>Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。</p><p>如果服务器允许跨域，需要在返回的响应头中携带下面信息：</p><pre><code class="http">Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8</code></pre><ul><li>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）</li><li>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</li></ul><blockquote><p>有关cookie：</p></blockquote><p>要想操作cookie，需要满足3个条件：</p><ul><li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li><li>浏览器发起ajax需要指定withCredentials 为true</li><li>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</li></ul><h4 id="2-2-特殊请求"><a href="#2-2-特殊请求" class="headerlink" title="2.2.特殊请求"></a>2.2.特殊请求</h4><p>不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。</p><blockquote><p>预检请求</p></blockquote><p>特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>一个“预检”请求的样板：</p><pre><code class="http">OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>与简单请求相比，除了Origin以外，多了两个头：</p><ul><li>Access-Control-Request-Method：接下来会用到的请求方式，比如PUT</li><li>Access-Control-Request-Headers：会额外用到的头信息</li></ul><blockquote><p>预检请求的响应</p></blockquote><p>服务的收到预检请求，如果许可跨域，会发出响应：</p><pre><code class="http">HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain</code></pre><p>除了<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Credentials</code>以外，这里又额外多出3个头：</p><ul><li>Access-Control-Allow-Methods：允许访问的方式</li><li>Access-Control-Allow-Headers：允许携带的头</li><li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，<strong>过期之前的ajax请求就无需再次进行预检了</strong></li></ul><p>如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。</p><h3 id="3-实现非常简单"><a href="#3-实现非常简单" class="headerlink" title="3.实现非常简单"></a>3.实现非常简单</h3><p>虽然原理比较复杂，但是前面说过：</p><ul><li>浏览器端都有浏览器自动完成，我们无需操心</li><li>服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。</li></ul><p>事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</p><p>在<code>leyou-gateway</code>中编写一个配置类，并且注册CorsFilter：</p><pre><code class="java">import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig {    @Bean    public CorsFilter corsFilter() {        //1.添加CORS配置信息        CorsConfiguration config = new CorsConfiguration();        //1) 允许的域,不要写*，否则cookie就无法使用了        config.addAllowedOrigin(&quot;http://manage.leyou.com&quot;);        //2) 是否发送Cookie信息        config.setAllowCredentials(true);        //3) 允许的请求方式        config.addAllowedMethod(&quot;OPTIONS&quot;);        config.addAllowedMethod(&quot;HEAD&quot;);        config.addAllowedMethod(&quot;GET&quot;);        config.addAllowedMethod(&quot;PUT&quot;);        config.addAllowedMethod(&quot;POST&quot;);        config.addAllowedMethod(&quot;DELETE&quot;);        config.addAllowedMethod(&quot;PATCH&quot;);        // 4）允许的头信息        config.addAllowedHeader(&quot;*&quot;);        //2.添加映射路径，我们拦截一切请求        UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();        configSource.registerCorsConfiguration(&quot;/**&quot;, config);        //3.返回新的CorsFilter.        return new CorsFilter(configSource);    }}</code></pre><p>结构：<br><img src="https://img-blog.csdnimg.cn/20181221084136322.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="跨域" scheme="https://www.xiongtianci.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>CollectionUtils工具类使用指南</title>
    <link href="https://www.xiongtianci.com/2018/12/20/CollectionUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.xiongtianci.com/2018/12/20/CollectionUtils工具类使用指南/</id>
    <published>2018-12-20T12:58:08.000Z</published>
    <updated>2019-06-12T09:11:36.796Z</updated>
    
    <content type="html"><![CDATA[<p>CollectionUtils提供很多对集合的操作方法，常用的方法如下：</p><pre><code class="java">//并集  Collection&lt;String&gt; union = CollectionUtils.union(a, b);  //交集  Collection&lt;String&gt; intersection = CollectionUtils.intersection(a, b);  //交集的补集  Collection&lt;String&gt; disjunction = CollectionUtils.disjunction(a, b);  //集合相减 Collection&lt;String&gt; subtract = CollectionUtils.subtract(a, b);  //判断集合是否为空Boolean boolean = CollectionUtils.isEmpty(Collection&lt;?&gt; collection);//判断集合是否不为空Boolean boolean = CollectionUtils.isNotEmpty(Collection&lt;?&gt; collection);</code></pre><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><pre><code class="java">@Testpublic void testUnion(){    String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; };      String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; };    List&lt;String&gt; listA = Arrays.asList(arrayA);    List&lt;String&gt; listB = Arrays.asList(arrayB);    //2个数组取并集     System.out.println(ArrayUtils.toString(CollectionUtils.union(listA, listB)));    //[A, B, C, D, E, F, G, H, K]}</code></pre><h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><pre><code class="java">@Testpublic void testIntersection(){    String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; };      String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; };    List&lt;String&gt; listA = Arrays.asList(arrayA);    List&lt;String&gt; listB = Arrays.asList(arrayB);    //2个数组取交集     System.out.println(ArrayUtils.toString(CollectionUtils.intersection(listA, listB)));    //[B, D, F]}</code></pre><h4 id="交集的补集（析取）"><a href="#交集的补集（析取）" class="headerlink" title="交集的补集（析取）"></a>交集的补集（析取）</h4><pre><code class="java">@Testpublic void testDisjunction(){    String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; };      String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; };    List&lt;String&gt; listA = Arrays.asList(arrayA);    List&lt;String&gt; listB = Arrays.asList(arrayB);    //2个数组取交集 的补集    System.out.println(ArrayUtils.toString(CollectionUtils.disjunction(listA, listB)));    //[A, C, E, G, H, K]}</code></pre><h4 id="差集（扣除）"><a href="#差集（扣除）" class="headerlink" title="差集（扣除）"></a>差集（扣除）</h4><pre><code class="java">@Testpublic void testSubtract(){    String[] arrayA = new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; };      String[] arrayB = new String[] { &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;K&quot; };    List&lt;String&gt; listA = Arrays.asList(arrayA);    List&lt;String&gt; listB = Arrays.asList(arrayB);    //arrayA扣除arrayB    System.out.println(ArrayUtils.toString(CollectionUtils.subtract(listA, listB)));    //[A, C, E]}</code></pre><h4 id="集合是否为空"><a href="#集合是否为空" class="headerlink" title="集合是否为空"></a>集合是否为空</h4><pre><code class="java">@Testpublic void testIsEmpty(){    class Person{}    class Girl extends Person{}    List&lt;Integer&gt; first = new ArrayList&lt;&gt;();    List&lt;Integer&gt; second = null;    List&lt;Person&gt; boy = new ArrayList&lt;&gt;();    //每个男孩心里都装着一个女孩    boy.add(new Girl());    //判断集合是否为空    System.out.println(CollectionUtils.isEmpty(first));   //true    System.out.println(CollectionUtils.isEmpty(second));   //true    System.out.println(CollectionUtils.isEmpty(boy));   //false    //判断集合是否不为空    System.out.println(CollectionUtils.isNotEmpty(first));   //false    System.out.println(CollectionUtils.isNotEmpty(second));   //false    System.out.println(CollectionUtils.isNotEmpty(boy));   //true}</code></pre><h4 id="集合是否相等"><a href="#集合是否相等" class="headerlink" title="集合是否相等"></a>集合是否相等</h4><pre><code class="java">@Testpublic void testIsEqual(){    class Person{}    class Girl extends Person{    }    List&lt;Integer&gt; first = new ArrayList&lt;&gt;();    List&lt;Integer&gt; second = new ArrayList&lt;&gt;();    first.add(1);    first.add(2);    second.add(2);    second.add(1);    Girl goldGirl = new Girl();    List&lt;Person&gt; boy1 = new ArrayList&lt;&gt;();    //每个男孩心里都装着一个女孩    boy1.add(new Girl());    List&lt;Person&gt; boy2 = new ArrayList&lt;&gt;();    //每个男孩心里都装着一个女孩    boy2.add(new Girl());    //比较两集合值    System.out.println(CollectionUtils.isEqualCollection(first,second));   //true    System.out.println(CollectionUtils.isEqualCollection(first,boy1));   //false    System.out.println(CollectionUtils.isEqualCollection(boy1,boy2));   //false    List&lt;Person&gt; boy3 = new ArrayList&lt;&gt;();    //每个男孩心里都装着一个女孩    boy3.add(goldGirl);    List&lt;Person&gt; boy4 = new ArrayList&lt;&gt;();    boy4.add(goldGirl);    System.out.println(CollectionUtils.isEqualCollection(boy3,boy4));   //true}</code></pre><h4 id="不可修改的集合"><a href="#不可修改的集合" class="headerlink" title="不可修改的集合"></a>不可修改的集合</h4><p>我们对c进行操作，s也同样获得了和c相同的内容，这样就可以避免其他人员修改这个s对象。有时候需要对它进行保护，避免返回结果被人修改。</p><pre><code class="java">@Testpublic void testUnmodifiableCollection(){    Collection&lt;String&gt; c = new ArrayList&lt;&gt;();    Collection&lt;String&gt; s = CollectionUtils.unmodifiableCollection(c);    c.add(&quot;boy&quot;);    c.add(&quot;love&quot;);    c.add(&quot;girl&quot;);    //! s.add(&quot;have a error&quot;);    System.out.println(s);}</code></pre><p>Collections.unmodifiableCollection可以得到一个集合的镜像，它的返回结果是不可直接被改变，否则会提示错误</p><pre><code>java.lang.UnsupportedOperationExceptionat org.apache.commons.collections.collection.UnmodifiableCollection.add(UnmodifiableCollection.java:75)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="工具类" scheme="https://www.xiongtianci.com/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="CollectionUtils" scheme="https://www.xiongtianci.com/tags/CollectionUtils/"/>
    
  </entry>
  
  <entry>
    <title>通用Mapper的select(T t)的使用</title>
    <link href="https://www.xiongtianci.com/2018/12/20/%E9%80%9A%E7%94%A8Mapper%E7%9A%84select(T%20t)%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.xiongtianci.com/2018/12/20/通用Mapper的select(T t)的使用/</id>
    <published>2018-12-20T12:35:14.000Z</published>
    <updated>2019-06-14T03:57:39.996Z</updated>
    
    <content type="html"><![CDATA[<p>通用mapper类：</p><pre><code class="java">public interface CategoryMapper extends Mapper&lt;Category&gt; {}</code></pre><p>使用select(T t)</p><pre><code class="java">public List&lt;Category&gt; queryCategoryListByParentId(Long pid) {    // select(T t) 将对象c中的非空字段当作查询的条件参数    Category record = new Category();    record.setParentId(pid);    return this.categoryMapper.select(record);}</code></pre><blockquote><p>select(T t) 将实例对象t中的非空字段作为条件参数<br>上面实例转换的sql语句：select * from category c where c.pid = #{pid}</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mapper" scheme="https://www.xiongtianci.com/tags/Mapper/"/>
    
  </entry>
  
  <entry>
    <title>使用nginx进行反向代理</title>
    <link href="https://www.xiongtianci.com/2018/12/20/%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://www.xiongtianci.com/2018/12/20/使用nginx进行反向代理/</id>
    <published>2018-12-20T09:17:17.000Z</published>
    <updated>2019-06-12T09:07:35.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h2><ul><li>代理：通过客户机的配置，实现让一台服务器(代理服务器)代理客户机，客户的所有请求都交给代理服务器处理。</li><li>反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。</li></ul><p>nginx可以当做反向代理服务器来使用：</p><ul><li>我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</li><li>当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能</li></ul><p>利用反向代理，就可以解决我们前面所说的端口问题，如图：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/20181220170949726.png" alt="在这里插入图片描述"></p><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/20181220171122796.gif" alt="在这里插入图片描述"></p><blockquote><p>下载nginx：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p></blockquote><p>我们在本地安装一台nginx：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/20181220171233798.png" alt="在这里插入图片描述"></p><p>解压后，目录结构：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/20181220171247576.png" alt="在这里插入图片描述"></p><ol><li>conf：配置目录</li><li>contrib：第三方依赖</li><li>html：默认的静态资源目录，类似于tomcat的webapps</li><li>logs：日志目录</li><li>nginx.exe：启动程序。可双击运行，但不建议这么做。</li></ol><h3 id="反向代理配置"><a href="#反向代理配置" class="headerlink" title="反向代理配置"></a>反向代理配置</h3><p>示例：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/20181220171320144.png" alt="在这里插入图片描述"></p><p>nginx中的每个server就是一个反向代理配置，可以有多个server</p><p>完整配置：</p><pre><code class="nginx">#user  nobody;worker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    gzip  on;    server {        listen       80;        server_name  manage.leyou.com;        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Server $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        location / {            proxy_pass http://127.0.0.1:9001;            proxy_connect_timeout 600;            proxy_read_timeout 600;        }    }    server {        listen       80;        server_name  api.leyou.com;        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Server $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        location / {            proxy_pass http://127.0.0.1:10010;            proxy_connect_timeout 600;            proxy_read_timeout 600;        }    }}</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>nginx可以通过命令行来启动，操作命令：</p><ul><li>启动：<code>start nginx.exe</code></li><li>停止：<code>nginx.exe -s stop</code></li><li>重新加载：<code>nginx.exe -s reload</code></li></ul><p>启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/20181222113315892.png" alt="在这里插入图片描述"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动nginx，然后用域名访问后台管理系统：<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/2018122017160322.png" alt="在这里插入图片描述"><br>现在实现了域名访问网站了，中间的流程是怎样的呢？<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-%E4%BD%BF%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/20181220171624185.png" alt="在这里插入图片描述"></p><ol><li>浏览器准备发起请求，访问 <code>http://mamage.leyou.com</code>，但需要进行域名解析</li><li>优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：<code>127.0.0.1</code></li><li>请求被发往解析得到的ip，并且默认使用80端口： <code>http://127.0.0.1:80</code><br>本机的nginx一直监听 <code>80</code> 端口，因此捕获这个请求</li><li>nginx中配置了反向代理规则，将 <code>manage.leyou.com</code> 代理到 <code>127.0.0.1:9001</code>，因此请求被转发</li><li>后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx</li><li>nginx将得到的结果返回到浏览器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nginx" scheme="https://www.xiongtianci.com/tags/Nginx/"/>
    
      <category term="反向代理" scheme="https://www.xiongtianci.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>win10使用Switchhost显示无修改权限</title>
    <link href="https://www.xiongtianci.com/2018/12/20/win10%E4%BD%BF%E7%94%A8Switchhost%E6%98%BE%E7%A4%BA%E6%97%A0%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/"/>
    <id>https://www.xiongtianci.com/2018/12/20/win10使用Switchhost显示无修改权限/</id>
    <published>2018-12-20T08:41:06.000Z</published>
    <updated>2019-06-12T09:09:06.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>使用Switchhost!操作电脑hosts文件时，显示无修改权限，即使使用管理员身份运行Switchhost!也是如此<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-win10%E4%BD%BF%E7%94%A8Switchhost%E6%98%BE%E7%A4%BA%E6%97%A0%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/20181220162929593.png" alt="在这里插入图片描述"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>找到<strong>hosts</strong>文件<br>路径：<code>C:\Windows\System32\drivers\etc</code></li><li>右键<strong>hosts</strong>，点击<strong>属性</strong>，选择<strong>安全</strong><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-win10%E4%BD%BF%E7%94%A8Switchhost%E6%98%BE%E7%A4%BA%E6%97%A0%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/2018122016401089.png" alt="在这里插入图片描述"></li><li>点击<strong>编辑</strong>，赋予<strong>Users</strong> <code>完全权限</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-win10%E4%BD%BF%E7%94%A8Switchhost%E6%98%BE%E7%A4%BA%E6%97%A0%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90/20181220164036629.png" alt="在这里插入图片描述"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="win10" scheme="https://www.xiongtianci.com/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>IDEA报错：Lombok Requires Annotation Processing</title>
    <link href="https://www.xiongtianci.com/2018/12/20/IDEA%E6%8A%A5%E9%94%99%EF%BC%9ALombok%20Requires%20Annotation%20Processing/"/>
    <id>https://www.xiongtianci.com/2018/12/20/IDEA报错：Lombok Requires Annotation Processing/</id>
    <published>2018-12-20T08:17:49.000Z</published>
    <updated>2019-06-12T09:10:29.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>Lombok安装完成之后，启动项目时出现 <code>Lombok Requires Annotation Processing</code> 的错误提示<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-IDEA%E6%8A%A5%E9%94%99%EF%BC%9ALombok%20Requires%20Annotation%20Processing/20181220161224759.png" alt="在这里插入图片描述"></p><pre><code>16:08    Lombok Requires Annotation Processing    Annotation processing seems to be disabled for the project &quot;leyou&quot;.    For the plugin to function correctly, please enable it under    &quot;Settings &gt; Build &gt; Compiler &gt; Annotation Processors&quot;</code></pre><p><br></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>依次点 <code>File</code> &rarr; <code>Settings</code> &rarr; <code>Build, Execution, Deploymen</code> &rarr; <code>Annotation Processors</code> 打开编辑页面，勾上 <code>Enable annotation processing</code> 前面的选框，保存重启IDEA即可解决<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181220-IDEA%E6%8A%A5%E9%94%99%EF%BC%9ALombok%20Requires%20Annotation%20Processing/20181220162024980.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="IDEA" scheme="https://www.xiongtianci.com/tags/IDEA/"/>
    
      <category term="踩坑" scheme="https://www.xiongtianci.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Java中clone()与new的区别？</title>
    <link href="https://www.xiongtianci.com/2018/12/20/Java%E4%B8%ADclone()%E4%B8%8Enew%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2018/12/20/Java中clone()与new的区别？/</id>
    <published>2018-12-20T03:27:48.000Z</published>
    <updated>2019-06-12T09:09:26.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要使用clone-？"><a href="#为什么要使用clone-？" class="headerlink" title="为什么要使用clone()？"></a>为什么要使用clone()？</h3><p>在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A 中已经包含了一些有效值，此时可能会需要一个和A 完全相同新对象B，并且此后对B 任何改动都不会影响到A 中的值，也就是说，A 与B 是两个独立的对象，但B 的初始值是由A 对象确定的。<br>在Java 语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现<code>clone()</code>方法是其中最简单，也是最高效的手段<br><br></p><h3 id="clone-与new的区别"><a href="#clone-与new的区别" class="headerlink" title="clone()与new的区别"></a>clone()与new的区别</h3><ol><li>clone()不会调用构造方法；new会调用构造方法</li><li>clone()更快。clone()能快速创建一个已有对象的副本，即创建对象并且将已有对象中所有属性值克隆；new只能在JVM中申请一个空的内存区域，对象的属性值要通过构造方法赋值</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>基本数据类型与String之间的转换</title>
    <link href="https://www.xiongtianci.com/2018/12/19/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.xiongtianci.com/2018/12/19/基本数据类型与String之间的转换/</id>
    <published>2018-12-19T13:12:35.000Z</published>
    <updated>2019-06-12T09:12:15.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串转基本数据类型"><a href="#字符串转基本数据类型" class="headerlink" title="字符串转基本数据类型"></a>字符串转基本数据类型</h3><p>调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型。<br><br></p><h3 id="基本数据类型转字符串"><a href="#基本数据类型转字符串" class="headerlink" title="基本数据类型转字符串"></a>基本数据类型转字符串</h3><p>一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String<br>类中的valueOf()方法返回相应字符串</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>为何short s1=1;是对的，而float f=3.4;是错的？</title>
    <link href="https://www.xiongtianci.com/2018/12/19/%E4%B8%BA%E4%BD%95short%20s1=1;%E6%98%AF%E5%AF%B9%E7%9A%84%EF%BC%8C%E8%80%8Cfloat%20f=3.4;%E6%98%AF%E9%94%99%E7%9A%84%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2018/12/19/为何short s1=1;是对的，而float f=3.4;是错的？/</id>
    <published>2018-12-19T12:42:28.000Z</published>
    <updated>2019-06-12T09:11:54.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Java中，没小数点的默认是<code>int</code> ,有小数点的默认是 <code>double</code></p></blockquote><p>编译器可以自动向上转型，如 int 转成 long 系统自动转换没有问题，因为后者精度更高 ；但如果是向下转型，就需要强制类型转换</p><p>short类型变量的初始化语句，只要不超过short范围( -215 ~ 215-1 )的就可以直接初始化，所以short s1 = 1;是对的；<br>而对于小数，默认情况下：<code>float f=3.4;</code>中的小数3.4此时为double类型。此时，等式<code>float f=3.4;</code>左边为float类型，等式右边为double类型，将涉及到强制类型转换，所以<code>float f=3.4;</code>这个写法是错误的，</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法指南</title>
    <link href="https://www.xiongtianci.com/2018/12/18/ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    <id>https://www.xiongtianci.com/2018/12/18/ES6语法指南/</id>
    <published>2018-12-18T08:10:28.000Z</published>
    <updated>2019-06-12T09:15:35.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：<a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a></p><p>链接：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p></blockquote><h1 id="ES6-语法指南"><a href="#ES6-语法指南" class="headerlink" title="ES6 语法指南"></a>ES6 语法指南</h1><p>后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。</p><p>什么是ES6？就是ECMAScript第6版标准。</p><h2 id="1-什么是ECMAScript？"><a href="#1-什么是ECMAScript？" class="headerlink" title="1.什么是ECMAScript？"></a>1.什么是ECMAScript？</h2><p>来看下前端的发展历程：</p><blockquote><p>web1.0时代：</p></blockquote><ul><li>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。<strong>开发人员也只关心页面的样式和内容</strong>即可。</li></ul><blockquote><p>web2.0时代：</p></blockquote><ul><li>1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。</li><li>1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。</li><li>1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了<code>ECMAscript</code>标准规范。JavaScript和JScript都是<code>ECMAScript</code>的标准实现者，随后各大浏览器厂商纷纷实现了<code>ECMAScript</code>标准。</li></ul><p>所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。</p><h2 id="2-ECMAScript的快速发展"><a href="#2-ECMAScript的快速发展" class="headerlink" title="2.ECMAScript的快速发展"></a>2.ECMAScript的快速发展</h2><p>而后，ECMAScript就进入了快速发展期。</p><ul><li><p>1998年6月，ECMAScript 2.0 发布。</p></li><li><p>1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。</p></li><li><p>2007年10月。。。。ECMAScript 4.0 草案发布。</p><p>这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。</p><ul><li>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。</li><li>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</li></ul><p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中</p></li><li><p>2009年12月，ECMAScript 5 发布。</p></li><li><p>2011年6月，ECMAScript 5.1 发布。</p></li><li><p>2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 </p></li></ul><h2 id="3-ES5和6的一些新特性"><a href="#3-ES5和6的一些新特性" class="headerlink" title="3.ES5和6的一些新特性"></a>3.ES5和6的一些新特性</h2><p>我们这里只把一些常用的进行学习，更详细的大家参考：<a href="http://es6.ruanyifeng.com/?search=reduce&amp;x=0&amp;y=0#README" target="_blank" rel="noopener">阮一峰的ES6教程</a></p><h3 id="3-1-let-和-const-命令"><a href="#3-1-let-和-const-命令" class="headerlink" title="3.1.let 和 const 命令"></a>3.1.let 和 const 命令</h3><blockquote><p>var</p></blockquote><p>之前，js定义变量只有一个关键字：<code>var</code></p><p><code>var</code>有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。</p><p>例如这样的一段代码：</p><pre><code class="js">for(var i = 0; i &lt; 5; i++){    console.log(i);}console.log(&quot;循环外：&quot; + i)</code></pre><p>你猜下打印的结果是什么？</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526107278999.png" alt="1526107278999"></p><blockquote><p>let</p></blockquote><p><code>let</code>所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><p>我们把刚才的<code>var</code>改成<code>let</code>试试：</p><pre><code class="js">for(let i = 0; i &lt; 5; i++){    console.log(i);}console.log(&quot;循环外：&quot; + i)</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526107347275.png" alt="1526107347275"></p><blockquote><p>const</p></blockquote><p><code>const</code>声明的变量是常量，不能被修改</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526107425000.png" alt="1526107425000"></p><h3 id="3-2-字符串扩展"><a href="#3-2-字符串扩展" class="headerlink" title="3.2.字符串扩展"></a>3.2.字符串扩展</h3><blockquote><p>新的API</p></blockquote><p>ES6为字符串扩展了几个新的API：</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><p>实验一下：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526107640349.png" alt="1526107640349"></p><blockquote><p>字符串模板</p></blockquote><p>ES6中提供了`来作为字符串模板标记。我们可以这么玩：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526108070980.png" alt="1526108070980"></p><p>在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本</p><p>键盘是的1的左侧，tab的上侧，esc的正下方</p><h3 id="3-3-解构表达式"><a href="#3-3-解构表达式" class="headerlink" title="3.3.解构表达式"></a>3.3.解构表达式</h3><blockquote><p>数组解构</p></blockquote><p>比如有一个数组：</p><pre><code class="js">let arr = [1,2,3]</code></pre><p>我想获取其中的值，只能通过角标。ES6可以这样：</p><pre><code class="js">const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z);</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526109778368.png" alt="1526109778368"></p><blockquote><p>对象解构</p></blockquote><p>例如有个person对象：</p><pre><code class="js">const person = {    name:&quot;jack&quot;,    age:21,    language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;]}</code></pre><p>我们可以这么做：</p><pre><code class="js">// 解构表达式获取值const {name,age,language} = person;// 打印console.log(name);console.log(age);console.log(language);</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526109984544.png" alt="1526109984544"></p><p>如过想要用其它变量接收，需要额外指定别名：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526110159450.png" alt="1526110159450"></p><ul><li><code>{name:n}</code>：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。</li></ul><h3 id="3-4-函数优化"><a href="#3-4-函数优化" class="headerlink" title="3.4.函数优化"></a>3.4.函数优化</h3><blockquote><p>函数参数默认值</p></blockquote><p>在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法：</p><pre><code class="js">    function add(a , b) {        // 判断b是否为空，为空就给默认值1        b = b || 1;        return a + b;    }    // 传一个参数    console.log(add(10));</code></pre><p>现在可以这么写：</p><pre><code class="js">function add(a , b = 1) {    return a + b;}// 传一个参数console.log(add(10));</code></pre><blockquote><p>箭头函数</p></blockquote><p>ES6中定义函数的简写方式：</p><p>一个参数时：</p><pre><code class="js">var print = function (obj) {    console.log(obj);}// 简写为：var print2 = obj =&gt; console.log(obj);</code></pre><p>多个参数：</p><pre><code class="js">// 两个参数的情况：var sum = function (a , b) {    return a + b;}// 简写为：var sum2 = (a,b) =&gt; a+b;</code></pre><p>代码不止一行，可以用<code>{}</code>括起来</p><pre><code class="js">var sum3 = (a,b) =&gt; {    return a + b;}</code></pre><blockquote><p>对象的函数属性简写</p></blockquote><p>比如一个Person对象，里面有eat方法：</p><pre><code class="js">let person = {    name: &quot;jack&quot;,    // 以前：    eat: function (food) {        console.log(this.name + &quot;在吃&quot; + food);    },    // 箭头函数版：    eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food),// 这里拿不到this    // 简写版：    eat3(food){        console.log(this.name + &quot;在吃&quot; + food);    }}</code></pre><blockquote><p>箭头函数结合解构表达式</p></blockquote><p>比如有一个函数：</p><pre><code class="js">const person = {    name:&quot;jack&quot;,    age:21,    language: [&#39;java&#39;,&#39;js&#39;,&#39;css&#39;]}function hello(person) {    console.log(&quot;hello,&quot; + person.name)}</code></pre><p>如果用箭头函数和解构表达式</p><pre><code class="js">var hi = ({name}) =&gt;  console.log(&quot;hello,&quot; + name);</code></pre><h3 id="3-5-map和reduce"><a href="#3-5-map和reduce" class="headerlink" title="3.5.map和reduce"></a>3.5.map和reduce</h3><p>数组中新增了map和reduce方法。</p><blockquote><p>map</p></blockquote><p><code>map()</code>：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p><p>举例：有一个字符串数组，我们希望转为int数组</p><pre><code class="js">let arr = [&#39;1&#39;,&#39;20&#39;,&#39;-5&#39;,&#39;3&#39;];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr)</code></pre><p>  <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526110796839.png" alt="1526110796839"></p><blockquote><p>reduce</p></blockquote><p><code>reduce()</code>：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数：</p><ul><li>第一个参数是上一次reduce处理的结果</li><li>第二个参数是数组中要处理的下一个元素</li></ul><p><code>reduce()</code>会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数</p><p>举例：</p><pre><code>const arr = [1,20,-5,3]</code></pre><p>没有初始值：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526111537204.png" alt="1526111537204"></p><p>指定初始值：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526111580742.png" alt="1526111580742"></p><h3 id="3-6-promise"><a href="#3-6-promise" class="headerlink" title="3.6.promise"></a>3.6.promise</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>感觉跟java的Future类很像啊，有木有！</p><p>我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。</p><p>语法：</p><pre><code class="js">const promise = new Promise(function(resolve, reject) {  // ... 执行异步操作  if (/* 异步操作成功 */){    resolve(value);// 调用resolve，代表Promise将返回成功的结果  } else {    reject(error);// 调用reject，代表Promise会返回失败结果  }});</code></pre><p>这样，在promise中就封装了一段异步执行的结果。</p><p>如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法：</p><pre><code class="js">promise.then(function(value){    // 异步执行成功后的回调});</code></pre><p>如果想要处理promise异步执行失败的事件，还可以跟上catch：</p><pre><code class="js">promise.then(function(value){    // 异步执行成功后的回调}).catch(function(error){    // 异步执行失败后的回调})</code></pre><p>示例：</p><pre><code>const p = new Promise(function (resolve, reject) {    // 这里我们用定时任务模拟异步    setTimeout(() =&gt; {        const num = Math.random();        // 随机返回成功或失败        if (num &lt; 0.5) {            resolve(&quot;成功！num:&quot; + num)        } else {            reject(&quot;出错了！num:&quot; + num)        }    }, 300)})// 调用promisep.then(function (msg) {    console.log(msg);}).catch(function (msg) {    console.log(msg);})</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526113115887.png" alt="1526113115887"></p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526113140074.png" alt="1526113140074"></p><h3 id="3-7-set和map（了解）"><a href="#3-7-set和map（了解）" class="headerlink" title="3.7.set和map（了解）"></a>3.7.set和map（了解）</h3><p>ES6提供了Set和Map的数据结构。</p><p>Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。</p><p>构造函数：</p><pre><code class="js">// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5]</code></pre><p>普通方法：</p><pre><code>set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。</code></pre><p>map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即：</p><ul><li>object是 &lt;string,object&gt;集合</li><li>map是&lt;object,object&gt;集合</li></ul><p>构造函数：</p><pre><code class="js">// map接收一个数组，数组中的元素是键值对数组const map = new Map([    [&#39;key1&#39;,&#39;value1&#39;],    [&#39;key2&#39;,&#39;value2&#39;],])// 或者接收一个setconst set = new Set([    [&#39;key1&#39;,&#39;value1&#39;],    [&#39;key2&#39;,&#39;value2&#39;],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map);</code></pre><p>方法：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1526114799767.png" alt="1526114799767"></p><h3 id="3-8-模块化"><a href="#3-8-模块化" class="headerlink" title="3.8.模块化"></a>3.8.模块化</h3><h4 id="3-8-1-什么是模块化"><a href="#3-8-1-什么是模块化" class="headerlink" title="3.8.1.什么是模块化"></a>3.8.1.什么是模块化</h4><p>模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。</p><p>而JS中没有包的概念，换来的是 模块。</p><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。</p><ul><li><code>export</code>命令用于规定模块的对外接口，</li><li><code>import</code>命令用于导入其他模块提供的功能。</li></ul><h4 id="3-8-2-export"><a href="#3-8-2-export" class="headerlink" title="3.8.2.export"></a>3.8.2.export</h4><p>比如我定义一个js文件:hello.js，里面有一个对象：</p><pre><code class="js">const util = {    sum(a,b){        return a + b;    }}</code></pre><p>我可以使用export将这个对象导出：</p><pre><code class="js">const util = {    sum(a,b){        return a + b;    }}export util;</code></pre><p>当然，也可以简写为：</p><pre><code class="js">export const util = {    sum(a,b){        return a + b;    }}</code></pre><p><code>export</code>不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。</p><p>当要导出多个值时，还可以简写。比如我有一个文件：user.js：</p><pre><code class="js">var name = &quot;jack&quot;var age = 21export {name,age}</code></pre><blockquote><p>省略名称</p></blockquote><p>上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。</p><p>因此js提供了<code>default</code>关键字，可以对导出的变量名进行省略</p><p>例如：</p><pre><code class="js">// 无需声明对象的名字export default {    sum(a,b){        return a + b;    }}</code></pre><p>这样，当使用者导入时，可以任意起名字</p><h4 id="3-8-3-import"><a href="#3-8-3-import" class="headerlink" title="3.8.3.import"></a>3.8.3.import</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><p>例如我要使用上面导出的util：</p><pre><code class="js">// 导入utilimport util from &#39;hello.js&#39;// 调用util中的属性util.sum(1,2)</code></pre><p>要批量导入前面导出的name和age： </p><pre><code class="js">import {name, age} from &#39;user.js&#39;console.log(name + &quot; , 今年&quot;+ age +&quot;岁了&quot;)</code></pre><p>但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如<code>Babel-cli</code>工具</p><p> 我们暂时不做测试，大家了解即可。</p><h3 id="3-9-对象扩展"><a href="#3-9-对象扩展" class="headerlink" title="3.9.对象扩展"></a>3.9.对象扩展</h3><p>ES6给Object拓展了许多新的方法，如：</p><ul><li>keys(obj)：获取对象的所有key形成的数组</li><li>values(obj)：获取对象的所有value形成的数组</li><li>entries(obj)：获取对象的所有key和value形成的二维数组。格式：<code>[[k1,v1],[k2,v2],...]</code></li><li><p>assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181218-ES6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/1527210872966.png" alt="1527210872966"></p></li></ul><h3 id="3-10-数组扩展"><a href="#3-10-数组扩展" class="headerlink" title="3.10.数组扩展"></a>3.10.数组扩展</h3><p>ES6给数组新增了许多方法：</p><ul><li>find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素</li><li>findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引</li><li>includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。</li></ul>]]></content>
    
    <summary type="html">
    
      ES6语法指南
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="转载" scheme="https://www.xiongtianci.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="ES6" scheme="https://www.xiongtianci.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>IntellijIDEA使用时的小技巧</title>
    <link href="https://www.xiongtianci.com/2018/12/17/Intellij%20IDEA%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://www.xiongtianci.com/2018/12/17/Intellij IDEA使用时的小技巧/</id>
    <published>2018-12-17T10:24:16.000Z</published>
    <updated>2019-06-12T09:16:45.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Inject-language编写JSON字符串"><a href="#使用Inject-language编写JSON字符串" class="headerlink" title="使用Inject language编写JSON字符串"></a>使用Inject language编写JSON字符串</h1><p>如果你使用IDEA在编写JSON字符串的时候，然后要一个一个<code>\</code>去转义双引号的话，就实在太不应该了，又烦又容易出错。在IDEA可以使用<code>Inject language</code>帮我们自动转义双引号</p><ol><li>在双引号内 <code>Alt+回车</code>，选择<code>Inject language or reference</code>，然后回车<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181217-Intellij%20IDEA%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/20181217181824340.png" alt="在这里插入图片描述"></li><li>输入 <strong>json</strong>，在列表中选择 json组件，回车<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181217-Intellij%20IDEA%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/20181217181753821.png" alt="在这里插入图片描述"></li><li>选择完后，在双引号内<code>Alt+回车</code>，选择<code>Edit JSON Fragment</code>，回车<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181217-Intellij%20IDEA%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/20181217181854421.png" alt="在这里插入图片描述"></li><li>此时将弹出编辑JSON文件的视图了<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181217-Intellij%20IDEA%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/20181217182000472.png" alt="在这里插入图片描述"></li></ol><p>可以看到IDEA确实帮我们自动转义双引号了。如果要退出编辑JSON信息的视图，只需要使用<code>Ctrl+F4</code>快捷键即可。</p><hr><h1 id="Structure展示一个类的所有方法"><a href="#Structure展示一个类的所有方法" class="headerlink" title="Structure展示一个类的所有方法"></a>Structure展示一个类的所有方法</h1><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181217-Intellij%20IDEA%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/20181217190146126.png" alt="在这里插入图片描述"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181217-Intellij%20IDEA%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/20181217190405526.png" alt="在这里插入图片描述"><br>或者使用<code>Ctrl+F12</code>弹框查看当前类的所有方法</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="IDEA" scheme="https://www.xiongtianci.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>自定义百度云分享密码</title>
    <link href="https://www.xiongtianci.com/2018/12/14/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/"/>
    <id>https://www.xiongtianci.com/2018/12/14/自定义百度云分享密码/</id>
    <published>2018-12-14T01:13:35.000Z</published>
    <updated>2019-06-12T09:17:09.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>打开百度云盘网页版</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544750054257.png" alt="1544750054257"></p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>找到需要分享的资源，点击分享之后看见下面内容：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544750254778.png" alt="1544750254778"></p><p>别动，重点的在后面</p><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>按下F12，进入开发者模式，点击 consle 进入控制台，如下图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544750550143.png" alt="1544750550143"></p><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><p>在控制台中输入下面代码，按下回车</p><blockquote><p>avascript:require([“function-widget-1:share/util/shareFriend/createLinkShare.js”]).prototype.makePrivatePassword=function(){return prompt(“请输入自定义的密码”,”1234”)}</p></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544750784118.png" alt="1544750784118"></p><h1 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h1><p>关闭开发者模式，点击“创建链接”，输入你想要自定义的密码，回车确定即可</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544751090180.png" alt="1544751090180"></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544751100617.png" alt="1544751100617"></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544751152701.png" alt="1544751152701"></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181214-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BE%E5%BA%A6%E4%BA%91%E5%88%86%E4%BA%AB%E5%AF%86%E7%A0%81/1544751191191.png" alt="1544751191191"></p>]]></content>
    
    <summary type="html">
    
      自定义百度云分享密码
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="百度网盘" scheme="https://www.xiongtianci.com/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序笔记</title>
    <link href="https://www.xiongtianci.com/2018/12/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.xiongtianci.com/2018/12/11/微信小程序笔记/</id>
    <published>2018-12-11T13:15:58.000Z</published>
    <updated>2019-06-12T09:17:44.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序账号与工具"><a href="#微信小程序账号与工具" class="headerlink" title="微信小程序账号与工具"></a>微信小程序账号与工具</h1><p>在线文档：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/</a></p><h2 id="小程序开发者账号注册"><a href="#小程序开发者账号注册" class="headerlink" title="小程序开发者账号注册"></a>小程序开发者账号注册</h2><p>微信公众平台：<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a></p><p>小程序开发者账号注册：<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a></p><h2 id="微信开发者工具"><a href="#微信开发者工具" class="headerlink" title="微信开发者工具"></a>微信开发者工具</h2><p>微信开发者工具：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html</a></p><h2 id="小程序在线Demo二维码"><a href="#小程序在线Demo二维码" class="headerlink" title="小程序在线Demo二维码"></a>小程序在线Demo二维码</h2><p>体验小程序官方源码：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip</a></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181211-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/weChatAppdemo.jpg?raw=true"></p><h1 id="微信小程序文件结构"><a href="#微信小程序文件结构" class="headerlink" title="微信小程序文件结构"></a>微信小程序文件结构</h1><h2 id="主体文件结构"><a href="#主体文件结构" class="headerlink" title="主体文件结构"></a>主体文件结构</h2><p>主体部分由三个文件组成，必须放在项目的根目录，如下：</p><table><thead><tr><th>文件</th><th>必填</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html" target="_blank" rel="noopener">app.js</a></td><td>是</td><td>小程序逻辑</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="noopener">app.json</a></td><td>是</td><td>小程序公共设置</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html" target="_blank" rel="noopener">app.wxss</a></td><td>否</td><td>小程序公共样式表</td></tr></tbody></table><h2 id="页面文件结构"><a href="#页面文件结构" class="headerlink" title="页面文件结构"></a>页面文件结构</h2><p>页面由四个文件组成，分别是：</p><table><thead><tr><th>文件类型</th><th>必填</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html" target="_blank" rel="noopener">js</a></td><td>是</td><td>页面逻辑 ( 微信小程序没有window和document对象 )</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/" target="_blank" rel="noopener">wxml</a></td><td>是</td><td>页面结构  ( XML语法，不是HTML语法 )</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html" target="_blank" rel="noopener">wxss</a></td><td>否</td><td>页面样式表 ( <strong>拓展了rpx尺寸单位，微信专属响应式像素</strong> )</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pagejson" target="_blank" rel="noopener">json</a></td><td>否</td><td>页面配置  ( 不能写注释，否则编译报错 )</td></tr></tbody></table><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181211-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/fileTree.png"></p><h1 id="WXML-结构-基础-标签、组件"><a href="#WXML-结构-基础-标签、组件" class="headerlink" title="WXML 结构_基础 (标签、组件)"></a>WXML 结构_基础 (标签、组件)</h1><p>组件文档：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/component/</a></p><h2 id="常用布局标签-组件"><a href="#常用布局标签-组件" class="headerlink" title="常用布局标签(组件)"></a>常用布局标签(组件)</h2><pre><code class="xml">&lt;view&gt;&lt;/view&gt;                相当于    &lt;div&gt;&lt;/div&gt;&lt;text&gt;&lt;/text&gt;                相当于    &lt;span&gt;&lt;/span&gt;&lt;image&gt;&lt;/image&gt;                相当于    &lt;img /&gt;&lt;navigator&gt;&lt;/navigator&gt;        相当于    &lt;a&gt;&lt;/a&gt;&lt;block&gt;&lt;/block&gt;                区块标签，不会渲染到页面</code></pre><p><strong>注意：image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高</strong></p><h2 id="常用表单标签-组件"><a href="#常用表单标签-组件" class="headerlink" title="常用表单标签(组件)"></a>常用表单标签(组件)</h2><pre><code class="xml">&lt;button&gt;&lt;/button&gt;&lt;input type=&quot;text&quot; /&gt;                &lt;checkbox /&gt;&lt;radio/&gt;</code></pre><h2 id="轮播图组件"><a href="#轮播图组件" class="headerlink" title="轮播图组件"></a>轮播图组件</h2><pre><code class="xml">&lt;swiper indicator-dots=&quot;是否显示面板指示点&quot; autoplay=&quot;是否自动切换&quot; interval=&quot;自动切换时间间隔&quot; duration=&quot;滑动动画时长&quot;&gt;    &lt;swiper-item&gt;          &lt;image src=&quot;图片路径1&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt;    &lt;/swiper-item&gt;    &lt;swiper-item&gt;          &lt;image src=&quot;图片路径2&quot; width=&quot;375&quot; height=&quot;150&quot;/&gt;    &lt;/swiper-item&gt;&lt;/swiper&gt;</code></pre><p>探索：实现无缝轮播怎么办？</p><h1 id="WXSS-样式"><a href="#WXSS-样式" class="headerlink" title="WXSS 样式"></a>WXSS 样式</h1><p>WXSS (WeiXin Style Sheets) 是一套样式语言。</p><p>WXSS文档： <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html</a></p><h2 id="WXSS-新增特性"><a href="#WXSS-新增特性" class="headerlink" title="WXSS 新增特性"></a>WXSS 新增特性</h2><p>与 CSS 相比，WXSS 扩展以下2个特性：</p><ul><li>尺寸单位      rpx ( responsive pixel 响应式像素) </li><li>样式导入      @import  “样式表路径”;</li></ul><h2 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h2><ul><li>rpx  ( responsive pixel 响应式像素) : 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li><li><strong>建议：</strong> 开发微信小程序时设计师可以用 <code>iPhone6</code> 作为视觉稿的标准。</li></ul><h1 id="JSON-配置"><a href="#JSON-配置" class="headerlink" title="JSON 配置"></a>JSON 配置</h1><p>配置文档：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html</a></p><h2 id="app-json-配置项列表"><a href="#app-json-配置项列表" class="headerlink" title="app.json 配置项列表"></a>app.json 配置项列表</h2><blockquote><p><code>app.json</code> 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pages" target="_blank" rel="noopener">pages</a></td><td>String Array</td><td>是</td><td>设置页面路径</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#window" target="_blank" rel="noopener">window</a></td><td>Object</td><td>否</td><td>设置默认页面的窗口表现</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar" target="_blank" rel="noopener">tabBar</a></td><td>Object</td><td>否</td><td>设置底部 tab 的表现</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#networktimeout" target="_blank" rel="noopener">networkTimeout</a></td><td>Object</td><td>否</td><td>设置网络超时时间</td></tr><tr><td><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#debug" target="_blank" rel="noopener">debug</a></td><td>Boolean</td><td>否</td><td>设置是否开启 debug 模式</td></tr></tbody></table></blockquote><p>如：<code>app.json</code> </p><pre><code class="javascript">{  &quot;pages&quot;: [    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;  ],  &quot;window&quot;: {    &quot;navigationBarTitleText&quot;: &quot;小程序标题&quot;  },  &quot;tabBar&quot;: {    &quot;list&quot;: [{      &quot;pagePath&quot;: &quot;pages/index/index&quot;,      &quot;text&quot;: &quot;首页&quot;    }, {      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,      &quot;text&quot;: &quot;Tab栏&quot;    }]  },  &quot;networkTimeout&quot;: {    &quot;request&quot;: 10000,    &quot;downloadFile&quot;: 10000  },  &quot;debug&quot;: true}</code></pre><h2 id="window-配置"><a href="#window-配置" class="headerlink" title="window 配置"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#window" target="_blank" rel="noopener">window</a> 配置</h2><blockquote><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p></blockquote><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>navigationBarBackgroundColor</td><td>HexColor</td><td>#000000</td><td>导航栏背景颜色，如”#000000”</td></tr><tr><td>navigationBarTextStyle</td><td>String</td><td>white</td><td>导航栏标题颜色，仅支持 black/white</td></tr><tr><td>navigationBarTitleText</td><td>String</td><td></td><td>导航栏标题文字内容</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>#ffffff</td><td>窗口的背景色</td></tr><tr><td>backgroundTextStyle</td><td>String</td><td>dark</td><td>下拉背景字体、loading 图的样式，仅支持 dark/light</td></tr><tr><td>enablePullDownRefresh</td><td>Boolean</td><td>false</td><td>是否开启下拉刷新，详见<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html#页面相关事件处理函数" target="_blank" rel="noopener">页面相关事件处理函数</a>。</td></tr><tr><td>onReachBottomDistance</td><td>Number</td><td>50</td><td>页面上拉触底事件触发时距页面底部距离，单位为px</td></tr></tbody></table><h3 id="window-配置图示"><a href="#window-配置图示" class="headerlink" title="window 配置图示"></a>window 配置图示</h3><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181211-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/config.jpg?raw=true"></p><h3 id="window-配置注意事项"><a href="#window-配置注意事项" class="headerlink" title="window 配置注意事项"></a>window 配置注意事项</h3><blockquote><p>!! 注意：页面的<code>.json</code>只能设置 <code>window</code> 相关的配置项，以决定本页面的窗口表现，所以无需写 <code>window</code> 这个关键词。</p></blockquote><p>如：/pages/message/message.json</p><pre><code class="javascript">{    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,    &quot;navigationBarTitleText&quot;: &quot;内页标题修改&quot;,    &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,    &quot;backgroundTextStyle&quot;: &quot;light&quot;}</code></pre><h2 id="tabBar-配置"><a href="#tabBar-配置" class="headerlink" title="tabBar 配置"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar" target="_blank" rel="noopener">tabBar</a> 配置</h2><p>如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p><p><strong>属性说明：</strong></p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>HexColor</td><td>是</td><td></td><td>tab 上的文字默认颜色</td></tr><tr><td>selectedColor</td><td>HexColor</td><td>是</td><td></td><td>tab 上的文字选中时的颜色</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>是</td><td></td><td>tab 的背景色</td></tr><tr><td>borderStyle</td><td>String</td><td>否</td><td>black</td><td>tabbar上边框的颜色， 仅支持 black/white</td></tr><tr><td>list</td><td>Array</td><td>是</td><td></td><td>tab 的列表，详见 list 属性说明，最少2个、最多5个 tab</td></tr><tr><td>position</td><td>String</td><td>否</td><td>bottom</td><td>可选值 bottom、top，设置成top是无图标</td></tr></tbody></table><p>其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：</p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>pagePath</td><td>String</td><td>是</td><td>页面路径，必须在 pages 中先定义</td></tr><tr><td>text</td><td>String</td><td>是</td><td>tab 上按钮文字</td></tr><tr><td>iconPath</td><td>String</td><td>否</td><td>图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效</td></tr><tr><td>selectedIconPath</td><td>String</td><td>否</td><td>选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效</td></tr></tbody></table><h3 id="tabBar-配置图示"><a href="#tabBar-配置图示" class="headerlink" title="tabBar 配置图示"></a>tabBar 配置图示</h3><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181211-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/tabBar.png"></p><h3 id="tabBar-配置注意事项"><a href="#tabBar-配置注意事项" class="headerlink" title="tabBar 配置注意事项"></a>tabBar 配置注意事项</h3><blockquote><ol><li>当设置 position 为 top 时，将不会显示 icon。</li><li>tabBar 中的 list 是一个数组，<strong>只能配置最少2个、最多5个 tab</strong>，tab 按数组的顺序排序。</li><li>icon 大小限制为40kb，建议尺寸为 81px * 81px。</li></ol></blockquote><h1 id="JS-行为-逻辑"><a href="#JS-行为-逻辑" class="headerlink" title="JS 行为(逻辑)"></a>JS 行为(逻辑)</h1><h2 id="微信小程序生命周期函数"><a href="#微信小程序生命周期函数" class="headerlink" title="微信小程序生命周期函数"></a>微信小程序生命周期函数</h2><pre><code class="javascript">Page({  /** 页面的初始数据 */  data: {  },  /** 生命周期函数--监听页面加载 */  onLoad: function (options) {      console.log(options);  },  /** 生命周期函数--监听页面初次渲染完成 */  onReady: function () {  },  /** 生命周期函数--监听页面显示 */  onShow: function () {  },  /** 生命周期函数--监听页面隐藏 */  onHide: function () {  },  /** 生命周期函数--监听页面卸载 */  onUnload: function () {  }})</code></pre><h2 id="页面相关事件处理函数"><a href="#页面相关事件处理函数" class="headerlink" title="页面相关事件处理函数"></a>页面相关事件处理函数</h2><pre><code class="javascript"> /** 页面相关事件处理函数--监听用户下拉动作 */  onPullDownRefresh: function () {  },  /** 页面上拉触底事件的处理函数 */  onReachBottom: function () {  },  /** 用户点击右上角分享 */  onShareAppMessage: function () {  }</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>微信小程序没有BOM和DOM概念，所以不能使用window对象和document对象。</p></blockquote><h1 id="WXML-高级-指令、事件"><a href="#WXML-高级-指令、事件" class="headerlink" title="WXML  高级(指令、事件)"></a>WXML  高级(指令、事件)</h1><h2 id="数据绑定-123-123-125-125"><a href="#数据绑定-123-123-125-125" class="headerlink" title="数据绑定  &#123;&#123; &#125;&#125;"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html" target="_blank" rel="noopener">数据绑定</a>  &#123;&#123; &#125;&#125;</h2><pre><code class="xml">&lt;!--wxml--&gt;&lt;view&gt; {{message}} &lt;/view&gt;</code></pre><pre><code class="javascript">// page.jsPage({  data: {    message: &#39;Hello MINA!&#39;  }})</code></pre><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li><strong>花括号和引号之间不能有空格。</strong></li><li><strong>不要直接写 checked=”false”，其计算结果是一个字符串，转成 boolean 类型后代表真值。</strong></li></ol><pre><code class="xml">&lt;checkbox checked=&quot;false&quot;&gt; &lt;/checkbox&gt;                    其计算结果是一个字符串，转成 boolean 类型后变成了 true&lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt;                正确写法</code></pre><h2 id="列表渲染-wx-for"><a href="#列表渲染-wx-for" class="headerlink" title="列表渲染  wx:for"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html" target="_blank" rel="noopener">列表渲染</a>  wx:for</h2><pre><code class="xml">&lt;!--wxml--&gt;&lt;view wx:for=&quot;{{array}}&quot;&gt; {{item}} &lt;/view&gt;</code></pre><pre><code class="javascript">// page.jsPage({  data: {    array: [1, 2, 3, 4, 5]  }})</code></pre><h3 id="wx-key"><a href="#wx-key" class="headerlink" title="wx:key"></a>wx:key</h3><p>主要功能：提高列表渲染时排序的效率。</p><p><code>wx:key</code> 的值以两种形式提供：</p><ol><li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li><li>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。</li></ol><blockquote><p>如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p></blockquote><h2 id="条件渲染-wx-if-wx-else-wx-elif"><a href="#条件渲染-wx-if-wx-else-wx-elif" class="headerlink" title="条件渲染  wx:if   wx:else   wx:elif"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html" target="_blank" rel="noopener">条件渲染</a>  wx:if   wx:else   wx:elif</h2><pre><code class="xml">&lt;!--wxml--&gt;&lt;view wx:if=&quot;{{length >= 80}}&quot;&gt; 优秀 &lt;/view&gt;&lt;view wx:elif=&quot;{{length >= 60}}&quot;&gt; 良好 &lt;/view&gt;&lt;view wx:else&gt; 加油 &lt;/view&gt;</code></pre><pre><code class="javascript">// page.jsPage({  data: {    length: &#39;95&#39;  }})</code></pre><h3 id="wx-if-与-hidden-区别"><a href="#wx-if-与-hidden-区别" class="headerlink" title="wx:if 与 hidden 区别"></a><code>wx:if</code> 与 <code>hidden</code> 区别</h3><p> <code>wx:if</code>  是否渲染， <code>hidden</code>  是否隐藏。</p><p>一般来说，<code>wx:if</code> 有更高的切换消耗而 <code>hidden</code> 有更高的初始渲染消耗。</p><p>因此，如果需要频繁切换的情景下，用 <code>hidden</code> 更好。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html" target="_blank" rel="noopener">事件</a></h2><ul><li>事件对象可以获取额外信息，如 id, dataset(自定义属性集合), touches(触摸点坐标)。</li></ul><h3 id="事件绑定和冒泡"><a href="#事件绑定和冒泡" class="headerlink" title="事件绑定和冒泡"></a>事件绑定和冒泡</h3><ol><li>冒泡事件    bind事件类型        如     <code>bindtap</code>   <code>bindlongpress</code></li><li>非冒泡事件    catch事件类型    如  <code>catchtap</code>   <code>catchlongpress</code></li></ol><h3 id="常用事件类型"><a href="#常用事件类型" class="headerlink" title="常用事件类型"></a>常用事件类型</h3><table><thead><tr><th>类型</th><th>触发条件</th></tr></thead><tbody><tr><td>tap</td><td>手指触摸后马上离开</td></tr><tr><td>longpress</td><td>手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td></tr></tbody></table><pre><code class="xml">&lt;!--wxml--&gt;&lt;view data-index=&quot;自定义属性&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt;</code></pre><pre><code class="javascript">// page.jsPage({  tapHandle: function(event) {    console.log(event)  }})</code></pre><h3 id="事件传参注意"><a href="#事件传参注意" class="headerlink" title="事件传参注意"></a>事件传参注意</h3><p>小程序绑定事件只能写函数名称，不能通过括号方式传参。</p><pre><code class="xml">&lt;!--wxml--&gt;&lt;view bindtap=&quot;tapHandle(520)&quot;&gt; 点我触发事件 &lt;/view&gt;                                错误，事件不能触发&lt;view data-index=&quot;520&quot; bindtap=&quot;tapHandle&quot;&gt; 点我触发事件 &lt;/view&gt;    </code></pre><pre><code class="javascript">// page.jsPage({  tapHandle: function(event) {     console.log( event.target.dataset.index );  // 输出标签自定义属性上的index值  }})</code></pre><h2 id="WXS-脚本"><a href="#WXS-脚本" class="headerlink" title="WXS  脚本"></a>WXS  脚本</h2><p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，功能类似<code>&lt;script&gt;</code>标签，主要用于在视图层定义函数(比较少用)。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。</li><li>wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。</li><li>wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。</li><li>wxs 函数不能作为组件的事件回调。</li><li>由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。</li></ol><pre><code class="xml">&lt;!--wxml--&gt;&lt;wxs module=&quot;foo&quot;&gt;var sum = function(a,b){  return a+b;};// 这里可以导出一个对象，这个对象可以直接在界面上使用 module.exports.sum = sum;&lt;/wxs&gt;&lt;view&gt; {{foo.sum(1,2)}} &lt;/view&gt;</code></pre><h1 id="微信开发者工具常用快捷键"><a href="#微信开发者工具常用快捷键" class="headerlink" title="微信开发者工具常用快捷键"></a>微信开发者工具常用快捷键</h1><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>Shift + Alt + F</td><td>格式化代码</td></tr><tr><td>Ctrl + P</td><td>跳到文件</td></tr><tr><td>Ctrl + E</td><td>跳到最近文件</td></tr><tr><td>Ctrl + Shift + P</td><td>上传扫码预览</td></tr><tr><td>Ctrl + Shift + I</td><td>显示/隐藏调试器</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      小程序基础
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="微信小程序" scheme="https://www.xiongtianci.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix状态</title>
    <link href="https://www.xiongtianci.com/2018/12/07/Hystrix%E7%8A%B6%E6%80%81/"/>
    <id>https://www.xiongtianci.com/2018/12/07/Hystrix状态/</id>
    <published>2018-12-07T00:12:05.000Z</published>
    <updated>2019-06-12T09:17:59.626Z</updated>
    
    <content type="html"><![CDATA[<p>@SpringCloudApplication 相当于：@EnableCircuitBreaker、@EnableDiscoveryClilent、@SpringBootApplication</p><h3 id="熔断器状态的相关配置"><a href="#熔断器状态的相关配置" class="headerlink" title="熔断器状态的相关配置"></a>熔断器状态的相关配置</h3><p>@HystrixProperty相关配置在抽象类：package com.netflix.hystrix.HystrixCommandProperties 中</p><p><strong>熔断器开启或者关闭的条件：</strong></p><p>1、  当满足一定的阀值的时候（默认10秒内超过20个请求次数）</p><p>2、  当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p><p>3、  到达以上阀值，断路器将会开启</p><p>4、  当开启的时候，所有请求都不会进行转发</p><p>5、  一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5。</p><pre><code class="java">// 开启服务降级@HystrixCommand(        // 熔断器状态相关配置        commandProperties = {                // 当请求次数达到10次时才能开启熔断                @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),                // 状态变换的时间，由开启 --&gt; 半开                @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;20000&quot;),                // 失败请求/所有请求=60% --&gt; 开启熔断器                @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;)        })</code></pre>]]></content>
    
    <summary type="html">
    
      Hystrix状态
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.xiongtianci.com/tags/SpringCloud/"/>
    
      <category term="Hystrix" scheme="https://www.xiongtianci.com/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>HashSet如何去重？</title>
    <link href="https://www.xiongtianci.com/2018/12/06/HashSet%E5%A6%82%E4%BD%95%E5%8E%BB%E9%87%8D/"/>
    <id>https://www.xiongtianci.com/2018/12/06/HashSet如何去重/</id>
    <published>2018-12-06T02:37:51.000Z</published>
    <updated>2019-06-10T01:35:22.008Z</updated>
    
    <content type="html"><![CDATA[<p>&lt; !– more –&gt;<br>HashSet存储元素的原理：<br>往hashSet添加元素的时候，首先会调用元素的 <code>hashCode</code> 方法得到元素的哈希码值，然后把哈希码值经过运算算出该元素存在哈希表中的位置。有两种情况：</p><ul><li><p>情况1：如果算出的位置目前还没有存在任何的元素，那么该元素可以直接添加到哈希表中。</p></li><li><p>情况2： 如果算出的位置目前已经存在其他的元素，那么还会调用元素的 <code>equals</code> 方法再与这个位置上的元素比较一次。<br>如果 <code>equals</code> 方法返回的是true，那么该元素被视为重复元素，不允许添加。如果equals方法返回的是false，那么该元素也可以被添加。  </p></li></ul><h2 id="先看个最简单的构造方法"><a href="#先看个最简单的构造方法" class="headerlink" title="先看个最简单的构造方法"></a>先看个最简单的构造方法</h2><pre><code class="java">* Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has* default initial capacity (16) and load factor (0.75).*/public HashSet() {    map = new HashMap&lt;&gt;();}</code></pre><p>很明显，HashSet底层是Hashmap存储的。借大神的话</p><blockquote><p>HashSet 就是HashMap的马甲       —–someone</p></blockquote><h2 id="再看看add方法"><a href="#再看看add方法" class="headerlink" title="再看看add方法"></a>再看看add方法</h2><pre><code class="java">// Dummy value to associate with an Object in the backing Map private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object();/**     * Adds the specified element to this set if it is not already present.     * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if     * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that     * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.     * If this set already contains the element, the call leaves the set     * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.     *     * @param e element to be added to this set     * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified     * element     */    public boolean add(E e) {        return map.put(e, PRESENT)==null;    }</code></pre><p>add方法的参数：</p><ul><li>map：map是一个HashMap的实例</li><li>e：我们要存储的值，是HashMap的key</li><li>PRESENT：固定值( Object PRESENT = new Object(); )，空的obj对象</li></ul><p>Set偷偷的用了HashMap的 <code>put</code> 方法，然而HashMap并没有去重的功能呀，那么Set是如何做到去重的呢？</p><p>从add方法中可以看到，E是我们要存储的值，而到了HashMap里面却变成了Key，PRESENT就是个空对象。</p><p>在HashMap中Key的HashCode是决定底层数组的下标，进一步使用 <code>equals</code> 进行遍历对象链表中的<strong>Key</strong>进而覆盖原来的Value。</p><p>那么对于HashSet，如果 <code>e</code> 已经存在（先HashCode相同定位到链表，然后equals比较定位到具体的Node），那么覆盖oldValue（value其实就是个傀儡，没啥用），Key不变；如果不存在，就添加一个新的节点（即加了一个新的Key）。</p><p>HashMap的返回值是oldValue，oldValue==null说明节点之前不存在；反之说明节点存在，虽然返回false但实际上还是对底层数据进行了改变（即旧的空对象变成了新的空对象）。</p><p>总而言之，HashSet确定相同的方式其实就是HashCode相同（才能找到同一链表），然后equals的返回值（才能比较具体节点进行覆盖）。</p><h2 id="重点看key（敲黑板）"><a href="#重点看key（敲黑板）" class="headerlink" title="重点看key（敲黑板）"></a>重点看key（敲黑板）</h2><p>HashMap中的put方法</p><pre><code class="java">public V put(K key, V value) {        return putVal(hash(key), key, value, false, true);    }   /**     * Implements Map.put and related methods     *     * @param hash hash for key     * @param key the key     * @param value the value to put     * @param onlyIfAbsent if true, don&#39;t change existing value     * @param evict if false, the table is in creation mode.     * @return previous value, or null if none     */    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else {            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else {                for (int binCount = 0; ; ++binCount) {                    if ((e = p.next) == null) {                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    }                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                }            }            if (e != null) { // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            }        }        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    }</code></pre><p><strong>这里边有两个看点：</strong></p><ul><li>HashMap中key存储是hash后的值，对于String类型的相同值的hash值是一致的（其他接触类型类似，自定义对象类型需要重写hashcode方法与equel方法）。换句话说相同的值在hashMap中的存储位置是一样的。</li><li>基于上一点来看看怎么存储重复值的。如下代码对于hashMap中已经存在的key，key不变，新value覆盖就value。对于HashSet而言新旧value都是PRESENT对象，所以set在存储的时候就不会重复。</li></ul><pre><code class="java">if (e != null) { // existing mapping for key    V oldValue = e.value;    if (!onlyIfAbsent || oldValue == null)        e.value = value;        afterNodeAccess(e);    return oldValue;}</code></pre><p>所以hashset中存储的值输出的顺序和存储的先后顺序不一致，这是因为hashset是按照值的hash顺序进行输出。</p>]]></content>
    
    <summary type="html">
    
      HeshSet如何去重
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="HashSet" scheme="https://www.xiongtianci.com/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>IDEA常用快捷键</title>
    <link href="https://www.xiongtianci.com/2018/12/04/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://www.xiongtianci.com/2018/12/04/IDEA常用快捷键/</id>
    <published>2018-12-04T07:45:52.000Z</published>
    <updated>2019-06-12T09:18:51.530Z</updated>
    
    <content type="html"><![CDATA[<p><code>Ctrl+Alt+D</code> –&gt; 查看当前类的实现类</p><p>ctrl+l –&gt; 重写方法</p>]]></content>
    
    <summary type="html">
    
      IDEA常用快捷键
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="IDEA" scheme="https://www.xiongtianci.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA创建SpringBoot开启找回RunDashboard</title>
    <link href="https://www.xiongtianci.com/2018/12/04/IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/"/>
    <id>https://www.xiongtianci.com/2018/12/04/IDEA创建SpringBoot开启找回RunDashboard/</id>
    <published>2018-12-04T06:32:05.000Z</published>
    <updated>2019-06-14T03:07:36.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Run-Dashboard-面板"><a href="#Run-Dashboard-面板" class="headerlink" title="Run Dashboard 面板"></a>Run Dashboard 面板</h1><p><strong>Run Dashboard</strong>：微服务项目的开发过程中，工程会非常多，经常要启动很多个服务，才能完成一项测试。启动的多了，容易给开发者带来错乱的感觉，很不方便管理。IDEA开发工具推荐了一个很好用的功能–Run Dashboard。他是 Run 的升级版</p><p>我们可以对比一下这个是Run Dashboard的窗口</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543905902634.png" alt="1543905902634"> </p><p>普通的Run窗口：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543905965611.png" alt="1543905965611"> </p><p>显然如果启动多个端口Run Dashboard窗口显得更好管理。<br>一般有时候创建springboot项目的时候右下角可以提示你打开Run Dashboard，但是如果不提醒就需要自己配置了。</p><h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>新建项目或者通过 <code>open</code> 打开项目时，可能会弹出提示 “Multiple Spring Boot run configurations were detected. Run Dashboard allows to manage multiple run configurations at once.” 见下图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543906387601.png" alt="1543906387601"> </p><p>点击 <code>Show run configurations in Run Dashboard</code> ，<code>Run Dashboard</code> 面板重新在底部区域展示了出来。</p><p>如没有此提示，请选择方式二或方式三</p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>打开Run Dashboard：View –&gt; Tool Windows –&gt; Run Dashboard</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543906576903.png" alt="1543906576903"></p><h2 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h2><p>如果上述的方式都没有打开 <code>Run Dashboard</code> 面板，可以在工程目录下找 <code>.idea</code> 文件夹下的 <code>workspace.xml</code>文件，通过修改此文件可达到打开 <code>Run Dashboard</code> 面板的目的</p><ol><li><p>找到当前项目中 <code>.idea</code> 文件下的 <code>workspace.xml</code> 文件，双击打开<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543906852844.png" alt="1543906852844"> </p></li><li><p>接下来找到 <code>&lt;component name=&quot;RunDashboard&quot;&gt;</code><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181204-IDEA%E5%88%9B%E5%BB%BASpringBoot%E5%BC%80%E5%90%AF%E6%89%BE%E5%9B%9ERunDashboard/1543907062997.png" alt="1543907062997"> </p></li><li><p>加入如下配置：</p><pre><code class="xml">&lt;option name=&quot;configurationTypes&quot;&gt;  &lt;set&gt;    &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;  &lt;/set&gt;&lt;/option&gt;</code></pre><p>这样 <code>Run Dashboard</code> 自动就弹出来了</p><p>最终配置如下：</p><pre><code class="xml">&lt;component name=&quot;RunDashboard&quot;&gt;  &lt;option name=&quot;configurationTypes&quot;&gt;    &lt;set&gt;      &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;    &lt;/set&gt;  &lt;/option&gt;  &lt;option name=&quot;ruleStates&quot;&gt;    &lt;list&gt;      &lt;RuleState&gt;        &lt;option name=&quot;name&quot; value=&quot;ConfigurationTypeDashboardGroupingRule&quot; /&gt;      &lt;/RuleState&gt;      &lt;RuleState&gt;        &lt;option name=&quot;name&quot; value=&quot;StatusDashboardGroupingRule&quot; /&gt;      &lt;/RuleState&gt;    &lt;/list&gt;  &lt;/option&gt;&lt;/component&gt;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      IDEA
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="IDEA" scheme="https://www.xiongtianci.com/tags/IDEA/"/>
    
      <category term="工具" scheme="https://www.xiongtianci.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础-基本语法</title>
    <link href="https://www.xiongtianci.com/2018/11/30/Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.xiongtianci.com/2018/11/30/Vue基础-基本语法/</id>
    <published>2018-11-30T09:37:11.000Z</published>
    <updated>2019-06-12T09:19:06.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Vue-js"><a href="#1-什么是Vue-js" class="headerlink" title="1. 什么是Vue.js"></a>1. 什么是Vue.js</h1><ul><li>Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</li><li>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</li><li>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</li><li>前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；</li></ul><h1 id="2-安装-Vue"><a href="#2-安装-Vue" class="headerlink" title="2. 安装 Vue"></a>2. 安装 Vue</h1><h2 id="2-1-下载安装"><a href="#2-1-下载安装" class="headerlink" title="2.1 下载安装"></a>2.1 下载安装</h2><p>下载地址：<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a></p><p>可以下载2.5.16版本<a href="https://github.com/vuejs/vue/archive/v2.5.16.zip" target="_blank" rel="noopener">https://github.com/vuejs/vue/archive/v2.5.16.zip</a></p><p>下载解压，得到vue.js文件</p><h2 id="2-2-使用CDN"><a href="#2-2-使用CDN" class="headerlink" title="2.2 使用CDN"></a>2.2 使用CDN</h2><p>或者也可以直接使用公共的CDN服务：</p><pre><code class="html">&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></pre><p>或者：</p><pre><code class="html">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;</code></pre><h1 id="3-框架和库的区别"><a href="#3-框架和库的区别" class="headerlink" title="3. 框架和库的区别"></a>3. 框架和库的区别</h1><ul><li>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。<ul><li>node 中的 express；</li></ul></li><li>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。<ul><li>从Jquery 切换到 Zepto</li><li>从 EJS 切换到 art-template</li></ul></li></ul><h1 id="4-Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别（了解内容）"><a href="#4-Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别（了解内容）" class="headerlink" title="4. Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别（了解内容）"></a>4. Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别（了解内容）</h1><ul><li>MVC 主要是后端的分层开发思想；把 一个完整的后端项目，分成了三个部分：<ul><li>Model：（数据层）主要负责 数据库的操作；</li><li>View：（视图层）所有前端页面，统称为 View 层</li><li>Controller：（业务逻辑层）主要处理对应的业务逻辑；（对于后台来说，这是开发的重点）</li></ul></li><li>MVVM是<strong>前端页面的分层开发思想</strong>，主要关注于 <strong>视图层</strong> 分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View,  ViewModel<ul><li>Model 是 页面中，需要用到的数据</li><li>View 是页面中的HTML结构；</li><li>ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念；</li></ul></li><li>为什么有了MVC还要有MVVM<ul><li>因为 MVC是后端的开发思想，并没有明确定义前端的页面该如何开发；</li><li>MVVM 是前端的页面的开发思想，把每个页面，分成了三个部分，同时 VM 作为 MVVM 的核心，提供了双向数据绑定的概念，前端程序员，不需要手动渲染页面了，而且，页面数据发送变化，也不需要程序员手动把 数据的变化同步到Model中；这所有的操作，都是 VM 自动完成的！</li><li>有了 MVVM 的思想以后，前端只关心 页面交互逻辑，不关心页面如何渲染；</li></ul></li></ul><h2 id="4-2-Vue-js-基本代码-和-MVVM-之间的对应关系"><a href="#4-2-Vue-js-基本代码-和-MVVM-之间的对应关系" class="headerlink" title="4.2 Vue.js 基本代码 和 MVVM 之间的对应关系"></a>4.2 Vue.js 基本代码 和 MVVM 之间的对应关系</h2><ol><li>注意：Vue中，不推荐程序员手动操作DOM元素；所以，在Vue项目中，没有极其变态的需求，一般不要引入 Jquery；</li><li>Vue代码解析执行的步骤：<ol><li>当 VM 实例对象，被 创建完成之后，会立即解析 el 指定区域中的所有代码；</li><li>当 VM 在解析 el 区域中所有代码的时候，会把 data 中的数据，按需，填充到 页面指定的区域；</li></ol></li><li>注意：每当 vm 实例对象，监听到 data 中数据发生了变化，就会立即 重新解析 执行 el 区域内，所有的代码；</li></ol><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1540830117063.png" alt="1540830117063"></p><p>mvvm是前端思想，mvc是后台思想</p><h1 id="5-Vue调试工具vue-devtools的安装和使用"><a href="#5-Vue调试工具vue-devtools的安装和使用" class="headerlink" title="5. Vue调试工具vue-devtools的安装和使用"></a>5. Vue调试工具<code>vue-devtools</code>的安装和使用</h1><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p><h1 id="6-快速入门"><a href="#6-快速入门" class="headerlink" title="6. 快速入门"></a>6. 快速入门</h1><h1 id="7-Vue实例"><a href="#7-Vue实例" class="headerlink" title="7. Vue实例"></a>7. Vue实例</h1><h2 id="7-1-创建Vue实例"><a href="#7-1-创建Vue实例" class="headerlink" title="7.1 创建Vue实例"></a>7.1 创建Vue实例</h2><p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的：</p><pre><code class="javascript">var vm = new Vue({  // 选项})</code></pre><p>在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括：</p><ul><li>el</li><li>data</li><li>methods</li></ul><p>等等</p><p>接下来我们一 一介绍。</p><h2 id="7-2-模板或元素"><a href="#7-2-模板或元素" class="headerlink" title="7.2 模板或元素"></a>7.2 模板或元素</h2><p>每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。</p><p>我们可以通过el属性来指定。</p><p>例如一段html模板：</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code></pre><p>然后创建Vue实例，关联这个div</p><pre><code class="js">var vm = new Vue({    el:&quot;#app&quot;})</code></pre><p>这样，Vue就可以基于id为<code>app</code>的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。</p><h2 id="7-3-数据"><a href="#7-3-数据" class="headerlink" title="7.3 数据"></a>7.3 数据</h2><p>当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。</p><p>html：</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;&lt;/div&gt;</code></pre><p>js:</p><pre><code class="js">var vm = new Vue({    el:&quot;#app&quot;,    data:{        name:&quot;刘德华&quot;    }})</code></pre><ul><li>name的变化会影响到<code>input</code>的值</li><li>input中输入的值，也会导致vm中的name发生改变</li></ul><h2 id="7-4-方法"><a href="#7-4-方法" class="headerlink" title="7.4 方法"></a>7.4 方法</h2><p>Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue的作用范围内使用。</p><p>html:</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    {{num}}    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;&lt;/div&gt;</code></pre><p>js写法一：</p><pre><code class="js">&lt;div id=&quot;app&quot;&gt;    {{num}}    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vm = new Vue({       el:&quot;#app&quot;,       data:{           num:0       },       methods:{           add:function(){               this.num++;           }       }    });&lt;/script&gt;</code></pre><p>js写法二：</p><pre><code class="javascript">&lt;div id=&quot;app&quot;&gt;    {{num}}    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vm = new Vue({       el:&quot;#app&quot;,       data:{           num:0       },       methods:{           add(){               this.num++;           }       }    });&lt;/script&gt;</code></pre><h2 id="7-5-生命周期"><a href="#7-5-生命周期" class="headerlink" title="7.5 生命周期"></a>7.5 生命周期</h2><h3 id="7-5-1-生命周期"><a href="#7-5-1-生命周期" class="headerlink" title="7.5.1 生命周期"></a>7.5.1 生命周期</h3><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。</p><p>生命周期：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/lifecycle.png" alt="Vue life cycle"></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1540850010193.png" alt="1540850010193"></p><h3 id="7-5-2-钩子函数"><a href="#7-5-2-钩子函数" class="headerlink" title="7.5.2 钩子函数"></a>7.5.2 钩子函数</h3><p><strong>钩子函数</strong>：生命周期函数的别名；</p><ul><li>生命周期钩子 = 生命周期函数 = 生命周期事件</li><li>主要的生命周期函数分类：<ul><li>创建期间的生命周期函数：<ul><li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li><li><strong>created</strong>：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板【当 vm 实例的 data 和 methods 初始化完毕后，vm 实例会自动执行 created 函数】</li><li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li><li><strong>mounted</strong>：此时，已经将编译好的模板，挂载到了页面指定的容器中显示【如果要通过某些插件操作页面上的DOM元素节点，最早要在 mounted 中进行】</li></ul></li><li>运行期间的生命周期函数：<ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul></li><li>销毁期间的生命周期函数：<ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></li></ul></li></ul><ul><li>例1：created代表在vue实例创建后；</li></ul><p>我们可以在Vue中定义一个created函数，代表这个时期的构造函数：</p><p>html:</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    {{hello}}&lt;/div&gt;</code></pre><p>js:</p><pre><code class="js">&lt;script src=&quot;vue-2.5.17.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vm = new Vue({       el:&quot;#app&quot;,       data:{           hello:&#39;&#39;       },       created(){           this.hello = &#39;czdx,一统江湖，千秋万代&#39;       }    });&lt;/script&gt;</code></pre><p>结果：</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1540845983254.png" alt="1540845983254"></p><ul><li>例2：</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;   &lt;head&gt;      &lt;meta charset=&quot;utf-8&quot; /&gt;      &lt;title&gt;vuejs生命周期&lt;/title&gt;      &lt;script src=&quot;vuejs-2.5.17.js&quot;&gt;&lt;/script&gt;   &lt;/head&gt;   &lt;body&gt;      &lt;div id=&quot;app&quot;&gt;         {{message}}      &lt;/div&gt;   &lt;/body&gt;   &lt;script&gt;      var vm = new Vue({         el: &quot;#app&quot;,         data: {            message: &#39;hello world&#39;         },         beforeCreate: function() {            showData(&#39;创建vue实例前&#39;, this);         },         created: function() {            showData(&#39;创建vue实例后&#39;, this);         },         beforeMount: function() {            showData(&#39;挂载到dom前&#39;, this);         },         mounted: function() {            showData(&#39;挂载到dom后&#39;, this);         },         beforeUpdate: function() {            showData(&#39;数据变化更新前&#39;, this);         },         updated: function() {            showData(&#39;数据变化更新后&#39;, this);         },         beforeDestroy: function() {            showData(&#39;vue实例销毁前&#39;, this);         },         destroyed: function() {            showData(&#39;vue实例销毁后&#39;, this);         }      });      function realDom() {         console.log(&#39;真实dom结构：&#39; + document.getElementById(&#39;app&#39;).innerHTML);      }      function showData(process, obj) {         console.log(process);         console.log(&#39;data 数据：&#39; + obj.message)         console.log(&#39;挂载的对象：&#39;)         console.log(obj.$el)         realDom();         console.log(&#39;------------------&#39;)         console.log(&#39;------------------&#39;)      }      vm.message = &quot;good...&quot;;      vm.$destroy();   &lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="7-5-3-this"><a href="#7-5-3-this" class="headerlink" title="7.5.3 this"></a>7.5.3 this</h3><p>我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this</p><pre><code class="js">var vm = new Vue({    el:&quot;#app&quot;,    data:{        hello: &#39;&#39; // hello初始化为空    },    created(){        this.hello = &quot;czdx,一统江湖，千秋万代&quot;;        console.log(this);    }})</code></pre><p> 控制台的输出：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Vue%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1540846042618.png" alt="1540846042618"></p><h1 id="8-指令"><a href="#8-指令" class="headerlink" title="8. 指令"></a>8. 指令</h1><p><strong>指令</strong> (Directives)： 是带有 <code>v-</code> 前缀的特殊特性。指令特性的预期值是：<strong>单个 JavaScript 表达式</strong>。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 </p><p>例如我们在入门案例中的v-on，代表绑定事件。</p><h2 id="8-1-插值表达式"><a href="#8-1-插值表达式" class="headerlink" title="8.1 插值表达式"></a>8.1 插值表达式</h2><h3 id="8-1-1-大括号-u007B-u007B"><a href="#8-1-1-大括号-u007B-u007B" class="headerlink" title="8.1.1 大括号 u007B;u007B;"></a>8.1.1 大括号 u007B;u007B;</h3><ol><li><p>格式：</p><pre><code>u007B;u007B;表达式</code></pre><p>说明：</p></li></ol>]]></content>
    
    <summary type="html">
    
      Vue基础
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vue" scheme="https://www.xiongtianci.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Java线程状态</title>
    <link href="https://www.xiongtianci.com/2018/11/30/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>https://www.xiongtianci.com/2018/11/30/Java线程状态/</id>
    <published>2018-11-30T09:23:50.000Z</published>
    <updated>2019-06-12T09:58:06.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h1><p>网上流传了很久的线程具备5种状态，这样是不贴切JDK中描述的，JDK中描述线程状态只有6种，而网络流传的5种<br>状态就是进程的五态模型。那张广为流传的来自网络的图如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1542897157060.png" alt="1542897157060"></p><p>很明显这是操作系统中进程的5种状态，在很多操作系统书中也由介绍分别为new，ready，running，waiting，<br>terminated。不幸的是，有很多的书上常常把这些进程状态，线程状态与Java线程状态混在一起谈。</p><p>进程与线程的区分总图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1542897357723.png" alt="1542897357723"></p><blockquote><ol><li>很多人觉得在JVM线程中应该有，Running运行状态。对JAVA而言，Runnable包含了就绪与运行，那为<br>什么JAVA不区分开呢？这跟CPU分配的时间片有关，而且JAVA进行的是抢占式轮转调度，由于我们的JVM线程是服务于监控，线程又是切换的如此之快，那么区分ready与running又没有多大意义了。<br>再者，我们都知道现在使用的很多JVM底层都将线程映射到操作系统上了，JVM本身没有做什么调度，因为虚拟机看到的都是底层的映射与封装，故而将ready与running映射来也没有太大意义，不如统一为Runnable</li><li>总之还是有些乱的，我们不妨就拿Windows系统为例，用的就是“进程”和“线程”这两种较为标准的叫法，<br>这时一个进程下至少有一个线程，<strong>线程是CPU调度的基本单位</strong>，<strong>进程不参与CPU调度</strong>，CPU根本不知道进程的存在。</li><li>为了避免混乱，下面说的线程状态，只是站在JVM层面上</li></ol></blockquote><p>我们先来看下，这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1543039901810.png" alt="1543039901810"></p><table><thead><tr><th style="text-align:center">线程状态</th><th style="text-align:center">导致状态发生条件</th></tr></thead><tbody><tr><td style="text-align:center">NEW(新建)</td><td style="text-align:center">线程刚被创建，但是并未启动</td></tr><tr><td style="text-align:center">Runnable(可运行)</td><td style="text-align:center">线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器</td></tr><tr><td style="text-align:center">Blocked(锁阻塞)</td><td style="text-align:center">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态</td></tr><tr><td style="text-align:center">Waiting(无限等待)</td><td style="text-align:center">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</td></tr><tr><td style="text-align:center">Timed Waiting(计时等待)</td><td style="text-align:center">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td></tr><tr><td style="text-align:center">Teminated(被终止)</td><td style="text-align:center">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡</td></tr></tbody></table><blockquote><ol><li>初始(NEW)：新创建了一个线程对象，但还没有调用 <code>start()</code> 方法。</li><li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）</li><li>阻塞(BLOCKED)：表示线程阻塞于锁</li><li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）</li><li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回</li><li>终止(TERMINATED)：表示该线程已经执行完毕</li></ol></blockquote><h2 id="1-NEW-新建-状态"><a href="#1-NEW-新建-状态" class="headerlink" title="1. NEW(新建)状态"></a>1. NEW(新建)状态</h2><blockquote><p>概念：线程对象创建了，但是还没有启动之前，就是新建状态</p></blockquote><p>实现 <code>Runnable接口</code> 或继承 <code>Thread</code> 可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p><p>这里强调两点：</p><ul><li>线程对象创建之后，还未开启( 调用start()方法 )时候，就处于NEW的状态</li><li>开启线程，指的是调用start方法，并不是run方法，run方法仅仅作为一个普通方法存在</li></ul><blockquote><p>线程对象调用 <code>run()</code> 方法不开启线程，仅是对象调用方法。线程对象调用 <code>start()</code> 方法开启线程，并让jvm调用 <code>run()</code> 方法在开启的线程中执行</p></blockquote><p>当我们执行 <code>new Thread(target)</code> 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 <code>Runnable</code> (可运行)状态。</p><blockquote><p>在我们研究线程状态时，采用Thread中的getState()方法进行研究</p></blockquote><p>通过代码演示：</p><pre><code class="java">public class MyThread extends Thread{    @Override    public void run() {        // 线程执行的代码    }}</code></pre><pre><code class="java">/** * 研究新建线程状态 *   新建状态：至今还未启动的线程处于这一状态 */public class ThreadStateTest1 {    public static void main(String[] args) {        // 创建线程对象        MyThread myThread = new MyThread();        // 线程默认名：Thread-0 Thread-1...        System.out.println(myThread.getName());        System.out.println(&quot;线程创建之后处于：&quot; + myThread.getState());        myThread.run();        System.out.println(&quot;线程run之后处于：&quot; + myThread.getState());        myThread.start();        System.out.println(&quot;线程start之后处于：&quot; + myThread.getState());    }}// 输出：//   线程创建之后处于：NEW//   线程run之后处于：NEW//   线程start之后处于：RUNNABLE</code></pre><blockquote><p>当我们执行 <code>new Thread(target)</code> 时，jvm 要为线程的运行做一些前期的准备工作，比如检查线程类是否已经被加载、解析和初始化过，接下来还要为对象分配空间并对空间初始化零值等。当完成这些准备工作时线程才能进入到下一个 <code>Runnable</code> (可运行)状态。所以说</p><p>当业务需要频繁创建线城市，最好使用线程池，提高效率减轻JVM的压力。当然如果大量线程进行频繁上下文切换，此时多线程的效率会大打折扣。</p></blockquote><h2 id="2-RUNNABLE-可运行-状态"><a href="#2-RUNNABLE-可运行-状态" class="headerlink" title="2. RUNNABLE(可运行)状态"></a>2. RUNNABLE(可运行)状态</h2><blockquote><p>可运行状态：一个在JVM中执行的线程处于这个状态中，等待JVM调度，德能在执行，也可能在等待</p></blockquote><blockquote><p>注：这里的等待指的是等待调度，等待的是系统资源，如IO、CPU时间片，与 sleep、lock 的等待有着本质差别。</p></blockquote><p>接下来使用代码演示一个最简单的可运行状态：</p><pre><code class="java">public class MyThread extends Thread {    @Override    public void run() {        System.out.println(&quot;线程开始执行&quot;);        System.out.println(&quot;线程开始执行具体的任务&quot;);        // 假设这个任务使用5秒钟        long beiginTime = System.currentTimeMillis();        while (System.currentTimeMillis()-beiginTime &lt; 5000){            // 假设做了5秒钟的任务        }        System.out.println(&quot;线程执行完毕&quot;);    }}</code></pre><pre><code class="java">/** * 可运行状态 *   当线程有资格运行，调用了start方法，线程首先进入可运行状态 *   这种可运行状态不一定被线程调度运行 *   简单来说，调用start方法之后，该线程处于可运行状态，但未运行 *   此时存放在&quot;可运行池&quot;中 *   线程在运行的过程中，自然该线程也是处于可运行状态 * *   JDK中处于可运行状态的线程，有两种，一种是正在JVM中运行， *   另一种是可能正在等待操作系统其它资源，比如处理器 */public class Demo {    public static void main(String[] args) {        // 创建线程对象        MyThread myThread = new MyThread();        System.out.println(&quot;创建完成之后：&quot; + myThread.getState());        // 开启线程        myThread.start();        System.out.println(&quot;开启线程之后：&quot; + myThread.getState());    }}</code></pre><h2 id="3-BLOCHED-阻塞-状态"><a href="#3-BLOCHED-阻塞-状态" class="headerlink" title="3. BLOCHED(阻塞)状态"></a>3. BLOCHED(阻塞)状态</h2><p>我们还是使用代码来解析一下锁阻塞状态：</p><pre><code class="java">public class ThreadA extends Thread {    private Object obj;    public ThreadA(String name,Object obj){        super(name);        this.obj = obj;    }    @Override    public void run() {        // 同步代码块        synchronized (obj){            System.out.println(&quot;线程A开始执行&quot;);            System.out.println(&quot;线程A真正开始执行代码了&quot;);            long beginTime = System.currentTimeMillis();            // 模拟5秒钟的任务            while(System.currentTimeMillis()-beginTime &lt; 5000){            }            System.out.println(&quot;线程A执行完毕&quot;);        }    }}</code></pre><pre><code class="java">public class ThreadB extends Thread{    private Object obj;    public ThreadB(String name,Object obj){        super(name);        this.obj = obj;    }    @Override    public void run() {        // 同步代码块        synchronized (obj){            System.out.println(&quot;线程B开始执行&quot;);            System.out.println(&quot;线程B真正开始执行代码了&quot;);            long beginTime = System.currentTimeMillis();            // 模拟5秒钟的任务            while(System.currentTimeMillis()-beginTime &lt; 5000){            }            System.out.println(&quot;线程B执行完毕&quot;);        }    }}</code></pre><pre><code class="java">/** * 线程状态之阻塞状态BLOCKED *    JDK：锁阻塞并且正在等待监视器锁的某一线程状态 *    处于受阻状态的某一线程正在等待监视器锁，以便进入一个同步代码块/同步方 *    还有就是 调用Object.wart方法之后，再次进入同步中时 * */public class BlockedDemo {    public static void main(String[] args) throws InterruptedException {        // 创建一个锁对象        Object obj = new Object();        // 创建线程A、B        ThreadA a = new ThreadA(&quot;线程A&quot;, obj);        ThreadB b = new ThreadB(&quot;线程B&quot;, obj);        // 开启线程        a.start();        b.start();        //        Thread.sleep(3000);        System.out.println(&quot;线程A的状态是：&quot; + a.getState());        System.out.println(&quot;线程B的状态是：&quot; + b.getState());        //        Thread.sleep(3000);        System.out.println(&quot;线程A的状态是：&quot; + a.getState());        System.out.println(&quot;线程B的状态是：&quot; + b.getState());    }}</code></pre><p>在这里我们只是对之前分析的情况一进行了阐释</p><h2 id="4-Timed-Waiting-计时等待-状态"><a href="#4-Timed-Waiting-计时等待-状态" class="headerlink" title="4. Timed Waiting(计时等待)状态"></a>4. Timed Waiting(计时等待)状态</h2><blockquote></blockquote><p>带指定的等待时间的等待线程所处的状态。一个线程处于这一状态是因为用一个指定的正的等待时间（为参数）调用了一下方法中的其一：</p><ul><li>Thread.sleep</li><li>带时限（timeout）的 Object.wait</li><li>带时限（timeout）的 Thread.join</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul><p>Timed Waiting 在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？</p><p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p><blockquote><p>注：sleep的使用时区别去其他方法的。</p></blockquote><p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting（计时等待），那么我们通过一个案例加深对该状态的一个理解：</p><p>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</p><p>代码：</p><pre><code class="java">/** * 限时等待 */public class MyThread extends Thread {    public static void main(String[] args) {        MyThread myThread = new MyThread();        myThread.start();        for (int i = 0; i &lt; 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(&quot;mt的线程状态： &quot; + myThread.getState());        }    }    // 实现一个计算器，0-99计数，在每个数字之间暂停1秒，每个10个数字输出一个字符串    @Override    public void run() {        for (int i = 0; i &lt; 99; i++) {            if (i%10 == 0){                System.out.println(&quot;oewewowllskd &quot; + i);            }            System.out.println(i);            try {                Thread.sleep(1000);                System.out.println(&quot;    休息了1秒&quot;);            } catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><p>通过案例可以发西咸，sleep方法的使用还是很简单的。我们需要记住下面几点：</p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep() 的调用放线程run()之内，这样才能保证该线程执行过程中会睡眠</li><li>sleep 与锁无关，线程睡眠到期自动苏醒，并返回到 Runnable（可运行）状态</li></ol><blockquote><p>小提示：sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep() 方法不能保证该线程睡眠到期后就开始立刻执行</p></blockquote><h2 id="5-WAITING-无限等待-状态"><a href="#5-WAITING-无限等待-状态" class="headerlink" title="5. WAITING(无限等待)状态"></a>5. WAITING(无限等待)状态</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p><p>一个线程进入 WAITING 状态是因为调用了以下方法：</p><ul><li>不带时限的 Object.wait 方法</li><li>不带时限的 Thread.join 方法</li><li>LockSupport.park</li></ul><p>然后会等其他线程执行一个特别的动作，比如：</p><ul><li>一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 或 Object.notifyAll()</li><li>一个调用了 Thread.join 方法的线程会等待指定的线程结束</li></ul><p>代码演示：</p><pre><code class="java">/** * 无限等待 *   Object中的wait方法完成 *     使用当前线程 进入无限等待状态，直到其他线程有唤醒 notify 或 notifyAll 才能被唤醒 * *     线程间通信 两个线程执行不同的操作 关联的 *       两个线程 使用同样的锁 只能使用锁对象调用wait方法或者notify方法 */public class WaitingTest {    private static Object obj = new Object();    public static void main(String[] args) throws InterruptedException {        // 使用匿名函数创建线程        Thread t1 = new Thread() {            @Override            public void run() {                synchronized (obj){                    System.out.println(&quot;获取到锁，调用wait方法，当前线程进入无线等待状态。。。等待着别的线程来唤醒&quot;);                    try {                        obj.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(&quot;唤醒了这个线程，就不再是线程等待了，线程执行完毕&quot;);                }            }        };        // 开启线程t1        t1.start();        // 使用匿名内部内方式创建一个新的线程，用来唤醒t1线程        new Thread(){            @Override            public void run() {                // 获取到锁                synchronized (obj){                    try {                        // 3秒钟后执行唤醒操作                        Thread.sleep(3000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(&quot;获取到锁 执行 唤醒操作&quot;);                    // 唤醒操作                    obj.notify();                }            }        }.start();        // 4秒后查看线程t1状态        Thread.sleep(4000);        System.out.println(&quot;查看t1的线程状态&quot; + t1.getState());    }}</code></pre><p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 方法或 Object.notifyAll() 方法</p><p>其实 waiting 状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，<br>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司了你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作一完成某些任务。</p><h2 id="6-TEMINATED-终止-状态"><a href="#6-TEMINATED-终止-状态" class="headerlink" title="6. TEMINATED(终止)状态"></a>6. TEMINATED(终止)状态</h2><p>线程因如下两个原因之一将被终止：</p><ol><li>run() 方法正常退出而自然死亡</li><li>一个没有捕获的异常终止了 run() 方法而意外死亡</li></ol><h1 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h1><h2 id="1-wait-notify-notifyAll-等方法介绍"><a href="#1-wait-notify-notifyAll-等方法介绍" class="headerlink" title="1. wait(), notify(), notifyAll()等方法介绍"></a>1. wait(), notify(), notifyAll()等方法介绍</h2><p>在Object.java中，定义了wait(), notify()和notifyAll()等接口。<strong><code>wait()</code> 的作用是让当前线程进入等待状态</strong>，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；<strong><code>notify()</code> 是唤醒单个线程</strong>，<strong>而 <code>notifyAll()</code> 是唤醒所有的线程</strong>。</p><p>Object类中关于等待/唤醒的API详细信息如下：<br><strong>notify()</strong>        – 唤醒在此对象监视器上等待的单个线程。<br><strong>notifyAll()</strong>   – 唤醒在此对象监视器上等待的所有线程。<br><strong>wait()</strong>                                         – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout)</strong>                    – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。<br><strong>wait(long timeout, int nanos)</strong>  – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>]]></content>
    
    <summary type="html">
    
      Java线程状态
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java线程" scheme="https://www.xiongtianci.com/tags/Java%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="https://www.xiongtianci.com/2018/11/30/Flex%E5%B8%83%E5%B1%80/"/>
    <id>https://www.xiongtianci.com/2018/11/30/Flex布局/</id>
    <published>2018-11-30T09:12:44.000Z</published>
    <updated>2019-06-12T09:21:01.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex-布局教程：语法篇"><a href="#Flex-布局教程：语法篇" class="headerlink" title="Flex 布局教程：语法篇"></a>Flex 布局教程：语法篇</h1><blockquote><p>作者： <a href="http://www.ruanyifeng.com/blog//" target="_blank" rel="noopener">阮一峰</a><br>链接： <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p></blockquote><p>网页布局（layout）是 CSS 的一个重点应用</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071001.gif?raw=true" alt="img"></p><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">垂直居中</a>就不容易实现。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071002.png" alt="img"></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071003.jpg" alt="img"></p><p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">下一篇文章</a>给出常见布局的 Flex 写法。网友<a href="http://vgee.cn/" target="_blank" rel="noopener">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html" target="_blank" rel="noopener">Demo</a>，也可以参考。</p><p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="noopener">A Visual Guide to CSS3 Flexbox Properties</a>。</p><h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><blockquote><pre><code class="css">.box{  display: flex;}</code></pre></blockquote><p>行内元素也可以使用 Flex 布局。</p><blockquote><pre><code class="css">.box{  display: inline-flex;}</code></pre></blockquote><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><blockquote><pre><code class="css">.box{  display: -webkit-flex; /* Safari */  display: flex;}</code></pre></blockquote><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071004.png" alt="img"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、容器的属性-紫色大盒子"><a href="#三、容器的属性-紫色大盒子" class="headerlink" title="三、容器的属性  (紫色大盒子) *"></a>三、容器的属性  (紫色大盒子) *</h2><p>以下6个属性设置在容器上。</p><blockquote><ul><li>flex-direction  √</li><li>flex-wrap  √</li><li>flex-flow</li><li>justify-content  √</li><li>align-items √</li><li>align-content</li></ul></blockquote><h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性 **"></a>3.1 flex-direction属性 **</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><blockquote><pre><code>.box {  flex-direction: row | row-reverse | column | column-reverse;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071005.png" alt="img"></p><p>它可能有4个值。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性 **"></a>3.2 flex-wrap属性 **</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071006.png" alt="img"></p><blockquote><pre><code>.box{  flex-wrap: nowrap | wrap | wrap-reverse;}</code></pre></blockquote><p>它可能取三个值。</p><p>（1）<code>nowrap</code>（默认）：不换行。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071007.png" alt="img"></p><p>（2）<code>wrap</code>：换行，第一行在上方。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071008.jpg" alt="img"></p><p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071009.jpg" alt="img"></p><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><blockquote><pre><code>.box {  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;}</code></pre></blockquote><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性  **"></a>3.4 justify-content属性  **</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><blockquote><pre><code class="css">.box {  justify-content: flex-start | flex-end | center | space-between | space-around;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071010.png" alt="img"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性 **"></a>3.5 align-items属性 **</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><blockquote><pre><code>.box {  align-items: flex-start | flex-end | center | baseline | stretch;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071011.png" alt="img"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><blockquote><pre><code>.box {  align-content: flex-start | flex-end | center | space-between | space-around | stretch;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071012.png" alt="img"></p><p>该属性可能取6个值。</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h2 id="四、项目的属性-橙色小盒子"><a href="#四、项目的属性-橙色小盒子" class="headerlink" title="四、项目的属性  (橙色小盒子) *"></a>四、项目的属性  (橙色小盒子) *</h2><p>以下6个属性设置在项目上。</p><blockquote><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul></blockquote><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><blockquote><pre><code>.item {  order: &lt;integer&gt;;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071013.png" alt="img"></p><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><blockquote><pre><code>.item {  flex-grow: &lt;number&gt;; /* default 0 */}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071014.png" alt="img"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><blockquote><pre><code>.item {  flex-shrink: &lt;number&gt;; /* default 1 */}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071015.jpg" alt="img"></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><blockquote><pre><code>.item {  flex-basis: &lt;length&gt; | auto; /* default auto */}</code></pre></blockquote><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性 **"></a>4.5 flex属性 **</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><blockquote><pre><code>.item {  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]}</code></pre></blockquote><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><blockquote><pre><code>.item {  align-self: auto | flex-start | flex-end | center | baseline | stretch;}</code></pre></blockquote><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Flex%E5%B8%83%E5%B1%80/bg2015071016.png" alt="img"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
    
    <summary type="html">
    
      Flex布局
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="装载" scheme="https://www.xiongtianci.com/categories/%E8%A3%85%E8%BD%BD/"/>
    
    
      <category term="Flex" scheme="https://www.xiongtianci.com/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://www.xiongtianci.com/2018/11/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.xiongtianci.com/2018/11/30/Linux常用命令/</id>
    <published>2018-11-30T08:19:55.000Z</published>
    <updated>2019-06-12T09:19:20.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux介绍（了解）"><a href="#1-Linux介绍（了解）" class="headerlink" title="1. Linux介绍（了解）"></a>1. Linux介绍（了解）</h1><h2 id="1-1、Linux和Windows的区别"><a href="#1-1、Linux和Windows的区别" class="headerlink" title="1.1、Linux和Windows的区别"></a>1.1、Linux和Windows的区别</h2><p>Linux是一款操作系统。正规开发服务器项目部署都是放在Linux操作系统上。</p><p>Windows一款操作系统，民用操作系统。娱乐、影音、上网。</p><h2 id="1-2、Linux历史及使用场景"><a href="#1-2、Linux历史及使用场景" class="headerlink" title="1.2、Linux历史及使用场景"></a>1.2、Linux历史及使用场景</h2><p>Linux诞生90年代，仿制Unix操作系统。</p><p>Linux是免费的，开源的</p><p>Unix是收费的，封闭的。 </p><p>Linux使用场景：<strong>服务器操作系统</strong>，移动设备（安卓手机，平板电脑），路由器（WIFI），交换机，智能家居，Java程序开发</p><h2 id="1-3、Linux的版本"><a href="#1-3、Linux的版本" class="headerlink" title="1.3、Linux的版本"></a>1.3、Linux的版本</h2><p>Linux的版本分为两种：内核版本(<a href="https://www.kernel.org/)和发行版本" target="_blank" rel="noopener">https://www.kernel.org/)和发行版本</a></p><p>Linux内核版本：Linux内核运维开发小组。 源码在一定程度上不是开源的。</p><p>Linux发行版本：由各大互联网/软件公司定制。 外围的样式功能的源码完全开源</p><p>一个内核版本是有多种多样的发行版本 </p><p>Ubuntu：以强大的桌面应用为主，吸收不少Windows用户。</p><ul><li>因为桌面应用会在一定程度上大量占用系统资源，开发。</li><li>服务器部署上，不会优先选择Ubuntu</li></ul><p><strong>CentOS</strong>：对服务器性能进行了一定程度的优化，性能比较高，比较稳定。</p><ul><li>服务器操作系统的优选CentOS</li></ul><h1 id="2、Linux安装【重点】"><a href="#2、Linux安装【重点】" class="headerlink" title="2、Linux安装【重点】"></a>2、Linux安装【重点】</h1><h2 id="2-1、虚拟机、Linux安装"><a href="#2-1、虚拟机、Linux安装" class="headerlink" title="2.1、虚拟机、Linux安装"></a>2.1、虚拟机、Linux安装</h2><h2 id="2-2、CentOS安装jdk、tomcat、mysql"><a href="#2-2、CentOS安装jdk、tomcat、mysql" class="headerlink" title="2.2、CentOS安装jdk、tomcat、mysql"></a>2.2、CentOS安装jdk、tomcat、mysql</h2><h2 id="2-3、Linux目录介绍"><a href="#2-3、Linux目录介绍" class="headerlink" title="2.3、Linux目录介绍"></a>2.3、Linux目录介绍</h2><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538621186769.png" alt="1538621186769"></p><ul><li><p><strong>/</strong>：<strong>Linux系统根目录</strong></p></li><li><p><strong>/etc</strong>：(etcetera) <strong>系统配置文件存放的目录</strong>，不建议在此目录下存放可执行文件。</p><p>重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。</p><p>注：/etc/X11存放与 x windows 有关的设置（防火墙文件，网络设置文件，JDK环境配置文件，mysql）</p></li><li><p><strong>home</strong>:存放所有普通用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用<code>~user</code>表示</p></li><li><p><strong>/root</strong>： <strong>系统管理员root(超级用户)的家目录</strong>，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下</p><p>每一个用户都有家目录，超级管理员root家目录  /root</p><p>Linux命令行模式中相当于Windows的桌面</p></li><li><p><strong>/usr</strong>：(unix shared resources)：<strong>应用程序存放目录</strong>，比较重要的目录<code>/usr/local</code>本地系统管理员软件安装目录（安装系统级的应用）</p><p>/usr/bin 存放应用程序</p><p>/usr/share 存放共享数据</p><p>/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</p><p>/usr/local:存放软件升级包</p><p>/usr/share/doc: 系统说明文件存放目录</p><p>/usr/share/man: 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间。<br>​    Jdk,tomcat,mysql,redis,nginx</p></li><li><p><strong>/opt</strong>：<strong>额外安装的可选应用程序包</strong>所放置的位置。一般情况下，我们可以把tomcat等都安装到这里</p></li></ul><p>以上建议并不是强制性约束</p><h2 id="2-4-网络三种连接方式"><a href="#2-4-网络三种连接方式" class="headerlink" title="2.4 网络三种连接方式"></a>2.4 网络三种连接方式</h2><h3 id="2-4-1-桥接模式"><a href="#2-4-1-桥接模式" class="headerlink" title="2.4.1 桥接模式"></a>2.4.1 桥接模式</h3><p><strong>桥接模式</strong>(Bridged)：虚拟机是一台独立的电脑，直接连接到实际的网络上，与宿主机没有任何联系。</p><p> <img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1543535328477.png" alt="1543535328477"></p><h3 id="2-4-2-仅主机模式"><a href="#2-4-2-仅主机模式" class="headerlink" title="2.4.2 仅主机模式"></a>2.4.2 仅主机模式</h3><blockquote><p>这种方式下，虚拟机的网卡连接到宿主的 VMnet1 上，但系统并不为虚拟机提供任何路由服务，因此虚拟机只能和宿主机进行通信，而不能连接到实际网络上。</p></blockquote><p> <strong>仅主机模式</strong>(host-only)：虚拟机可以访问宿主机，宿主机无法访问虚拟机，虚拟机无法上网</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1543535410144.png" alt="1543535410144"></p><h3 id="2-4-3-NAT-模式"><a href="#2-4-3-NAT-模式" class="headerlink" title="2.4.3 NAT 模式"></a>2.4.3 NAT 模式</h3><blockquote><p>这种方式下，虚拟机的网卡连接到宿主的 VMnet8 上。此时系统的 VMWare NAT Service 服务就充当了路由器的作用，负责将虚拟机发到 VMnet8 的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过 VMnet8 发送给虚拟机。VMWare DHCP Service 负责为虚拟机提供 DHCP 服务。</p></blockquote><p><strong>NAT模式</strong>：</p><ul><li><p>虚拟机可以访问宿主机，宿主机可以访问虚拟机</p></li><li><p>此时宿主机相当于路由器，虚拟机可以通过宿主机上网</p></li><li><p>宿主机可以配置254个虚拟机 </p></li></ul><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1543535431117.png" alt="1543535431117"></p><h1 id="3、常用命令【重点】"><a href="#3、常用命令【重点】" class="headerlink" title="3、常用命令【重点】"></a>3、常用命令【重点】</h1><p>Linux命令中参数，一般都是无序的。特殊情况下除外</p><p>注意：Linux中的命令<strong>严格区分大小写</strong>的！</p><h2 id="3-1、磁盘管理命令"><a href="#3-1、磁盘管理命令" class="headerlink" title="3.1、磁盘管理命令"></a>3.1、磁盘管理命令</h2><h3 id="ls-列出目录内容"><a href="#ls-列出目录内容" class="headerlink" title="ls 列出目录内容"></a><em>ls</em> 列出目录内容</h3><ol><li><p>ls（list）功能：列出目录内容</p></li><li><p>格式：</p><pre><code class="shell">ls [参数] [文件或目录]# 参数-a或--all   查询所有文件和文件夹，包含隐藏。注意隐藏文件、特殊目录、. 和 ..-l           查询详细列表    ls -l--&gt;简写：ll-h             友好展示信息    ll -h (d目录，-普通文件, l链接)-t          用文件和目录的更改时间排序。-r             反向排序--help       在线帮助</code></pre></li><li><p>常用：</p><pre><code>ls -l        --&gt; 此命令非常常用，提供简化版命令 llls -alll /home/    --&gt; 显示指定目录下的内容</code></pre></li><li><p>eg:</p><pre><code>需求：展示某个目录下的内容    ls 目录名所在位置：/root想要查看:/etc目录下的内容命令：ll -h /etc</code></pre></li></ol><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd 切换目录"></a><em>cd</em> 切换目录</h3><ol><li><p>cd(change directory) 功能：切换目录</p></li><li><p>语法：</p><pre><code class="shell"># 格式cd [目录]# 常用cd /目录名   ，任意目录切换到指定目录中     /目录名--&gt;Linux的绝对路径                                       windows绝对路径--&gt;c:/xxxx/xxx.jpg?raw=truecd ../      ，向上一层目录cd ~        ，切换到当前用户 家目录。root用户家目录 /rootcd /        ，切换到Linux的 根目录cd -          ，切换到上一次访问的目录。   只能两个目录相互切换cd ..        ，上一级目录cd            ，缺省当前用户目录</code></pre></li></ol><ul><li><strong>Linux绝对</strong>：  <ul><li>eg：<code>cd /etc/x1</code>   先切换到 /目录，然后在 /目录 中找到子目录 etc，在 etc 中找 子目录x1</li><li>特点：在任意目录都可以随意切换</li></ul></li><li><strong>Linux相对</strong>：<ul><li>eg：<code>cd x1/x2</code>   在当前目录中寻找子目录x1, 在x1中寻找子目录x2</li><li>特点：必须确定 当前目录 下有子目录x1</li></ul></li></ul><h3 id="pwd-显示当前的所在目录"><a href="#pwd-显示当前的所在目录" class="headerlink" title="pwd 显示当前的所在目录"></a><em>pwd</em> 显示当前的所在目录</h3><ul><li>pwd(print working directory) 功能：显示工作目录(当前的所在目录)。返回绝对路径</li></ul><h3 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir 创建目录"></a><em>mkdir</em> 创建目录</h3><ol><li><p>mkdir（make directoriy）功能： 创建目录</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式mkdir -p 文件夹名称# 参数-p  父目录不存在情况下先生成父目录 （parents）-v    显示命令执行过程中的详细信息</code></pre></li><li><p>注意：</p><p>使用<code>mkdir</code>创建带后缀的文件时，创建的是<strong>目录</strong>，不是文件（创建文件使用<code>touch</code>命令）</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539658915126.png" alt="1539658915126"> </p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539659032657.png" alt="1539659032657"> </p></li><li><p>eg:</p><pre><code class="shell"># 1需要在/root/t1目录下创建一个t2目录位置：/root命令：相对路径：mkdir t1/t2绝对：mkdir /root/t1/t2# 2需要在/root/t3目录下创建一个t4目录位置：/root条件：t3和t4都不存在命令：mkdir -p t3/t4</code></pre></li></ol><h3 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir 删除空目录"></a><em>rmdir</em> 删除空目录</h3><ul><li>rmdir(remove directory) 功能：删除空目录</li></ul><h3 id="指令快捷键"><a href="#指令快捷键" class="headerlink" title="指令快捷键"></a>指令快捷键</h3><ol><li><p>历史输入<br>使用上、下箭头可以找出上一条指令和下一条指令</p></li><li><p>Tab代码补全<br>使用tab键可以快速输入指令<br>比如：我要输入shutdown指令，这时，我们可以只输入shut然后按下tab键，即可自动把shutdown补全</p><p><strong>注意</strong>：使用两下Tab补全时，如果匹配的结果有多个，这时候将会把所有匹配的结果展示出来。当结果很多时将会出现以下结果：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539654279277.png" alt="1539654279277"> </p><p>按<code>y</code>之后会列出所有匹配的结果，但因为129个比较多，而在电脑中无法一次全显示出来，所以先显示一部分：（More代表还有更多，这时按<code>回车</code>就可以向下滚动，按下<code>Ctrl+C</code>将会退出）</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539654354678.png" alt="1539654354678"> </p></li></ol><h2 id="3-2、文件浏览-管理-命令"><a href="#3-2、文件浏览-管理-命令" class="headerlink" title="3.2、文件浏览(管理)命令"></a>3.2、文件浏览(管理)命令</h2><p>日志文件,XML,properties文件</p><h3 id="cat-快捷查看当前文件的内容"><a href="#cat-快捷查看当前文件的内容" class="headerlink" title="cat 快捷查看当前文件的内容"></a><em>cat</em> 快捷查看当前文件的内容</h3><ol><li><p>cat（catenate）功能：快捷查看当前文件的内容</p><p>cat适合查看少量信息的文件</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式cat 文件名</code></pre></li></ol><h3 id="more-分页显示文件内容"><a href="#more-分页显示文件内容" class="headerlink" title="more 分页显示文件内容"></a><em>more</em> 分页显示文件内容</h3><ol><li><p>more功能：分页显示文件内容，还支持直接跳转行等功能</p></li><li><p><strong>语法</strong>：</p><pre><code>more 文件名</code></pre></li><li><p>操作：</p><pre><code>Enter    向下n行，需要定义。默认为1行空格键    向下滚动一屏 或 Ctrl+FB        返回上一屏 或 Ctrl+Bq        退出more</code></pre></li></ol><h3 id="less-分页显示文件内容"><a href="#less-分页显示文件内容" class="headerlink" title="less 分页显示文件内容"></a><em>less</em> 分页显示文件内容</h3><ol><li><p>less功能：分页显示文件内容，操作更详细</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式less -mN 文件名 # 参数-m  显示类似more命令的百分比-N  显示每行的行号</code></pre></li><li><p>操作：</p><pre><code class="shell">Enter    向下n行，需要定义。默认为1行空格键    向下滚动一屏 或 Ctrl+F    B    返回上一屏 或 Ctrl+B    q    退出more    d    前进半页    u    后退半页回车键    前进一行 或 方向键向下    y    后退一行    或 方向键向上    v    进入vim编辑器/字符串   向下搜索?字符串   向上搜索左右方向键 相当于水平滚动条</code></pre></li><li><p>特点：</p><p>适用于<strong>大量数据</strong>的查看</p></li></ol><h3 id="tail-指定文件末尾内容"><a href="#tail-指定文件末尾内容" class="headerlink" title="tail 指定文件末尾内容"></a><em>tail</em> 指定文件末尾内容</h3><ol><li><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式tail[必要参数][选择参数][文件]# 参数-n&lt;行数&gt;    显示行数-f         循环读取</code></pre></li><li><p>eg：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image001.png" alt="img"></p><ul><li>&amp; 表示后台运行，否则占用终端</li><li>ctrl + c 退出</li></ul></li></ol><h2 id="3-3、文件操作命令"><a href="#3-3、文件操作命令" class="headerlink" title="3.3、文件操作命令"></a>3.3、文件操作命令</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ol><li><p>隐藏文件</p><p>Linux中以 点<code>.</code> 开头的是隐藏文件，使用<code>ls</code>命令是查看不到的，需使用<code>ls -a</code></p></li><li><p>目录与文件的区别</p><p>当我们使用ls命令列出目录中的所有子目录和文件时，如何区分哪些是文件哪些是目录？<br>可以通过详细信息中第一列的信息来区分：以 <code>d</code> 开头的是目录，以 <code>-</code> 开头的是文件</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539658318279.png" alt="1539658318279"> </p></li></ol><h3 id="touch创建文件"><a href="#touch创建文件" class="headerlink" title="touch创建文件"></a><em>touch</em>创建文件</h3><ol><li><p>功能：创建文件</p></li><li><p>语法：</p><pre><code class="shell">touch 绝对路径/相对路径</code></pre></li></ol><h3 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp 复制"></a><em>cp</em> 复制</h3><ol><li><p>cp（copy）：复制文件或者复制目录</p></li><li><p>复制<strong>文件</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell">cp 需要复制的文件 复制的位置</code></pre><p>注意：cp可以进行重命名操作：</p><ul><li><p>cp demo1.java t1/ddd.java</p><p>当将一个 文件位置 以不同名字复制到<strong>当前文件</strong>时，意思是复制并重命名；即 将demo1.java复制到t1目录中，并重命名成ddd.java</p></li></ul></li><li><p>eg：</p><pre><code>需求：把/root/Demo1.java文件 复制到  /root/t1 目录中位置：/root命令：cp Demo1.java t1     cp /root/Demo1.java /root/t1需求：把/root/Demo1.java文件 复制到  /root/t1 目录中，改名为ddd.java位置：/root命令：cp Demo1.java t1/ddd.java</code></pre></li></ul></li><li><p>复制<strong>目录</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式cp -r 需要复制的目录 复制的位置# 参数-r或--recursive  递归处理，将指定目录下的文件与子目录一并处理 复制目录必须使用-r</code></pre></li></ul></li></ol><ul><li><p>eg：</p><pre><code>需求：把/root/t5目录 复制到  /root/t1目录中位置：/root命令：cp -r t5 t1     cp -r /root/t5 /root/t1cp ./abc ./xxx                #无法复制目录cp -r ./abc ./xxx            #复制目录必须使用 -r参数</code></pre></li></ul><h3 id="mv-移动、更名"><a href="#mv-移动、更名" class="headerlink" title="mv 移动、更名"></a><em>mv</em> 移动、更名</h3><ol><li><p>mv(move) 功能： <strong>移动</strong> 或 <strong>更名</strong> 现有的文件或目录</p></li><li><p>移动<strong>文件</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式mv -f 需要移动的文件 移动的位置# 参数-f或--force 　若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录，不进行询问</code></pre></li><li><p>eg：</p><pre><code>需求：把/root/t5 目录 移动到 /root/t3目录中位置：/root命令：mv t5 t3需求：把/root/t5 目录 移动到 /root/t3目录中        不询问，直接覆盖位置：/root已知：/root/t3目录中 已经有一个t5目录了命令：mv -f t5 t3</code></pre></li></ul></li><li><p>文件<strong>更名</strong>：</p><ul><li><p>格式：</p><pre><code class="shell">mv 需要移动的文件 新名字## 必须是在同一目录中进行此操作</code></pre></li><li><p>eg：</p><pre><code>文件/目录更名操作：需求：把/root/Demo1.java  改名为 hehe.java位置：/root命令：mv Demo1.java hehe.java</code></pre></li></ul></li></ol><h3 id="rm-删除"><a href="#rm-删除" class="headerlink" title="rm 删除"></a><em>rm</em> 删除</h3><ol><li><p>rm(remove) 功能：删除文件或目录</p></li><li><p>删除<strong>文件</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell">rm 文件名</code></pre></li></ul></li><li><p>删除<strong>目录</strong>：</p><ul><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式rm -rf 目录名# 参数-f或--force 　        强制删除文件或目录，不进行询问-r或-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。删除目录必须使用-r</code></pre></li></ul></li><li><p><strong>注意</strong>：</p><pre><code class="shell">rm -rf *     删除 当前目录 下所有内容rm –rf /*    删除Linux系统 根目录 下所有内容</code></pre></li><li><p>eg：</p><pre><code>需求：删除/root/t5 目录， 位置：/root已知：t5目录下有子目录或者文件命令：rm -rf t5</code></pre></li></ol><h3 id="find-查找"><a href="#find-查找" class="headerlink" title="find 查找"></a><em>find</em> 查找</h3><ol><li><p>find功能：查找文件或目录</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell">find 目录名 -name &#39;需要查找的字符串&#39;-name 指定字符串作为寻找文件或目录的范本样式* 表示0~多个任意字符 eg：find t1 -name &#39;*.txt&#39;</code></pre></li><li><p>eg:</p><pre><code>需求：查找/root目录下 所有以ins开头的文件或者目录位置：/root命令：find /root -name &#39;ins*&#39;</code></pre></li></ol><h2 id="3-4、文档编辑命令"><a href="#3-4、文档编辑命令" class="headerlink" title="3.4、文档编辑命令"></a>3.4、文档编辑命令</h2><p>Windows是有记事本<br>Linux也有类似的记事本功能   VIM编辑器</p><h3 id="VI-编辑"><a href="#VI-编辑" class="headerlink" title="VI 编辑"></a><em>VI</em> 编辑</h3><ol><li><p>操作：</p><ul><li>输入 <code>vi 文件名</code>  进入 “命令(一般)模式”</li><li>按下 “<strong>i</strong>” 从一般模式，进入“插入模式”</li><li>按下 “<strong>esc</strong>” 从“插入模式”退出到“一般模式”</li><li>在“一般模式”下，输入 “<strong>:wq</strong>”，退出编辑</li></ul><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538637143785.png" alt="1538637143785"></p></li><li></li></ol><h3 id="vim-命令"><a href="#vim-命令" class="headerlink" title="vim 命令"></a><em>vim</em> 命令</h3><ol><li><p>操作：</p><ul><li>输入 <code>vim 文件名</code> 或 <code>vi 文件名</code> 进入 “一般模式”</li><li>按下 “<strong>i</strong>” 从一般模式，进入“插入模式”</li><li>按下 “<strong>esc</strong>” 从“插入模式”退出到“一般模式”</li><li>在“一般模式”下，输入 “<strong>:wq</strong>”，退出编辑</li></ul><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538637143785.png" alt="1538637143785"></p></li><li><ul><li><strong>一般(命令)</strong>模式:<ul><li>可以<strong>浏览文件内容</strong>，可以进行文本快捷操作（单行复制，多行复制，单行删除，多行删除…）</li><li>按 <strong>i/a/o</strong> 可以切换到 <strong>插入</strong>模式<br>按 <strong>:</strong> 可以切换到 <strong>底行</strong>模式</li></ul></li><li><strong>插入</strong>模式：<ul><li>可以<strong>编辑</strong>文件内容。</li><li>按 <strong>ESC</strong> 可以切回 <strong>一般</strong>模式</li></ul></li><li><strong>底行</strong>模式：<ul><li>可以进行<strong>强制退出不保存</strong>操作   <strong>q!</strong></li><li>可以进行<strong>保存并退出</strong>操作  <strong>wq</strong></li></ul></li></ul></li></ol><h2 id="3-5、grep-、-管道-、重定向输出-gt-gt"><a href="#3-5、grep-、-管道-、重定向输出-gt-gt" class="headerlink" title="3.5、grep 、 管道|、重定向输出&gt;&gt;"></a>3.5、<em>grep</em> 、 管道|、重定向输出&gt;&gt;</h2><h3 id="grep-正则表达式"><a href="#grep-正则表达式" class="headerlink" title="grep 正则表达式"></a><em>grep</em> 正则表达式</h3><ol><li><p>grep：正则表达式，进行字符串搜索工作</p><p>用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活</p></li><li><p><strong>语法</strong>：</p><pre><code class="shell"># 格式grep -i 需要搜索的字符串 搜索的文件# 参数-i 忽略大小写查找数据</code></pre><p>符合规则，就会返回符合规则的<strong>行</strong></p></li></ol><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a><em>管道</em></h3><ol><li><p>管道命令： 可以连接多个Linux命令，其作用是<strong>将一个命令的输出用在另一个命令的输入</strong></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538638149167.png" alt="1538638149167"></p></li><li><p>格式：</p><pre><code class="seh">命令1 | 命令2 | 命令3……</code></pre></li><li><p>eg：</p><pre><code>需求：查询当前目录中，所有带ins关键字的行数据位置：/root思考：查询当前目录内容  ll     查询字符串，返回字符串所在行  grep命令：ll | grep ins需求：分页显示ls的help信息命令：ls --help | more</code></pre></li></ol><h3 id="重定向输出-gt-gt-gt"><a href="#重定向输出-gt-gt-gt" class="headerlink" title="重定向输出&gt; &gt;&gt;"></a>重定向输出&gt; &gt;&gt;</h3><ol><li><p>重定向输出</p><ul><li><p>&gt;</p><p>定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空</p></li><li><p>&gt;&gt;</p><p>将输出内容追加到目标文件中。如果文件不存在，就创建文件；如果文件存在，则将新的内容追加到那个文件的末尾，该文件中的原有内容不受影响</p></li></ul><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539671830735.png" alt="1539671830735"></p></li><li><p>格式：</p><p>注意：</p></li><li><p>使用：</p><ul><li><p>将一个文件夹的内容保存到文本文件中去，也就是将<code>ls</code>命令打印出来的内容都写到文本中去可以这样：</p><pre><code class="shell"># a.txt文件中就是ls命令打印出来的内容了ls -al &gt;&gt; a.txt</code></pre></li></ul></li></ol><h2 id="3-6、压缩、解压命令【重要】"><a href="#3-6、压缩、解压命令【重要】" class="headerlink" title="3.6、压缩、解压命令【重要】"></a>3.6、压缩、解压命令【重要】</h2><ol><li><p>Linux常见压缩包： <em>.tar        打包，大小不会进行压缩<br>​              </em>.tar.gz   打包并压缩文件大小</p></li><li><p><strong>压缩</strong>：(<strong>参数顺序不变</strong>)</p><pre><code># 格式tar -zcvf 压缩包名字.tar.gz 需要压缩的内容# 参数-z 是否需要用 gzip 压缩-c 建立一个压缩文件的参数指令（create）--压缩-v 压缩的过程中显示文件（verbose）-f 使用档案名称，在 f 之后要立即接档名（file）</code></pre><p>eg：</p><pre><code>例如：tar -zcvf hehe.tar.gz *   将当前目录下所有内容进行打包压缩，文件名hehe.tar.gz</code></pre></li><li><p><strong>解压</strong>：(<strong>参数顺序不变</strong>)</p><pre><code># 解压到当前目录tar -zxvf 需要解压的压缩包名称 解压到当前目录# 解压到指定目录tar -zxvf 需要解压的压缩包名称 -C 指定压缩路径  解压到指定目录中# 参数-z 是否需要用 gzip 压缩-x 解开一个压缩文件的参数指令（extract）--解压-v 压缩的过程中显示文件（verbose）-f 使用档名，在 f 之后要立即接档名（file）</code></pre><p>eg：</p><pre><code>需求：需要把/root/t5/hehe.tar.gz  压缩包 解压到 指定目录中。指定目录/root/t5/t5位置：/root/t5命令：tar -zxvf hehe.tar.gz -C /root/t5/t5tar -zxvf hehe.tar.gz -C t5</code></pre></li></ol><h2 id="3-7、系统命令"><a href="#3-7、系统命令" class="headerlink" title="3.7、系统命令"></a>3.7、系统命令</h2><h3 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h3><p>服务，是指常期运行，常驻内存中的进程，比如，apache、mysql、ssh等</p><h4 id="服务与端口"><a href="#服务与端口" class="headerlink" title="服务与端口"></a>服务与端口</h4><p>每个服务软件一般在运行时都会对应一个端口。<br>查看监听的端口：</p><pre><code class="shell">ss –lntp</code></pre><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1539792074690.png" alt="1539792074690"></p><h4 id="防火墙及防火墙设置"><a href="#防火墙及防火墙设置" class="headerlink" title="防火墙及防火墙设置"></a>防火墙及防火墙设置</h4><p>CentOS 7.0默认使用的是<code>firewall</code>作为防火墙，使用<code>iptables</code>必须重新设置一下</p><p>查看防火墙状态：</p><pre><code class="shell">firewall-cmd --state# running 防火墙处于开启状态# not running 防火墙处于关闭状态</code></pre><h5 id="直接关闭防火墙"><a href="#直接关闭防火墙" class="headerlink" title="直接关闭防火墙"></a>直接关闭防火墙</h5><p>停止<strong>firewall</strong>：</p><pre><code class="shell">systemctl stop firewalld.service</code></pre><p>禁止<strong>firewall</strong>开机启动：</p><pre><code class="shell">systemctl disable firewalld.service </code></pre><h4 id="查看系统进程：ps-ef"><a href="#查看系统进程：ps-ef" class="headerlink" title="查看系统进程：ps -ef"></a>查看系统进程：ps -ef</h4><pre><code>需求：查看进程中 和 vim相关的进程命令：ps -ef|grep -i vim-e 　此参数的效果和指定&quot;A&quot;参数相同，显示所有程序-f 　显示UID,PPIP,C与STIME栏位</code></pre><h4 id="强制杀死某个进程：kill-9-pid号"><a href="#强制杀死某个进程：kill-9-pid号" class="headerlink" title="强制杀死某个进程：kill -9 pid号"></a>强制杀死某个进程：kill -9 pid号</h4><pre><code>需求：查看进程 和 vim相关的进程有哪些，并将vim进程杀死命令：ps -ef|grep -i vim     Kill -9 pid号-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称kill 9 表示强制终止</code></pre><ol><li>查看网络配置：<strong>ifconfig</strong><ul><li>显示网络设备</li></ul></li><li>测试和目标的连通性：<strong>ping 主机名或ip地址</strong><ul><li>测试与目标主机的连通性</li><li>会持续不断一直测试，直到ctrl+c</li></ul></li><li>Linux centos重启命令：<strong>reboot</strong></li><li>Linux centos关机命令：<strong>halt</strong></li></ol><h2 id="3-8、其他命令（了解）"><a href="#3-8、其他命令（了解）" class="headerlink" title="3.8、其他命令（了解）"></a>3.8、其他命令（了解）</h2><h3 id="chmod-文件权限"><a href="#chmod-文件权限" class="headerlink" title="chmod 文件权限"></a><em>chmod</em> 文件权限</h3><ol><li><p>hmod(change mode) 功能：变更文件或目录的权限</p></li><li><p>语法：</p><pre><code># 格式chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;]# 参数-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理</code></pre><ul><li>权限范围的表示法如下：<ul><li>u：User，即文件或目录的拥有者</li><li>g：Group，即文件或目录的所属群组</li><li>o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围</li><li>a：All，即全部的用户，包含拥有者，所属群组以及其他用户</li></ul></li><li>符号：<ul><li>‘+’添加权限</li><li>‘-‘取消权限</li></ul></li><li>有关权限代号的部分，列表于下：<ul><li>r：读取权限，数字代号为”4”</li><li>w：写入权限，数字代号为”2”</li><li>x：执行或切换权限，数字代号为”1”</li><li>-：不具任何权限，数字代号为”0”</li></ul></li></ul></li><li><p>eg:</p><pre><code>mkdir xxxll | grep xxxchmod u-rwx xxx        #取消xxx目录，用户“读写执行”权限chmod g-rwx xxx     #取消xxx目录，组“读写执行”权限chmod 777 xxx        #给xxx目录添加所有权限</code></pre></li><li><p>linux 权限格式：&lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt;</p><p><img src="https://raw.githubusercontent.com/xiongtianci-tc/myHexoBlog/master/img/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1543568285232.png" alt="img"></p></li></ol><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><ol><li><p>VIM命令配置</p><ul><li><p>网卡配置 cat /etc/sysconfig/network-scripts/ifcfg-eth0</p></li><li><p>概要信息如下:</p><pre><code>DEVICE=eth0                 #网卡名称TYPE=Ethernet               #网卡类型ONBOOT=yes                  #是否开机启动网卡BOOTPROTO=static            #静态获取IP，其他取值：dhcp （如果设置dhcp下面红色不需要）IPADDR=192.168.44.100       #ip地址GATEWAY=192.168.44.2        #网关NETMASK=255.255.255.0       #子网掩码</code></pre></li></ul></li><li><p>setup设置</p><ol><li><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image002-1538642819190.jpg?raw=true" alt="img"> </p></li><li><p>选择“网络配置”</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image002-1538642858562.jpg?raw=true" alt="img"> </p></li><li><p>选择“设备配置”</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image001-1538642873407.png" alt="img"> </p></li><li><p>选择“第一块网卡”</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538642891449.png" alt="1538642891449"> </p></li><li><p>设置IP地址等详细信息</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/clip_image001.png" alt="img"> </p></li></ol></li></ol><h1 id="命令总结-和-帮助"><a href="#命令总结-和-帮助" class="headerlink" title="命令总结 和 帮助"></a>命令总结 和 帮助</h1><ul><li><p>内部命令：属于Shell解析器的一部分 （系统启动直接加载到内存的）</p><pre><code>cd   切换目录（change directory）pwd  显示当前工作目录（print working directory）help 帮助</code></pre></li><li><p>外部命令：独立于Shell解析器之外的文件程序（独立的可执行文件）</p><pre><code>ls    显示文件和目录列表（list）mkdir 创建目录（make directoriy）cp    复制文件或目录（copy）</code></pre></li><li><p>查看帮助文档</p><ul><li><p>内部命令：help + 命令（eg：help cd）</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538643143565.png" alt="1538643143565"> </p></li><li><p>外部命令：man + 命令（eg：man ls）</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181130-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1538643159745.png" alt="1538643159745"> </p></li></ul></li><li><p>不用特意记忆命令分类，开发中，如果需要查看命令参数，先使用<strong>man</strong>，如果没有结果，再使用<strong>help</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      Linux常用命令
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://www.xiongtianci.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣Top250资源合集</title>
    <link href="https://www.xiongtianci.com/2018/11/29/%E8%B1%86%E7%93%A3Top250%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/"/>
    <id>https://www.xiongtianci.com/2018/11/29/豆瓣Top250资源合集/</id>
    <published>2018-11-28T17:45:30.000Z</published>
    <updated>2019-06-12T09:22:37.781Z</updated>
    
    <content type="html"><![CDATA[<p><br><br><div style="display:flex;justify-content:center;"><font color="hotpink">点击影片”名称”即可获取资源链接</font></div></p><div style="display:flex;justify-content:flex-end"><font color="red"># 更新至Top1-Top100，敬请期待…</font></div><table border="1" style="text-align: center;"><thead><tr><th>排名</th><th>名称</th><th>年份</th><th>评分</th></tr></thead><tbody><tr><td>Top1</td><td><a href="https://pan.baidu.com/s/1Hl1j9BGzvxhdaRfGGGL2zQ" target="_blank" rel="noopener">肖申克的救赎</a></td><td>1994</td><td>9.6</td></tr><tr><td>Top2</td><td><a href="http://pan.baidu.com/s/1gfOr0Dd" target="_blank" rel="noopener">霸王别姬</a></td><td>1993</td><td>9.6</td></tr><tr><td>Top3</td><td><a href="http://pan.baidu.com/s/1bpNdERt" target="_blank" rel="noopener">这个杀手不太冷</a></td><td>1994</td><td>9.4</td></tr><tr><td>Top4</td><td><a href="https://pan.baidu.com/s/1o8Nejc2?fid=853395936269539" target="_blank" rel="noopener">阿甘正传</a></td><td>1994</td><td>9.4</td></tr><tr><td>Top5</td><td><a href="https://pan.baidu.com/s/14sshh?fid=738933366388433" target="_blank" rel="noopener">美丽人生</a></td><td>1997</td><td>9.5</td></tr><tr><td>Top6</td><td><a href="http://pan.baidu.com/s/1o7PiQ3w" target="_blank" rel="noopener">泰坦尼克号</a></td><td>1997</td><td>9.3</td></tr><tr><td>Top7</td><td><a href="https://pan.baidu.com/s/11xA1VNyZZlboNTckXywkxQ" target="_blank" rel="noopener">千与千寻</a></td><td>2001</td><td>9.3</td></tr><tr><td>Top8</td><td><a href="http://pan.baidu.com/s/1qXCTBic" target="_blank" rel="noopener">辛德勒的名单</a></td><td>1993</td><td>9.5</td></tr><tr><td>Top9</td><td><a href=" http://pan.baidu.com/s/1i5w3bkp" target="_blank" rel="noopener">盗梦空间</a></td><td>2010</td><td>9.3</td></tr><tr><td>Top10</td><td><a href="https://pan.baidu.com/s/1ge5y0nD?fid=923497949059553" target="_blank" rel="noopener">机器人总动员</a></td><td>2008</td><td>9.3</td></tr><tr><td>Top11</td><td><a href="https://pan.baidu.com/s/1mhQXQIG?fid=859409840409891" target="_blank" rel="noopener">忠犬八公的故事</a></td><td>2009</td><td>9.3</td></tr><tr><td>Top12</td><td><a href="http://pan.baidu.com/s/1eRFpHLK" target="_blank" rel="noopener">三傻大闹宝莱坞</a></td><td>2009</td><td>9.2</td></tr><tr><td>Top13</td><td><a href="http://pan.baidu.com/s/1boR7j3p" target="_blank" rel="noopener">海上钢琴师</a></td><td>1998</td><td>9.2</td></tr><tr><td>Top14</td><td><a href="http://pan.baidu.com/s/1eRDnUi2" target="_blank" rel="noopener">放牛班的春天</a></td><td>2004</td><td>9.2</td></tr><tr><td>Top15</td><td><a href="https://pan.baidu.com/s/1Cd9bMZjqWbhTS0wLKWfr_w?fid=351298108017917" target="_blank" rel="noopener">大话西游之大圣娶亲</a></td><td>1995</td><td>9.2</td></tr><tr><td>Top16</td><td><a href="https://pan.baidu.com/s/1GZ356B4GumSYp2afnrcCpg?fid=354248154465777" target="_blank" rel="noopener">楚门的世界</a></td><td>1998</td><td>9.2</td></tr><tr><td>Top17</td><td><a href="https://pan.baidu.com/s/1i3YIMAp?fid=1074753729212605" target="_blank" rel="noopener">教父</a></td><td>1972</td><td>9.2</td></tr><tr><td>Top18</td><td><a href="https://pan.baidu.com/s/14wznp?fid=823033633333159" target="_blank" rel="noopener">星际穿越</a></td><td>2014</td><td>9.2</td></tr><tr><td>Top19</td><td><a href="https://pan.baidu.com/s/1bo0FnXl?fid=252951322427901" target="_blank" rel="noopener">龙猫</a></td><td>1988</td><td>9.1</td></tr><tr><td>Top20</td><td><a href="https://pan.baidu.com/s/1zLis1PHuhxILsa7Ac7Wx9Q" target="_blank" rel="noopener">熔炉</a></td><td>2011</td><td>9.3</td></tr><tr><td>Top21</td><td><a href="https://pan.baidu.com/s/1MUAbY8A5kUaAh_6HXPCjqA" target="_blank" rel="noopener">无间道</a></td><td>2002</td><td>9.1</td></tr><tr><td>Top22</td><td><a href="https://pan.baidu.com/s/1nuSZ9ix?fid=703054725115319" target="_blank" rel="noopener">当幸福来敲门</a></td><td>2006</td><td>9.0</td></tr><tr><td>Top23</td><td><a href="https://pan.baidu.com/s/1FlfH_qZf38PlbwX9E512yA" target="_blank" rel="noopener">触不可及</a></td><td>2011</td><td>9.2</td></tr><tr><td>Top24</td><td><a href="https://pan.baidu.com/s/1s6_q9mZKLAKwNAh4O7-r3w" target="_blank" rel="noopener">怦然心动</a></td><td>2010</td><td>9.0</td></tr><tr><td>Top25</td><td><a href="https://pan.baidu.com/s/15svfI?fid=2938514528" target="_blank" rel="noopener">乱世佳人</a></td><td>1939</td><td>9.2</td></tr><tr><td>Top26</td><td><a href="https://pan.baidu.com/s/1jIvYj2m?fid=859083213231438" target="_blank" rel="noopener">疯狂动物城</a></td><td>2016</td><td>9.2</td></tr><tr><td>Top27</td><td><a href="https://pan.baidu.com/s/1gUs1lMPvhWLP8x_ijzpNGw" target="_blank" rel="noopener">蝙蝠侠：黑暗骑士</a></td><td>2008</td><td>9.1</td></tr><tr><td>Top28</td><td><a href="https://pan.baidu.com/s/1bqOlUAr?fid=1002856157420219" target="_blank" rel="noopener">天堂电影院</a></td><td>1988</td><td>9.1</td></tr><tr><td>Top29</td><td><a href="https://pan.baidu.com/s/1dE79wGx?fid=267490512661091" target="_blank" rel="noopener">活着</a></td><td>1994</td><td>9.1</td></tr><tr><td>Top30</td><td><a href="https://pan.baidu.com/s/1ZszH2VXTSPUAqNo8By1lfA" target="_blank" rel="noopener">少年派的奇幻漂流</a></td><td>2012</td><td>9.0</td></tr><tr><td>Top31</td><td><a href="https://pan.baidu.com/s/1IOy5uip6rYWhQsgbsxbB0g" target="_blank" rel="noopener">十二怒汉</a></td><td>1957</td><td>9.4</td></tr><tr><td>Top32</td><td><a href="https://pan.baidu.com/s/1gNtiJXKiXQ9DH0goLVuA2Q" target="_blank" rel="noopener">鬼子来了</a></td><td>2000</td><td>9.2</td></tr><tr><td>Top33</td><td><a href="https://pan.baidu.com/s/18wC7U?fid=254565905159819" target="_blank" rel="noopener">指环王3：王者无敌</a></td><td>2003</td><td>9.1</td></tr><tr><td>Top34</td><td><a href="https://pan.baidu.com/s/15m0uRMjTz07_TZ88L2uTUA" target="_blank" rel="noopener">控方证人</a></td><td>1957</td><td>9.6</td></tr><tr><td>Top35</td><td><a href="https://pan.baidu.com/s/1sjqhVGx?fid=906768803799193" target="_blank" rel="noopener">搏击俱乐部</a></td><td>1999</td><td>9.0</td></tr><tr><td>Top36</td><td><a href="https://pan.baidu.com/s/12MgZrABxuQ-oPNJ9auTgVA" target="_blank" rel="noopener">天空之城</a></td><td>1986</td><td>9.0</td></tr><tr><td>Top37</td><td><a href="https://pan.baidu.com/s/1Jc-0DcaIoJuUrtP2pH4vOg" target="_blank" rel="noopener">飞屋环游记</a></td><td>2009</td><td>8.9</td></tr><tr><td>Top38</td><td><a href="https://pan.baidu.com/s/10raMk?fid=973205912028341" target="_blank" rel="noopener">大话西游之月光宝盒</a></td><td>1995</td><td>8.9</td></tr><tr><td>Top39</td><td><a href="https://pan.baidu.com/s/13WJuB?fid=937467810241967" target="_blank" rel="noopener">罗马假日</a></td><td>1953</td><td>9.0</td></tr><tr><td>Top40</td><td><a href="https://pan.baidu.com/s/1sl3D0Gd#list/path=%2F" target="_blank" rel="noopener">摔跤吧！爸爸</a></td><td>2016</td><td>9.1</td></tr><tr><td>Top41</td><td><a href="https://pan.baidu.com/s/1TfnhXTgWsPub6HQwck3Oag" target="_blank" rel="noopener">窃听风暴</a></td><td>2006</td><td>9.1</td></tr><tr><td>Top42</td><td><a href="https://pan.baidu.com/s/14u2gB?fid=263900955744687" target="_blank" rel="noopener">辩护人</a></td><td>2013</td><td>9.2</td></tr><tr><td>Top43</td><td><a href="https://pan.baidu.com/share/link?shareid=558455183&uk=3623880440&fid=2141965982" target="_blank" rel="noopener">两杆大烟枪</a></td><td>1998</td><td>9.1</td></tr><tr><td>Top44</td><td><a href="https://pan.baidu.com/s/1-9SOF2mFoQSseIntwx_N9Q?fid=754656724538878" target="_blank" rel="noopener">闻香识女人</a></td><td>1992</td><td>9.0</td></tr><tr><td>Top45</td><td><a href="https://pan.baidu.com/s/1waI720ZTkEYh_KV_V102oQ" target="_blank" rel="noopener">哈尔的移动城堡</a></td><td>2004</td><td>8.9</td></tr><tr><td>Top46</td><td><a href="https://pan.baidu.com/s/1ifJ7h4Q_RWCsMOeRFY_RbA" target="_blank" rel="noopener">飞越疯人院</a></td><td>1975</td><td>9.0</td></tr><tr><td>Top47</td><td><a href="https://pan.baidu.com/s/1ge38MlH?fid=389555883875523" target="_blank" rel="noopener">死亡诗社</a></td><td>1989</td><td>9.0</td></tr><tr><td>Top48</td><td><a href="https://pan.baidu.com/s/1Js4qCj2GEQ9DF9hgkDL4cw" target="_blank" rel="noopener">V字仇杀队</a></td><td>2005</td><td>8.8</td></tr><tr><td>Top49</td><td><a href="https://pan.baidu.com/s/1gf4TipX?fid=309002731979882" target="_blank" rel="noopener">海豚湾</a></td><td>2009</td><td>9.3</td></tr><tr><td>Top50</td><td><a href="https://pan.baidu.com/s/1gfPWl0n?fid=95543062299217" target="_blank" rel="noopener">教父2</a></td><td>1974</td><td>9.1</td></tr><tr><td>Top51</td><td><a href="https://pan.baidu.com/s/15IgbR?fid=695943185158780" target="_blank" rel="noopener">指环王2：双塔奇兵</a></td><td>2002</td><td>9.0</td></tr><tr><td>Top52</td><td><a href="https://pan.baidu.com/s/19f0HS?fid=803394449358026" target="_blank" rel="noopener">指环王1：魔戒再现</a></td><td>2001</td><td>8.9</td></tr><tr><td>Top53</td><td><a href="https://pan.baidu.com/s/1Fo42K5QFS0ZLvnxFkmGVBQ" target="_blank" rel="noopener">美丽心灵</a></td><td>2001</td><td>8.9</td></tr><tr><td>Top54</td><td><a href="https://pan.baidu.com/s/1_GEJ_CoHeQuqUFtyzrwDIg" target="_blank" rel="noopener">饮食男女</a></td><td>1994</td><td>9.1</td></tr><tr><td>Top55</td><td><a href="https://pan.baidu.com/s/1O1Wi9V1ikEggIVpMMZSqZQ" target="_blank" rel="noopener">情书</a></td><td>1995</td><td>8.8</td></tr><tr><td>Top56</td><td><a href="https://pan.baidu.com/s/1jIBD8iU?fid=241575748710910" target="_blank" rel="noopener">素媛</a></td><td>2013</td><td>9.1</td></tr><tr><td>Top57</td><td><a href="https://pan.baidu.com/s/1acVbcpPFtCkuVaR0NuvVMA" target="_blank" rel="noopener">狮子王</a></td><td>1994</td><td>8.9</td></tr><tr><td>Top58</td><td><a href="https://pan.baidu.com/s/1ISIPJI1CzZ0wyxgchU7ZUQ" target="_blank" rel="noopener">钢琴家</a></td><td>2002</td><td>9.1</td></tr><tr><td>Top59</td><td><a href="https://pan.baidu.com/s/1Lr6zQTA94CbMXZP8CKePNA" target="_blank" rel="noopener">美国往事</a></td><td>1984</td><td>9.1</td></tr><tr><td>Top60</td><td><a href="https://pan.baidu.com/s/1e62DBaMv9qaYgP960B0dpQ" target="_blank" rel="noopener">小鞋子</a></td><td>1997</td><td>9.2</td></tr><tr><td>Top61</td><td><a href="https://pan.baidu.com/s/1K5Zgnm7DAFx_ZeNo18ayjA" target="_blank" rel="noopener">七宗罪</a></td><td>1995</td><td>8.8</td></tr><tr><td>Top62</td><td><a href="https://pan.baidu.com/s/1eoFq0O4ZrFo3mBs_3jPajA" target="_blank" rel="noopener">被嫌弃的松子的一生</a></td><td>2006</td><td>8.9</td></tr><tr><td>Top63</td><td><a href="https://pan.baidu.com/s/1KDC_qYq-nxCSAqZE0qDTIg" target="_blank" rel="noopener">致命魔术</a></td><td>2006</td><td>8.8</td></tr><tr><td>Top64</td><td><a href="https://pan.baidu.com/s/19a04jR2acwbTx2ho1v8Ejg" target="_blank" rel="noopener">本杰明·巴顿奇事</a></td><td>2008</td><td>8.8</td></tr><tr><td>Top65</td><td><a href="https://pan.baidu.com/s/1EwTT6TsO_yrrJxS0LVnOHw" target="_blank" rel="noopener">末代皇帝</a></td><td>1987</td><td>9.0</td></tr><tr><td>Top66</td><td><a href="https://pan.baidu.com/s/1XnhKY7Hxon8IQoTgUsFT_A?fid=1096320857195922" target="_blank" rel="noopener">西西里的美丽传说</a></td><td>2000</td><td>8.8</td></tr><tr><td>Top67</td><td><a href="https://pan.baidu.com/s/1453_7kpPiqeQnoG0LFiV5w" target="_blank" rel="noopener">天使爱美丽</a></td><td>2001</td><td>8.7</td></tr><tr><td>Top68</td><td><a href="https://pan.baidu.com/s/1ysPw4189zFZBDFm_Pe2FVA" target="_blank" rel="noopener">黑客帝国</a></td><td>1999</td><td>8.9</td></tr><tr><td>Top69</td><td><a href="https://pan.baidu.com/s/1AdCvtWEOE457L2mOCRJgPA" target="_blank" rel="noopener">让子弹飞</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top70</td><td><a href="https://pan.baidu.com/s/1KkAEvlGPBjVcS_3ugScM_A" target="_blank" rel="noopener">拯救大兵瑞恩</a></td><td>1998</td><td>8.9</td></tr><tr><td>Top71</td><td><a href="https://pan.baidu.com/s/1bqFwEvl#list/path=%2F&parentPath=%2F%E6%88%91%E7%9A%84%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">看不见的客人</a></td><td>2016</td><td>8.7</td></tr><tr><td>Top72</td><td><a href="https://pan.baidu.com/s/1EAE2GMs5tCz09Proae6uyw" target="_blank" rel="noopener">音乐之声</a></td><td>1965</td><td>8.9</td></tr><tr><td>Top73</td><td><a href="https://pan.baidu.com/s/1p_yW-ruXtEK5heKsFmQNUw" target="_blank" rel="noopener">低俗小说</a></td><td>1994</td><td>8.8</td></tr><tr><td>Top74</td><td><a href="https://pan.baidu.com/s/1WVXAxAM0I2b8SNIjDMGE0Q" target="_blank" rel="noopener">勇敢的心</a></td><td>1995</td><td>8.8</td></tr><tr><td>Top75</td><td><a href="https://pan.baidu.com/s/16XvuTxWzJh4s_w7-whqrOA" target="_blank" rel="noopener">剪刀手爱德华</a></td><td>1990</td><td>8.7</td></tr><tr><td>Top76</td><td><a href="https://pan.baidu.com/s/1mlcerfQxK3WForgNa6SKwg" target="_blank" rel="noopener">大闹天宫</a></td><td>1961196419782004</td><td>9.3</td></tr><tr><td>Top77</td><td><a href="https://pan.baidu.com/s/1pLgFPbX?fid=464690874078412" target="_blank" rel="noopener">沉默的羔羊</a></td><td>1991</td><td>8.8</td></tr><tr><td>Top78</td><td><a href="https://pan.baidu.com/s/1x7yq0ULCJtAtMtuVDemGRA" target="_blank" rel="noopener">蝴蝶效应</a></td><td>2004</td><td>8.7</td></tr><tr><td>Top79</td><td><a href="https://pan.baidu.com/s/1elizCqrt3kU7kHXjm_A-zQ" target="_blank" rel="noopener">哈利·波特与魔法石</a></td><td>2001</td><td>8.8</td></tr><tr><td>Top80</td><td><a href="https://pan.baidu.com/s/1gfOcT2r?fid=35225760102993" target="_blank" rel="noopener">春光乍泄</a></td><td>1997</td><td>8.8</td></tr><tr><td>Top81</td><td><a href="https://pan.baidu.com/s/1ZxEIADzr_rO3ZIDW5nGB3w" target="_blank" rel="noopener">入殓师</a></td><td>2008</td><td>8.8</td></tr><tr><td>Top82</td><td><a href="https://pan.baidu.com/s/1bGhs44VwbBZEqaaelsz8GQ" target="_blank" rel="noopener">心灵捕手</a></td><td>1997</td><td>8.8</td></tr><tr><td>Top83</td><td><a href="https://pan.baidu.com/s/13Lg1sGGb7aFN0oESt6F9Gw" target="_blank" rel="noopener">猫鼠游戏</a></td><td>2002</td><td>8.8</td></tr><tr><td>Top84</td><td><a href="https://pan.baidu.com/s/1pIugxrDIO6fZn7kqF-T2pw?fid=360967812964633" target="_blank" rel="noopener">布达佩斯大饭店</a></td><td>2014</td><td>8.8</td></tr><tr><td>Top85</td><td><a href="https://pan.baidu.com/s/15Lc06yp0Uu2-mrkDXa9V2g" target="_blank" rel="noopener">禁闭岛</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top86</td><td><a href="https://pan.baidu.com/s/1ZhGG3ccQiZmr2CJYr6BhEA" target="_blank" rel="noopener">玛丽和马克思</a></td><td>2009</td><td>8.9</td></tr><tr><td>Top87</td><td><a href="https://pan.baidu.com/s/1GuL7JmjlihphuNpV5ENc_A" target="_blank" rel="noopener">阳光灿烂的日子</a></td><td>1994</td><td>8.8</td></tr><tr><td>Top88</td><td><a href="https://pan.baidu.com/s/1gnDTK-Y2GV-ywPky8b75vg" target="_blank" rel="noopener">第六感</a></td><td>1999</td><td>8.8</td></tr><tr><td>Top89</td><td><a href="https://pan.baidu.com/s/1iQ_obdzemXyp7sd9-YEsUA" target="_blank" rel="noopener">幽灵公主</a></td><td>1997</td><td>8.8</td></tr><tr><td>Top90</td><td><a href="https://pan.baidu.com/s/17_MV94EH_TKT8XElVrGzFw" target="_blank" rel="noopener">重庆森林</a></td><td>1994</td><td>8.7</td></tr><tr><td>Top91</td><td><a href="https://pan.baidu.com/s/1bA7IQEPDwSEQXmEbGhp1Jw" target="_blank" rel="noopener">狩猎</a></td><td>2012</td><td>9.1</td></tr><tr><td>Top92</td><td><a href="https://pan.baidu.com/s/1XCZDkMDTvfSKOkPY-8VVDQ" target="_blank" rel="noopener">致命ID</a></td><td>2003</td><td>8.7</td></tr><tr><td>Top93</td><td><a href="https://pan.baidu.com/s/1kd0rlbX-aAJsDZhzzjBusw" target="_blank" rel="noopener">穿条纹睡衣的男孩</a></td><td>2008</td><td>8.9</td></tr><tr><td>Top94</td><td><a href="https://pan.baidu.com/s/1cCdglN-WrcOgcIKSsq9d_w" target="_blank" rel="noopener">断背山</a></td><td>2005</td><td>8.7</td></tr><tr><td>Top95</td><td><a href="https://pan.baidu.com/s/1Z0TdybqvMFqiGf5AssaP_w" target="_blank" rel="noopener">加勒比海盗</a></td><td>2003</td><td>8.6</td></tr><tr><td>Top96</td><td><a href="https://pan.baidu.com/s/1-tx2TPNbGAKQgId6fz8geA" target="_blank" rel="noopener">大鱼</a></td><td>2003</td><td>8.7</td></tr><tr><td>Top97</td><td><a href="https://pan.baidu.com/s/126MI3BRV4xc8yPGveGHKzw" target="_blank" rel="noopener">阿凡达</a></td><td>2009</td><td>8.6</td></tr><tr><td>Top98</td><td><a href="https://pan.baidu.com/s/1ef5Yb_O7HSUKAy_Gkr7zlg" target="_blank" rel="noopener">摩登时代</a></td><td>1936</td><td>9.2</td></tr><tr><td>Top99</td><td><a href="https://pan.baidu.com/s/1ruqr3uwuVTYLIBv5XP77LQ" target="_blank" rel="noopener">告白</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top100</td><td><a href="https://pan.baidu.com/s/1QvOiIg25WAtGBpE88AbOGw" target="_blank" rel="noopener">一一</a></td><td>2000</td><td>9.0</td></tr><tr><td>Top101</td><td><a href>射雕英雄传之东成西就</a></td><td>1993</td><td>8.7</td></tr><tr><td>Top102</td><td><a href>甜蜜蜜</a></td><td>1996</td><td>8.8</td></tr><tr><td>Top103</td><td><a href>阳光姐妹淘</a></td><td>2011</td><td>8.8</td></tr><tr><td>Top104</td><td><a href>消失的爱人</a></td><td>2014</td><td>8.7</td></tr><tr><td>Top105</td><td><a href>爱在黎明破晓前</a></td><td>1995</td><td>8.7</td></tr><tr><td>Top106</td><td><a href>上帝之城</a></td><td>2002</td><td>8.9</td></tr><tr><td>Top107</td><td><a href>小森林 夏秋篇</a></td><td>2014</td><td>8.9</td></tr><tr><td>Top108</td><td><a href>侧耳倾听</a></td><td>1995</td><td>8.8</td></tr><tr><td>Top109</td><td><a href>喜剧之王</a></td><td>1999</td><td>8.6</td></tr><tr><td>Top110</td><td><a href>倩女幽魂</a></td><td>1987</td><td>8.6</td></tr><tr><td>Top111</td><td><a href>恐怖直播</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top112</td><td><a href>风之谷</a></td><td>1984</td><td>8.8</td></tr><tr><td>Top113</td><td><a href>爱在日落黄昏时</a></td><td>2004</td><td>8.8</td></tr><tr><td>Top114</td><td><a href>超脱</a></td><td>2011</td><td>8.8</td></tr><tr><td>Top115</td><td><a href>红辣椒</a></td><td>2006</td><td>8.9</td></tr><tr><td>Top116</td><td><a href>菊次郎的夏天</a></td><td>1999</td><td>8.8</td></tr><tr><td>Top117</td><td><a href>驯龙高手</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top118</td><td><a href>幸福终点站</a></td><td>2004</td><td>8.7</td></tr><tr><td>Top119</td><td><a href>神偷奶爸</a></td><td>2010</td><td>8.5</td></tr><tr><td>Top120</td><td><a href>借东西的小人阿莉埃蒂</a></td><td>2010</td><td>8.7</td></tr><tr><td>Top121</td><td><a href>杀人回忆</a></td><td>2003</td><td>8.7</td></tr><tr><td>Top122</td><td><a href>七武士</a></td><td>1954</td><td>9.2</td></tr><tr><td>Top123</td><td><a href>岁月神偷</a></td><td>2010</td><td>8.6</td></tr><tr><td>Top124</td><td><a href>请以你的名字呼唤我</a></td><td>2017</td><td>8.8</td></tr><tr><td>Top125</td><td><a href>萤火虫之墓</a></td><td>1988</td><td>8.7</td></tr><tr><td>Top126</td><td><a href>怪兽电力公司</a></td><td>2001</td><td>8.6</td></tr><tr><td>Top127</td><td><a href>小森林 冬春篇</a></td><td>2015</td><td>9.0</td></tr><tr><td>Top128</td><td><a href>哈利·波特与死亡圣器(下)</a></td><td>2011</td><td>8.7</td></tr><tr><td>Top129</td><td><a href>谍影重重3</a></td><td>2007</td><td>8.7</td></tr><tr><td>Top130</td><td><a href>喜宴</a></td><td>1993</td><td>8.8</td></tr><tr><td>Top131</td><td><a href>东邪西毒</a></td><td>1994</td><td>8.6</td></tr><tr><td>Top132</td><td><a href>电锯惊魂</a></td><td>2004</td><td>8.7</td></tr><tr><td>Top133</td><td><a href>贫民窟的百万富翁</a></td><td>2008</td><td>8.5</td></tr><tr><td>Top134</td><td><a href>疯狂原始人</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top135</td><td><a href>记忆碎片</a></td><td>2000</td><td>8.6</td></tr><tr><td>Top136</td><td><a href>7号房的礼物</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top137</td><td><a href>黑天鹅</a></td><td>2010</td><td>8.5</td></tr><tr><td>Top138</td><td><a href>萤火之森</a></td><td>2011</td><td>8.8</td></tr><tr><td>Top139</td><td><a href>真爱至上</a></td><td>2003</td><td>8.5</td></tr><tr><td>Top140</td><td><a href>英雄本色</a></td><td>1986</td><td>8.6</td></tr><tr><td>Top141</td><td><a href>超能陆战队</a></td><td>2014</td><td>8.6</td></tr><tr><td>Top142</td><td><a href>雨人</a></td><td>1988</td><td>8.6</td></tr><tr><td>Top143</td><td><a href>心迷宫</a></td><td>2014</td><td>8.7</td></tr><tr><td>Top144</td><td><a href>蝙蝠侠：黑暗骑士崛起</a></td><td>2012</td><td>8.6</td></tr><tr><td>Top145</td><td><a href>卢旺达饭店</a></td><td>2004</td><td>8.9</td></tr><tr><td>Top146</td><td><a href>唐伯虎点秋香</a></td><td>1993</td><td>8.5</td></tr><tr><td>Top147</td><td><a href>海洋</a></td><td>2009</td><td>9.0</td></tr><tr><td>Top148</td><td><a href>傲慢与偏见</a></td><td>2005</td><td>8.5</td></tr><tr><td>Top149</td><td><a href>荒蛮故事</a></td><td>2014</td><td>8.8</td></tr><tr><td>Top150</td><td><a href>纵横四海</a></td><td>1991</td><td>8.7</td></tr><tr><td>Top151</td><td><a href>海边的曼彻斯特</a></td><td>2016</td><td>8.6</td></tr><tr><td>Top152</td><td><a href>教父3</a></td><td>1990</td><td>8.8</td></tr><tr><td>Top153</td><td><a href>虎口脱险</a></td><td>1966</td><td>8.9</td></tr><tr><td>Top154</td><td><a href>无人知晓</a></td><td>2004</td><td>9.1</td></tr><tr><td>Top155</td><td><a href>时空恋旅人</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top156</td><td><a href>完美的世界</a></td><td>1993</td><td>9.0</td></tr><tr><td>Top157</td><td><a href>寻梦环游记</a></td><td>2017</td><td>9.0</td></tr><tr><td>Top158</td><td><a href>玩具总动员3</a></td><td>2010</td><td>8.8</td></tr><tr><td>Top159</td><td><a href>燃情岁月</a></td><td>1994</td><td>8.7</td></tr><tr><td>Top160</td><td><a href>花样年华</a></td><td>2000</td><td>8.5</td></tr><tr><td>Top161</td><td><a href>恋恋笔记本</a></td><td>2004</td><td>8.5</td></tr><tr><td>Top162</td><td><a href>达拉斯买家俱乐部</a></td><td>2013</td><td>8.7</td></tr><tr><td>Top163</td><td><a href>血战钢锯岭</a></td><td>2016</td><td>8.7</td></tr><tr><td>Top164</td><td><a href>二十二</a></td><td>2015</td><td>8.7</td></tr><tr><td>Top165</td><td><a href>雨中曲</a></td><td>1952</td><td>9.0</td></tr><tr><td>Top166</td><td><a href>魂断蓝桥</a></td><td>1940</td><td>8.8</td></tr><tr><td>Top167</td><td><a href>穿越时空的少女</a></td><td>2006</td><td>8.6</td></tr><tr><td>Top168</td><td><a href>猜火车</a></td><td>1996</td><td>8.5</td></tr><tr><td>Top169</td><td><a href>我是山姆</a></td><td>2001</td><td>8.8</td></tr><tr><td>Top170</td><td><a href>冰川时代</a></td><td>2002</td><td>8.5</td></tr><tr><td>Top171</td><td><a href>人工智能</a></td><td>2001</td><td>8.6</td></tr><tr><td>Top172</td><td><a href>爆裂鼓手</a></td><td>2014</td><td>8.6</td></tr><tr><td>Top173</td><td><a href>头脑特工队</a></td><td>2015</td><td>8.7</td></tr><tr><td>Top174</td><td><a href>被解救的姜戈</a></td><td>2012</td><td>8.6</td></tr><tr><td>Top175</td><td><a href>未麻的部屋</a></td><td>1997</td><td>8.8</td></tr><tr><td>Top176</td><td><a href>罗生门</a></td><td>1950</td><td>8.7</td></tr><tr><td>Top177</td><td><a href>浪潮</a></td><td>2008</td><td>8.7</td></tr><tr><td>Top178</td><td><a href>香水</a></td><td>2006</td><td>8.4</td></tr><tr><td>Top179</td><td><a href>朗读者</a></td><td>2008</td><td>8.5</td></tr><tr><td>Top180</td><td><a href>阿飞正传</a></td><td>1990</td><td>8.5</td></tr><tr><td>Top181</td><td><a href>你的名字。</a></td><td>2016</td><td>8.4</td></tr><tr><td>Top182</td><td><a href>房间</a></td><td>2015</td><td>8.8</td></tr><tr><td>Top183</td><td><a href>可可西里</a></td><td>2004</td><td>8.7</td></tr><tr><td>Top184</td><td><a href>恐怖游轮</a></td><td>2009</td><td>8.4</td></tr><tr><td>Top185</td><td><a href>模仿游戏</a></td><td>2014</td><td>8.6</td></tr><tr><td>Top186</td><td><a href>一个叫欧维的男人决定去死</a></td><td>2015</td><td>8.8</td></tr><tr><td>Top187</td><td><a href>一次别离</a></td><td>2011</td><td>8.7</td></tr><tr><td>Top188</td><td><a href>忠犬八公物语</a></td><td>1987</td><td>9.1</td></tr><tr><td>Top189</td><td><a href>战争之王</a></td><td>2005</td><td>8.6</td></tr><tr><td>Top190</td><td><a href>追随</a></td><td>1998</td><td>8.9</td></tr><tr><td>Top191</td><td><a href>魔女宅急便</a></td><td>1989</td><td>8.5</td></tr><tr><td>Top192</td><td><a href>撞车</a></td><td>2004</td><td>8.6</td></tr><tr><td>Top193</td><td><a href>谍影重重</a></td><td>2002</td><td>8.5</td></tr><tr><td>Top194</td><td><a href>完美陌生人</a></td><td>2016</td><td>8.6</td></tr><tr><td>Top195</td><td><a href>地球上的星星</a></td><td>2007</td><td>8.9</td></tr><tr><td>Top196</td><td><a href>牯岭街少年杀人事件</a></td><td>1991</td><td>8.8</td></tr><tr><td>Top197</td><td><a href>谍影重重2</a></td><td>2004</td><td>8.6</td></tr><tr><td>Top198</td><td><a href>哪吒闹海</a></td><td>1979</td><td>8.9</td></tr><tr><td>Top199</td><td><a href>惊魂记</a></td><td>1960</td><td>8.9</td></tr><tr><td>Top200</td><td><a href>青蛇</a></td><td>1993</td><td>8.5</td></tr><tr><td>Top201</td><td><a href>梦之安魂曲</a></td><td>2000</td><td>8.7</td></tr><tr><td>Top202</td><td><a href>无敌破坏王</a></td><td>2012</td><td>8.7</td></tr><tr><td>Top203</td><td><a href>黑客帝国3：矩阵革命</a></td><td>2003</td><td>8.6</td></tr><tr><td>Top204</td><td><a href>小萝莉的猴神大叔</a></td><td>2015</td><td>8.5</td></tr><tr><td>Top205</td><td><a href>再次出发之纽约遇见你</a></td><td>2013</td><td>8.5</td></tr><tr><td>Top206</td><td><a href>海街日记</a></td><td>2015</td><td>8.7</td></tr><tr><td>Top207</td><td><a href>新龙门客栈</a></td><td>1992</td><td>8.5</td></tr><tr><td>Top208</td><td><a href>东京物语</a></td><td>1953</td><td>9.2</td></tr><tr><td>Top209</td><td><a href>步履不停</a></td><td>2008</td><td>8.8</td></tr><tr><td>Top210</td><td><a href>终结者2：审判日</a></td><td>1991</td><td>8.6</td></tr><tr><td>Top211</td><td><a href>源代码</a></td><td>2011</td><td>8.4</td></tr><tr><td>Top212</td><td><a href>初恋这件小事</a></td><td>2010</td><td>8.3</td></tr><tr><td>Top213</td><td><a href>绿里奇迹</a></td><td>1999</td><td>8.7</td></tr><tr><td>Top214</td><td><a href>城市之光</a></td><td>1931</td><td>9.2</td></tr><tr><td>Top215</td><td><a href>末路狂花</a></td><td>1991</td><td>8.7</td></tr><tr><td>Top216</td><td><a href>爱在午夜降临前</a></td><td>2013</td><td>8.8</td></tr><tr><td>Top217</td><td><a href>疯狂的石头</a></td><td>2006</td><td>8.3</td></tr><tr><td>Top218</td><td><a href>秒速5厘米</a></td><td>2007</td><td>8.3</td></tr><tr><td>Top219</td><td><a href>无耻混蛋</a></td><td>2009</td><td>8.5</td></tr><tr><td>Top220</td><td><a href>这个男人来自地球</a></td><td>2007</td><td>8.5</td></tr><tr><td>Top221</td><td><a href>勇闯夺命岛</a></td><td>1996</td><td>8.6</td></tr><tr><td>Top222</td><td><a href>E.T. 外星人</a></td><td>1982</td><td>8.5</td></tr><tr><td>Top223</td><td><a href>碧海蓝天</a></td><td>1988</td><td>8.7</td></tr><tr><td>Top224</td><td><a href>变脸</a></td><td>1997</td><td>8.4</td></tr><tr><td>Top225</td><td><a href>卡萨布兰卡</a></td><td>1942</td><td>8.6</td></tr><tr><td>Top226</td><td><a href>黄金三镖客</a></td><td>1966</td><td>9.1</td></tr><tr><td>Top227</td><td><a href>发条橙</a></td><td>1971</td><td>8.5</td></tr><tr><td>Top228</td><td><a href>彗星来的那一夜</a></td><td>2013</td><td>8.4</td></tr><tr><td>Top229</td><td><a href>聚焦</a></td><td>2015</td><td>8.8</td></tr><tr><td>Top230</td><td><a href>海盗电台</a></td><td>2009</td><td>8.6</td></tr><tr><td>Top231</td><td><a href>美国丽人</a></td><td>1999</td><td>8.5</td></tr><tr><td>Top232</td><td><a href>血钻</a></td><td>2006</td><td>8.5</td></tr><tr><td>Top233</td><td><a href>非常嫌疑犯</a></td><td>1995</td><td>8.6</td></tr><tr><td>Top234</td><td><a href>国王的演讲</a></td><td>2010</td><td>8.3</td></tr><tr><td>Top235</td><td><a href>荒野生存</a></td><td>2007</td><td>8.6</td></tr><tr><td>Top236</td><td><a href>英国病人</a></td><td>1996</td><td>8.5</td></tr><tr><td>Top237</td><td><a href>黑鹰坠落</a></td><td>2001</td><td>8.6</td></tr><tr><td>Top238</td><td><a href>我爱你</a></td><td>2011</td><td>9.0</td></tr><tr><td>Top239</td><td><a href>迁徙的鸟</a></td><td>2001</td><td>9.1</td></tr><tr><td>Top240</td><td><a href>遗愿清单</a></td><td>2007</td><td>8.5</td></tr><tr><td>Top241</td><td><a href>勇士</a></td><td>2011</td><td>8.9</td></tr><tr><td>Top242</td><td><a href>荒岛余生</a></td><td>2000</td><td>8.5</td></tr><tr><td>Top243</td><td><a href>2001太空漫游</a></td><td>1968</td><td>8.7</td></tr><tr><td>Top244</td><td><a href>枪火</a></td><td>1999</td><td>8.7</td></tr><tr><td>Top245</td><td><a href>燕尾蝶</a></td><td>1996</td><td>8.6</td></tr><tr><td>Top246</td><td><a href>叫我第一名</a></td><td>2008</td><td>8.6</td></tr><tr><td>Top247</td><td><a href>穆赫兰道</a></td><td>2001</td><td>8.3</td></tr><tr><td>Top248</td><td><a href>千钧一发</a></td><td>1997</td><td>8.7</td></tr><tr><td>Top249</td><td><a href>大卫·戈尔的一生</a></td><td>2003</td><td>8.6</td></tr><tr><td>Top250</td><td><a href>上帝也疯狂</a></td><td>1980</td><td>8.7</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      《千与千寻》 6.28值得所有期待
    
    </summary>
    
      <category term="资源" scheme="https://www.xiongtianci.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="公众号文章" scheme="https://www.xiongtianci.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
      <category term="Top电影" scheme="https://www.xiongtianci.com/tags/Top%E7%94%B5%E5%BD%B1/"/>
    
      <category term="电仪" scheme="https://www.xiongtianci.com/tags/%E7%94%B5%E4%BB%AA/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo+GitHub 搭建个人博客</title>
    <link href="https://www.xiongtianci.com/2018/11/28/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://www.xiongtianci.com/2018/11/28/使用Hexo+GitHub搭建个人博客/</id>
    <published>2018-11-28T07:36:06.000Z</published>
    <updated>2019-06-12T09:24:00.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>昨天偶然看见一篇有关使用Hexo搭建个人博客的文章，瞬间吸引我的注意。今天使用的一天的时间在GitHub上搭建了一个个人博客，感觉还不错，分享给大家，并记录下我搭建过程中趟过的坑</p><p>环境：Win10 + Hexo + GitHub</p><p>效果展示：<a href="https://xiongtianci-tc.github.io/" target="_blank" rel="noopener">脚印的博客</a></p></blockquote><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-了解Hexo"><a href="#1-了解Hexo" class="headerlink" title="1. 了解Hexo"></a>1. 了解Hexo</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>官方文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h2 id="2-搭建Node-js环境"><a href="#2-搭建Node-js环境" class="headerlink" title="2. 搭建Node.js环境"></a>2. 搭建Node.js环境</h2><p>Hexo基于Node.js环境，那么我们搭建博客网站首先需要安装Node.js环境</p><p>下载地址：<a href="http://nodejs.cn/download" target="_blank" rel="noopener">http://nodejs.cn/download</a></p><p>详细安装文档：<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-install-setup.html</a></p><p>测试安装：命令行使用 <code>node -v</code> 、<code>npm -v</code>，查看显示版本号即成功。如下图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543458424692.png" alt="1543458424692"> </p><h2 id="3-注册Github账号"><a href="#3-注册Github账号" class="headerlink" title="3. 注册Github账号"></a>3. 注册Github账号</h2><p>这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件</p><p>注册地址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com</a><br>注册流程：<a href="https://blog.csdn.net/p10010/article/details/51336332" target="_blank" rel="noopener">https://blog.csdn.net/p10010/article/details/51336332</a></p><blockquote><p>注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦</p></blockquote><h2 id="4-安装Git版本工具"><a href="#4-安装Git版本工具" class="headerlink" title="4. 安装Git版本工具"></a>4. 安装Git版本工具</h2><blockquote><p>使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步</p></blockquote><ul><li><p>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>Windows系统需下载，Mac系统因为自带Git无需操作</p><p>详细安装文档：<a href="https://blog.csdn.net/u013295518/article/details/78746007" target="_blank" rel="noopener">https://blog.csdn.net/u013295518/article/details/78746007</a></p><p>测试安装：<code>git --version</code>，查看显示版本号即成功。如下图：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543458907014.png" alt="1543458907014"> </p></li><li><p>配置SSH：<a href="https://blog.csdn.net/qq_35246620/article/details/69061355" target="_blank" rel="noopener">https://blog.csdn.net/qq_35246620/article/details/69061355</a></p><p>SSH key添加之后，就可以在本机git bash中进行测试，输入<code>ssh -T git@github.com</code>进行测试</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543476938196.png" alt="1543476938196"> </p><p>显示 <code>Hi username ！You&#39;ve successfully...</code> 说明ssh配置成功了</p></li></ul><h2 id="5-在本地安装-Hexo"><a href="#5-在本地安装-Hexo" class="headerlink" title="5. 在本地安装 Hexo"></a>5. 在本地安装 Hexo</h2><blockquote><p>Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件</p></blockquote><pre><code>npm install -g hexo-cli</code></pre><blockquote><p>注意：在回车之后，可能会出现一行WARN的警告语句，不用管它，这个不妨碍安装</p><p>过一段时间如果出现hexo版本号之类的语句就代表差不多了</p></blockquote><p>然后输入</p><pre><code>npm install hexo --save</code></pre><p>这个时候你会看到命令行出现了一堆白字，紧接着输入<code>hexo v</code>查看是否安装成功：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543477381834.png" alt="1543477381834"> </p><p>此时，Hexo已经安装完成</p><h1 id="二、搭建博客"><a href="#二、搭建博客" class="headerlink" title="二、搭建博客"></a>二、搭建博客</h1><h2 id="1-开启GitHub-Pages服务"><a href="#1-开启GitHub-Pages服务" class="headerlink" title="1. 开启GitHub Pages服务"></a>1. 开启GitHub Pages服务</h2><p>搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543474709681.png" alt="1543474709681"></p><p>这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是：</p><blockquote><p>仓库名固定：你的github的username.github.io</p></blockquote><p> 这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：<code>https://UserName.github.io</code>的形式。</p><p>点击<code>Create Repository</code>后，选着仓库的<code>Setting</code>进入设置</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543476148226.png" alt="1543476148226"></p><p>往下滑找到 <code>Github Pages</code> 如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543477847990.png" alt="1543477847990"></p><p>这里我们需要点击 <code>Choose a theme</code> 任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543477980475.png" alt="1543477980475"></p><p>点击 <code>Select theme</code> 选着主题后，此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543478176563.png" alt="1543478176563"></p><p>输入你的 GitHub 的用户名和密码，成功后复制<code>https://username.github.io/</code>到浏览器打开就行。看！这就是你的博客了，只要能连接到互联网，就能随时查看它(๑•̀ㅂ•́)و✧！</p><h2 id="2-创建本地博客站点"><a href="#2-创建本地博客站点" class="headerlink" title="2. 创建本地博客站点"></a>2. 创建本地博客站点</h2><p>上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下：</p><blockquote><p>hexo init  myHexoBlog       //myHexoBlog是项目名</p></blockquote><p>等一会，如果出现橙色的 <strong>WARN</strong> 没关系，只要不出现红色的 <strong>ERROR</strong> 就行。好了后，输入命令：</p><blockquote><p> hexo g      //g是generetor的缩写，生成博客</p><p> hexo s     //s是server的缩写，启动服务</p></blockquote><p>然后点开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，恭喜你！已经在本地搭建好博客了(๑•̀ㅂ•́)و✧！</p><h2 id="3-同步Github-允许公共访问"><a href="#3-同步Github-允许公共访问" class="headerlink" title="3. 同步Github,允许公共访问"></a>3. 同步Github,允许公共访问</h2><p>在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。<br>首先找到我们的博客仓库，并拷贝仓库地址：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543480461386.png" alt="1543480461386"></p><p>然后修改本地博客目录的配置：<br>修改本地博客根目录下的<code>_config.yml</code>文件，修改<code>deploy</code>下的配置，如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543480729831.png" alt="1543480729831"></p><pre><code>deploy:  type: git  repository: git@github.com:xiongtianci-tc/xiongtianci-tc.github.io.git #复制的仓库地址  branch: master</code></pre><blockquote><p>注意：</p><ol><li>repository后面的内容是 <a href="mailto:git@gitbub.com" target="_blank" rel="noopener">git@gitbub.com</a>:username/库地址 的形式</li><li>type、repository、branch冒号的后面都有一个空格（切记~~）</li></ol></blockquote><p>最后执行控制台命令：</p><pre><code>npm install hexo-deployer-git --save //安装部署插件hexo d //部署到github</code></pre><p>现在，我们再次访问链接：<code>https://userName.github.io</code>，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。</p><h1 id="三、发布你的第一篇博客"><a href="#三、发布你的第一篇博客" class="headerlink" title="三、发布你的第一篇博客"></a>三、发布你的第一篇博客</h1><p>终于可以发布自己的第一篇博客了，是不是很激动？（博主当时可是超级激动的~）<br>首先，在本地博客文件夹根目录输入：</p><pre><code>hexo new &quot;我个人博客的第一篇博客，激动~&quot;hexo g   //生成网页hexo d  //部署到远端(github)</code></pre><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543481316715.png" alt="1543481316715"> </p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543481394185.png" alt="1543481394185"> </p><p>现在打开我们的博客网站：<code>http://UserName.github.io</code>,会看到网页如下(可能需要刷新几次页面)：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543483567301.png" alt="1543483567301"></p><p>需要编写博客内容时，只需编写本地博客的 <code>_posts</code> 的博客原文，然后通过 <code>hexo g &amp;&amp; hexo d</code> 重新部署到github即可</p><h1 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h1><p>此时，我们的个人博客已经搭建完成。但是我们需要网站更加高大上，更加美观些，我们可以通过更换主题来实现个性化博客</p><p>这里以使用github上的next主题为例：</p><h2 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h2><p>next主题：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><p>在控制台中切换到本地博客根目录输入：</p><pre><code>$ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>下载成之后我们会看到next的主题已经存在 <code>thems</code> 里了如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543484274020.png" alt="1543484274020"> </p><h2 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2. 更换主题"></a>2. 更换主题</h2><p>修改博客根目录(不是next主题)下的 <code>_config.yml</code> 文件，搜索 <code>theme</code> 字段，并将其值修改为 <code>next</code></p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543484383922.png" alt="1543484383922"> </p><p>然后在控制台下输入如下命令：</p><pre><code>hexo clean  //清理缓存hexo g    //重新生成博客代码hexo d   //部署到本地// 或者直接输入：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>再次打开我们的博客网站：<code>https://UserName.github.io</code>，将会发现我们的博客主题已经发生了改变</p><h1 id="五、个性化"><a href="#五、个性化" class="headerlink" title="五、个性化"></a>五、个性化</h1><p>通过此步骤我们可以设置博客的作者、格言、语言…</p><blockquote><p>在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项</p></blockquote><h2 id="1-站点配置"><a href="#1-站点配置" class="headerlink" title="1. 站点配置"></a>1. 站点配置</h2><p>在本地的博客根目录下找到_config.yml，用编辑器打开进行内容的设置，如下：</p><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181128-%E4%BD%BF%E7%94%A8Hexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1543485321688.png" alt="1543485321688"></p><p>这里可以修改博客网站的标题、描述，语言等属性</p><h2 id="2-主题设置"><a href="#2-主题设置" class="headerlink" title="2. 主题设置"></a>2. 主题设置</h2><p>网上有个超级详细的教程，我就不赘述了：</p><p>文档地址：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p><hr><p>终于结束了，</p><p>最后，</p>]]></content>
    
    <summary type="html">
    
      梦的起点
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="生活" scheme="https://www.xiongtianci.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Hexo" scheme="https://www.xiongtianci.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="https://www.xiongtianci.com/tags/GitHub/"/>
    
      <category term="博客" scheme="https://www.xiongtianci.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>java中的&amp;#92;t&amp;#92;r&amp;#92;n&amp;#92;b分别是什么？</title>
    <link href="https://www.xiongtianci.com/2018/11/27/java%E4%B8%AD%E7%9A%84-t-r-n-b%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2018/11/27/java中的-t-r-n-b分别是什么？/</id>
    <published>2018-11-27T08:29:04.000Z</published>
    <updated>2019-06-12T10:23:55.992Z</updated>
    
    <content type="html"><![CDATA[<table border="1" style="text-align: center;"><br>    <thead><br>        <tr><br>            <th></th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>\t</td><br>            <td>相当于tab，缩进</td><br>        </tr><br>         <tr><br>            <td>\r</td><br>            <td>回车</td><br>        </tr><br>         <tr><br>            <td>\n</td><br>            <td>换行符</td><br>        </tr><br>        <tr><br>            <td>\b</td><br>            <td>换成一个黑点</td><br>        </tr><br>         <tr><br>            <td>\”</td><br>            <td>转义”</td><br>        </tr><br>         <tr><br>            <td>\’</td><br>            <td>转义’</td><br>        </tr><br>         <tr><br>            <td>\</td><br>            <td>转义\</td><br>        </tr><br>    </tbody><br></table>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>使用Notepad++替换某一特定中文后面的所有内容</title>
    <link href="https://www.xiongtianci.com/2018/11/27/%E4%BD%BF%E7%94%A8Notepad++%E6%9B%BF%E6%8D%A2%E6%9F%90%E4%B8%80%E7%89%B9%E5%AE%9A%E4%B8%AD%E6%96%87%E5%90%8E%E9%9D%A2%E7%9A%84%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9/"/>
    <id>https://www.xiongtianci.com/2018/11/27/使用Notepad++替换某一特定中文后面的所有内容/</id>
    <published>2018-11-27T02:48:26.000Z</published>
    <updated>2019-06-12T09:30:47.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求：删除”电影描述”以及其后面的内容"><a href="#需求：删除”电影描述”以及其后面的内容" class="headerlink" title="需求：删除”电影描述”以及其后面的内容"></a>需求：删除”电影描述”以及其后面的内容</h3><blockquote><p>Top1 肖申克的救赎    评分：9.6    电影描述：希望让人自由<br>Top2 霸王别姬    评分：9.5    电影描述：风华绝代<br>Top3 这个杀手不太冷    评分：9.4    电影描述：怪蜀黍和小萝莉不得不说的故事<br>Top4 阿甘正传    评分：9.4    电影描述：一部美国近现代史<br>Top5 美丽人生    评分：9.5    电影描述：最美的谎言<br>Top6 千与千寻    评分：9.2    电影描述：最好的宫崎骏，最好的久石让<br>Top7 泰坦尼克号    评分：9.2    电影描述：失去的才是永恒的<br>Top8 辛德勒的名单    评分：9.4    电影描述：拯救一个人，就是拯救整个世界<br>Top9 盗梦空间    评分：9.3    电影描述：诺兰给了我们一场无法盗取的梦<br>Top10 机器人总动员    评分：9.3    电影描述：小瓦力，大人生<br>Top11 海上钢琴师    评分：9.2    电影描述：每个人都要走一条自己坚定了的路，就算是粉身碎骨<br>Top12 三傻大闹宝莱坞    评分：9.1    电影描述：英俊版憨豆，高情商版谢耳朵<br>Top13 忠犬八公的故事    评分：9.2    电影描述：永远都不能忘记你所爱的人<br>Top14 放牛班的春天    评分：9.2    电影描述：天籁一般的童声，是最接近上帝的存在<br>Top15 大话西游之大圣娶亲    评分：9.2    电影描述：一生所爱</p></blockquote><p><br></p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><ol><li>Ctrl+R 打开替换窗口</li><li>在”查找目标”中输入：特定字符.*</li><li>选择右下角的”正则表达式”</li><li>点击”全部替换”<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181127-%E4%BD%BF%E7%94%A8Notepad%2B%2B%E6%9B%BF%E6%8D%A2%E6%9F%90%E4%B8%80%E7%89%B9%E5%AE%9A%E4%B8%AD%E6%96%87%E5%90%8E%E9%9D%A2%E7%9A%84%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9/20181127104259536.png" alt="在这里插入图片描述"></li></ol><p><br></p><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><blockquote><p>Top1 肖申克的救赎    评分：9.6<br>Top2 霸王别姬    评分：9.5<br>Top3 这个杀手不太冷    评分：9.4<br>Top4 阿甘正传    评分：9.4<br>Top5 美丽人生    评分：9.5<br>Top6 千与千寻    评分：9.2<br>Top7 泰坦尼克号    评分：9.2<br>Top8 辛德勒的名单    评分：9.4<br>Top9 盗梦空间    评分：9.3<br>Top10 机器人总动员    评分：9.3<br>Top11 海上钢琴师    评分：9.2<br>Top12 三傻大闹宝莱坞    评分：9.1<br>Top13 忠犬八公的故事    评分：9.2<br>Top14 放牛班的春天    评分：9.2<br>Top15 大话西游之大圣娶亲    评分：9.2  </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Notepad" scheme="https://www.xiongtianci.com/tags/Notepad/"/>
    
  </entry>
  
  <entry>
    <title>win10常用快捷键</title>
    <link href="https://www.xiongtianci.com/2018/11/26/win10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://www.xiongtianci.com/2018/11/26/win10常用快捷键/</id>
    <published>2018-11-26T08:52:44.000Z</published>
    <updated>2019-06-12T09:31:47.222Z</updated>
    
    <content type="html"><![CDATA[<table><caption><font color="hotpink" size="6">常用快捷键</font></caption></table><br><table><br>    <thead><br>        <tr><br>            <th>快捷键</th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Alt + F4</td><br>            <td>关闭活动项，或者退出活动应用</td><br>        </tr><br>        <tr><br>            <td>Alt + Tab</td><br>            <td>在打开的应用之间切换</td><br>        </tr><br>        <tr><br>            <td>Win + L</td><br>            <td>锁定电脑</td><br>        </tr><br>        <tr><br>            <td>Win + D</td><br>            <td>显示和隐藏桌面</td><br>        </tr><br>        <tr><br>            <td>Ctrl + D（或 Delete）</td><br>            <td>删除选定项并将其移动到“回收站”</td><br>        </tr><br>    </tbody><br></table><p><br></p><table><br>    <thead><br>        <tr><br>            <th>快捷键</th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Win + A</td><br>            <td>打开操作中心</td><br>        </tr><br>        <tr><br>            <td>Win + E</td><br>            <td>打开文件资源管理器</td><br>        </tr><br>        <tr><br>            <td>Win + I</td><br>            <td>打开Windows设置</td><br>        </tr><br>        <tr><br>            <td>Win + Q / Win + S</td><br>            <td>打开Cortana</td><br>        </tr><br>        <tr><br>            <td>Win + R</td><br>            <td>打开运行</td><br>        </tr><br>        <tr><br>            <td>Win + L</td><br>            <td>锁定笔记本</td><br>        </tr><br>        <tr><br>            <td>Ctrl + Shift + Esc</td><br>            <td>打开任务管理器</td><br>        </tr><br>        <tr><br>            <td>Win + X</td><br>            <td>打开开始菜单左侧选项</td><br>        </tr><br>        <tr><br>            <td>Win + 加号</td><br>            <td>打开放大镜并放大屏幕内容</td><br>        </tr><br>        <tr><br>            <td>Win + 减号</td><br>            <td>打开放大镜并缩小屏幕内容</td><br>        </tr><br>        <tr><br>            <td>Win + Esc</td><br>            <td>退出放大镜</td><br>        </tr><br>    </tbody><br></table><p><br></p><table><caption><font color size="5">运行(Win+R)的常用命令</font></caption></table><br><table><br>    <thead><br>        <tr><br>            <th>命令</th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>notepad</td><br>            <td>打开记事本</td><br>        </tr><br>        <tr><br>            <td>calc</td><br>            <td>打开计算器</td><br>        </tr><br>        <tr><br>            <td>mspaint</td><br>            <td>打开画图</td><br>        </tr><br>        <tr><br>            <td>osk</td><br>            <td>打开虚拟键盘</td><br>        </tr><br>        <tr><br>            <td>sysdm.cpl</td><br>            <td>打开系统设置（常用于配置环境变量）</td><br>        </tr><br>        <tr><br>            <td>appwiz.cpl</td><br>            <td>打开控制面板（常用于卸载程序）</td><br>        </tr><br>        <tr><br>            <td>psr.exe</td><br>            <td>打开步骤记录器（常用于记录操作步骤）</td><br>        </tr><br>        <tr><br>            <td>cmd</td><br>            <td>打开命令行窗口</td><br>        </tr><br>    </tbody><br></table><p><br></p><table><caption><font color size="5">管理窗口</font></caption></table><br><table><br>    <thead><br>        <tr><br>            <th>快捷键</th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Win + D</td><br>            <td>最小化所有窗口，重复按下可还原</td><br>        </tr><br>        <tr><br>            <td>Win + 1…9</td><br>            <td>打开任务栏对应窗口</td><br>        </tr><br>        <tr><br>            <td>Win + T</td><br>            <td>将焦点切换到任务栏图标，并在图标之间进行切换</td><br>        </tr><br>        <tr><br>            <td>Win + 上/下</td><br>            <td>使窗口在最大化，正常状态以及最小化之间切换</td><br>        </tr><br>        <tr><br>            <td>Win + 左/右</td><br>            <td>使窗口在左半屏幕，正常状态以及右半屏幕之间切换</td><br>        </tr><br>        <tr><br>            <td>Ctrl + Tab</td><br>            <td>切换当前程序中的不同页面</td><br>        </tr><br>        <tr><br>            <td>Alt + Tab</td><br>            <td>切换当前程序</td><br>        </tr><br>        <tr><br>            <td>Ctrl + F4</td><br>            <td>关闭当前程序中的当前页面</td><br>        </tr><br>        <tr><br>            <td>Alt + F4</td><br>            <td>关闭当前程序</td><br>        </tr><br>    </tbody><br></table><p><br></p><table><caption><font color size="5">虚拟窗口</font></caption></table><br><table><br>    <thead><br>        <tr><br>            <th>快捷键</th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Win + Ctrl + D</td><br>            <td>创建新的虚拟桌面</td><br>        </tr><br>        <tr><br>            <td>Win + Ctrl + F4</td><br>            <td>关闭当前虚拟桌面</td><br>        </tr><br>        <tr><br>            <td>Win + Ctrl + 左/右</td><br>            <td>切换虚拟桌面</td><br>        </tr><br>    </tbody><br></table><p><br></p><table><caption><font color size="5">录频和截图</font></caption></table><br><table><br>    <thead><br>        <tr><br>            <th>快捷键</th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Win + G</td><br>            <td>打开屏幕录制工具栏</td><br>        </tr><br>        <tr><br>            <td>PtrSc</td><br>            <td>全屏截图并保存到剪贴板</td><br>        </tr><br>        <tr><br>            <td>Alt + PtrSc</td><br>            <td>当前窗口截图并保存到剪贴板</td><br>        </tr><br>        <tr><br>            <td>Win + PtrSc</td><br>            <td>全屏截图并保存到本地</td><br>        </tr><br>    </tbody><br></table><p><br></p><table><caption><font color size="5">输入法</font></caption></table><br><table><br>    <thead><br>        <tr><br>            <th>快捷键</th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>Shift</td><br>            <td>切换输入法</td><br>        </tr><br>        <tr><br>            <td>Shift + Space</td><br>            <td>切换全半角</td><br>        </tr><br>    </tbody><br></table><p><br></p><table><caption><font color size="6">触控板常用手势</font></caption></table><br><table><br>    <thead><br>        <tr><br>            <th>操作</th><br>            <th>描述</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>单指双击拖动</td><br>            <td>拖拽文件</td><br>        </tr><br>        <tr><br>            <td>两指上下移动</td><br>            <td>滚动屏幕</td><br>        </tr><br>        <tr><br>            <td>两指缩放</td><br>            <td>缩放</td><br>        </tr><br>        <tr><br>            <td>两指旋转</td><br>            <td>旋转</td><br>        </tr><br>        <tr><br>            <td>三指扩张</td><br>            <td>显示所有窗口</td><br>        </tr><br>        <tr><br>            <td>三指上下移动</td><br>            <td>隐藏或显示窗口</td><br>        </tr><br>        <tr><br>            <td>三指左右移动</td><br>            <td>切换窗口</td><br>        </tr><br>    </tbody><br></table>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="win10" scheme="https://www.xiongtianci.com/tags/win10/"/>
    
      <category term="快捷键" scheme="https://www.xiongtianci.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程安全问题</title>
    <link href="https://www.xiongtianci.com/2018/11/23/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://www.xiongtianci.com/2018/11/23/Java中的线程安全问题/</id>
    <published>2018-11-22T17:07:37.000Z</published>
    <updated>2019-06-12T09:32:26.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><strong>线程安全</strong>：如果有多个线程在<strong>同时</strong>运行，而这些线程可能会<strong>同时运行这段代码</strong>。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，此时我们就称之为是线程安全的。</p><p>我们通过一个案例，演示线程的安全问题：</p><pre><code>电影院卖票，使用了A、B、C三个窗口进行卖票，电影票总数为100张</code></pre><p>采用线程对象来模拟卖票窗口A、B、C；使用Runnable接口的子类来模拟买的电影票</p><p>模拟电影票：</p><pre><code class="java">public class Ticket implements Runnable{    // 在成员位置 定义票的总数100    int ticket = 100;    @Override    public void run() {        // 模拟买票窗口        // 买票窗口永远开启        while (true){            // 判断是否还有票可以卖            if(ticket &gt; 0){                // 使用sleep增加“程序的时间”--每张票卖50ms                try {                    Thread.sleep(50);                } catch (Exception e) {                    e.printStackTrace();                }                // 获得线程名称 即买票窗口名称                String name = Thread.currentThread().getName();                System.out.println(name + &quot;卖掉第&quot; + ticket-- + &quot;票&quot;);            }        }    }}</code></pre><p>模拟买票：</p><pre><code class="java">/** * 模拟买票操作 *    假设一场电影有100张票 *    三个窗口同时买票 * *    窗口  线程对象 *    买票  线程任务 实现runnable接口 */public class Demo {    public static void main(String[] args) {        // 创建买票任务对象        Ticket ticket = new Ticket();        // 创建三个窗口        Thread t1 = new Thread(ticket, &quot;窗口A&quot;);        Thread t2 = new Thread(ticket, &quot;窗口B&quot;);        Thread t3 = new Thread(ticket, &quot;窗口C&quot;);        // 开启线程        t1.start();        t2.start();        t3.start();    }}</code></pre><p>运行结果：</p><pre><code>窗口A卖掉第100张票窗口C卖掉第98张票窗口B卖掉第99张票窗口A卖掉第97张票窗口B卖掉第95张票窗口C卖掉第96张票窗口C卖掉第94张票 ⇐窗口B卖掉第94张票 ⇐窗口A卖掉第94张票 ⇐...窗口C卖掉第1张票窗口A卖掉第0张票窗口B卖掉第-1张票 ⇐</code></pre><p>发现程序出现了两个问题：</p><pre><code> 1. 相同的票数被卖了多次，如第94张被三个窗口都卖了 2. 卖出了不存在的票，如窗口B卖掉了第-1张票</code></pre><p>此时，几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p><blockquote><p>线程安全问题都是有全局变量即静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作。一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全</p></blockquote><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有些的操作，就容易出现<strong>线程安全</strong>问题<br>要解决上述多想成并发访问一个资源的安全性问题：也就是解决重复卖同一张票和卖不存在的票问题，Java中提供了同步机制(synchronized)来解决<br>根据案例简述：</p><pre><code>窗口A线程进入操作(买票)的时候，窗口B和窗口C线程只能在外等着，窗口A操作结束，窗口A、窗口B和窗口C(CPU分配内存是随机的，所以还有可能是窗口A进入)才有机会进入代码去执行。也就是说，在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</code></pre><p>为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。</p><p>有三种方式完成同步操作：</p><pre><code> 1. 同步代码块 2. 同步方法 3. 锁机制</code></pre><h1 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h1><p><strong>同步代码块</strong>：<code>synchronized</code> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p><p>格式：</p><pre><code class="java">synchronized(同步锁){    // 需要同步的操作的代码}</code></pre><p><strong>同步锁</strong>：</p><p>对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。</p><pre><code> 1. 锁对象可以是任意类型 2. 多个线程对象要使用同一把锁</code></pre><blockquote><p>注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到就进入代码块，其他的线程只能在外等着</p></blockquote><p>使用同步代码块解决卖票问题：</p><pre><code class="java">/** * synchronized(锁对象){ * * } * 1. 锁对象可以是任意类型 * 2. 互斥线程需要使用同一把锁 */public class Ticket implements Runnable{    // 在成员位置 定义票的总数100    int ticket = 100;    Object obj = new Object();    @Override    public void run() {        // 模拟买票窗口        // 买票窗口永远开启        while (true){            // 同步锁            synchronized (obj){                // 判断是否还有票可以卖                if(ticket &gt; 0){                    // 使用sleep增加“程序的时间”--每张票卖50ms                    try {                        Thread.sleep(50);                    } catch (Exception e) {                        e.printStackTrace();                    }                    // 获得线程名称 即买票窗口名称                    String name = Thread.currentThread().getName();                    System.out.println(name + &quot;卖掉第&quot; + ticket-- + &quot;票&quot;);                }            }        }    }}</code></pre><p>执行结果：</p><pre><code>窗口A卖掉第100票窗口C卖掉第99票窗口B卖掉第98票窗口B卖掉第97票...窗口C卖掉第4票窗口A卖掉第3票窗口A卖掉第2票窗口A卖掉第1票</code></pre><p>此时，每张票都只会被卖掉一次，不会存在卖掉不存在的电影票的问题。</p><p>当使用了同步代码块后，上述的线程的安全问题即可解决</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="多线程" scheme="https://www.xiongtianci.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Word2016问题导致无法创建其他博客账号</title>
    <link href="https://www.xiongtianci.com/2018/11/22/Word2016%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E5%85%B6%E4%BB%96%E5%8D%9A%E5%AE%A2%E8%B4%A6%E5%8F%B7/"/>
    <id>https://www.xiongtianci.com/2018/11/22/Word2016问题导致无法创建其他博客账号/</id>
    <published>2018-11-22T11:23:57.000Z</published>
    <updated>2019-06-12T09:33:38.344Z</updated>
    
    <content type="html"><![CDATA[<p>网友介绍能够在word上直接将博文发布到CSDN上，纯洁的我跟着网友的说法一顿操作，结果凉凉~<br>按照网友说法在word中创建博客账号时，需要选择“其他”，就是这个&darr;&darr;&darr;<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181122-Word2016%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E5%85%B6%E4%BB%96%E5%8D%9A%E5%AE%A2%E8%B4%A6%E5%8F%B7/20181122191455372.png" alt="在这里插入图片描述"><br>结果&darr;&darr;&darr;<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181122-Word2016%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E5%85%B6%E4%BB%96%E5%8D%9A%E5%AE%A2%E8%B4%A6%E5%8F%B7/20181122182840183.png" alt="在这里插入图片描述"><br>网上搜了半天，终于找到一篇看似有用的文章：<a href="https://answers.microsoft.com/zh-hans/msoffice/forum/msoffice_word-mso_win10/%E6%9B%B4%E6%96%B0offices/b0f47f10-fd19-4de4-aad3-87a64ecc60fe" target="_blank" rel="noopener">Word 2016 无法创建其他博客账号</a><br>然并卵，我并没有找到所谓的补丁( 一群羊驼奔腾而过~ )<br>希望各位大神赐教</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Word2016" scheme="https://www.xiongtianci.com/tags/Word2016/"/>
    
  </entry>
  
  <entry>
    <title>JS中Cookie、LocalStorage与SessionStorage</title>
    <link href="https://www.xiongtianci.com/2018/11/22/JS%E4%B8%ADCookie%E3%80%81LocalStorage%E4%B8%8ESessionStorage/"/>
    <id>https://www.xiongtianci.com/2018/11/22/JS中Cookie、LocalStorage与SessionStorage/</id>
    <published>2018-11-22T07:56:16.000Z</published>
    <updated>2019-06-12T09:34:06.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h3 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h3><blockquote><p><strong>cookie</strong>：主要用途有保存登录信息。cookie 非常小，它的大小限制为4KB左右。<br>用途：比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p></blockquote><h3 id="2-LocalStorage"><a href="#2-LocalStorage" class="headerlink" title="2. LocalStorage"></a>2. LocalStorage</h3><blockquote><p><strong>localStorage</strong>生命周期是<strong>永久</strong>，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信</p></blockquote><h3 id="3-SessionStorage"><a href="#3-SessionStorage" class="headerlink" title="3. SessionStorage"></a>3. SessionStorage</h3><blockquote><p><strong>sessionStorage</strong>仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p></blockquote><p><br></p><h1 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h1><table><br>    <thead><br>        <th>特性</th><br>        <th>Cookie</th><br>        <th>LocalStorage</th><br>        <th>SessionStorage</th><br>    </thead><br>    <tdoby><br>        <tr><br>            <th>数据的生命周期</th><br>            <td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td><br>            <td>除非被清除，否则<font color="hotpink">永久保存</font></td><br>            <td>仅在<font color="hotpink">当前会话</font>下有效，关闭页面或浏览器后被清除<br></td><br>        </tr><br>        <tr><br>            <th>存放数据大小</th><br>            <td>4K左右</td><br>            <td colspan="2">一般为5MB</td><br>        </tr><br>        <tr><br>            <th>与服务器端通信</th><br>            <td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td><br>            <td colspan="2">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><br>        </tr><br>        <tr><br>            <th>易用性</th><br>            <td>需要程序员自己封装，源生的Cookie接口不友好</td><br>            <td colspan="2">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td><br>        </tr><br>    <br></tdoby></table><blockquote><p><font size="4" color="hotpink"><strong>LocalStorage和SessionStorage：</strong></font></p><ol><li><strong>不同浏览器</strong>无法共享 localStorage 或 sessionStorage 中的信息。</li><li>相同浏览器的<strong>不同页面</strong>间可以共享相同的 <code>localStorage</code>（页面属于相同域名和端口），但是不同页面或标签页间无法共享 <code>sessionStorage</code> 的信息。</li><li>这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个 <code>iframe</code> 标签且他们属于同源页面，那么他们之间是可以共享 <code>sessionStorage</code> 的</li></ol></blockquote><p><br> </p><h1 id="三、LocalStorage-和-SessionStorage-的操作"><a href="#三、LocalStorage-和-SessionStorage-的操作" class="headerlink" title="三、LocalStorage 和 SessionStorage 的操作"></a>三、LocalStorage 和 SessionStorage 的操作</h1><p><code>LocalStorage</code> 和 <code>SessionStorage</code> 具有相同的操作方法，例如<code>setItem</code>、 <code>getItem</code> 和 <code>removeItem</code> 等</p><h3 id="1-添加value"><a href="#1-添加value" class="headerlink" title="1. 添加value"></a>1. 添加value</h3><p><strong>描述</strong>：使用 <code>key/value</code> 的形式将数据存储进本地存储中<br><strong>格式</strong>：</p><pre><code class="js">sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;);localStorage.setItem(&quot;site&quot;, &quot;js8.in&quot;);</code></pre><h3 id="2-获取value"><a href="#2-获取value" class="headerlink" title="2.获取value"></a>2.获取value</h3><p><strong>描述</strong>：获取指定 <code>key</code> 本地存储的值<br><strong>格式</strong>：</p><pre><code class="js">var value = sessionStorage.getItem(&quot;key&quot;);var site = localStorage.getItem(&quot;site&quot;);</code></pre><h3 id="3-删除value"><a href="#3-删除value" class="headerlink" title="3.删除value"></a>3.删除value</h3><p><strong>描述</strong>：删除指定 <code>key</code> 本地存储的值<br><strong>格式</strong>：</p><pre><code class="js">sessionStorage.removeItem(&quot;key&quot;);localStorage.removeItem(&quot;site&quot;);</code></pre><h3 id="4-清除value"><a href="#4-清除value" class="headerlink" title="4.清除value"></a>4.清除value</h3><p><strong>描述</strong>：清除所有的 <code>key/value</code><br><strong>格式</strong>：</p><pre><code class="js">sessionStorage.clear();localStorage.clear();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="JS" scheme="https://www.xiongtianci.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Java中创建线程的两种方式</title>
    <link href="https://www.xiongtianci.com/2018/11/22/Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.xiongtianci.com/2018/11/22/Java中创建线程的两种方式/</id>
    <published>2018-11-22T03:35:47.000Z</published>
    <updated>2019-06-12T09:34:38.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建线程方式一"><a href="#创建线程方式一" class="headerlink" title="创建线程方式一"></a>创建线程方式一</h2><blockquote><p>通过<strong>继承</strong><code>Thread</code>类来创建并启动多线程</p></blockquote><p>Java使用<code>java.lang.Thread</code>类代表线程，所有的线程对象都必须是<code>Thread</code>类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。<br>Java中通过<strong>继承Thread类</strong>来创建并启动多线程的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的<code>run()</code>方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>自定义线程类：</p><pre><code class="java">/** * 自定义线程类 */public class MyThread extends Thread {    public MyThread(String name){        super(name);    }    @Override    public void run() {        for(int i = 1; i &lt;= 20; i++){            System.out.println(getName() + &quot; &quot; + i);        }    }}</code></pre><p>测试类：</p><pre><code class="java">/** * 创建线程方式一： *  1. 创建自定义类继承Thread类 *  2. 重写run方法(run方法就是新的线程要执行的代码) *  3. 创建自定义类对象(线程对象) *  4. 调用start方法开启新的线程 */public class Demo01 {    public static void main(String[] args) {        System.out.println(&quot;main线程开启&quot;);        // 创建线程对象        MyThread myThread = new MyThread(&quot;线程A&quot;);        // 开启新的线程myThread        myThread.start();        // 这个循环在main线程中执行        for (int i = 1; i &lt;= 20; i++) {            System.out.println(&quot;mian线程 &quot; + i);        }    }}</code></pre><p><br></p><h2 id="创建线程方式二"><a href="#创建线程方式二" class="headerlink" title="创建线程方式二"></a>创建线程方式二</h2><blockquote><p>通过<strong>实现</strong><code>Runnable</code>类来创建并启动多线程</p></blockquote><p>采用java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可<br>步骤如下：</p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象</li><li>调用线程对象的start()方法来启动线程</li></ol><p>代码如下：</p><pre><code class="java">public class MyRunnable implements Runnable {    @Override    public void run() {        for (int i = 1; i &lt;= 20; i++) {            System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);        }    }}</code></pre><pre><code class="java">/** * 创建线程方式二： *  1. 定义自定义类实现Runnable接口 *  2. 重写run方法 *  3. 创建自定义对象 *  4. 创建Threed对象的时候，作为构造方法的参数进行传递 *  5. 启动线程start方法 */public class Demo02 {    public static void main(String[] args) {        // 创建线程任务对象        MyRunnable myRunnable = new MyRunnable();        // 创建线程对象        Thread t1 = new Thread(myRunnable, &quot;线程A&quot;);        Thread t2 = new Thread(myRunnable, &quot;线程B&quot;);        // 开启线程        t1.start();        t2.start();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="线程" scheme="https://www.xiongtianci.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>重载(overload)和重写(override)的区别？</title>
    <link href="https://www.xiongtianci.com/2018/11/21/%E9%87%8D%E8%BD%BD(overload)%E5%92%8C%E9%87%8D%E5%86%99(override)%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>https://www.xiongtianci.com/2018/11/21/重载(overload)和重写(override)的区别？/</id>
    <published>2018-11-21T12:04:30.000Z</published>
    <updated>2019-06-12T09:35:01.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><font color="hotpink">方法重载：</font></p><ol><li>方法名相同，参数列表【参数的顺序，类型，个数】不同</li><li>重载与方法的返回值无关，发生在同一类中</li><li>是编译时的多态性</li></ol></blockquote><blockquote><p><font color="hotpink">方法重写：</font></p><ol><li>参数列表和返回值类型必须相同</li><li>重写发生在子类与父类之间</li><li>子类抛出的异常不能超过父类相应方法抛出的异常</li><li>子类方法的的访问级别不能低于父类相应方法的访问级别</li><li>是运行时的多态性</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js中window&amp;#46;location&amp;#46;search的用法和作用</title>
    <link href="https://www.xiongtianci.com/2018/11/20/js%E4%B8%ADwindow-46-location-46-search%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>https://www.xiongtianci.com/2018/11/20/js中window-46-location-46-search的用法和作用/</id>
    <published>2018-11-20T09:29:20.000Z</published>
    <updated>2019-06-12T09:35:46.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>window.location.search的作用为：获取页面 URL 地址</p></blockquote><table><br>    <th>属性</th><br>    <th>描述</th><br>    <tbody><br>        <tr><br>            <td>hash</td><br>            <td>从 # 开始的 URL（锚）</td><br>        </tr><br>        <tr><br>            <td>host</td><br>            <td>主机名和当前 URL 的端口号</td><br>        </tr><br>        <tr><br>            <td>hostname</td><br>            <td>当前 URL 的主机名</td><br>        </tr><br>        <tr><br>            <td>href</td><br>            <td>完整的 URL</td><br>        </tr><br>        <tr><br>            <td>pathname</td><br>            <td>当前 URL 的路径部分</td><br>        </tr><br>        <tr><br>            <td>port</td><br>            <td>当前 URL 的端口号</td><br>        </tr><br>        <tr><br>            <td>protocol</td><br>            <td>当前 URL 的协议</td><br>        </tr><br>        <tr><br>            <td><font color="hotpink">search</font><br>            </td><td><font color="hotpink">从问号 (?) 开始的 URL（查询部分）</font><br>        </td></tr><br>    </tbody><br></table>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="https://www.xiongtianci.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JSP九大内置对象及其作用和四大作用域详解</title>
    <link href="https://www.xiongtianci.com/2018/11/20/JSP%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E5%92%8C%E5%9B%9B%E5%A4%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.xiongtianci.com/2018/11/20/JSP九大内置对象及其作用和四大作用域详解/</id>
    <published>2018-11-20T06:33:08.000Z</published>
    <updated>2019-06-12T09:36:08.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是内置对象？"><a href="#一、什么是内置对象？" class="headerlink" title="一、什么是内置对象？"></a>一、什么是内置对象？</h1><p>在JSP开发中会频繁使用到一些对象，SUN公司为简化开发，在设计JSP时规定JSP页面加载完毕之后自动帮开发者创建好了这些对象，开发者只需要使用相应的对象调用相应的方法即可。这些系统创建好的对象就叫做内置对象。</p><h1 id="二、九大内置对象"><a href="#二、九大内置对象" class="headerlink" title="二、九大内置对象"></a>二、九大内置对象</h1><pre><code>内置对象名          类型request           HttpServletRequestresponse       HttpServletResponseconfig         ServletConfigapplication    ServletContextsession        HttpSessionexception      Throwablepage           Object(this)out            JspWriterpageContext    PageContext </code></pre><p>1、request对象<br>request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。</p><p>2、response对象<br>response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。</p><p>3、session对象<br>session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。</p><p>4、application对象<br> application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。</p><p>5、out 对象<br>out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。</p><p>6、pageContext 对象<br>pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。</p><p>7、config 对象<br>config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。</p><p>8、page 对象<br>page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。</p><p>9、exception 对象<br>exception 对象的作用是显示异常信息，只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。</p><h1 id="三、四大作用域"><a href="#三、四大作用域" class="headerlink" title="三、四大作用域"></a>三、四大作用域</h1><pre><code>page域:    只能在当前jsp页面使用                (当前页面)request域: 只能在同一个请求中使用                (转发)session域: 只能在同一个会话(session对象)中使用        (私有的)context域: 只能在同一个web应用中使用            (全局的)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="JSP" scheme="https://www.xiongtianci.com/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>==和equals()的区别</title>
    <link href="https://www.xiongtianci.com/2018/11/20/==%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.xiongtianci.com/2018/11/20/==和equals的区别/</id>
    <published>2018-11-20T02:26:33.000Z</published>
    <updated>2019-06-12T09:36:28.569Z</updated>
    
    <content type="html"><![CDATA[<p>equals 和 == 最大的区别是一个是方法一个是运算符</p><ul><li><strong>==</strong>：如果比较的对象是==基本数据类型==，则比较的是<strong>数值</strong>是否相等；如果比较的是==引用数据类型==，则比较的是对象的<strong>地址值</strong>是否相等。</li><li><strong>equals()</strong>：用来比较方法两个对象的内容是否相等。<br>注意：equals 方法不能用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是==引用类型==的变量所指向的<strong>对象的地址</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder以及对String不变性的理解</title>
    <link href="https://www.xiongtianci.com/2018/11/20/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%BB%A5%E5%8F%8A%E5%AF%B9String%E4%B8%8D%E5%8F%98%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://www.xiongtianci.com/2018/11/20/String、StringBuffer、StringBuilder以及对String不变性的理解/</id>
    <published>2018-11-20T01:21:22.000Z</published>
    <updated>2019-06-12T09:35:20.776Z</updated>
    
    <content type="html"><![CDATA[<ul><li>String、StringBuffer、StringBuilder<ul><li>都是<code>final</code> 类, 都不允许被继承<ul><li>String 长度是不可变的, StringBuffer、StringBuilder 长度是可变的;</li><li>StringBuffer 是线程安全的, StringBuilder 不是线程安全的，但它们两个中的所有方法都是相同的，StringBuffer在StringBuilder的方法之上添加了synchronized修饰，保证线程安全</li><li>StringBuilder比StringBuffer拥有更好的性能</li><li>如果一个String类型的字符串，在编译时就可以确定是一个字符串常量，则编译完成之后，字符串会自动拼接成一个常量。此时String的速度比StringBuffer和StringBuilder的性能好的多</li></ul></li></ul></li></ul><ul><li>String不变性的理解<ul><li>String 类是被<code>final</code>进行修饰的，不能被继承</li><li>在用+号链接字符串的时候会创建新的字符串；<strong>对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</strong></li><li>String s = new String(“Hello world”); 可能创建两个对象也可能创建一个对象。如果静态区中有“Hello world”字符串常量对象的话，则仅仅在堆中创建一个对象。如果静态区中没有“Hello world”对象，则堆上和静态区中都需要创建对象</li><li>在java 中, 通过使用”+” 符号来串联字符串的时候, 实际上底层会转成通过StringBuilder 实例的append() 方法来实现</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>同源策略与JS跨域</title>
    <link href="https://www.xiongtianci.com/2018/11/19/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8EJS%E8%B7%A8%E5%9F%9F/"/>
    <id>https://www.xiongtianci.com/2018/11/19/同源策略与JS跨域/</id>
    <published>2018-11-19T02:49:12.000Z</published>
    <updated>2019-06-12T09:37:10.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要跨域"><a href="#为什么要跨域" class="headerlink" title="为什么要跨域"></a>为什么要跨域</h1><p>为了用户的信息安全，浏览器就引入了同源策略<br>那么同源策略是如何保证用户的信息安全的呢？</p><ul><li>如果没有同源策略，你打开了你的银行账户页面A，又打开了另一个不相关的页面B，这时候如果B是恶意网站，B可以通过Javascript轻松访问和修改A页面中的内容</li><li>现在我们广泛的使用cookie来维护用户的登录状态，而如果没有同源策略，这些cookie信息就会泄露，其他网站就可以冒充这个登录用户</li></ul><p>由此可以看出，同源策略确实是必不可少的，那么它会带来哪些限制呢？</p><blockquote><ol><li>Cookie、LocalStorage和IndexDB无法读取</li><li>DOM无法获得</li><li>AJAX请求不能发送</li></ol></blockquote><p>有时候我们需要突破上述限制，就需要用跨域的方法来解决</p><h1 id="跨域是什么？"><a href="#跨域是什么？" class="headerlink" title="跨域是什么？"></a>跨域是什么？</h1><ol><li>什么叫做不同的域？<br>协议（http）、域名（<a href="http://www.a.com）、端口（8000）三者中有一个不同就叫不同的域" target="_blank" rel="noopener">www.a.com）、端口（8000）三者中有一个不同就叫不同的域</a></li><li>跨域就是不同的域间相互访问时使用某些方法来突破上述限制</li><li>协议或者端口的不同，只能通过后台来解决<h1 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h1><h3 id="一、解决上面提到的1、2两点限制："><a href="#一、解决上面提到的1、2两点限制：" class="headerlink" title="一、解决上面提到的1、2两点限制："></a>一、解决上面提到的1、2两点限制：</h3><h4 id="1-通过document-domain跨子域"><a href="#1-通过document-domain跨子域" class="headerlink" title="1. 通过document.domain跨子域"></a>1. 通过document.domain跨子域</h4><blockquote><p>适用范围：</p><ol><li>两个域只是子域不同</li><li>只适用于iframe窗口与父窗口之间互相获取cookie和DOM节点，不能突破LocalStorage和IndexDB的限制</li></ol></blockquote></li></ol><p>当两个不同的域只是子域不同时，可以通过把document.domain设置为他们共同的父域来解决</p><blockquote><p>eg:<br>A: <a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a><br>B: <a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a></p></blockquote><p>当A、B想要获取对方的<code>cookie</code>或者<code>DOM节点</code>时，可以设置:</p><blockquote><p>document.domain=’example.com’;</p></blockquote><p>这时A网页通过脚本设置:</p><blockquote><p>document.cookie = “testA=hello”;</p></blockquote><p>B网页就可以拿到这个cookie：</p><blockquote><p>var aCookie = document.cookie;</p></blockquote><h4 id="2-通过window-name跨域"><a href="#2-通过window-name跨域" class="headerlink" title="2. 通过window.name跨域"></a>2. 通过window.name跨域</h4><blockquote><p>使用范围：</p><ol><li>可以是两个完全不同源的域</li><li>同一个窗口内：即同一个标签页内先后打开的窗口</li></ol></blockquote><p>window.name属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。</p><p>基于这个思想，我们可以在某个页面设置好 window.name 的值，然后在本标签页内跳转到另外一个域下的页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。</p><p>结合iframe还有更高级的用法：</p><p>父窗口先打开一个与自己不同源的子窗口，在这个子窗口里设置：</p><blockquote><p>window.name = data;</p></blockquote><p>然后让子窗口跳转到一个与父窗口同域的网址：</p><blockquote><p>location=’<a href="http://www.parent.com/a.html&#39;" target="_blank" rel="noopener">http://www.parent.com/a.html&#39;</a>;</p></blockquote><p>这时，因为同域并且同一窗口window.name是不变的，所以父窗口可以获取到子窗口下的window.name。</p><blockquote><p>var data = document.getElementById(‘myFrame’).contentWindow.name;</p></blockquote><p>优点：window.name容量很大，可以放置非常长的字符串；缺点：必须监听子窗口window.name属性的变化，影响网页性能。</p><h4 id="3-使用HTML5的window-postMessage跨域"><a href="#3-使用HTML5的window-postMessage跨域" class="headerlink" title="3. 使用HTML5的window.postMessage跨域"></a>3. 使用HTML5的window.postMessage跨域</h4><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p><p>otherWindow.postMessage(message, targetOrigin);</p><p>otherWindow:接受消息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。<br>message:所要发送的数据，string类型。<br>targetOrigin:用于限制otherWindow，*表示不做限制。</p><h5 id="eg1"><a href="#eg1" class="headerlink" title="eg1:"></a>eg1:</h5><p>在父页面中嵌入子页面，通过postMessage发送数据。<br>parent.com/index.html中的代码：</p><pre><code>&lt;iframe id=&quot;ifr&quot; src=&quot;child.com/index.html&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() {    var ifr = document.getElementById(&#39;ifr&#39;);    var targetOrigin = &#39;http://child.com&#39;;     // 若写成&#39;http://child.com/c/proxy.html&#39;效果一样    // 若写成&#39;http://c.com&#39;就不会执行postMessage了    ifr.contentWindow.postMessage(&#39;I was there!&#39;, targetOrigin);};&lt;/script&gt;</code></pre><p>在子页面中通过message事件监听父页面发送来的消息并显示。<br>child.com/index.html中的代码：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;window.addEventListener(&#39;message&#39;, function(event){    // 通过origin属性判断消息来源地址    if (event.origin == &#39;http://parent.com&#39;) {        alert(event.data);    // 弹出&quot;I was there!&quot;        alert(event.source);          // 对parent.com、index.html中window对象的引用        // 但由于同源策略，这里event.source不可以访问window对象    }}, false);&lt;/script&gt;</code></pre><h5 id="eg2"><a href="#eg2" class="headerlink" title="eg2:"></a>eg2:</h5><p>假设在a.html里嵌套个</p><pre><code>&lt;iframe src=&quot;http://www.child.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code></pre><p>在这两个页面里互相通信</p><p><strong>a.html</strong></p><pre><code>window.onload = function() {    window.addEventListener(&quot;message&quot;, function(e) {        alert(e.data);    });    window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.child.com/b.html&quot;);}</code></pre><p><strong>b.html</strong></p><pre><code>window.onload = function() {    window.addEventListener(&quot;message&quot;, function(e) {        alert(e.data);    });    window.parent.postMessage(&quot;a data&quot;, &quot;http://www.parent.com/a.html&quot;);}</code></pre><p>这样打开a页面，首先监听到了b.html通过postMessage传来的消息，就先弹出 a data，然后a通过postMessage传递消息给子页面b.html，这时会弹出 b data</p><h3 id="二、解决第3点限制："><a href="#二、解决第3点限制：" class="headerlink" title="二、解决第3点限制："></a>二、解决第3点限制：</h3><blockquote><p>AJAX请求不能发送</p></blockquote><h4 id="4-通过JSONP跨域"><a href="#4-通过JSONP跨域" class="headerlink" title="4. 通过JSONP跨域"></a>4. 通过JSONP跨域</h4><blockquote><p>适用范围：</p><ol><li>可以是两个完全不同源的域；</li><li>只支持HTTP请求中的GET方式；</li><li>老式浏览器全部支持；</li><li>需要服务端支持</li></ol></blockquote><p>JSONP(JSON with Padding)是资料格式JSON的一种使用模式，可以让网页从别的网域要资料。</p><p>由于浏览器的同源策略，在网页端出现了这个“跨域”的问题，然而我们发现，所有的 src 属性并没有受到相关的限制，比如 img / script 等。</p><p>JSONP 的原理就要从 script 说起。script 可以引用其他域的脚本文件，比如这样：</p><pre><code>a.html...&lt;script&gt;    function callback(data) {        console.log(data.url)    }&lt;/script&gt;&lt;script src=&#39;b.js&#39;&gt;&lt;/script&gt;...b.jscallback({url: &#39;http://www.rccoder.net&#39;})</code></pre><p>这就类似于JSONP的原理了。</p><p>JSONP的基本思想是：先在网页上添加一个script标签，设置这个script标签的src属性用于向服务器请求JSON数据 ，需要注意的是，src属性的查询字符串一定要加一个callback参数，用来指定回调函数的名字 。而这个函数是在资源加载之前就已经在前端定义好的，这个函数接受一个参数并利用这个参数做一些事情。向服务器请求后，服务器会将JSON数据放在一个指定名字的回调函数里作为其参数传回来。这时，因为函数已经在前端定义好了，所以会直接调用。</p><p>eg：</p><pre><code>function addScriptTag(src) {    var script = document.createElement(&#39;script&#39;);    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);    script.src = src;    document.body.appendChild(script);}window.onload = function () {    addScriptTag(&#39;http://example.com/ip?callback=foo&#39;);//请求服务器数据并规定回调函数为foo}function foo(data) {    console.log(&#39;Your public IP address is: &#39; + data.ip);};</code></pre><p>向服务器example.com请求数据，这时服务器会先生成JSON数据，这里是{“ip”: “8.8.8.8”}，然后以JS语法的方式生成一个函数，函数名就是传递上来的callback参数的值，最后将数据放在函数的参数中返回：</p><pre><code>foo({    &quot;ip&quot;: &quot;8.8.8.8&quot;});</code></pre><p>客户端解析script标签，执行返回的JS代码，调用函数。</p><h5 id="5-通过CORS跨域"><a href="#5-通过CORS跨域" class="headerlink" title="5. 通过CORS跨域"></a>5. 通过CORS跨域</h5><blockquote><p>适用范围：</p><ol><li>可以是两个完全不同源的域；</li><li>支持所有类型的HTTP请求；</li><li>被绝大多数现代浏览器支持，老式浏览器不支持；</li><li>需要服务端支持</li></ol></blockquote><p>对于前端开发者来说，跨域的CORS通信与同源的AJAX通信没有差别，代码完全一样。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><pre><code>（1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre><p>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p><p>简单请求：<br>下面是一次跨源AJAX请求，浏览器发现它是简单请求，就会直接在头信息中加一个origin字段：</p><pre><code>GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>服务器收到这条请求，如果这个origin指定的源在许可范围内，那么服务器返回的头信息中会包含Access-Control-Allow-Origin字段，值与origin的值相同，以及其他几个相关字段：</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBar</code></pre><p>Access-Control-Allow-Origin: 该字段是必须的。要么与origin相同，要么为*<br>Access-Control-Allow-Credentials: 该字段可选。设为true表示服务器允许发送cookie<br>Access-Control-Expose-Headers: 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><p>想要发送cookie，这里还有两点需要额外注意：</p><p>1）开发者必须在AJAX请求中打开withCredentials属性。</p><pre><code>var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre><p>否则即使服务器允许，客户端也不会发送。</p><p>2）Access-Control-Allow-Origin不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><p>非简单请求：<br>1.预检请求：</p><p>非简单请求会在正式通信前加一次预检（preflight）请求。作用是浏览器先询问服务器当前网页所在域名是否在服务器的许可名单中，以及可以使用哪些HTTP方法以及头信息字段。只有得到肯定答复，浏览器才会发送XMLHttpRequest，否则报错。<br>一个例子：</p><pre><code>var url = &#39;http://api.alice.com/cors&#39;;var xhr = new XMLHttpRequest();xhr.open(&#39;PUT&#39;, url, true);xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;);xhr.send();</code></pre><p>HTTP请求方法为PUT，并发送一个自定义头信息”X-Custom-Header”，浏览器发现这是一个非简单请求，就会自动发送一个预检请求，预检请求的HTTP头信息如下：</p><pre><code>OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>请求方法是OPTIONS，表示这个请求是用来询问的，头信息中的关键信息有3个：</p><p>（1）表示请求来自哪个源</p><pre><code>Origin: http://api.bob.com</code></pre><p>（2）列出浏览器的CORS请求会用到哪些HTTP方法</p><pre><code>Access-Control-Request-Method: PUT</code></pre><p>（3）指定浏览器CORS请求会额外发送的头信息字段</p><pre><code>Access-Control-Request-Headers: X-Custom-Header</code></pre><p>2.预检请求的回应（有两种情况：A允许、B不允许）</p><p>A.服务器允许这次跨域请求</p><pre><code>HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plainAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000</code></pre><p>服务器返回中要注意的字段：</p><p>（1）服务器同意的跨域请求源：</p><pre><code>Access-Control-Allow-Origin: http://api.bob.com</code></pre><p>（2）服务器支持的所有跨域请求的方法：</p><pre><code>Access-Control-Allow-Methods: GET, POST, PUT</code></pre><p>（3）表明服务器支持的所有头信息字段：</p><pre><code>Access-Control-Allow-Headers: X-Custom-Header</code></pre><p>（4）指定本次预检请求的有效期，单位为秒，即允许请求该条回应在有效期之前都不用再发送预检请求：</p><pre><code>Access-Control-Max-Age: 1728000</code></pre><p>B.服务器不允许这次跨域请求<br>即origin指定的源不在许可范围内，服务器会返回一个正常的HTTP回应。但是头信息中没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。但是要注意的是，这种HTTP回应的状态码很有可能是200，所以无法通过状态码识别这种错误。</p><p>3.正式请求<br>过了预检请求，非简单请求的正式请求就与简单请求一样了。</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题、" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%81/"/>
    
      <category term="同源策略" scheme="https://www.xiongtianci.com/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
      <category term="JS跨域" scheme="https://www.xiongtianci.com/tags/JS%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>电商项目中的SPU和SKU概念</title>
    <link href="https://www.xiongtianci.com/2018/11/16/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84SPU%E5%92%8CSKU%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.xiongtianci.com/2018/11/16/电商项目中的SPU和SKU概念/</id>
    <published>2018-11-16T06:58:37.000Z</published>
    <updated>2019-06-12T09:37:39.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPU"><a href="#SPU" class="headerlink" title="SPU"></a>SPU</h2><p><strong>SPU</strong>：Standard Product Unit，标准产品单位。</p><blockquote><p>概念：SPU 是商品信息聚合的最小单位【即：商品共同的属性】，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。<br>通俗点讲，属性值、特性相同的货品就可以称为一个 SPU</p></blockquote><p>SPU是用来定位的<br>例如：iphone8 就是一个 SPU，与商家、颜色、款式、套餐都无关</p><h2 id="SKU"><a href="#SKU" class="headerlink" title="SKU"></a>SKU</h2><p><strong>SKU</strong>：Stock Keeping Unit，库存量单位。</p><blockquote><p>概念：SKU 即库存进出计量的单位， 可以是以件、盒、托盘等为单位，是物理上不可分割的最小存货单元。<br>在使用时要根据不同业务，不同管理模式来处理</p></blockquote><p>SKU是用来定价和管理库存的<br>iphone8 有很多颜色，很多配置，每个颜色和配置的组合都会形成新的产品，这时就产生很多SKU<br>例如：银色 64G 的 iphone8 就是一个SKU；纺织品中一个 SKU 通常表示：规格、颜色、款式</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Servlet简介及其生命周期详解</title>
    <link href="https://www.xiongtianci.com/2018/11/16/Servlet%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.xiongtianci.com/2018/11/16/Servlet简介及其生命周期详解/</id>
    <published>2018-11-16T02:36:38.000Z</published>
    <updated>2019-06-12T09:39:36.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Servlet？"><a href="#一、什么是Servlet？" class="headerlink" title="一、什么是Servlet？"></a>一、什么是Servlet？</h2><p><strong>Servlet</strong>：是用Java编写的服务器端程序，一门用于开发动态web资源的技术。其主要功能在与交互式的浏览和修改数据，生成动态web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet的类。一般对Servlet的理解是后者。<br>若想开发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：<br>　　1、编写一个Java类，实现servlet接口。<br>　　2、把开发好的Java类部署到web服务器中。<br>按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet</p><h2 id="二、Servlet的运行流程"><a href="#二、Servlet的运行流程" class="headerlink" title="二、Servlet的运行流程"></a>二、Servlet的运行流程</h2><p>Servlet程序是由WEB服务器调用，WEB服务器收到客户端的Servlet访问请求后：</p><ol><li>Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步</li><li>装载并创建该Servlet的一个实例对象 </li><li>调用Servlet实例对象的<code>init()</code>方法</li><li>创建一个用于封装HTTP请求消息的<code>HttpServletRequest</code>对象和一个代表HTTP响应消息的<code>HttpServletResponse</code>对象，然后调用Servlet的<code>service()</code>方法并将请求和响应对象作为参数传递进去</li><li>WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的<code>destroy()</code>方法</li></ol><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181116-Servlet%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/20181116103539879.png" alt="在这里插入图片描述"></p><h2 id="三、Servlet的生命周期"><a href="#三、Servlet的生命周期" class="headerlink" title="三、Servlet的生命周期"></a>三、Servlet的生命周期</h2><p>Servlet运行在Servlet容器中，其生命周期由容器来管理。Servlet的生命周期通过javax.servlet.Servlet接口中的<code>init()</code>、<code>service()</code>和<code>destroy()</code>方法来表示<br>Servlet的生命周期包含了下面4个阶段：</p><ol><li><strong>加载和实例化</strong>：第一次请求时创建，通过服务器反射机制创建Servlet对象</li><li><strong>初始化</strong>：调用Servlet对象的<code>init()</code>方法，初始化Servlet的信息，<code>init()</code>方法只会在创建后被调用一次</li><li><strong>请求处理</strong>：调用<code>service()</code>或者是<code>doGet()</code>，<code>doPost()</code>方法来处理请求</li><li><strong>服务终止</strong>：在长时间没有被调用或者是服务器关闭时，会调用<code>destroy()</code>方法来销毁Servlet对象</li></ol><p>在整个Servlet的生命周期过程中，创建Servlet实例、调用实例的<code>init()</code>和<code>destroy()</code>方法都只执行一次，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的<code>service()</code>方法，为接收到的请求服务</p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Servlet" scheme="https://www.xiongtianci.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>反向安装jar包到Mave本地仓库</title>
    <link href="https://www.xiongtianci.com/2018/11/15/%E5%8F%8D%E5%90%91%E5%AE%89%E8%A3%85jar%E5%8C%85%E5%88%B0Mave%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"/>
    <id>https://www.xiongtianci.com/2018/11/15/反向安装jar包到Mave本地仓库/</id>
    <published>2018-11-14T17:17:48.000Z</published>
    <updated>2019-06-12T09:39:10.774Z</updated>
    
    <content type="html"><![CDATA[<p>当maven中央仓库没有所需jar的坐标时，需要自行将jar包反向安装到maven的本地仓库中<br>步骤：</p><blockquote><p>注意：前提是安装好Maven并且配置好maven的环境变量</p><ol><li>准备所需的jar包<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181115-%E5%8F%8D%E5%90%91%E5%AE%89%E8%A3%85jar%E5%8C%85%E5%88%B0Mave%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/20181115010549472.png" alt="在这里插入图片描述"></li><li>打开命令行，输入以下命令，按下回车即可安装<pre><code>mvn install:install-file -Dfile=d:\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</code></pre><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181115-%E5%8F%8D%E5%90%91%E5%AE%89%E8%A3%85jar%E5%8C%85%E5%88%B0Mave%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/20181115011230828.png" alt="在这里插入图片描述"></li><li>可以在Maven本地仓库中查看是否安装成功<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181115-%E5%8F%8D%E5%90%91%E5%AE%89%E8%A3%85jar%E5%8C%85%E5%88%B0Mave%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/20181115011514373.png" alt="在这里插入图片描述"></li><li>在pom文件中导入坐标<br><code>`</code>xml</li></ol></blockquote><p><dependency><br>    <groupid>com.alibaba</groupid><br>    <artifactid>dubbo</artifactid><br>    <version>2.8.4</version><br></dependency><br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://www.xiongtianci.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="maven" scheme="https://www.xiongtianci.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC的工作原理</title>
    <link href="https://www.xiongtianci.com/2018/11/09/SpringMVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://www.xiongtianci.com/2018/11/09/SpringMVC的工作原理/</id>
    <published>2018-11-09T13:17:04.000Z</published>
    <updated>2019-06-12T09:41:04.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SpringMVC的主要组件"><a href="#1-SpringMVC的主要组件" class="headerlink" title="1. SpringMVC的主要组件"></a>1. SpringMVC的主要组件</h2><ul><li><strong>DispatchServlet</strong>：前端控制器，接收请求，响应结果，返回可以是json,String等数据类型，也可以是页面（Model）</li><li><strong>HandlerMapping</strong>：处理器映射器，根据URL去查找处理器，一般通过xml配置或者注解进行查找</li><li><strong>Handler</strong>：处理器，即Controller控制器，由我们程序员编写</li><li><strong>HandlerAdapter</strong>：处理器适配器，可以将处理器包装成适配器，这样就可以支持多种类型的处理器</li><li><strong>ViewResolver</strong>：视图解析器，进行视图解析，返回view对象（常见的有JSP,FreeMark等）</li></ul><h2 id="2-SpringMVC的工作原理"><a href="#2-SpringMVC的工作原理" class="headerlink" title="2. SpringMVC的工作原理"></a>2. SpringMVC的工作原理</h2><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181109-SpringMVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/20181109211450528.png" alt="在这里插入图片描述"></p><ol><li>用户向服务器发送请求，请求被 SpringMVC 前端控制器DispatchServlet 捕获</li><li>DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping<br>将请求映射到处理器 HandlerExcutionChain</li><li>DispatchServlet 根据获得 Handler 选择一个合适的 HandlerAdapter 适配器处理；</li><li>Handler 对数据处理完成以后将返回一个 ModelAndView() 对象给 DisPatchServlet;</li><li>Handler 返回的 ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet 通过 ViewResolver 试图解析器将逻辑视图转化为真正的视图View;</li><li>DispatcherServle 通过model 解析出 ModelAndView() 中的参数进行解析最终展现出完整的 view 并返回给<br>客户端</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringMVC" scheme="https://www.xiongtianci.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Java 的基本数据类型都有哪些，各占几个字节</title>
    <link href="https://www.xiongtianci.com/2018/11/09/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/"/>
    <id>https://www.xiongtianci.com/2018/11/09/Java的基本数据类型都有哪些，各占几个字节/</id>
    <published>2018-11-09T09:37:25.000Z</published>
    <updated>2019-06-12T09:41:31.429Z</updated>
    
    <content type="html"><![CDATA[<table><br>    <thead><br>        <tr><br>            <th>四类</th><br>            <th>八种</th><br>            <th>字节数</th><br>            <th>数据表示范围</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <th rowspan="4">整型</th><br>            <td>byte</td><br>            <td>1</td><br>            <td>-128~127</td><br>        </tr><br>        <tr><br>            <td>short</td><br>            <td>2</td><br>            <td>-32768~32767</td><br>        </tr><br>        <tr><br>            <td>int</td><br>            <td>4</td><br>            <td>-2147483648～2147483647</td><br>        </tr><br>        <tr><br>            <td>long</td><br>            <td>8</td><br>            <td>-2^63^～2^63^-1</td><br>        </tr><br>        <tr><br>            <th rowspan="2">浮点型</th><br>            <td>float</td><br>            <td>4</td><br>            <td>-3.403E38～3.403E38</td><br>        </tr><br>        <tr><br>            <td>double </td><br>            <td>8</td><br>            <td>-1.798E308～1.798E308</td><br>        </tr><br>        <tr><br>            <th>字符型</th><br>            <td>char</td><br>            <td>2</td><br>            <td>表示一个字符，如(‘a’，’A’，’0’，’家’)</td><br>        </tr><br>        <tr><br>            <th>布尔型</th><br>            <td>boolean</td><br>            <td>1</td><br>            <td>只有两个值true与false</td><br>        </tr><br>    </tbody><br></table>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>final、finally、finalize 的区别</title>
    <link href="https://www.xiongtianci.com/2018/11/09/final%E3%80%81finally%E3%80%81finalize-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.xiongtianci.com/2018/11/09/final、finally、finalize-的区别/</id>
    <published>2018-11-09T08:33:44.000Z</published>
    <updated>2019-06-12T09:41:46.690Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>final</strong>：用于声明属性( 变量 )，方法和类。分别表示属性不可变( 不可二次赋值 )，方法不可覆盖，被其修饰的类不可继承</li><li><strong>finally</strong>：异常处理语句 try/catch 结构的一部分，表示总是执行</li><li><strong>finalize</strong>：Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数组的两种排序方式：选择排序和冒泡排序</title>
    <link href="https://www.xiongtianci.com/2018/11/09/%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.xiongtianci.com/2018/11/09/数组的两种排序方式：选择排序和冒泡排序/</id>
    <published>2018-11-09T08:23:06.000Z</published>
    <updated>2019-06-12T09:40:05.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>原理：在数组中选择出最小（大）的一个数，与第一个位置的数进行交换位置；<br><code>`</code><br>int[] arr = {5,8,3,9,10,2};<br>System.out.println(“排序前：” + Arrays.toString(arr));</p></blockquote><p>// 使用两层循环遍历数组，将前一位数值与后面以为数值进行比较，<br>// 如果前一位数值要大于后一位数值，则交换他们的位置。故而可以实现排序<br>for(int m = 0; m&lt;arr.length-1; m++){<br>    for(int n = m+1; n&lt;arr.length; n++){<br>        if(arr[m] &gt; arr[n]){<br>            // 用于临时储存需要交换位置的某一个值<br>            int temp = arr[m];<br>            // 交换位置<br>            arr[m] = arr[n];<br>            arr[n] = temp;<br>        }<br>    }<br>}<br>System.out.println(“排序后：” + Arrays.toString(arr));</p><pre><code>## 冒泡排序</code></pre><p>int[] arr = {5,8,3,9,10,2};<br>System.out.println(“排序前：” + Arrays.toString(arr));</p><p>// 使用两层循环遍历数组<br>for(int m = 0; m&lt;arr.length-1; m++){<br>    // 第二层循环，将 arr 索引为 0~arr.length-1-m 中最大的一个数移动到 arr[arr.length-1-m] 的位置<br>    for(int n = 0; n&lt;arr.length-1-m; n++){<br>        if(arr[n] &gt; arr[n+1]){<br>            // 用于临时储存需要交换位置的某一个值<br>            int temp = arr[n];<br>            // 交换位置<br>            arr[n] = arr[n+1];<br>            arr[n+1] = temp;<br>        }<br>    }<br>}<br>System.out.println(“排序后：” + Arrays.toString(arr));<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试题" scheme="https://www.xiongtianci.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="数组" scheme="https://www.xiongtianci.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="https://www.xiongtianci.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何显示隐藏的Chrome扩展程序图标</title>
    <link href="https://www.xiongtianci.com/2018/11/08/%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E7%9A%84Chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87/"/>
    <id>https://www.xiongtianci.com/2018/11/08/如何显示隐藏的Chrome扩展程序图标/</id>
    <published>2018-11-08T07:33:35.000Z</published>
    <updated>2019-06-12T09:42:48.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-将扩展程序图标在-Chrome-菜单中隐藏"><a href="#1-将扩展程序图标在-Chrome-菜单中隐藏" class="headerlink" title="1. 将扩展程序图标在 Chrome 菜单中隐藏"></a>1. 将扩展程序图标在 Chrome 菜单中隐藏</h2><p>将鼠标移动到需要隐藏的扩展程序上面，点击鼠标右键，选择“在 Chrome 菜单中隐藏”即可进行隐藏<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181108-%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E7%9A%84Chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87/20181108152413697.png" alt="在这里插入图片描述"></p><h2 id="2-将隐藏的扩展程序图标在-Chrome-菜单中重新显示"><a href="#2-将隐藏的扩展程序图标在-Chrome-菜单中重新显示" class="headerlink" title="2. 将隐藏的扩展程序图标在 Chrome 菜单中重新显示"></a>2. 将隐藏的扩展程序图标在 Chrome 菜单中重新显示</h2><p>在浏览器地址栏最右边，待鼠标变成左右双向箭头图标的时候向左拖动，会发现隐藏的扩展程序出现了<br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20181108-%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E7%9A%84Chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87/20181108152531335.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Chrome" scheme="https://www.xiongtianci.com/tags/Chrome/"/>
    
      <category term="扩展程序" scheme="https://www.xiongtianci.com/tags/%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Typora设置图片的相对路径（win系统）</title>
    <link href="https://www.xiongtianci.com/2018/09/30/Typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/"/>
    <id>https://www.xiongtianci.com/2018/09/30/Typora设置图片的相对路径（win系统）/</id>
    <published>2018-09-30T07:17:41.000Z</published>
    <updated>2019-06-12T09:44:31.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typora设置图片的相对路径（win系统）"><a href="#Typora设置图片的相对路径（win系统）" class="headerlink" title="Typora设置图片的相对路径（win系统）"></a>Typora设置图片的相对路径（win系统）</h1><h2 id="步骤：文件–-gt-偏好设置–-gt-图片插入"><a href="#步骤：文件–-gt-偏好设置–-gt-图片插入" class="headerlink" title="步骤：文件–&gt;偏好设置–&gt;图片插入"></a>步骤：文件–&gt;偏好设置–&gt;图片插入</h2><h2 id="结果：将插入的图片路径设置成相对路径（-assets目录）"><a href="#结果：将插入的图片路径设置成相对路径（-assets目录）" class="headerlink" title="结果：将插入的图片路径设置成相对路径（./assets目录）"></a>结果：将插入的图片路径设置成相对路径（./assets目录）</h2><p><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20180930-Typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20180930151428623.png" alt="第一步"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20180930-Typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20180930151509174.png" alt="第二步"><br><img src="https://dev.tencent.com/u/xiongtianci/p/myHexoBlog/git/raw/master/blog/20180930-Typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%88win%E7%B3%BB%E7%BB%9F%EF%BC%89/20180930151533395.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
      <category term="技术" scheme="https://www.xiongtianci.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件" scheme="https://www.xiongtianci.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Typora" scheme="https://www.xiongtianci.com/tags/Typora/"/>
    
  </entry>
  
</feed>
